                      **********************************************************
                      * Wrapper to compule 6809BAS with 6502 assembler enabled *
                      **********************************************************
                      
0001                  ASSEMBLER_6502          EQU     1
                      
                                      include "./6809BAS.asm"
                      ;                       (c) Dominic Beesley 2017 - translated BAS4816 - forked from BAS432JGH to 6809
                      ;                       ;  > Basic4/src
                      ;                       ;  Source code for 6502 BBC BASIC IV for the BBC
                      ;                       
                      ;                       ; ZP pointers are all in big endian
                      ;                       ; INTs in ZP_WA are in big endian
                      ;                       ; when address of variables and type are in ZP_WA then pointer is at +2, type at + 0
                      ;                       ; when line numbers in ZP_WA then stored at WA+2
                      ;
                      ;
                      
0433                  VERSION                 EQU $0433       ; Version 4.33
                      VERSIONSTR      MACRO
                                              FCB     "2022 Dossy",0
                                      ENDM
                      
                                              INCLUDE         "../../includes/common.inc"
                                      ; processor flags
0001                  CC_C            EQU     $01
0002                  CC_V            EQU     $02
0004                  CC_Z            EQU     $04
0008                  CC_N            EQU     $08
0010                  CC_I            EQU     $10
0020                  CC_H            EQU     $20
0040                  CC_F            EQU     $40
0080                  CC_E            EQU     $80
                      
                      m_tax           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    X
                                      ENDM
                      
                      m_tax_se        MACRO
                                      jsr     _m_tax_se
                                      ENDM
                      
                      
                      m_tay           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      m_tay_c         MACRO
                                      pshs    A
                                      lda     #0
                                      sta     ,-S
                                      lda     1,S
                                      puls    Y
                                      ENDM
                      
                      
                      m_tbx           MACRO
                                      pshs    B                       ;6
                                      clr     ,-S                     ;8
                                      puls    X                       ;7 = 21
                                      ENDM
                      
                      m_tby           MACRO
                                      pshs    B
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      
                      m_txa           MACRO
                                      pshs    X
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_tya           MACRO
                                      pshs    Y
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_txb           MACRO
                                      pshs    X
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      m_tyb           MACRO
                                      pshs    Y
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      
                      
0002                  BRKSIZE         EQU     2
                      
                      
                      DEBUG_INST      MACRO
                                      SWI
                                      ENDM
                      
                      BRK     MACRO
                              swi3
                              ENDM
                      
                      DO_BRK  MACRO
                              BRK
                              FCB     \1
                              FCB     \2,0
                              ENDM
                      
                      
                      CLI     MACRO
                              ANDCC   #~(CC_I)
                              ENDM
                      
                      SEI     MACRO
                              ORCC    #CC_I
                              ENDM
                      
                      CLC     MACRO
                              ANDCC   #~CC_C
                              ENDM
                      
                      SEC     MACRO
                              ORCC    #CC_C
                              ENDM
                      
                      CLV     MACRO
                              ANDCC   #~CC_V
                              ENDM
                      
                      SEV     MACRO
                              ORCC    #CC_V
                              ENDM
                      
                      CLZ     MACRO
                              ANDCC   #~CC_Z
                              ENDM
                      
                      SEZ     MACRO
                              ORCC    #CC_Z
                              ENDM
                      
                      
                      STX_B   MACRO
                              PSHS    D
                              TFR     X,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      
                      STY_B   MACRO
                              PSHS    D
                              TFR     Y,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      LDX_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,X
                              PULS    D
                              ENDM
                      
                      LDY_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,Y
                              PULS    D
                              ENDM
                      
                      OSCALL  MACRO
                              JSR     \1
                              ENDM
                      
                      OSJMP   MACRO
                              JMP     \1
                              ENDM
                      
                              IF      FLEX=1
                                              INCLUDE         "../../includes/flex/flexlib.inc"
                              ELSE
                                              INCLUDE         "../../includes/mosrom.inc"
0063                  mos_MACHINE_TYPE_BYTE                   EQU $63
                      
                      * Address of MOS ROM base
C000                  MOSROMBASE                              EQU $C000
F500                  MOSSTRINGS                              EQU $F500
                      
                      * default direct page for MOS ROM
0000                  MOSROMSYS_DP                            EQU $0
                      
                      * OSENTRIESLOC - this is the area that contains the OS call JSRs
                      * to mimic the published BBC MOS API
FFB6                  OSENTRIESLOC                            EQU $FFB6
                      
FF98                  JGH_OSENTRIESLOC                        EQU OSENTRIESLOC-3*10
                      
FF8C                  DOM_DEBUG_ENTRIES                       EQU JGH_OSENTRIESLOC-3*4
                      
                      * BOUNCELOC - an area of "bounces" where the indirected jumps and
                      * jsrs are stored - these need an extra instruction byte to 6502
                      * so must indirect through here
FF6C                  BOUNCELOC                               EQU JGH_OSENTRIESLOC-4*11
                      
                      
                      
0003                  FSCV_CODE_OSCLI_UK                      EQU $03
                      
                      
0000                  zp_lang                                 EQU $0000
0090                  zp_eco                                  EQU $0090
00A0                  zp_nmi                                  EQU $00A0
00A9                  L00A9                                   EQU $00A9
00B0                  zp_fs_s                                 EQU $00B0
00C0                  zp_fs_w                                 EQU $00C0
00D0                  zp_vdu_status                           EQU $00D0       ; VDU Status as read by OSBYTE &75
00D1                  zp_vdu_grpixmask                        EQU $00D1       ; Graphics pixel mask
00D2                  zp_vdu_txtcolourOR                      EQU $00D2       ; Text colour OR mask
00D3                  zp_vdu_txtcolourEOR                     EQU $00D3       ; Text colour EOR mask
00D4                  zp_vdu_gracolourOR                      EQU $00D4       ; Graphics colour OR mask
00D5                  zp_vdu_gracolourEOR                     EQU $00D5       ; Graphics colour EOR mask
00D6                  zp_vdu_gra_char_cell                    EQU $00D6       ; Graphics character cell
00D8                  zp_vdu_top_scanline                     EQU $00D8       ; Top scan line
00DA                  zp_vdu_wksp                             EQU $00DA       ; Temporary workspace
                      ;;;;removed !zp_rom_mul                 EQU $00E0       ; BBC, Electron: Row multiplication
00E2                  zp_cfs_w                                EQU $00E2
00E3                  zp_opt_val                              EQU $00E3       ; DB? check
00E4                  zp_mos_GSREAD_quoteflag                 EQU $00E4       ; GSREAD quote flag
00E5                  zp_mos_GSREAD_characc                   EQU $00E5       ; GSREAD character accumulator
00E6                  zp_mos_OS_wksp                          EQU $00E6       ; General OS workspace
00E7                  zp_mos_autorep_countdown                EQU $00E7       ; Auto repeat countdown timer
00E8                  zp_mos_input_buf                        EQU $00E8       ; Input buffer pointer for OSWORD 0
00EA                  zp_mos_rs423timeout                     EQU $00EA       ; RS423 timeout counter, unused if no RS423
00EB                  zp_mos_cfs_critical                     EQU $00EB       ; CFS/RFS 'critical' flag
00EC                  zp_mos_keynumlast                       EQU $00EC       ; Internal key number (last)
00ED                  zp_mos_keynumfirst                      EQU $00ED       ; Internal key number (first)
00EE                  zp_mos_jimdevsave                       EQU $00EE       ; Internal key number of character to be ignored by OSBYTE &79, also the 1MHz bus paging register
00EF                  zp_mos_OSBW_A                           EQU $00EF       ; OSBYTE/OSWORD A reg value
                              ***** NOTE: zp_mos_OSBW_Y&X swapped for endiannedss
00F0                  zp_mos_OSWORD_X                         EQU $00F0
00F0                  zp_mos_OSBW_Y                           EQU $00F0       ; OSBYTE/OSWORD Y reg value
00F1                  zp_mos_OSBW_X                           EQU $00F1       ; OSBYTE/OSWORD X reg value
                      
00F2                  zp_mos_txtptr                           EQU $00F2       ; OS Text pointer (eg star commands and filenames)
00F4                  zp_mos_curROM                           EQU $00F4       ; Currently selected ROM
00F5                  zp_mos_curPHROM                         EQU $00F5       ; Current PHROM or RFS ROM number or OSRDSC/OSWRSC number
00F6                  zp_mos_genPTR                           EQU $00F6       ; PHROM/RFSROM/OSRDSC/OSWRSC pointer
00F8                  zp_mos_X                                EQU $00F8       ; BBC, Electron: Unused, Master: Soft key expansion pointer
00FA                  zp_mos_OS_wksp2                         EQU $00FA       ; General OS workspace, used by buffer access code in interrupts
00FC                  zp_mos_INT_A                            EQU $00FC       ; Interrupt Temp A reg store
00FD                  zp_mos_error_ptr                        EQU $00FD       ; Error message pointer, initially set to language version string
00FF                  zp_mos_ESC_flag                         EQU $00FF       ; Escape flag (bit 7)
                      
0100                  stack                                   EQU $0100
0200                  STACKTOP                                EQU $0200
                      
0236                  sysvar_OSVARADDR                        EQU $0236       ; fx166/7 &A6/7 Address of OS variables
0238                  sysvar_ROMPTRTAB                        EQU $0238       ; fx168/9 &A8/9 Address of ROM pointer table
023A                  sysvar_ROMINFOTAB                       EQU $023A       ; fx170/1 &AA/B Address of ROM info table
023C                  sysvar_KEYB_ADDRTRANS                   EQU $023C       ; fx172/3 &AC/D Address of key translation table
023E                  sysvar_ADDRVDUVARS                      EQU $023E       ; fx174/5 &AE/F Address of VDU variables
0240                  sysvar_CFSTOCTR                         EQU $0240       ; fx176   &B0   CFS timeout counter, decremented every frame flyback
0241                  sysvar_CURINSTREAM                      EQU $0241       ; fx177   &B1   Currently selected input stream set with FX2
0242                  sysvar_KEYB_SEMAPHORE                   EQU $0242       ; fx178   &B2   BBC, Master: Keyboard semaphore
0243                  sysvar_PRI_OSHWM                        EQU $0243       ; fx179   &B3   Primary OSHWM
0244                  sysvar_CUR_OSHWM                        EQU $0244       ; fx180   &B4   Current OSHWM
0245                  sysvar_RS423_MODE                       EQU $0245       ; fx181   &B5   RS423 mode
0246                  sysvar_EXPLODESTATUS                    EQU $0246       ; fx182   &B6   BBC, Electron: Character definition explosion status
0247                  sysvar_CFSRFS_SWITCH                    EQU $0247       ; fx183   &B7   CFS/RFS switch
0248                  sysvar_VIDPROC_CTL_COPY                 EQU $0248       ; fx184   &B8   BBC, Master: RAM copy of VIDPROC control register
0249                  sysvar_VIDPROC_PAL_COPY                 EQU $0249       ; fx185   &B9   BBC, Master: RAM copy of VIDPROC palette register
024A                  sysvar_ROMNO_ATBREAK                    EQU $024A       ; fx186   &BA   ROM active last BRK
024B                  sysvar_ROMNO_BASIC                      EQU $024B       ; fx187   &BB   BASIC ROM number
024C                  sysvar_ADC_CUR                          EQU $024C       ; fx188   &BC   Current ADC Channel
024D                  sysvar_ADC_MAX                          EQU $024D       ; fx189   &BD   Maximum ADC Channel number
024E                  sysvar_ADC_ACCURACY                     EQU $024E       ; fx190   &BE   ADC conversion type/accuracy
024F                  sysvar_RS423_USEFLAG                    EQU $024F       ; fx191   &BF   RS423 use flag
0250                  sysvar_RS423_CTL_COPY                   EQU $0250       ; fx192   &C0   RAM copy of RS423 control register
0251                  sysvar_FLASH_CTDOWN                     EQU $0251       ; fx193   &C1   Flashing colour countdown timer
0252                  sysvar_FLASH_SPACE_PERIOD               EQU $0252       ; fx194   &C2   Flashing colour space period count set by FX9
0253                  sysvar_FLASH_MARK_PERIOD                EQU $0253       ; fx195   &C3   Flashing colour mark period count set by FX10
0254                  sysvar_KEYB_AUTOREP_DELAY               EQU $0254       ; fx196   &C4   Keyboard auto-repeat delay set by FX11
0255                  sysvar_KEYB_AUTOREP_PERIOD              EQU $0255       ; fx197   &C5   Keyboard auto-repeat period set by FX12
0256                  sysvar_EXEC_FILE                        EQU $0256       ; fx198   &C6   *EXEC file
0257                  sysvar_SPOOL_FILE                       EQU $0257       ; fx199   &C7   *SPOOL file handle
0258                  sysvar_BREAK_EFFECT                     EQU $0258       ; fx200   &C8   ESCAPE, BREAK effect
0259                  sysvar_KEYB_DISABLE                     EQU $0259       ; fx201   &C9   Keyboard disable
025A                  sysvar_KEYB_STATUS                      EQU $025A       ; fx202   &CA   Keyboard status byte
                                                                              ;Bit 7  =1 shift enabled   
                                                                              ;Bit 6  =1 control pressed 
                                                                              ;bit 5  =0 shift lock      
                                                                              ;Bit 4  =0 Caps lock       
                                                                              ;Bit 3  =1 shift pressed   
                      
025B                  sysvar_RS423_BUF_EXT                    EQU $025B       ; fx203   &CB   BBC, Master: Serial input buffer extent
025C                  sysvar_RS423_SUPPRESS                   EQU $025C       ; fx204   &CC   BBC, Master: Serial input supression flag
025D                  sysvar_RS423CASS_SELECT                 EQU $025D       ; fx205   &CD   BBC, Master: Serial/cassette selection flag
025E                  sysvar_ECO_OSBW_INTERCEPT               EQU $025E       ; fx206   &CE   Econet OSBYTE/OSWORD intercept flag
025F                  sysvar_ECO_OSRDCH_INTERCEPT             EQU $025F       ; fx207   &CF   Econet OSRDCH intercept flag
0260                  sysvar_ECO_OSWRCH_INTERCEPT             EQU $0260       ; fx208   &D0   Econet OSWRCH intercept flag
0261                  sysvar_SPEECH_SUPPRESS                  EQU $0261       ; fx209   &D1   Speech suppression status
0262                  sysvar_SOUND_SUPPRESS                   EQU $0262       ; fx210   &D2   Sound suppression status
0263                  sysvar_BELL_CH                          EQU $0263       ; fx211   &D3   BELL channel number
0264                  sysvar_BELL_ENV                         EQU $0264       ; fx212   &D4   BELL envelope number/amplitude
0265                  sysvar_BELL_FREQ                        EQU $0265       ; fx213   &D5   BELL frequency
0266                  sysvar_BELL_DUR                         EQU $0266       ; fx214   &D6   BELL duration
0267                  sysvar_STARTUP_DISPOPT                  EQU $0267       ; fx215   &D7   Startup display and BOOT error options
0268                  sysvar_KEYB_SOFTKEY_LENGTH              EQU $0268       ; fx216   &D8   Soft key string length
0269                  sysvar_SCREENLINES_SINCE_PAGE           EQU $0269       ; fx217   &D9   Screen lines since last page
026A                  sysvar_VDU_Q_LEN                        EQU $026A       ; fx218   &DA   256-number of items in VDU queue
026B                  sysvar_KEYB_TAB_CHAR                    EQU $026B       ; fx219   &DB   BBC, Master: TAB key character
026C                  sysvar_KEYB_ESC_CHAR                    EQU $026C       ; fx220   &DC   ESCAPE character
026D                  sysvar_KEYB_C0CF_INSERT_INT             EQU $026D       ; fx221   &DD   Char &C0-&CF buffer insert interpretation
026E                  sysvar_KEYB_D0DF_INSERT_INT             EQU $026E       ; fx222   &DE   Char &D0-&DF buffer insert interpretation
026F                  sysvar_KEYB_E0EF_INSERT_INT             EQU $026F       ; fx223   &DF   Char &E0-&EF buffer insert interpretation
0270                  sysvar_KEYB_F0FF_INSERT_INT             EQU $0270       ; fx224   &E0   Char &F0-&FF buffer insert interpretation
0271                  sysvar_KEYB_808F_INSERT_INT             EQU $0271       ; fx225   &E1   Char &80-&8F buffer insert interpretation (FKey)
0272                  sysvar_KEYB_909F_INSERT_INT             EQU $0272       ; fx226   &E2   Char &90-&9F buffer insert interpretation (Sh+FKey)
0273                  sysvar_KEYB_A0AF_INSERT_INT             EQU $0273       ; fx227   &E3   Char &A0-&AF buffer insert interpretation (Ct+FKey)
0274                  sysvar_KEYB_B0BF_INSERT_INT             EQU $0274       ; fx228   &E4   Char &B0-&BF buffer insert interpretation (Ct+Sh+FKey)
0275                  sysvar_KEYB_ESC_ACTION                  EQU $0275       ; fx229   &E5   ESCAPE key action
0276                  sysvar_KEYB_ESC_EFFECT                  EQU $0276       ; fx230   &E6   ESCAPE effects
0277                  sysvar_USERVIA_IRQ_MASK_CPY             EQU $0277       ; fx231   &E7   User 6522 VIA IRQ mask
0278                  sysvar_ACIA_IRQ_MASK_CPY                EQU $0278       ; fx232   &E8   6850 ACIA IRQ bit mask
0279                  sysvar_SYSVIA_IRQ_MASK_CPY              EQU $0279       ; fx233   &E9   System 6522 VIA IRQ mask
027A                  sysvar_TUBE_PRESENT                     EQU $027A       ; fx234   &EA   Tube presence flag
027B                  sysvar_SPEECH_PRESENT                   EQU $027B       ; fx235   &EB   Speech processor presence flag
027C                  sysvar_OUTSTREAM_DEST                   EQU $027C       ; fx236   &EC   Output stream character destination, set with FX3
027D                  sysvar_KEY_CURSORSTAT                   EQU $027D       ; fx237   &ED   Cursor key status, set with FX4
027E                  sysvar_FX238                            EQU $027E       ; fx238   &EE   BBC, Electron: unused
027F                  sysvar_FX239                            EQU $027F       ; fx239   &EF   unused
0280                  sysvar_COUNTRY                          EQU $0280       ; fx240   &F0   Country code
0281                  sysvar_USERFLAG                         EQU $0281       ; fx241   &F1   User flag location, set with FX1
0282                  sysvar_SERPROC_CTL_CPY                  EQU $0282       ; fx242   &F2   BBC, Master: RAM copy of SERPROC control register
0283                  sysvar_TIMER_SWITCH                     EQU $0283       ; fx243   &F3   Timer switch state
0284                  sysvar_KEYB_SOFT_CONSISTANCY            EQU $0284       ; fx244   &F4   Soft key consistancy flag
0285                  sysvar_PRINT_DEST                       EQU $0285       ; fx245   &F5   Printer destination, set with FX5
0286                  sysvar_PRINT_IGNORE                     EQU $0286       ; fx246   &F6   Printer ignore character, set with FX6
0287                  sysvar_BREAK_VECTOR_JMP                 EQU $0287       ; fx247   &F7   Break Intercept Vector JMP
0288                  sysvar_BREAK_VECTOR_LOW                 EQU $0288       ; fx248   &F8   Break Intercept Vector address low byte
0289                  sysvar_BREAK_VECTOR_HIGH                EQU $0289       ; fx249   &F9   Break Intercept Vector address high byte
028A                  sysvar_SHADOW1                          EQU $028A       ; fx250   &FA   BBC, Electron: unused, unless shadow screen present
028B                  sysvar_SHADOW2                          EQU $028B       ; fx251   &FB   BBC, Electron: unused, unless shadow screen present
028C                  sysvar_CUR_LANG                         EQU $028C       ; fx252   &FC   Current language ROM
028D                  sysvar_BREAK_LAST_TYPE                  EQU $028D       ; fx253   &FD   Last BREAK type
028E                  sysvar_RAM_AVAIL                        EQU $028E       ; fx254   &FE   BBC: Available RAM
028F                  sysvar_STARTUP_OPT                      EQU $028F       ; fx255   &FF   Startup options
0290                  oswksp_VDU_VERTADJ                      EQU $0290       ; VDU vertical adjust, *TV first parameter
0291                  oswksp_VDU_INTERLACE                    EQU $0291       ; Interlace toggle flag, *TV second parameter
0292                  oswksp_TIME                             EQU $0292       ; TIME value 1, high byte...low byte
0297                  oswksp_TIME2                            EQU $0297       ; TIME value 2, high byte...low byte
029C                  oswksp_OSWORD3_CTDOWN                   EQU $029C       ; OSWORD 3/4 Countdown interval timer value
02A1                  oswksp_ROMTYPE_TAB                      EQU $02A1       ; Paged ROM type table
02B1                  oswksp_INKEY_CTDOWN                     EQU $02B1       ; INKEY countdown timer
02B3                  oswksp_OSWORD0_LINE_LEN                 EQU $02B3       ; OSWORD 0 maximum line length
02B4                  oswksp_OSWORD0_MIN_CH                   EQU $02B4       ; OSWORD 0 minimum character
02B5                  oswksp_OSWORD0_MAX_CH                   EQU $02B5       ; OSWORD 0 maximum character
02B6                  adc_CH1_LOW                             EQU $02B6       ; Channel 1 ADC value low
02B7                  adc_CH2_LOW                             EQU $02B7       ; Channel 2 ADC value low
02B8                  adc_CH3_LOW                             EQU $02B8       ; Channel 3 ADC value low
02B9                  adc_CH4_LOW                             EQU $02B9       ; Channel 4 ADC value low
02BA                  adc_CH1_HI                              EQU $02BA       ; Channel 1 ADC value high
02BB                  adc_CH2_HI                              EQU $02BB       ; Channel 2 ADC value high
02BC                  adc_CH3_HI                              EQU $02BC       ; Channel 3 ADC value high
02BD                  adc_CH4_HI                              EQU $02BD       ; Channel 4 ADC value high
02BE                  adc_CH_LAST                             EQU $02BE       ; Last ADC channel converted
02BF                  mosvar_EVENT_ENABLE                     EQU $02BF       ; MOS Event enable flags
02C9                  mosvar_SOFTKEY_PTR                      EQU $02C9       ; Soft key expansion pointer
02CA                  mosvar_KEYB_AUTOREPEAT_COUNT            EQU $02CA       ; First auto repeat count
02CB                  mosvar_KEYB_TWOKEY_ROLLOVER             EQU $02CB       ; Two key rollover workspace
02CE                  mosvar_SOUND_SEMAPHORE                  EQU $02CE       ; Sound semaphore
02CF                  mosbuf_buf_busy                         EQU $02CF       ; Buffer busy flags           
02D8                  mosbuf_buf_start                        EQU $02D8       ; Buffer start indexes        
02E1                  mosbuf_buf_end                          EQU $02E1       ; Buffer end indexes          
02EA                  cfsrfs_BLK_SIZE                         EQU $02EA       ; Block size
02EC                  cfsrfs_BLK_FLAG                         EQU $02EC       ; Block flag
02ED                  cfsrfs_LAST_CHA                         EQU $02ED       ; Last input character
02EE                  osfile_ctlblk                           EQU $02EE       ; OSFILE control blocks for *LOAD, *SAVE, *CREATE and *DELETE.
0300                  vduvars_start                           EQU $0300
0300                  vduvar_GRA_WINDOW                       EQU $0300                               
0300                  vduvar_GRA_WINDOW_LEFT                  EQU $0300       ; Current graphics window left column in pixels
0302                  vduvar_GRA_WINDOW_BOTTOM                EQU $0302       ; Current graphics window bottom row in pixels
0304                  vduvar_GRA_WINDOW_RIGHT                 EQU $0304       ; Current graphics window right column in pixels
0306                  vduvar_GRA_WINDOW_TOP                   EQU $0306       ; Current graphics window top row in pixels
0308                  vduvar_TXT_WINDOW_LEFT                  EQU $0308       ; Current text window left hand column
0309                  vduvar_TXT_WINDOW_BOTTOM                EQU $0309       ; Current text window bottom row
030A                  vduvar_TXT_WINDOW_RIGHT                 EQU $030A       ; Current text window right hand column
030B                  vduvar_TXT_WINDOW_TOP                   EQU $030B       ; Current text window top column
030C                  vduvar_GRA_ORG_EXT                      EQU $030C       ; Current graphics origin in external coordinates
0310                  vduvar_GRA_CUR_EXT                      EQU $0310       ; Current graphics cursor in external coordinates
0314                  vduvar_GRA_CUR_INT_OLD                  EQU $0314       ; Old graphics cursor in external coordinates
0318                  vduvar_TXT_CUR_X                        EQU $0318       ; Current text cursor X
0319                  vduvar_TXT_CUR_Y                        EQU $0319       ; Current text cursor Y
031A                  vduvar_GRA_CUR_CELL_LINE                EQU $031A       ; Line within current graphics cell of graphics cursor
031B                  vduvar_VDU_Q_START                      EQU $031B
0324                  vduvar_VDU_Q_END                        EQU $0324       ; end of VDU Q (well 1 after!)
0324                  vduvar_GRA_CUR_INT                      EQU $0324       ; Current graphics cursor in internal coordinates
0328                  vduvar_TEMP_8                           EQU $0328       ; Bitmap read from screen by OSBYTE 135, various coordinate routines
0330                  vduvar_GRA_WKSP                         EQU $0330       ; Graphics workspace
034A                  vduvar_6845_CURSOR_ADDR                 EQU $034A       ; Text cursor address for 6845
034C                  vduvar_TXT_WINDOW_WIDTH_BYTES           EQU $034C       ; Text window width in bytes
034E                  vduvar_SCREEN_BOTTOM_HIGH               EQU $034E       ; High byte of bottom of screen memory
034F                  vduvar_BYTES_PER_CHAR                   EQU $034F       ; Bytes per character for current mode
0350                  vduvar_6845_SCREEN_START                EQU $0350       ; Screen display start address for 6845
0352                  vduvar_BYTES_PER_ROW                    EQU $0352       ; Bytes per screen row
0354                  vduvar_SCREEN_SIZE_HIGH                 EQU $0354       ; Screen memory size high byte
0355                  vduvar_MODE                             EQU $0355       ; Current screen mode
0356                  vduvar_MODE_SIZE                        EQU $0356       ; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
0357                  vduvar_TXT_FORE                         EQU $0357       ; Foreground text colour
0358                  vduvar_TXT_BACK                         EQU $0358       ; Background text colour
0359                  vduvar_GRA_FORE                         EQU $0359       ; Foreground graphics colour
035A                  vduvar_GRA_BACK                         EQU $035A       ; Background graphics colour
035B                  vduvar_GRA_PLOT_FORE                    EQU $035B       ; Foreground plot mode
035C                  vduvar_GRA_PLOT_BACK                    EQU $035C       ; Background plot mode
035D                  vduvar_VDU_VEC_JMP                      EQU $035D       ; General VDU jump vector
035F                  vduvar_CUR_START_PREV                   EQU $035F       ; Cursor start register previous setting
0360                  vduvar_COL_COUNT_MINUS1                 EQU $0360       ; Number logical colours -1
0361                  vduvar_PIXELS_PER_BYTE_MINUS1           EQU $0361       ; Pixels per byte -1 (zero if text only mode)
0362                  vduvar_LEFTMOST_PIX_MASK                EQU $0362       ; Leftmost pixel colour mask
0363                  vduvar_RIGHTMOST_PIX_MASK               EQU $0363       ; Rightmost pixel colour mask
0364                  vduvar_TEXT_IN_CUR_X                    EQU $0364       ; Text input cursor X
0365                  vduvar_TEXT_IN_CUR_Y                    EQU $0365       ; Text input cursor Y
0366                  vduvar_MO7_CUR_CHAR                     EQU $0366       ; Teletext output cursor character
0367                  vduvar_EXPLODE_FLAGS                    EQU $0367       ; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
0368                  vduvar_FONT_LOC32_63                    EQU $0368       ; Font location, characters 32-63
0369                  vduvar_FONT_LOC64_95                    EQU $0369       ; Font location, characters 64-95 
036A                  vduvar_FONT_LOC96_127                   EQU $036A       ; Font location, characters 96-127
036B                  vduvar_FONT_LOC128_159                  EQU $036B       ; Font location, characters 128-159
036C                  vduvar_FONT_LOC160_191                  EQU $036C       ; Font location, characters 160-191
036D                  vduvar_FONT_LOC192_223                  EQU $036D       ; Font location, characters 192-223
036E                  vduvar_FONT_LOC224_255                  EQU $036E       ; Font location, characters 224-255
036F                  vduvar_PALLETTE                         EQU $036F       ; Palette for colours 0 to 15
                      
03D1                  fsvar_seq_block_gap                     EQU $03D1
                      
                      ********************************************************
                      *           B U F F E R   A D D R E S S E S            *
                      ********************************************************
                      
03E0                  BUFFER_KEYB_START                       EQU $03E0
03FF                  BUFFER_KEYB_END                         EQU $03FF
0A00                  BUFFER_SERI_START                       EQU $0A00
0AFF                  BUFFER_SERI_END                         EQU $0AFF
0900                  BUFFER_SERO_START                       EQU $0900
09BF                  BUFFER_SERO_END                         EQU $09BF
0880                  BUFFER_LPT_START                        EQU $0880
08BF                  BUFFER_LPT_END                          EQU $08BF
0840                  BUFFER_SND0_START                       EQU $0840
084F                  BUFFER_SND0_END                         EQU $084F
0850                  BUFFER_SND1_START                       EQU $0850
085F                  BUFFER_SND1_END                         EQU $085F
0860                  BUFFER_SND2_START                       EQU $0860
086F                  BUFFER_SND2_END                         EQU $086F
0870                  BUFFER_SND3_START                       EQU $0870
087F                  BUFFER_SND3_END                         EQU $087F
09C0                  BUFFER_SPCH_START                       EQU $09C0
09FF                  BUFFER_SPCH_END                         EQU $09FF
                      
                      
                      BUFFER_PTR_ADDR         MACRO ; 1=START, 2=END
                                              FDB (\2+1)-$100
                                              ENDM
                      
                      BUFFER_ACC_OFF          MACRO ; 1=START, 2=END
                                              FCB \1-(\2+1)-$100              ; i.e. $100 - len!
                                              ENDM
                      
                      
                      
                      
0800                  snd_unused1                             EQU $800        ; Unused
0804                  snd_q_occupied                          EQU $804        ; Sound queue occupancy flag
0808                  snd_amplitude                           EQU $808        ; Current amplitude
080C                  snd_amplitude_phase_count               EQU $80C        ; Number of amplitude phases processed
0810                  snd_abs_pitch                           EQU $810        ; Absolute pitch value
0814                  snd_pitch_phase_count                   EQU $814        ; Number of pitch phases processed
0818                  snd_steps_left                          EQU $818        ; Number of steps to process
081C                  snd_duration_ctr                        EQU $81C        ; Duration
0820                  snd_duration_mul                        EQU $820        ; Interval multiplier
0824                  snd_env_no                              EQU $824        ; Envelope number/auto repeat parameter
0828                  snd_length_left                         EQU $828        ; Length of remaining note interval
082C                  snd_sync_hold_parm                      EQU $82C        ; Sync hold parameter
0830                  snd_chip_pitch                          EQU $830        ; Sound chip current pitch setting
0834                  snd_pitch_deviation                     EQU $834        ; Pitch deviation
0838                  snd_num_chans_sync                      EQU $838        ; Number of channels required for sync
0839                  snd_cur_amp_step                        EQU $839        ; Current amplitude step
083A                  snd_cur_target_amplitude                EQU $83A        ; Current target amplitude
083B                  snd_num_chans_hold_sync                 EQU $83B        ; Number of channels on hold for sync
                      
083C                  snd_parm_wksp                           EQU $83C        ; Sound parameter calculation workspace
083D                  snd_low_parm                            EQU $83D        ; Low order frequency parameter as sent to the sound generator
083E                  snd_high_parm                           EQU $83E        ; High order frequency parameter as sent to the sound generator
083F                  snd_tempx                               EQU $83F
                      
08C0                  snd_envelope_defs                       EQU $8C0
                      
0B00                  soft_keys_start                         EQU $B00
0B00                  soft_keys_ptrs                          EQU soft_keys_start
0B10                  soft_keys_end_ptr                       EQU soft_keys_ptrs+$10
0B11                  soft_keys_defs                          EQU soft_keys_start+$11
                      
0D00                  vec_nmi                                 EQU $0D00
                      
0DF0                  swrom_wksp_tab                          EQU $0DF0
                      
                      ; REMAPPED HARDWARE VECTOS
                      
F7F0                  HWVEC_DIV0                              EQU     $F7F0
F7F2                  HWVEC_SWI3V                             EQU     $F7F2
F7F4                  HWVEC_SWI2V                             EQU     $F7F4
F7F6                  HWVEC_FIRQV                             EQU     $F7F6
F7F8                  HWVEC_IRQV                              EQU     $F7F8
F7FA                  HWVEC_SWIV                              EQU     $F7FA
F7FC                  HWVEC_NMIV                              EQU     $F7FC
F7FE                  HWVEC_RESETV                            EQU     $F7FE
                                              INCLUDE         "../../includes/oslib.inc"
                      ;       OS Entry points
                      
FFC2                  GSINIT                                  EQU     $FFC2
FFC5                  GSREAD                                  EQU     $FFC5
FFC8                  OSRDCH_NV                               EQU     $FFC8
FFCB                  OSWRCH_NV                               EQU     $FFCB
FFCE                  OSFIND                                  EQU     $FFCE
FFD1                  OSGBPB                                  EQU     $FFD1
FFD4                  OSBPUT                                  EQU     $FFD4
FFD7                  OSBGET                                  EQU     $FFD7
FFDA                  OSARGS                                  EQU     $FFDA
FFDD                  OSFILE                                  EQU     $FFDD
FFE0                  OSRDCH                                  EQU     $FFE0
FFE3                  OSASCI                                  EQU     $FFE3
FFE7                  OSNEWL                                  EQU     $FFE7
FFEC                  OSWRCR                                  EQU     $FFEC
FFEE                  OSWRCH                                  EQU     $FFEE
FFF1                  OSWORD                                  EQU     $FFF1
FFF4                  OSBYTE                                  EQU     $FFF4
FFF7                  OSCLI                                   EQU     $FFF7
                      
FF9B                  PRSTRING                                EQU     $FF9B
FFB9                  CLICOM                                  EQU     $FFB9
FFBC                  ERRJMP                                  EQU     $FFBC
FFBF                  OSINIT                                  EQU     $FFBF
FFA1                  SCANHEX                                 EQU     $FFA1
FFA7                  OSQUIT                                  EQU     $FFA7
FFAA                  PRHEX                                   EQU     $FFAA
FFAD                  PR2HEX                                  EQU     $FFAD
FFB0                  USERINT                                 EQU     $FFB0
FFB3                  PRTEXT                                  EQU     $FFB3
                      
FF98                  OSRDRM                                  EQU     $FF98   !!! Different to Beeb !!!
FF9E                  OSEVEN                                  EQU     $FF9E   !!! Different to Beeb !!!
FFA3                  RAWVDU                                  EQU     $FFA3   !!! Different to Beeb !!!
                      
FF8C                  DEBUGPRINTNEWL                          EQU     $FF8C
FF8F                  DEBUGPRINTHEX                           EQU     $FF8F
FF92                  DEBUGPRINTA                             EQU     $FF92
FF95                  DEBUGPRINTX                             EQU     $FF95
                      
                      ;       OS Constants
00FF                  OSFILE_LOAD                             EQU $FF
0000                  OSFILE_SAVE                             EQU $00
0005                  OSFILE_CAT                              EQU $05
0000                  OSFILE_OFS_FILENAME                     EQU $00
0002                  OSFILE_OFS_LOAD                         EQU $02
0006                  OSFILE_OFS_EXEC                         EQU $06
000A                  OSFILE_OFS_LEN                          EQU $0A
000A                  OSFILE_OFS_START                        EQU $0A
000E                  OSFILE_OFS_ATTR                         EQU $0E
000E                  OSFILE_OFS_END                          EQU $0E
                      
0000                  OSFIND_CLOSE                            EQU $00
0040                  OSFIND_OPENIN                           EQU $40
0080                  OSFIND_OPENOUT                          EQU $80
00C0                  OSFIND_OPENUP                           EQU $C0
                      
0007                  OSWORD_SOUND                            EQU $07
0008                  OSWORD_ENVELOPE                         EQU $08
                      
0001                  OSARGS_cmdtail                          EQU $01
0002                  OSARGS_EXT                              EQU $02
                      
                      
0000                  OSGBPB_WRITE_PTR                        EQU     $00
0002                  OSGBPB_WRITE_NOPTR                      EQU     $02
0003                  OSGBPB_READ_PTR                         EQU     $03
0004                  OSGBPB_READ_NOPTR                       EQU     $04
0005                  OSGBPB_READ_TITLE                       EQU     $05
0006                  OSGBPB_READ_DIR                         EQU     $06
0007                  OSGBPB_READ_LIB                         EQU     $07
0008                  OSGBPB_GET_DIRENT                       EQU     $08
                      
                      
0000                  SERVICE_0_NOP                           EQU     $0
0001                  SERVICE_1_ABSWKSP_REQ                   EQU     $1
0002                  SERVICE_2_RELWKSP_REQ                   EQU     $2
0003                  SERVICE_3_AUTOBOOT                      EQU     $3
0004                  SERVICE_4_UKCMD                         EQU     $4
0005                  SERVICE_5_UKINT                         EQU     $5
0006                  SERVICE_6_BRK                           EQU     $6
0007                  SERVICE_7_UKOSBYTE                      EQU     $7
0008                  SERVICE_7_UKOSWORD                      EQU     $8
0009                  SERVICE_9_HELP                          EQU     $9
000A                  SERVICE_A_ABSWKSP_CLAIM                 EQU     $A
000B                  SERVICE_B_NMI_RELEASE                   EQU     $B
000C                  SERVICE_C_NMI_CLAIM                     EQU     $C
000D                  SERVICE_D_ROMFS_INIT                    EQU     $D
000E                  SERVICE_E_ROMFS_GETB                    EQU     $E
000F                  SERVICE_F_FSVEC_CLAIMED                 EQU     $F
0010                  SERVICE_10_SPOOL_CLOSE                  EQU     $10
0011                  SERVICE_11_FONT_BANG                    EQU     $11
0012                  SERVICE_12_INITFS                       EQU     $12
0013                  SERVICE_13_SERIAL_CHAR                  EQU     $13
0014                  SERVICE_14_PRINT_CHAR                   EQU     $14
0015                  SERVICE_15_100Hz                        EQU     $15
0025                  SERVICE_25_FSINFO                       EQU     $25
                      
0006                  FSCV_6_NewFS                            EQU     $06
                      
                      ; OS Vectors
                      
0200                  USERV                                   EQU     $0200   ; User vector, called by *LINE, *CODE, OSWORD >=&E0
0202                  BRKV                                    EQU     $0202   ; The BRK vector
0204                  IRQ1V                                   EQU     $0204   ; Main interrupt vector
0206                  IRQ2V                                   EQU     $0206   ; Secondary interrupt vector
0208                  CLIV                                    EQU     $0208   ; Command Line Interpreter vector
020A                  BYTEV                                   EQU     $020A   ; OSBYTE (*FX) calls
020C                  WORDV                                   EQU     $020C   ; OSWORD calls
020E                  WRCHV                                   EQU     $020E   ; Send character to current output stream
0210                  RDCHV                                   EQU     $0210   ; Wait for a character from current input stream
0212                  FILEV                                   EQU     $0212   ; Operate on a whole file, eg loading/saving/delete/etc
0214                  ARGSV                                   EQU     $0214   ; Read/Write arguments on an open file
0216                  BGETV                                   EQU     $0216   ; Read a byte from an open file
0218                  BPUTV                                   EQU     $0218   ; Write a byte to an open file
021A                  GBPBV                                   EQU     $021A   ; Read/Write block of data from/to open file or device
021C                  FINDV                                   EQU     $021C   ; Open or close a file
021E                  FSCV                                    EQU     $021E   ; Various filing system control calls
0220                  EVNTV                                   EQU     $0220   ; Event handler
0222                  UPTV                                    EQU     $0222   ; User Print vector
0224                  NETV                                    EQU     $0224   ; Network Print vector
0226                  VDUV                                    EQU     $0226   ; Unrecognised VDU commands
0228                  KEYV                                    EQU     $0228   ; Read the keyboard
022A                  INSV                                    EQU     $022A   ; Insert characters into a buffer
022C                  REMV                                    EQU     $022C   ; Remove characters from a buffer
022E                  CNPV                                    EQU     $022E   ; Count or Purge a buffer
                      ;;IND1V                                 EQU     $0230   ; Spare 
0230                  SWI9V                                   EQU     $0230   ; SWI instruction vector - do not use except for debugging
0232                  ILOPV                                   EQU     $0232   ; Illegal operation vector
0234                  NMI9V                                   EQU     $0234   ; NMI vector - do not use except for debugging
                      
                      ; OS Extended Vectors Marker addresses
                      
FF00                  EXTVEC_ENTER_USERV                      EQU     $FF00   ; User vector, called by *LINE, *CODE, OSWORD >=&E0
FF03                  EXTVEC_ENTER_BRKV                       EQU     $FF03   ; The BRK vector
FF06                  EXTVEC_ENTER_IRQ1V                      EQU     $FF06   ; Main interrupt vector
FF09                  EXTVEC_ENTER_IRQ2V                      EQU     $FF09   ; Secondary interrupt vector
FF0C                  EXTVEC_ENTER_CLIV                       EQU     $FF0C   ; Command Line Interpreter vector
FF0F                  EXTVEC_ENTER_BYTEV                      EQU     $FF0F   ; OSBYTE (*FX) calls
FF12                  EXTVEC_ENTER_WORDV                      EQU     $FF12   ; OSWORD calls
FF15                  EXTVEC_ENTER_WRCHV                      EQU     $FF15   ; Send character to current output stream
FF18                  EXTVEC_ENTER_RDCHV                      EQU     $FF18   ; Wait for a character from current input stream
FF1B                  EXTVEC_ENTER_FILEV                      EQU     $FF1B   ; Operate on a whole file, eg loading/saving/delete/etc
FF1E                  EXTVEC_ENTER_ARGSV                      EQU     $FF1E   ; Read/Write arguments on an open file
FF21                  EXTVEC_ENTER_BGETV                      EQU     $FF21   ; Read a byte from an open file
FF24                  EXTVEC_ENTER_BPUTV                      EQU     $FF24   ; Write a byte to an open file
FF27                  EXTVEC_ENTER_GBPBV                      EQU     $FF27   ; Read/Write block of data from/to open file or device
FF2A                  EXTVEC_ENTER_FINDV                      EQU     $FF2A   ; Open or close a file
FF2D                  EXTVEC_ENTER_FSCV                       EQU     $FF2D   ; Various filing system control calls
FF30                  EXTVEC_ENTER_EVNTV                      EQU     $FF30   ; Event handler
FF33                  EXTVEC_ENTER_UPTV                       EQU     $FF33   ; User Print vector
FF36                  EXTVEC_ENTER_NETV                       EQU     $FF36   ; Network Print vector
FF39                  EXTVEC_ENTER_VDUV                       EQU     $FF39   ; Unrecognised VDU commands
FF3C                  EXTVEC_ENTER_KEYV                       EQU     $FF3C   ; Read the keyboard
FF3F                  EXTVEC_ENTER_INSV                       EQU     $FF3F   ; Insert characters into a buffer
FF42                  EXTVEC_ENTER_REMV                       EQU     $FF42   ; Remove characters from a buffer
FF45                  EXTVEC_ENTER_CNPV                       EQU     $FF45   ; Count or Purge a buffer
FF48                  EXTVEC_ENTER_SWI9V                      EQU     $FF48   ; Spare
FF4B                  EXTVEC_ENTER_ILOPV                      EQU     $FF4B   ; Spare
FF4E                  EXTVEC_ENTER_NMI9V                      EQU     $FF4E   ; Spare
                      
0D9F                  EXT_USERV                               EQU     $0D9F   ; User vector, called by *LINE, *CODE, OSWORD >=&E0
0DA2                  EXT_BRKV                                EQU     $0DA2   ; The BRK vector
0DA5                  EXT_IRQ1V                               EQU     $0DA5   ; Main interrupt vector
0DA8                  EXT_IRQ2V                               EQU     $0DA8   ; Secondary interrupt vector
0DAB                  EXT_CLIV                                EQU     $0DAB   ; Command Line Interpreter vector
0DAE                  EXT_BYTEV                               EQU     $0DAE   ; OSBYTE (*FX) calls
0DB1                  EXT_WORDV                               EQU     $0DB1   ; OSWORD calls
0DB4                  EXT_WRCHV                               EQU     $0DB4   ; Send character to current output stream
0DB7                  EXT_RDCHV                               EQU     $0DB7   ; Wait for a character from current input stream
0DBA                  EXT_FILEV                               EQU     $0DBA   ; Operate on a whole file, eg loading/saving/delete/etc
0DBD                  EXT_ARGSV                               EQU     $0DBD   ; Read/Write arguments on an open file
0DC0                  EXT_BGETV                               EQU     $0DC0   ; Read a byte from an open file
0DC3                  EXT_BPUTV                               EQU     $0DC3   ; Write a byte to an open file
0DC6                  EXT_GBPBV                               EQU     $0DC6   ; Read/Write block of data from/to open file or device
0DC9                  EXT_FINDV                               EQU     $0DC9   ; Open or close a file
0DCC                  EXT_FSCV                                EQU     $0DCC   ; Various filing system control calls
0DCF                  EXT_EVNTV                               EQU     $0DCF   ; Event handler
0DD2                  EXT_UPTV                                EQU     $0DD2   ; User Print vector
0DD5                  EXT_NETV                                EQU     $0DD5   ; Network Print vector
0DD8                  EXT_VDUV                                EQU     $0DD8   ; Unrecognised VDU commands
0DDB                  EXT_KEYV                                EQU     $0DDB   ; Read the keyboard
0DDE                  EXT_INSV                                EQU     $0DDE   ; Insert characters into a buffer
0DE1                  EXT_REMV                                EQU     $0DE1   ; Remove characters from a buffer
0DE4                  EXT_CNPV                                EQU     $0DE4   ; Count or Purge a buffer
0DE7                  EXT_SWI9V                               EQU     $0DE7   ; SWI instruction vector - do not use except for debugging
0DEA                  EXT_ILOPV                               EQU     $0DEA   ; Illegal operation vector
0DED                  EXT_NMI9V                               EQU     $0DED   ; NMI vector - do not use except for debugging
                      
000D                  OSBYTE_13_ENABLE_EVENT                  EQU     13
000E                  OSBYTE_14_ENABLE_EVENT                  EQU     14
006C                  OSBYTE_108_WRITE_SHADOW_STATE           EQU     108
0077                  OSBYTE_119_CLOSE_SPOOL_AND_EXEC         EQU     119
007E                  OSBYTE_126_ESCAPE_ACK                   EQU     126
0081                  OSBYTE_129_INKEY                        EQU     129
008F                  OSBYTE_142_SERVICE_CALL                 EQU     143
009C                  OSBYTE_156_SERIAL_STATE                 EQU     156
00A0                  OSBYTE_160_READ_VDU_VARIABLE            EQU     160
00A8                  OSBYTE_168_READ_ROM_POINTER_TABLE       EQU     168
00AA                  OSBYTE_171_ROMTAB                       EQU     170
00E8                  OSBYTE_232_VAR_IRQ_MASK_SERIAL          EQU     232
00EA                  OSBYTE_234_VAR_TUBE                     EQU     234
00FD                  OSBYTE_253_VAR_LAST_RESET               EQU     253
                      
0000                  vduvar_ix_GRA_WINDOW                    EQU $00                         
0000                  vduvar_ix_GRA_WINDOW_LEFT               EQU $00 ; Current graphics window left column in pixels
0002                  vduvar_ix_GRA_WINDOW_BOTTOM             EQU $02 ; Current graphics window bottom row in pixels
0004                  vduvar_ix_GRA_WINDOW_RIGHT              EQU $04 ; Current graphics window right column in pixels
0006                  vduvar_ix_GRA_WINDOW_TOP                EQU $06 ; Current graphics window top row in pixels
0008                  vduvar_ix_TXT_WINDOW_LEFT               EQU $08 ; Current text window left hand column
0009                  vduvar_ix_TXT_WINDOW_BOTTOM             EQU $09 ; Current text window bottom row
000A                  vduvar_ix_TXT_WINDOW_RIGHT              EQU $0A ; Current text window right hand column
000B                  vduvar_ix_TXT_WINDOW_TOP                EQU $0B ; Current text window top column
000C                  vduvar_ix_GRA_ORG_EXT                   EQU $0C ; Current graphics origin in external coordinates
0010                  vduvar_ix_GRA_CUR_EXT                   EQU $10 ; Current graphics cursor in external coordinates
0014                  vduvar_ix_GRA_CUR_INT_OLD               EQU $14 ; Old graphics cursor in external coordinates
0018                  vduvar_ix_TXT_CUR_X                     EQU $18 ; Current text cursor X
0019                  vduvar_ix_TXT_CUR_Y                     EQU $19 ; Current text cursor Y
001A                  vduvar_ix_GRA_CUR_CELL_LINE             EQU $1A ; Line within current graphics cell of graphics cursor
001B                  vduvar_ix_VDU_Q_START                   EQU $1B
0024                  vduvar_ix_VDU_Q_END                     EQU $24 ; end of VDU Q (well 1 after!)
0024                  vduvar_ix_GRA_CUR_INT                   EQU $24 ; Current graphics cursor in internal coordinates
0028                  vduvar_ix_TEMP_8                        EQU $28 ; Bitmap read from screen by OSBYTE 135, various coordinate routines
0030                  vduvar_ix_GRA_WKSP                      EQU $30 ; Graphics workspace
004A                  vduvar_ix_6845_CURSOR_ADDR              EQU $4A ; Text cursor address for 6845
004C                  vduvar_ix_TXT_WINDOW_WIDTH_BYTES        EQU $4C ; Text window width in bytes
004E                  vduvar_ix_SCREEN_BOTTOM_HIGH            EQU $4E ; High byte of bottom of screen memory
004F                  vduvar_ix_BYTES_PER_CHAR                EQU $4F ; Bytes per character for current mode
0050                  vduvar_ix_6845_SCREEN_START             EQU $50 ; Screen display start address for 6845
0052                  vduvar_ix_BYTES_PER_ROW                 EQU $52 ; Bytes per screen row
0054                  vduvar_ix_SCREEN_SIZE_HIGH              EQU $54 ; Screen memory size high byte
0055                  vduvar_ix_MODE                          EQU $55 ; Current screen mode
0056                  vduvar_ix_MODE_SIZE                     EQU $56 ; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
0057                  vduvar_ix_TXT_FORE                      EQU $57 ; Foreground text colour
0058                  vduvar_ix_TXT_BACK                      EQU $58 ; Background text colour
0059                  vduvar_ix_GRA_FORE                      EQU $59 ; Foreground graphics colour
005A                  vduvar_ix_GRA_BACK                      EQU $5A ; Background graphics colour
005B                  vduvar_ix_GRA_PLOT_FORE                 EQU $5B ; Foreground plot mode
005C                  vduvar_ix_GRA_PLOT_BACK                 EQU $5C ; Background plot mode
005D                  vduvar_ix_VDU_VEC_JMP                   EQU $5D ; General VDU jump vector
005F                  vduvar_ix_CUR_START_PREV                EQU $5F ; Cursor start register previous setting
0060                  vduvar_ix_COL_COUNT_MINUS1              EQU $60 ; Number logical colours -1
0061                  vduvar_ix_PIXELS_PER_BYTE_MINUS1        EQU $61 ; Pixels per byte -1 (zero if text only mode)
0062                  vduvar_ix_LEFTMOST_PIX_MASK             EQU $62 ; Leftmost pixel colour mask
0063                  vduvar_ix_RIGHTMOST_PIX_MASK            EQU $63 ; Rightmost pixel colour mask
0064                  vduvar_ix_TEXT_IN_CUR_X                 EQU $64 ; Text input cursor X
0065                  vduvar_ix_TEXT_IN_CUR_Y                 EQU $65 ; Text input cursor Y
0066                  vduvar_ix_MO7_CUR_CHAR                  EQU $66 ; Teletext output cursor character
0067                  vduvar_ix_EXPLODE_FLAGS                 EQU $67 ; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
0068                  vduvar_ix_FONT_LOC32_63                 EQU $68 ; Font location, characters 32-63
0069                  vduvar_ix_FONT_LOC64_95                 EQU $69 ; Font location, characters 64-95 
006A                  vduvar_ix_FONT_LOC96_127                EQU $6A ; Font location, characters 96-127
006B                  vduvar_ix_FONT_LOC128_159               EQU $6B ; Font location, characters 128-159
006C                  vduvar_ix_FONT_LOC160_191               EQU $6C ; Font location, characters 160-191
006D                  vduvar_ix_FONT_LOC192_223               EQU $6D ; Font location, characters 192-223
006E                  vduvar_ix_FONT_LOC224_255               EQU $6E ; Font location, characters 224-255
006F                  vduvar_ix_PALLETTE                      EQU $6F ; Palette for colours 0 to 15
                              ENDIF
                      
0001                  DEBUG                   EQU     1
8000                  LOADADDR                EQU $8000
8000                  COMPADDR                EQU $8000
                      
00FD                  ZP_MOS_ERROR_PTR_QRY    EQU     $FD             ; TODOFLEX - move this defn somewhere?
                      
                                              INCLUDE         "./macros.inc"
                      ABSR            MACRO
                      1
                      __ABSR          SET 1B+2
                              IF \1-__ABSR <=127 AND \1-__ABSR >=-128
                                      BSR     \1
                              ELSE
                                      LBSR    \1
                              ENDIF
                                      ENDM
                      
                      
                      
                      
                      TODODEADENDFLEX         MACRO
                                      DO_BRK_B
                                      FCB             $7E,"F:"
                                      FCB             \1
                                      FCB             0
                                              ENDM
                      
                      TODODEADEND             MACRO
                                      DO_BRK_B
                                      FCB             $7E,"D:"
                                      FCB             \1
                                      FCB             0
                                              ENDM
                      
                      TODO_CMD                MACRO
                                              TODODEADEND "\1"
                                              ENDM
                      
                      DO_BRK_B                MACRO                   ; code
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
                                              SWI
                                      ELSE
                                              SWI3
                                      ENDIF
                                              ENDM
                      
                      RESET_MACH_STACK        MACRO
                                              LDS     #MACH_STACK_TOP
                                              ENDM
                      
                      LDX_FPC                 MACRO                   ; this may be changed for position independent code
                                              LDX     #\1             ; leave as LDX for now for faster execution
                                              ENDM
                      
                      LDU_FPC                 MACRO                   ; this may be changed for position independent code
                                              LDY     #\1             ; leave as LDX for now for faster execution
                                              ENDM
                      
                      LDY_FPC                 MACRO                   ; this may be changed for position independent code
                                              LDY     #\1             ; leave as LDX for now for faster execution
                                              ENDM
                      
                      
                      CALL                    MACRO                   ; this may be changed for position independent code
                      9
                      __XBSR                  SET 9B+2
                      __XBSR2                 SET (\1-__XBSR) & $FF00
                      __XBSR3                 SET (\1-__XBSR) & $FF
                      
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                                              ENDM
                      
                      JUMP                    MACRO                   ; this may be changed for position independant code
                                              JMP     \1
                                              ENDM
                                              INCLUDE         "./zp.inc"
                                              ; Zero page
0000                  ZP_LOMEM                EQU $00
0002                  ZP_VARTOP               EQU $02
0004                  ZP_BAS_SP               EQU $04
0006                  ZP_HIMEM                EQU $06
0008                  ZP_ERL                  EQU $08
000A                  ZP_TXTOFF               EQU $0A
000B                  ZP_TXTPTR               EQU $0B
000D                  ZP_RND_WA               EQU $0D         ; this keeps same endianness as 6502
0012                  ZP_TOP                  EQU $12
0014                  ZP_PRINTBYTES           EQU $14         ; order of these is assumed in cmdPRINT
0015                  ZP_PRINTFLAG            EQU $15
0016                  ZP_ERR_VECT             EQU $16
0018                  ZP_PAGE_H               EQU $18
0019                  ZP_TXTPTR2              EQU $19
001B                  ZP_TXTOFF2              EQU $1B
001C                  ZP_READ_PTR             EQU $1C
001E                  ZP_PRLINCOUNT           EQU $1E
001F                  ZP_LISTO                EQU $1F
0020                  ZP_TRACE                EQU $20
0021                  ZP_MAXTRACLINE          EQU $21
0023                  ZP_WIDTH                EQU $23
0024                  ZP_REPEAT_LVL           EQU $24
0025                  ZP_GOSUB_LVL            EQU $25
0026                  ZP_FOR_LVL_X_15         EQU $26
0027                  ZP_VARTYPE              EQU $27
0028                  ZP_OPT                  EQU $28
0029                  ZP_ASS_OPBUF            EQU $29         ;; overlaps ZP_DUNNO, ZP_INT_WA stores opcode/postbytes being assembled
0029                  ZP_DUNNO                EQU $29
002A                  ZP_INT_WA               EQU $2A
002E                  ZP_FPA                  EQU $2E
0036                  ZP_STRBUFLEN            EQU $36
0037                  ZP_SAVE_BUF             EQU $37         ;; note this overlaps 
0037                  ZP_GEN_PTR              EQU $37
0038                  ZP_ASS_LIST_OPLEN       EQU $38
0039                  ZP_ASS_OPLEN            EQU $39         ;; length of opcode + postbytes
                      
0037                  ZP_NAMELENORVT          EQU $37         ;; NOTE this is different to 6502 where it is ZP_GEN_PTR+2
                      
003A                  ZP_ASS_OPSAVED          EQU $3A         ;; start of last saved instruction (used in print)
003B                  ZP_FPB                  EQU $3B
0039                  ZP_INT_WA_B             EQU $39         ;; note overlaps ZP_NAMELENORVT and ZP_FP_WA_B sign, exponent
003D                  ZP_INT_WA_C             EQU $3D         ;; note overlaps ZP_FP_WA_B mantissa
0044                  ZP_ASS_OP_IX            EQU ZP_FPB + 9
0043                  ZP_FP_TMP               EQU $43
004A                  ZP_FP_TMP_PTR1          EQU $4A
004C                  ZP_FP_TMP_PTR2          EQU $4C
                      
004E                  ZP_ASS_LBLEND           EQU $4E
004E                  ZP_TMP                  EQU $4E         ; new temporary save / loop counter area
0050                  ZP_DUNNO_WA             EQU $50 
                      
0050                  ZP_ESCPTR               EQU $50         ; new save pointer to escape flag
0052                  ZP_EXTRA_SAVE           EQU $52         ; get rid if possible? (used in cmdFOR)
0054                  ZP_BIGEND               EQU $54         ; =0 for bigendian OS NE for anything else
0056                  ZP_EXTRA_SAVE_PROC      EQU $56         ; get rid if possible? (used in doFNPROC)
006F                  ZP_DAFT                 EQU $6F
                      
                                              INCLUDE         "./tokens.inc"
                                              ;   Basic Tokens                
0080                  tknAND                  EQU $80
0081                  tknDIV                  EQU $81
0082                  tknEOR                  EQU $82
0083                  tknMOD                  EQU $83
0084                  tknOR                   EQU $84
0085                  tknERROR                EQU $85
0086                  tknLINE                 EQU $86
0087                  tknOFF                  EQU $87
0088                  tknSTEP                 EQU $88
0089                  tknSPC                  EQU $89
008A                  tknTAB                  EQU $8A
008B                  tknELSE                 EQU $8B
008D                  tknMissing              EQU $8D
008D                  tknLineNo               EQU $8D
008E                  tknOPENIN               EQU $8E
008C                  tknTHEN                 EQU $8C
008F                  tknPTR                  EQU $8F
0090                  tknPAGE                 EQU $90
0091                  tknTIME                 EQU $91
0092                  tknLOMEM                        EQU $92
0093                  tknHIMEM                        EQU $93
0094                  tknABS                  EQU $94
0095                  tknACS                  EQU $95
0096                  tknADVAL                        EQU $96
0097                  tknASC                  EQU $97
0098                  tknASN                  EQU $98
0099                  tknATN                  EQU $99
009A                  tknBGET                 EQU $9A
009B                  tknCOS                  EQU $9B
009C                  tknCOUNT                        EQU $9C
009D                  tknDEG                  EQU $9D
009E                  tknERL                  EQU $9E
009F                  tknERR                  EQU $9F
00A0                  tknEVAL                 EQU $A0
00A1                  tknEXP                  EQU $A1
00A2                  tknEXT                  EQU $A2
00A3                  tknFALSE                        EQU $A3
00A4                  tknFN                   EQU $A4
00A5                  tknGET                  EQU $A5
00A6                  tknINKEY                        EQU $A6
00A7                  tknINSTR                        EQU $A7
00A8                  tknINT                  EQU $A8
00A9                  tknLEN                  EQU $A9
00AA                  tknLN                   EQU $AA
00AB                  tknLOG                  EQU $AB
00AC                  tknNOT                  EQU $AC
00AD                  tknOPENUP                       EQU $AD
00AE                  tknOPENOUT                      EQU $AE
00AF                  tknPI                   EQU $AF
00B0                  tknPOINT                        EQU $B0
00B1                  tknPOS                  EQU $B1
00B2                  tknRAD                  EQU $B2
00B3                  tknRND                  EQU $B3
00B4                  tknSGN                  EQU $B4
00B5                  tknSIN                  EQU $B5
00B6                  tknSQR                  EQU $B6
00B7                  tknTAN                  EQU $B7
00B8                  tknTO                   EQU $B8
00B9                  tknTRUE                 EQU $B9
00BA                  tknUSR                  EQU $BA
00BB                  tknVAL                  EQU $BB
00BC                  tknVPOS                 EQU $BC
00BD                  tknCHR                  EQU $BD
00BE                  tknGETDollar            EQU $BE
00BF                  tknINKEYDollar          EQU $BF
00C0                  tknLEFT                 EQU $C0
00C1                  tknMID                  EQU $C1
00C2                  tknRIGHT                        EQU $C2
00C3                  tknSTR                  EQU $C3
00C4                  tknSTRING                       EQU $C4
00C5                  tknEOF                  EQU $C5
00C6                  tknAUTO                 EQU $C6
00C7                  tknDELETE                       EQU $C7
00C8                  tknLOAD                 EQU $C8
00C9                  tknLIST                 EQU $C9
00CA                  tknNEW                  EQU $CA
00CB                  tknOLD                  EQU $CB
00CC                  tknRENUMBER             EQU $CC
00CD                  tknSAVE                 EQU $CD
00CE                  tknEDIT                 EQU $CE
00CF                  tknPTRc                 EQU $CF
00D0                  tknPAGESet              EQU $D0
00D1                  tknTIMESet              EQU $D1
00D2                  tknLOMEMSet             EQU $D2
00D3                  tknHIMEMSet             EQU $D3
00D4                  tknSOUND                        EQU $D4
00D5                  tknBPUT                 EQU $D5
00D6                  tknCALL                 EQU $D6
00D7                  tknCHAIN                        EQU $D7
00D8                  tknCLEAR                        EQU $D8
00D9                  tknCLOSE                        EQU $D9
00DA                  tknCLG                  EQU $DA
00DB                  tknCLS                  EQU $DB
00DC                  tknDATA                 EQU $DC
00DD                  tknDEF                  EQU $DD
00DE                  tknDIM                  EQU $DE
00DF                  tknDRAW                 EQU $DF
00E0                  tknEND                  EQU $E0
00E1                  tknENDPROC                      EQU $E1
00E2                  tknENVELOPE                     EQU $E2
00E3                  tknFOR                  EQU $E3
00E4                  tknGOSUB                EQU $E4
00E5                  tknGOTO                 EQU $E5
00E6                  tknGCOL                 EQU $E6
00E7                  tknIF                   EQU $E7
00E8                  tknINPUT                        EQU $E8
00E9                  tknLET                  EQU $E9
00EA                  tknLOCAL                EQU $EA
00EB                  tknMODE                 EQU $EB
00EC                  tknMOVE                 EQU $EC
00ED                  tknNEXT                 EQU $ED
00EE                  tknON                   EQU $EE
00EF                  tknVDU                  EQU $EF
00F0                  tknPLOT                 EQU $F0
00F1                  tknPRINT                EQU $F1
00F2                  tknPROC                 EQU $F2
00F3                  tknREAD                 EQU $F3
00F4                  tknREM                  EQU $F4
00F5                  tknREPEAT               EQU $F5
00F6                  tknREPORT               EQU $F6
00F7                  tknRESTORE                      EQU $F7
00F8                  tknRETURN                       EQU $F8
00F9                  tknRUN                  EQU $F9
00FA                  tknSTOP                 EQU $FA
00FB                  tknCOLOR                        EQU $FB
00FC                  tknTRACE                        EQU $FC
00FD                  tknUNTIL                        EQU $FD
00FE                  tknWIDTH                EQU $FE
00FF                  tknOSCLI                        EQU $FF
                                              INCLUDE         "./layout.inc"
                      ***************************************************************************
                      * GENERAL MEMORY MAP AND CONSTANTS
                      ***************************************************************************
                      
                      
0400                  BASWKSP_INTVAR          EQU $400                                ; @%
0480                  BASWKSP_DYNVAR_HEADS    EQU $480
00F6                  BASWKSP_DYNVAR_off_PROC EQU $F6
00F8                  BASWKSP_DYNVAR_off_FN   EQU $F8
046C                  BASWKSP_FPTEMP1         EQU $46C
0471                  BASWKSP_FPTEMP2         EQU $471
0476                  BASWKSP_FPTEMP3         EQU $476
047B                  BASWKSP_FPTEMP4         EQU $47B
0500                  BASWKSP_REPEATSTACK     EQU $500
0528                  BASWKSP_FORSTACK        EQU $528
05CC                  BASWKSP_GOSUBSTACK      EQU $5CC
0600                  BASWKSP_STRING          EQU $600                                        ; note TIME$ trashes BASWKSP-1 if this is moved need to recode
                      
000F                  FORSTACK_ITEM_SIZE      EQU     15
000A                  FORSTACK_MAX_ITEMS      EQU     10
0000                  FORSTACK_OFFS_VARPTR    EQU     0
0002                  FORSTACK_OFFS_VARTYPE   EQU     2
0003                  FORSTACK_OFFS_STEP      EQU     3       ; 5 bytes for real, 4 for int
0008                  FORSTACK_OFFS_TO        EQU     8       ; 5 bytes for real, 4 for int
000D                  FORSTACK_OFFS_LOOP      EQU     13      ; pointer to start of loop instructions
                      
0011                  GOSUBSTACK_MAX          EQU     17
                      
0600                  BAS_StrA                EQU $600
0700                  BAS_InBuf               EQU $700
                      
0000                  VAR_TYPE_BYTE           EQU     $00
0002                  VAR_TYPE_INT_LE         EQU     $02     ; new type, int 32 in LE order for ! operator
0004                  VAR_TYPE_INT            EQU     $04
0005                  VAR_TYPE_REAL           EQU     $05
0080                  VAR_TYPE_STRING_STAT    EQU     $80
0081                  VAR_TYPE_STRING_DYN     EQU     $81
                      
0100                  MACH_STACK_BOT          EQU     $100
0200                  MACH_STACK_TOP          EQU     $200
                      
0440                  VAR_P_PERCENT           EQU     $440
043C                  VAR_O_PERCENT           EQU     $43C
                      
                      ************************** SETUP TABLES AND CODE AREAS ******************************
8000                                          ORG     COMPADDR
                                              SETDP   $00
                      
                      ************************** START MAIN ROM CODE ******************************
                              IF FLEX != 1
8000                  ROMSTART                
                                              INCLUDE         "./rom-header-tube.asm"
                      ; > HeaderROM
                      ; -----------
                      ; ROM header for non-6502 language ROMs to claim *BASIC command if CoPro matches
                      ; target CPU, disables self if CoPro doesn't match target CPU.
                      ;
                      ; TO DO: On 6809Beeb, service entry won't run as it is 6502 code. CHECK does 6809Beeb
                      ; check validity of service entry? If 6809MOS skips ROMs with entry<>6809 "JMP"
                      ; then service code will be ignored and ROM will work.
                      ;
                      ;
                      ; 18-Jan-2001 v0.01 Service code matches *help and *command with ROM title.
                      ;                   *Help prints ROM title and whole version string.
                      ; 15-Aug-2005 v0.02 *Help prints ROM title and version number only.
                      ; 28-Nov-2008 v0.03 *Help optimised slightly.
                      ; 15-Aug-2015 v0.04 Simple non-matched *Help, claims *BASIC command.
                      ; 03-Oct-2015 v0.05 Watches for Tube being set up to disable other ROMs if
                      ;                   not for this CPU and claim *BASIC, checks for Master
                      ;                   giving 'Not a language' on Reset.
                      ; 17-Oct-2015 v0.06 Checks the CPU on the other side of the Tube.
                      
                      
0003                  TUBECPU         EQU     $03     ; $03 = ROM type for CPU
007E                  TUBEMATCH       EQU     $7E     ; $7E = JMP opcode for CPU
                      
                      
8000                  HeaderStart
8000  7E80F7                  JMP     HeaderEnter             ; Allows entry at first byte
                              IF MACH_MATCHBOX
8003  4C                      FCB     $4C                     ; 6502 JMP for service entry
8004  2B                      FCB     HeaderService % 256     ; 6502 service address - little endian
8005  80                      FCB     HeaderService / 256     ; 6502 service address
8006  E3                      FCB     $E0+TUBECPU             ; Service+Language+Tube+CPU
                              ELSE
                              FCB     0,0,0
                              FCB     $60+TUBECPU             ; Lang+6809 BASIC               ; TODO: check beeb6809 service call handler, make it check for valid 6x09 JMP instruction?
                              ENDIF
8007  18                      FCB     HeaderCopyright-HeaderStart
8008  04                      FCB     4                       ; For BASIC, must match which 6502 equivalant to
                                                              ; 0: no offset assembly, no OSCLI
                                                              ; 2: offset assembly, OSCLI, OPENIN/OUT/UP
                                                              ; 4: TIME$
                              IF CPU_6309
                              FCB     "6309"
                              ELSE
8009  36383039                FCB     "6809"
                              ENDIF
800D  20424153494300          FCB     " BASIC",0                      ; ROM title, for BASIC must be <CPU><SPC>"BASIC"
8014  34                      FCB     ((VERSION / 256) & 15)+'0'      ; Version string
8015  2E                      FCB     "."
8016  33                      FCB     ((VERSION / 16) & 15)+'0'
8017  33                      FCB     (VERSION & 15)+'0'
8018                  HeaderCopyright
8018  002843293230323220446F73737900         FCB     0,"(C)2022 Dossy",0             ; Copyright message
8027  00                      FCB     LOADADDR % 256                  ; Second processor transfer address
8028  80                      FCB     LOADADDR / 256                  ; Note stored in little-endian byte order!
8029  00                      FCB     0                               ; 32-bit address
802A  00                      FCB     0
                      
                              ;
802B                  HeaderService
802B  48C901F031C911F05EC927F05AC906F0         FCB     $48,$C9,$01,$F0,$31,$C9,$11,$F0,$5E,$C9,$27,$F0,$5A,$C9,$06,$F0
803B  36C909D030B1F2C90DD02A20E7FFA200         FCB     $36,$C9,$09,$D0,$30,$B1,$F2,$C9,$0D,$D0,$2A,$20,$E7,$FF,$A2,$00
804B  BD0980D002A920C928F00620EEFFE8D0         FCB     $BD,$09,$80,$D0,$02,$A9,$20,$C9,$28,$F0,$06,$20,$EE,$FF,$E8,$D0
805B  EF20E7FF6860AD7A02300AA6F4BDA102         FCB     $EF,$20,$E7,$FF,$68,$60,$AD,$7A,$02,$30,$0A,$A6,$F4,$BD,$A1,$02
806B  29BF9DA1026860A6F0BD02014AB0F6A0         FCB     $29,$BF,$9D,$A1,$02,$68,$60,$A6,$F0,$BD,$02,$01,$4A,$B0,$F6,$A0
807B  00B1FDD0F071FDC8C017D0F9C9EAD0E5         FCB     $00,$B1,$FD,$D0,$F0,$71,$FD,$C8,$C0,$17,$D0,$F9,$C9,$EA,$D0,$E5
808B  A6F4A98E4CF4FFAD0302D0D99848A9FF         FCB     $A6,$F4,$A9,$8E,$4C,$F4,$FF,$AD,$03,$02,$D0,$D9,$98,$48,$A9,$FF
809B  20060490F9A9004848A9F848BAA001A9         FCB     $20,$06,$04,$90,$F9,$A9,$00,$48,$48,$A9,$F8,$48,$BA,$A0,$01,$A9
80AB  004820060468686868A207CAD0FDAEE5         FCB     $00,$48,$20,$06,$04,$68,$68,$68,$68,$A2,$07,$CA,$D0,$FD,$AE,$E5
80BB  FEA9BF20060468A8E07ED09FA20F         FCB     $FE,$A9,$BF,$20,$06,$04,$68,$A8,$E0,TUBEMATCH,$D0,$9F,$A2,$0F
80C9  BDA102294FC943F008BDA10229BF         FCB     $BD,$A1,$02,$29,$4F,$C9,$40+TUBECPU,$F0,$08,$BD,$A1,$02,$29,$BF
80D7  9DA102CA10ECAE8C023009BDA102294F         FCB     $9D,$A1,$02,$CA,$10,$EC,$AE,$8C,$02,$30,$09,$BD,$A1,$02,$29,$4F
80E7  C947F005A6F48E8C02A6F48E4B026860         FCB     $C9,$47,$F0,$05,$A6,$F4,$8E,$8C,$02,$A6,$F4,$8E,$4B,$02,$68,$60
                              ;
80F7                  HeaderEnter
                              ; Language code starts here
                      
80F7  8101                                    CMPA    #1
80F9  270B                                    BEQ     ROM_LANGST
80FB  39                                      RTS
                              ELSE
                                              BRA     FLEX_LANGST
                              ENDIF
80FC  0001            tblTENS_BE              FDB     $0001
80FE  000A                                    FDB     $000A
8100  0064                                    FDB     $0064
8102  03E8                                    FDB     $03E8
8104  2710                                    FDB     $2710
                      
                      ;               ;  LANGUAGE STARTUP
                      ;               ;  ================
                      ;;JGH 15-Jun-2017
                      ;; Startup procedure should be:
                      ;;  Reset stack - we can now do CALLs
                      ;;  Set up direct page in case OSINIT doesn't change it
                      ;;  Initialise error handler - we can now claim BRKV, ask for memory limits and access Direct Page
                      ;;  Doing in this order allows OSINIT to set DP to a per-task area
                      ;;  Claim BRKV as pointed to by OSINIT
                      ;;  Request memory limits
                      ;;  Start initialising memory
                      ;;  DB - 
                      
                      
                              IF FLEX != 1
                      ;
                      ;               ;  LANGUAGE STARTUP
                      ;               ;  ================
8106                  ROM_LANGST      RESET_MACH_STACK
8106  10CE0200                                LDS     #MACH_STACK_TOP
810A  3402                            PSHS    A                                       ; store A
                      
810C  4F                              CLRA
                      ;;              TFR     A, DP                                   ; Default direct page
                      
810D  BDFFBF                          JSR     OSINIT                                  ; A=0, Set up default environment
8110  9754                            STA     ZP_BIGEND
8112  109F50                          STY     ZP_ESCPTR
8115  338D2DEC                        LEAU    HandleBRK, PCR
8119  EF84                            STU     ,X                                      ; Claim BRKV
                      
811B  338DFEF9                        LEAU    HeaderCopyright, PCR
811F  DFFD                            STU     ZP_MOS_ERROR_PTR_QRY
                      
8121  8684                            LDA     #$84
8123  BDFFF4                          JSR     OSBYTE                                  ; Read top of memory, set HIMEM
8126  9F06                            STX     ZP_HIMEM
8128  308DFED4                        LEAX    ROMSTART,PCR
812C  9C06                            CMPX    ZP_HIMEM                                ; check to see if the returned HIMEM is > than start of ROM
812E  2402                            BHS     1F                                      ; if it is ignore it and set to start of ROM - this for
8130  9F06                            STX     ZP_HIMEM                                ; old matchbox copros with unfixed tube client code
8132  8683            1               LDA     #$83                                    ; DB: must reload value here as A might be set above
8134  BDFFF4                          JSR     OSBYTE
8137  1F10                            TFR     X,D                                     ; A=high byte of returned bottom of memory
8139  8108                            CMPA    #8
813B  2304                            BLS     2F                                      ; Too low, reserve space for workspace
813D  9106                            CMPA    ZP_HIMEM                                ; check to see that returned page isn't too high (matchbox client code fix)
813F  2502                            BLO     1F
8141  8608            2               LDA     #8                                      ; make PAGE at least 800 to leave room for ZP, stack, variable pointers etc
8143  9718            1               STA     ZP_PAGE_H                               ; Read bottom of memory, set PAGE
                                                                                      ; Will need more work to do "per task" memory relocations
                              ELSE
                      FLEX_LANGST
                                      CLRA
                                      TFR     A, DP                                   ; Default direct page
                                      RESET_MACH_STACK
                      
                                      LDA     #$80
                                      LDY     #$00FF
                                      CLR     $FF                                     ; TODOFLEX - how to detect ESCAPE?
                                      STA     ZP_BIGEND
                                      STY     ZP_ESCPTR
                                      LDA     #$8
                                      STA     ZP_PAGE_H
                                      LDX     #$8000
                                      STX     ZP_HIMEM                                ; TODOFLEX this assumes program loaded at $8000 and full 56k memory
                      
                                      ;;CLR   ECHOFLAG                                ; TODOFLEX - is this the right way to turn off local echo?
                              ENDIF
                      
                      ;       IF DEBUG != 0
                      ;               TST     ZP_BIGEND
                      ;               BPL     1F
                      ;               PRINT_STR       "(LE"
                      ;               BRA     2F
                      ;1              PRINT_STR       "(BE"
                      ;2              PRINT_STR       ", page="
                      ;               LDA     ZP_PAGE_H
                      ;               CALL    PRHEX
                      ;               PRINT_STR "00, himem="
                      ;               LDX     ZP_HIMEM
                      ;               CALL    PR2HEX
                      ;
                      ;               PRINT_STR ", swr#="
                      ;
                      ;               LDA     <$F4    ; get current rom number
                      ;               CALL    PRHEX
                      ;
                      ;       IF IF FLEX = 1
                      ;               PRINT_STR ", FLEX)\r"
                      ;       ELSE
                      ;               PRINT_STR ", BBC/CHIP/MB)\r"
                      ;       ENDIF
                      ;       ENDIF
                      
8145  8601                            LDA     #$01
8147  9411                            ANDA    ZP_RND_WA + 4                           ; just bottom bit of +4?
8149  9A10                            ORA     ZP_RND_WA + 3
814B  9A0F                            ORA     ZP_RND_WA + 2
814D  9A0E                            ORA     ZP_RND_WA + 1
814F  9A0D                            ORA     ZP_RND_WA + 0                           ;  Check RND seed
8151  260A                            BNE     1F                                      ;  If nonzero, skip past
8153  CC5241                          LDD     #$5241
8156  DD0F                            STD     ZP_RND_WA + 2                           ;  Set RND seed to "ARW" - Acorn/Roger/Wilson
8158  CC0057                          LDD     #$57
815B  DD0D                            STD     ZP_RND_WA + 0
815D                  1               
                      
815D  0F1F                            CLR     ZP_LISTO                                ;  Set LISTO to 0
815F  7F0400                          CLR     BASWKSP_INTVAR + 0
8162  7F0401                          CLR     BASWKSP_INTVAR + 1                      ;  Set @% to $0000xxxx
8165  86FF                            LDA     #$FF
8167  9723                            STA     ZP_WIDTH                                ;  Set WIDTH to $ff
8169  CC090A                          LDD     #$090A                                  ;  Set up @% (thanks JGH)
816C  FD0402                          STD     BASWKSP_INTVAR + 2
                      
816F                                  CLI                                             ; enable IRQ
816F  1CEF                    ANDCC   #~(CC_I)
8171                                  JUMP    reset_prog_enter_immedprompt            ;  Enable IRQs, jump to immediate loop - DB - I've kept this similar as I may want to add command line params later...
8171  7E8F57                                  JMP     \1
                      
                                      ******************************************
                                      * FLEX - Replacement routines
                                      ******************************************
                      
                              IF FLEX =1
                      PRSTRING        LDA     ,X+
                                      BEQ     1F
                                      JSR     OSASCI                                  ; TODOFLEX: need to check for special chars?
                                      BRA     PRSTRING
                      1               RTS
                      
                      PRHEX           PSHS    A,X
                                      LEAX    1,S
                                      JSR     OUTHEX
                                      PULS    A,X,PC
                      PR2HEX          PSHS    X
                                      LEAX    0,S
                                      JSR     OUTHEX
                                      LEAX    1,S
                                      JSR     OUTHEX
                                      PULS    X,PC
                      OSASCI          cmpa    #$0D            
                                      bne     OSWRCH          
                      OSNEWL          lda     #$0A            
                                      JSR     OSWRCH  
                                      lda     #$0D            
                      OSWRCH          PSHS    A
                                      JSR     PUTCHR
                                      PULS    A,PC
                      
                      OSCLI           PSHS    D,X,U,U,CC
                                      CLRB
                                      LDU     #LINBUF
                                      STU     CBUFPT
                      1               LDA     B,X
                                      STA     B,U
                                      CMPA    #$D
                                      BEQ     1F
                                      INCB
                                      BPL     1B
                      
                      1               JSR     DOCMD
                                      TSTB
                                      BEQ     OSCLI_OK
                                      ORB     #$80                            ; make a BASIC error number from a Flex error number
                      FLEXERROR
                                      LDU     #MACH_STACK_BOT
                                      PSHS    U                               ; "return address" for HandleBRK
                                      STB     ,U+                             ; error number
                                      LEAX    strFLEXERROR,PCR
                      1               LDA     ,X+
                                      STA     ,U+
                                      BNE     1B
                                      JMP     HandleBRK                       ; jump to dynamic error
                      
                      
                      OSCLI_OK                PULS    D,X,U,U,CC,PC
                      
                      OSRDCH          JMP     GETCHR
                                      
                      
                      FLEX_READLINE   CLRB                                    ; TODOFLEX - this is very simplistic
                                      TFR     D,X
                      FLEX_RL_LP      JSR     OSRDCH                          ; get char
                                      CMPA    #$D
                                      BEQ     FLEX_RL_CR
                                      CMPA    #8
                                      BEQ     FLEX_RL_BS
                                      CMPA    #$1B
                                      BEQ     FLEX_RL_ESC
                                      INCB
                                      BEQ     FLEX_RL_FULL
                                      STA     ,X+
                                      ;;JSR   OSWRCH
                                      BRA     FLEX_RL_LP
                      FLEX_RL_FULL
                                      DECB
                      FLEX_RL_BEEP
                                      LDA     #7
                                      JSR     OSWRCH
                                      BRA     FLEX_RL_LP
                      FLEX_RL_CR
                                      INCB
                                      BEQ     FLEX_RL_RTS
                                      STA     ,X+
                                      JSR     OSNEWL
                                      BRA     FLEX_RL_RTS
                      FLEX_RL_BS      TSTB
                                      BEQ     FLEX_RL_BEEP
                                      DECB
                                      LEAX    -1,X
                                      LDA     #' '
                                      JSR     OSWRCH                          ; TODOFLEX - assumes char 8 is backspace
                                      LDA     #8
                                      JSR     OSWRCH
                                      BRA     FLEX_RL_LP
                      
                      FLEX_RL_ESC     SEC
                      FLEX_RL_RTS     RTS
                      
                                      SECTION "tables_and_strings"
                      strFLEXERROR    FCB     "Flex Error",0
                                      CODE
                      
                              ENDIF
                      
                      
                              include         "./tokenstable.asm"
                      ;                       ;  Meaning of ZP_FP_WA_B and ZP_FP_WA_B + 1 in tokenizer loop
                                              ;  ZP_FP_WA_B   +0      +1      State is
                                              ;               FF      0       Middle of statement mode
                                              ;               0       0       Start of statement mode
                                              ;               -       FF      Expect line number next
                      
                      ;                       ;  TOKEN TABLE
                      ;                       ;  ===========
                      ;                       ;  string, token (b7=1), flag
                      ;                       ;
                      ;                       ;  Token flag
                      ;                       ;  Bit 0 - Conditional tokenisation (don't tokenise if followed by an alphabetic character).
                      ;                       ;  Bit 1 - Go into "Middle of Statement" mode.
                      ;                       ;  Bit 2 - Go into "Start of Statement" mode.
                      ;                       ;  Bit 3 - FN/PROC keyword - don't tokenise the name of the subroutine.
                      ;                       ;  Bit 4 - Start tokenising a line number now (after a GOTO, etc...).
                      ;                       ;  Bit 5 - Don't tokenise rest of line (REM , DATA, etc...) ; DB: JGH had this as bit 6
                      ;                       ;  Bit 6 - Pseudo variable flag - add $40 to token if at the start of a 
                                              ;          statement/hex number i.e. PAGE
                      ;                       ;  Bit 7 - Unused - externally used for quote toggle.
                      
0001                  TOK_FLAG_CONDITIONAL    EQU     $01
0000                  BIT_FLAG_CONDITIONAL    EQU     0
                      
0002                  TOK_FLAG_NEXT_MID       EQU     $02
0001                  BIT_FLAG_NEXT_MOD       EQU     1
                      
0004                  TOK_FLAG_NEXT_START     EQU     $04
0002                  BIT_FLAG_NEXT_START     EQU     2
                      
0008                  TOK_FLAG_FNPROC         EQU     $08
0003                  BIT_FLAG_FNPROC         EQU     3
                      
0010                  TOK_FLAG_NEXTLINENO     EQU     $10
0004                  BIT_FLAG_NEXTLINENO     EQU     4
                      
                      
0020                  TOK_FLAG_SKIP_EOL       EQU     $20
0005                  BIT_FLAG_SKIP_EOL       EQU     5
                      
0040                  TOK_FLAG_PSEUDO_VAR     EQU     $40
0006                  BIT_FLAG_PSEUDO_VAR     EQU     6
                      
8174                  tblTOKENS
8174  414E448000                       FCB      "AND",        $80,    $00             ;  00000000
8179  4142539400                       FCB      "ABS",        $94,    $00             ;  00000000
817E  4143539500                       FCB      "ACS",        $95,    $00             ;  00000000
8183  414456414C9600                   FCB      "ADVAL",      $96,    $00             ;  00000000
818A  4153439700                       FCB      "ASC",        $97,    $00             ;  00000000
818F  41534E9800                       FCB      "ASN",        $98,    $00             ;  00000000
8194  41544E9900                       FCB      "ATN",        $99,    $00             ;  00000000
8199  4155544FC610                     FCB      "AUTO",       $C6,    $10             ;  00010000
819F  424745549A01                     FCB      "BGET",       $9A,    $01             ;  00000001
81A5  42505554D503                     FCB      "BPUT",       $D5,    $03             ;  00000011
81AB  434F4C4F5552FB02                  FCB      "COLOUR",     $FB,    $02             ;  00000010
81B3  43414C4CD602                     FCB      "CALL",       $D6,    $02             ;  00000010
81B9  434841494ED702                   FCB      "CHAIN",      $D7,    $02             ;  00000010
81C0  43485224BD00                     FCB      "CHR$",       $BD,    $00             ;  00000000
81C6  434C454152D801                   FCB      "CLEAR",      $D8,    $01             ;  00000001
81CD  434C4F5345D903                   FCB      "CLOSE",      $D9,    $03             ;  00000011
81D4  434C47DA01                       FCB      "CLG",        $DA,    $01             ;  00000001
81D9  434C53DB01                       FCB      "CLS",        $DB,    $01             ;  00000001
81DE  434F539B00                       FCB      "COS",        $9B,    $00             ;  00000000
81E3  434F554E549C01                   FCB      "COUNT",      $9C,    $01             ;  00000001
81EA  434F4C4F52FB02                   FCB      "COLOR",      $FB,    $02             ;  00000010
81F1  44415441DC20                     FCB      "DATA",       $DC,    $20             ;  00100000
81F7  4445479D00                       FCB      "DEG",        $9D,    $00             ;  00000000
81FC  444546DD00                       FCB      "DEF",        $DD,    $00             ;  00000000
8201  44454C455445C710                  FCB      "DELETE",     $C7,    $10             ;  00010000
8209  4449568100                       FCB      "DIV",        $81,    $00             ;  00000000
820E  44494DDE02                       FCB      "DIM",        $DE,    $02             ;  00000010
8213  44524157DF02                     FCB      "DRAW",       $DF,    $02             ;  00000010
8219  454E4450524F43E101                  FCB      "ENDPROC",    $E1,    $01             ;  00000001
8222  454E44E001                       FCB      "END",        $E0,    $01             ;  00000001
8227  454E56454C4F5045E202                  FCB      "ENVELOPE",   $E2,    $02             ;  00000010
8231  454C53458B14                     FCB      "ELSE",       $8B,    $14             ;  00010100
8237  4556414CA000                     FCB      "EVAL",       $A0,    $00             ;  00000000
823D  45524C9E01                       FCB      "ERL",        $9E,    $01             ;  00000001
8242  4552524F528504                   FCB      "ERROR",      $85,    $04             ;  00000100
8249  454F46C501                       FCB      "EOF",        $C5,    $01             ;  00000001
824E  454F528200                       FCB      "EOR",        $82,    $00             ;  00000000
8253  4552529F01                       FCB      "ERR",        $9F,    $01             ;  00000001
8258  455850A100                       FCB      "EXP",        $A1,    $00             ;  00000000
825D  455854A201                       FCB      "EXT",        $A2,    $01             ;  00000001
8262  45444954CE10                     FCB      "EDIT",       $CE,    $10             ;  00010000
8268  464F52E302                       FCB      "FOR",        $E3,    $02             ;  00000010
826D  46414C5345A301                   FCB      "FALSE",      $A3,    $01             ;  00000001
8274  464EA408                         FCB      "FN",         $A4,    $08             ;  00001000
8278  474F544FE512                     FCB      "GOTO",       $E5,    $12             ;  00010010
827E  47455424BE00                     FCB      "GET$",       $BE,    $00             ;  00000000
8284  474554A500                       FCB      "GET",        $A5,    $00             ;  00000000
8289  474F535542E412                   FCB      "GOSUB",      $E4,    $12             ;  00010010
8290  47434F4CE602                     FCB      "GCOL",       $E6,    $02             ;  00000010
8296  48494D454D9343                   FCB      "HIMEM",      $93,    $43             ;  00100011
829D  494E505554E802                   FCB      "INPUT",      $E8,    $02             ;  00000010
82A4  4946E702                         FCB      "IF",         $E7,    $02             ;  00000010
82A8  494E4B455924BF00                  FCB      "INKEY$",     $BF,    $00             ;  00000000
82B0  494E4B4559A600                   FCB      "INKEY",      $A6,    $00             ;  00000000
82B7  494E54A800                       FCB      "INT",        $A8,    $00             ;  00000000
82BC  494E53545228A700                  FCB      "INSTR(",     $A7,    $00             ;  00000000
82C4  4C495354C910                     FCB      "LIST",       $C9,    $10             ;  00010000
82CA  4C494E458600                     FCB      "LINE",       $86,    $00             ;  00000000
82D0  4C4F4144C802                     FCB      "LOAD",       $C8,    $02             ;  00000010
82D6  4C4F4D454D9243                   FCB      "LOMEM",      $92,    $43             ;  00100011
82DD  4C4F43414CEA02                   FCB      "LOCAL",      $EA,    $02             ;  00000010
82E4  4C4546542428C000                  FCB      "LEFT$(",     $C0,    $00             ;  00000000
82EC  4C454EA900                       FCB      "LEN",        $A9,    $00             ;  00000000
82F1  4C4554E904                       FCB      "LET",        $E9,    $04             ;  00000100
82F6  4C4F47AB00                       FCB      "LOG",        $AB,    $00             ;  00000000
82FB  4C4EAA00                         FCB      "LN",         $AA,    $00             ;  00000000
82FF  4D49442428C100                   FCB      "MID$(",      $C1,    $00             ;  00000000
8306  4D4F4445EB02                     FCB      "MODE",       $EB,    $02             ;  00000010
830C  4D4F448300                       FCB      "MOD",        $83,    $00             ;  00000000
8311  4D4F5645EC02                     FCB      "MOVE",       $EC,    $02             ;  00000010
8317  4E455854ED02                     FCB      "NEXT",       $ED,    $02             ;  00000010
831D  4E4557CA01                       FCB      "NEW",        $CA,    $01             ;  00000001
8322  4E4F54AC00                       FCB      "NOT",        $AC,    $00             ;  00000000
8327  4F4C44CB01                       FCB      "OLD",        $CB,    $01             ;  00000001
832C  4F4EEE02                         FCB      "ON",         $EE,    $02             ;  00000010
8330  4F46468700                       FCB      "OFF",        $87,    $00             ;  00000000
8335  4F528400                         FCB      "OR",         $84,    $00             ;  00000000
8339  4F50454E494E8E00                  FCB      "OPENIN",     $8E,    $00             ;  00000000
8341  4F50454E4F5554AE00                  FCB      "OPENOUT",    $AE,    $00             ;  00000000
834A  4F50454E5550AD00                  FCB      "OPENUP",     $AD,    $00             ;  00000000
8352  4F53434C49FF02                   FCB      "OSCLI",      $FF,    $02             ;  00000010
8359  5052494E54F102                   FCB      "PRINT",      $F1,    $02             ;  00000010
8360  504147459043                     FCB      "PAGE",       $90,    $43             ;  01000011
8366  5054528F43                       FCB      "PTR",        $8F,    $43             ;  01000011
836B  5049AF01                         FCB      "PI",         $AF,    $01             ;  00000001
836F  504C4F54F002                     FCB      "PLOT",       $F0,    $02             ;  00000010
8375  504F494E5428B000                  FCB      "POINT(",     $B0,    $00             ;  00000000
837D  50524F43F20A                     FCB      "PROC",       $F2,    $0A             ;  00001010
8383  504F53B101                       FCB      "POS",        $B1,    $01             ;  00000001
8388  52455455524EF801                  FCB      "RETURN",     $F8,    $01             ;  00000001
8390  524550454154F500                  FCB      "REPEAT",     $F5,    $00             ;  00000000
8398  5245504F5254F601                  FCB      "REPORT",     $F6,    $01             ;  00000001
83A0  52454144F302                     FCB      "READ",       $F3,    $02             ;  00000010
83A6  52454DF420                       FCB      "REM",        $F4,    $20             ;  00100000
83AB  52554EF901                       FCB      "RUN",        $F9,    $01             ;  00000001
83B0  524144B200                       FCB      "RAD",        $B2,    $00             ;  00000000
83B5  524553544F5245F712                  FCB      "RESTORE",    $F7,    $12             ;  00010010
83BE  52494748542428C200                  FCB      "RIGHT$(",    $C2,    $00             ;  00000000
83C7  524E44B301                       FCB      "RND",        $B3,    $01             ;  00000001
83CC  52454E554D424552CC10                  FCB      "RENUMBER",   $CC,    $10             ;  00010000
83D6  535445508800                     FCB      "STEP",       $88,    $00             ;  00000000
83DC  53415645CD02                     FCB      "SAVE",       $CD,    $02             ;  00000010
83E2  53474EB400                       FCB      "SGN",        $B4,    $00             ;  00000000
83E7  53494EB500                       FCB      "SIN",        $B5,    $00             ;  00000000
83EC  535152B600                       FCB      "SQR",        $B6,    $00             ;  00000000
83F1  5350438900                       FCB      "SPC",        $89,    $00             ;  00000000
83F6  53545224C300                     FCB      "STR$",       $C3,    $00             ;  00000000
83FC  535452494E472428C400                  FCB      "STRING$(",   $C4,    $00             ;  00000000
8406  534F554E44D402                   FCB      "SOUND",      $D4,    $02             ;  00000010
840D  53544F50FA01                     FCB      "STOP",       $FA,    $01             ;  00000001
8413  54414EB700                       FCB      "TAN",        $B7,    $00             ;  00000000
8418  5448454E8C14                     FCB      "THEN",       $8C,    $14             ;  00010100
841E  544FB800                         FCB      "TO",         $B8,    $00             ;  00000000
8422  544142288A00                     FCB      "TAB(",       $8A,    $00             ;  00000000
8428  5452414345FC12                   FCB      "TRACE",      $FC,    $12             ;  00010010
842F  54494D459143                     FCB      "TIME",       $91,    $43             ;  01000011
8435  54525545B901                     FCB      "TRUE",       $B9,    $01             ;  00000001
843B  554E54494CFD02                   FCB      "UNTIL",      $FD,    $02             ;  00000010
8442  555352BA00                       FCB      "USR",        $BA,    $00             ;  00000000
8447  564455EF02                       FCB      "VDU",        $EF,    $02             ;  00000010
844C  56414CBB00                       FCB      "VAL",        $BB,    $00             ;  00000000
8451  56504F53BC01                     FCB      "VPOS",       $BC,    $01             ;  00000001
8457  5749445448FE02                   FCB      "WIDTH",      $FE,    $02             ;  00000010
845E  50414745D000                     FCB      "PAGE",       $D0,    $00             ;  00000000
8464  505452CF00                       FCB      "PTR",        $CF,    $00             ;  00000000
8469  54494D45D100                     FCB      "TIME",       $D1,    $00             ;  00000000
846F  4C4F4D454DD200                   FCB      "LOMEM",      $D2,    $00             ;  00000000
8476  48494D454DD300                   FCB      "HIMEM",      $D3,    $00             ;  00000000
847D  4D697373696E67208D00                  FCB      "Missing ",   $8D,    $00
                      ; END
                      
                      
                      
                      
                      ;               
                      ;               
                      ;               ;  Look up FN/PROC address
                      ;               ;  =======================
                      ;               ;  On entry, B=length of name
                      ;               ;            [ZP_GEN_PTR+2]+1=>FN/PROC token (ie, first character of name)
8487  3440            findFNPROC      PSHS    U
8489  D737                            STB     ZP_NAMELENORVT                  ;  Store length of name
848B  DE39                            LDU     ZP_GEN_PTR+2
848D  A641                            LDA     1,U                             ;  Get FN/PROC character
848F  C6F6                            LDB     #BASWKSP_DYNVAR_off_PROC        ;  Preload with offset to PROC list
8491  81F2                            CMPA    #tknPROC
8493  270D                            BEQ     findLinkedListNewAPI            ;  If PROC, follow PROC list
8495  C6F8                            LDB     #BASWKSP_DYNVAR_off_FN
8497  2009                            BRA     findLinkedListNewAPI            ;  Otherwise, follow FN list
                      ;               
                      ;               
                      ;                       ;  Look up variable address
                      ;                       ;  ========================
                      ;                       ;  On entry, B=1 + length of name
                      ;                       ;            [ZP_GEN_PTR+2]+1=>first character of name
                                              ;  On exit
                                              ;       Z = 1 for not found
                                              ;       else X and ZP_INT_WA + 2 points at variable data
8499                  findVarDynLL_NewAPI
8499  3440                            PSHS    U
849B  D737                            STB     ZP_NAMELENORVT                  ;  Store length of name
849D  DE39                            LDU     ZP_GEN_PTR+2
849F  E641                            LDB     1,U                             ;  Get initial letter
84A1  58                              ASLB
                      ;                       ;  Follow linked variable list to find named item
                      ;                       ;  ----------------------------------------------
                      ;                       ;  B = offset in Page 4 link start table
84A2                  findLinkedListNewAPI
84A2  8604                            LDA     #BASWKSP_INTVAR / 256
84A4  1F01                            TFR     D,X
                      ;               LDX     ,X                              ; X contains pointer to first var block (or zero)
                      ;               BRA     fll_skitem                                                              
84A6                  fll_nextItem    
84A6  C602                            LDB     #2
84A8  AE84                            LDX     ,X
84AA  271B            fll_skitem      BEQ     fll_sk_nomatch                          
                                      *STX    ZP_INT_WA + 2                   ; store pointer
84AC  A685            fll_chlp        LDA     B,X
84AE  270F                            BEQ     fll_sk_nameEnd
84B0  A1C5                            CMPA    B,U
84B2  26F2                            BNE     fll_nextItem
84B4  5C                              INCB
84B5  D137                            CMPB    ZP_NAMELENORVT                  ; at end of name?
84B7  26F3                            BNE     fll_chlp
84B9  A685                            LDA     B,X                             ; at end of name - check 0 term in dynvar
84BB  26E9                            BNE     fll_nextItem
84BD  2004                            BRA     fll_match
                      ;
84BF                  fll_sk_nameEnd
84BF  D137                            CMPB    ZP_NAMELENORVT
84C1  26E3                            BNE     fll_nextItem
84C3  5C              fll_match       INCB
84C4  3A                              ABX
84C5  9F2C                            STX     ZP_INT_WA + 2                   ; ZP_INT_WA points at the start of the variable data
84C7                  fll_sk_nomatch
84C7  35C0                            PULS    U,PC                            ;  not matched Z = 1
                      
                      
                                      ;  Search for program line
                                      ;  =======================
                                      ; NEW API
                                      ;  On entry,    ZP_INT_WA + 2 => line number
                                      ;  On Exit,     X,Y and ZP_FPB + 2 => program line start or next line (points at the 0D at start of this line)
                                      ;               Cy=1 indicates line found
                                      ;               Cy=0 not found
                              ;  TODO: check all occurrences and remove store to ZP_FPB if not ever used
                                      ; OLD API
                                      ;  On entry,    ZP_INT_WA = line number
                                      ;  On exit,  ZP_FPB + 2 =>program line, or next line
                                      ;            CS = line found
                                      ;            CC = line not found
                                      ;           NOTE: Y = 2 always - TODO: Remove ?
                                      
84C9                  findProgLineNewAPI      
84C9  9618                            LDA     ZP_PAGE_H               ; X points at start of Program
84CB  5F                              CLRB
84CC  1F01                            TFR     D,X
84CE  EC01            fpl_lp1         LDD     1,X                     ; get 16 bit line number at +1
84D0  10932C                          CMPD    ZP_INT_WA + 2
84D3  2405                            BHS     fpl_ge
84D5  E603                            LDB     3,X
84D7  3A                              ABX
84D8  20F4                            BRA     fpl_lp1
84DA  2602            fpl_ge          BNE     flp_sk1
84DC                                  SEC
84DC  1A01                    ORCC    #CC_C
84DE  9F3D            flp_sk1         STX     ZP_FPB + 2
84E0  3384                            LEAU    ,X
84E2  39                              RTS
                      ;               
                      ;               
                      ;;findProgLineNewAPI: 
                      ;;              STZ ZP_FPB + 2
                      ;;              LDA ZP_PAGE_H
                      ;;              STA ZP_FPB + 3                  ;  Start at PAGE
                      ;;@lp1:         LDU #$01
                      ;;              LDA (ZP_FPB + 2),Y                      ;  Check line number high byte
                      ;;              CMP ZP_INT_WA + 1
                      ;;              BCS @sk1                                ;  Partial match, jump to check low byte
                      ;;@lp2:         LDU #$03
                      ;;              LDA (ZP_FPB + 2),Y                      ;  Get line length
                      ;;              ADC ZP_FPB + 2
                      ;;              STA ZP_FPB + 2                  ;  Step to next line
                      ;;              BCC @lp1
                      ;;              INC ZP_FPB + 3
                      ;;              BRA @lp1                                ;  Loop back to check next line
                      ;;@sk1:         BNE @sk2                                ;  Gone past target, jump to return CC and Y=2
                      ;;              INY
                      ;;              LDA (ZP_FPB + 2),Y                      ;  Check line number low byte
                      ;;              CMP ZP_INT_WA
                      ;;              BCC @lp2                                ;  line < target, step to next line
                      ;;              BNE @sk2                                ;  Line not equal, jump to return CC
                      ;;              RTS                                     ;  Line found, return CS and Y=2
                      ;;@sk2:         LDU #$02
                      ;;              CLC
                      ;;              RTS                                     ;  Line not found, return CC and Y=2
                      ;
                      ;                       
                      ;                       
                      ;                       
                      ;                       
                      ;               ;  Integer division
                      ;               ;  ================
                      ;               ;  On entry, $2A-$2D (IntA)  =  integer LHS of A DIV B or A MOD B
                      ;               ;            $30-$34 (RealA) =  real LHS of A DIV B or A MOD B
                      ;               ;            Program pointer => RHS of expression
                      ;               ;  On exit,  $39-$3C = result, $37=sign of result
                      ;               ;            $3D-$40 = remainder, $38=sign of remainder
                      ;               ;
84E3                  evalDoIntDivide                                         ; L80F9
84E3                                  CALL    checkTypeInAConvert2INT         ;  Convert Real to Integer
84E3                  9
84E5                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84E3  BD94EF                                  JSR     \1
                              ENDIF
84E6  962A                            LDA     ZP_INT_WA + 0
84E8  A7E2                            STA     ,-S                             ; save sign of LHS as sign of remainder
84EA                                  CALL    intWA_ABS                       ; Ensure LHS is positive
84EA                  9
84EC                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84EA  BDA97A                                  JSR     \1
                              ENDIF
84ED                                  CALL    stackINTEvalLevel2              ; Stack LHS, evaluate RHS
84ED                  9
84EF                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
003D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84ED  BD9D2C                                  JSR     \1
                              ENDIF
84F0  D727                            STB     ZP_VARTYPE                      ; Save current token
84F2                                  CALL    checkTypeInAConvert2INT         ; Save next character, convert Real to Int
84F2                  9
84F4                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84F2  BD94EF                                  JSR     \1
                              ENDIF
84F5  A6E0                            LDA     ,S+                             ; get back sign of remainder
84F7  982A                            EORA    ZP_INT_WA + 0                   
84F9  9737                            STA     ZP_GEN_PTR                      ; EOR with sign of RHS to get sign of result
84FB                                  CALL    intWA_ABS                       ; Ensure RHS is positive
84FB                  9
84FD                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84FB  BDA97A                                  JSR     \1
                              ENDIF
84FE  8E0039                          LDX     #ZP_INT_WA_B                    
8501                                  CALL    popIntAtXNew                    ; Pop LHS from stack to IntB at $39-$3C
8501                  9
8503                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8501  BDB87F                                  JSR     \1
                              ENDIF
8504  4F                              CLRA
8505  973D                            STA     ZP_INT_WA_C
8507  973E                            STA     ZP_INT_WA_C + 1
8509  973F                            STA     ZP_INT_WA_C + 2
850B  9740                            STA     ZP_INT_WA_C + 3                 ; Clear remainder in IntC
850D                                  CALL    IntWAZero                       ; Check if IntA is zero
850D                  9
850F                  __XBSR                  SET 9B+2
3100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
850D  BDB656                                  JSR     \1
                              ENDIF
8510  2745                            BEQ     brkDivideByZero                 ; Error if divide by zero
8512  C620                            LDB     #$20                            ; 32-bit division
8514  D743                            STB     ZP_FP_TMP
                      
                                      ; TODO - bytewise shift here should speed things up
                      
8516                  1                                                       ; L812D
8516  0A43                            DEC     ZP_FP_TMP
8518  273C                            BEQ     2F                              ; All bits done
851A  083C                            ASL     ZP_INT_WA_B + 3
851C  093B                            ROL     ZP_INT_WA_B + 2
851E  093A                            ROL     ZP_INT_WA_B + 1
8520  0939                            ROL     ZP_INT_WA_B + 0                 ; Result=Result*2
8522  2AF2                            BPL     1B                              ; Loop if no zero bit
8524                  3                                                       ; L813A:
8524  093C                            ROL     ZP_INT_WA_B + 3                 ; Result=Result*2
8526  093B                            ROL     ZP_INT_WA_B + 2
8528  093A                            ROL     ZP_INT_WA_B + 1
852A  0939                            ROL     ZP_INT_WA_B + 0
852C  0940                            ROL     ZP_INT_WA_C + 3                 ; Remainder=Remainder*2+1 
852E  093F                            ROL     ZP_INT_WA_C + 2                 ; (there is always a carry from WA_B 
8530  093E                            ROL     ZP_INT_WA_C + 1                 ; as it was PL at end of loop above)
8532  093D                            ROL     ZP_INT_WA_C + 0                         
                      
8534  DC3F                            LDD     ZP_INT_WA_C + 2
8536  932C                            SUBD    ZP_INT_WA + 2
8538  3406                            PSHS    D
853A  DC3D                            LDD     ZP_INT_WA_C + 0
853C  D22B                            SBCB    ZP_INT_WA + 1
853E  922A                            SBCA    ZP_INT_WA + 0
8540  2508                            BCS     4F                              ; Couldn't subtract, do next bit
8542  DD3D                            STD     ZP_INT_WA_C + 0
8544  3506                            PULS    D
8546  DD3F                            STD     ZP_INT_WA_C + 2                 ; Remainder=Remainder-Divisor
8548  2006                            BRA     5F                              ; Loop to do next bit
854A                  4                                                       ; L816C:
854A                                  CLC                             ; swap carry
854A  1CFE                    ANDCC   #~CC_C
854C  3262                            LEAS    2,S                             ; Couldn't subtract, drop stacked value
854E  2002                            BRA     6F
8550                  5                                                       ; L816E:
8550                                  SEC                             ; swap carry
8550  1A01                    ORCC    #CC_C
8552  0A43            6               DEC     ZP_FP_TMP
8554  26CE                            BNE     3B                              ; Loop for another bit
8556                  2                                                       ; L8171
8556  39                              RTS                                     ; All done, return
                      
8557                  brkDivideByZero
8557                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8557  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8558  124469766973696F6E206279207A65726F00                 FCB     $12,"Division by zero",0
                      
                      
                      ;               ;  Convert Integer to Real
                      ;               ;  =======================
                      ;               ;  On entry, $2A-$2D (IntA) = Integer
                      ;               ;  On exit,  $2E=sign of real
                      ;               ; TODO - this first bit of shuffling could be done better with D/16
856A                  IntToReal
856A  4F                              CLRA
856B  9735                            STA     ZP_FPA + 7
856D  972F                            STA     ZP_FPA + 1                              ; Clear rounding byte and exponent high byte
856F                  IntToReal2                                                      ; L8189
856F  962A                            LDA     ZP_INT_WA + 0
8571  972E                            STA     ZP_FPA                          ; set sign from integer sign
8573  2A05                            BPL     Int2R_skPos                             ; Copy IntA sign to RealA sign, jump if positive
8575                                  CALL    negateIntA                              ; Convert negative IntA to positive
8575                  9
8577                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0024                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8575  BDA99B                                  JSR     \1
                              ENDIF
                      
                                      ; left justify the integer in the FPA register mantissa
                      
8578  962A                            LDA     ZP_INT_WA + 0                           
857A                  Int2R_skPos                                                     ; L8194:
857A  2622                            BNE     IntToReal_left32                                        ; Top byte nonzero, so jump to convert
857C  0F34                            CLR     ZP_FPA + 6
857E  962B                            LDA     ZP_INT_WA + 1
8580  2614                            BNE     IntToReal_left24                                        ; Clear RealA, if next byte nonzero jump to convert
8582  0F33                            CLR     ZP_FPA + 5
8584  962C                            LDA     ZP_INT_WA + 2
8586  2606                            BNE     IntToReal_left16                                        ; Clear RealA, if next byte nonzero jump to convert
8588  0F32                            CLR     ZP_FPA + 4
858A  962D                            LDA     ZP_INT_WA + 3
858C  202D                            BRA     IntToReal_skSetB88cont                  ;  Clear RealA, if next byte nonzero jump to convert
                      
                      ;               ;  INT=$0000xxyy where xx<>00
                      ;               ;  ----------------------
                      
858E                  IntToReal_left16                                                        ; L81A8
858E  D62D                            LDB     ZP_INT_WA + 3
8590  D732                            STB     ZP_FPA + 4                              ;  Copy $yy000000 to mantissa
8592  C690                            LDB     #$90
8594  2027                            BRA     IntToReal_Normalize                                     ;  Normalise 16 bits
                      
                      ;               ;  INT=$00xxyyyy where xx<>00, A = $xx
                      ;               ;  -----------------------------
8596                  IntToReal_left24                                                ; L81B0
8596  9E2C                            LDX     ZP_INT_WA + 2
8598  9F32                            STX     ZP_FPA + 4                              ;  Copy $yyyy0000 to mantissa
859A  C698                            LDB     #$98
859C  201F                            BRA     IntToReal_Normalize                                     ;  Normalise 24 bits
                      
                      ;               ;  $xxyyyyyy when xx<>00, A = $xx
                      ;               ;  ----------------------------
859E                  IntToReal_left32                                                ; L81BC
859E  9E2B                            LDX     ZP_INT_WA + 1
85A0  9F32                            STX     ZP_FPA + 4                              ;  Copy $yyyyyy00 to mantissa
85A2  D62D                            LDB     ZP_INT_WA + 3
85A4  D734                            STB     ZP_FPA + 6
85A6  C6A0                            LDB     #$A0
85A8  2013                            BRA     IntToReal_Normalize                                     ;  Normalise 32 bits
                      
                      ;               ;  Return Real zero
                      ;               ;  ----------------
                                              ; expects A=0 on entry, trashes B
85AA                  IntToReal_retReal0
85AA  5F                              CLRB
85AB  DD2E                            STD     ZP_FPA
85AD  DD30                            STD     ZP_FPA + 2
                      
85AF  39              anRTS8          RTS
                      
85B0                  IntToReal_8signedA2real_check                           ; L81D5
85B0                                  CALL    zero_FPA
85B0                  9
85B2                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
85B0  BDA36D                                  JSR     \1
                              ENDIF
85B3  4D                              TSTA
85B4  2A05                            BPL     IntToReal_skSetB88cont
85B6  972E                            STA     ZP_FPA
85B8  88FF                            EORA    #$FF
85BA  4C                              INCA
85BB                  IntToReal_skSetB88cont                                  ; L81E0
85BB  C688                            LDB     #$88                            ;  Normalise 8 bits
                      
                      ;                       ;  Normalise RealA
                      ;                       ;  ---------------
                      ;                       ;  On entry, A=high byte of mantissa, B=exponent
                      ;                       ;  On exit,  exponent and mantissa in RealA normalised
85BD                  IntToReal_Normalize                                     ; L81E2
85BD  4D                              TSTA
85BE  2B0C                            BMI     IntToReal_Normalize_sk0         ; Top bit set, it is normalized
85C0  27E8                            BEQ     IntToReal_retReal0              ; Zero, jump to return Real zero
85C2                  IntToReal_Normalize_lp                                  ; L81E8
85C2  5A                              DECB                                    ; Decrease exponent, dividing number by 2
85C3  0834                            ASL     ZP_FPA + 6
85C5  0933                            ROL     ZP_FPA + 5
85C7  0932                            ROL     ZP_FPA + 4                      ; Multiply mantissa by 2, keeping number the same
85C9  49                              ROLA
85CA  2AF6                            BPL     IntToReal_Normalize_lp          ; Loop while exponent still >= $80+0
85CC                  IntToReal_Normalize_sk0                                 ; L81F2
85CC  9731                            STA     ZP_FPA + 3                      ; store MSB
85CE  D730                            STB     ZP_FPA + 2                      ; store exponent
85D0  39                              RTS                                     ; Store mantissa and exponent, return
                      ;               
                      ;                       ;  Normalise RealA
                      ;                       ;  ---------------
85D1                  NormaliseRealA
85D1  9631                            LDA     ZP_FPA + 3                      ; Get mantissa top byte
85D3                  NormaliseRealA_2
85D3  2BDA                            BMI     anRTS8                          ; top bit set, return
85D5                  NormaliseRealA_3
85D5  2620                            BNE     __NormaliseRealA_sk2            ; Nonzero, skip zero test
85D7  9A32                            ORA     ZP_FPA + 4
85D9  9A33                            ORA     ZP_FPA + 5                      ; Check if mantissa is zero
85DB  9A34                            ORA     ZP_FPA + 6
85DD  9A35                            ORA     ZP_FPA + 7
85DF  27C9                            BEQ     IntToReal_retReal0              ; Jump to return Real zero
85E1  9E2F                            LDX     ZP_FPA + 1                      ; Not zero, get exponent
85E3                  NormaliseRealA_lp1                                      ; If we got here top byte of mantissa is empty, shift mant up 8 and dec the exp
85E3  DC32                            LDD     ZP_FPA + 4
85E5  DD31                            STD     ZP_FPA + 3
85E7  DC34                            LDD     ZP_FPA + 6
85E9  DD33                            STD     ZP_FPA + 5
85EB  0F35                            CLR     ZP_FPA + 7
85ED  3018                            LEAX    -8,X                            ; Decrease exponent by 8
85EF                  NormaliseRealA_sk1
85EF  0D31                            TST     ZP_FPA + 3
85F1  27F0                            BEQ     NormaliseRealA_lp1              ; Mantissa top byte still zero, need to normalise more
85F3  2B14                            BMI     __NormaliseRealA_sk5            ; Fully normalised, store and return
85F5  2002                            BRA     __NormaliseRealA_sk3            ; Less than 8 bits left to normalise
85F7                  __NormaliseRealA_sk2
85F7  9E2F                            LDX     ZP_FPA + 1                      ;  Get exponent
85F9                  __NormaliseRealA_sk3
85F9  DC31                            LDD     ZP_FPA + 3
85FB                  NormaliseRealA_lp2
85FB  301F                            LEAX    -1,X                            ;  Decrease exponent by 1
85FD                  NormaliseRealA_sk4
85FD  0835                            ASL     ZP_FPA + 7
85FF  0934                            ROL     ZP_FPA + 6                      ;  Multiply mantissa by 2
8601  0933                            ROL     ZP_FPA + 5
8603  59                              ROLB
8604  49                              ROLA
8605  2AF4                            BPL     NormaliseRealA_lp2              ;  Still not normalise, loop for another bit
8607  DD31                            STD     ZP_FPA + 3
8609                  __NormaliseRealA_sk5
8609  9F2F                            STX     ZP_FPA + 1
860B  39                              RTS                             ;  Store exponent and return
                      ;               
                      ;                       ;  Convert float to integer
                      ;                       ;  ========================
                      ;                       ;  On entry, FloatA (ZP_FPA + 0..7) holds a float (extended exponent ignored but sign byte at ZP_FPA is used)
                      ;                       ;  On exit,  FloatA (ZP_FPA + 2..7) holds integer part
                      ;                       ;  ---------------------------------------------
                      ;                       ;  The real value is partially denormalised by repeatedly dividing the mantissa
                      ;                       ;  by 2 and incrementing the exponent to multiply the number by 2, until the
                      ;                       ;  exponent is $80, indicating that we have got to mantissa * 2^0.
                      ;                       ;
860C                  fpAMant2Int
860C  9630                            LDA     ZP_FPA + 2
860E  2A28                            BPL     fpAMant2Int_sk1                 ; Exponent<$80, number<1, jump to return 0
8610  0D31                            TST     ZP_FPA + 3
8612  2776                            BEQ     fpMant2Int_CheckSignAndNegate   ; Mantissa = $00xxxxxx, real holds an int, jump to check for negative
8614                  fpAMant2Int_lp1
8614  0431                            LSR     ZP_FPA + 3
8616  0632                            ROR     ZP_FPA + 4                      ; Divide the mantissa by 2 to denormalise by one power
8618  0633                            ROR     ZP_FPA + 5
861A  0634                            ROR     ZP_FPA + 6
861C  4C                              INCA
861D  2764                            BEQ     fpMant2Int_brkTooBig            ; Inc. exponent, if run out of exponent, jump to 'Too big'
861F  81A0            fpAMant2Int_lp2 CMPA    #$A0
8621  2463                            BHS     fpMant2Int_brkTooBigIfNE        ; Exponent is +32, float has been denormalised to an integer
8623  8199                            CMPA    #$99
8625  24ED                            BHS     fpAMant2Int_lp1                 ; Loop to keep dividing
8627  8B08                            ADDA    #$08                            ; Increment exponent by 8
8629  9E32                            LDX     ZP_FPA + 4
862B  9F33                            STX     ZP_FPA + 5                      ; Divide mantissa by 2^8
862D  D631                            LDB     ZP_FPA + 3
862F  D732                            STB     ZP_FPA + 4
8631  0F31                            CLR     ZP_FPA + 3
8633  20EA                            BRA     fpAMant2Int_lp2                 ; Loop to keep dividing
                      
                      
8635                  fpFPAtoFPBzeroFPA
8635                                  CALL fpCopyFPAtoFPB
8635                  9
8637                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8635  BDA118                                  JSR     \1
                              ENDIF
8638                  fpAMant2Int_sk1 JUMP    zero_FPA
8638  7EA36D                                  JMP     \1
                      
863B                  fpFPAMant2Int_remainder_inFPB                           ; L8275
863B  9630                            LDA     ZP_FPA + 2
863D  2AF6                            BPL     fpFPAtoFPBzeroFPA               ; if exponent < $80 then zero FPA and copy FPA to FPB
863F                                  CALL    fpSetRealBto0
863F                  9
8641                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
863F  BDA239                                  JSR     \1
                              ENDIF
8642  D631                            LDB     ZP_FPA + 3                      ; get mantissa MSB return 0 or -1 depending on sign
8644  2744                            BEQ     fpMant2Int_CheckSignAndNegate   ; L827E
8646                  L8280
8646  0431                            LSR     ZP_FPA + 3                      ; roll A mantissa into B mantissa
8648  0632                            ROR     ZP_FPA + 4
864A  0633                            ROR     ZP_FPA + 5
864C  0634                            ROR     ZP_FPA + 6
864E  063D                            ROR     ZP_FPB + 2
8650  063E                            ROR     ZP_FPB + 3
8652  063F                            ROR     ZP_FPB + 4
8654  0640                            ROR     ZP_FPB + 5
8656  4C                              INCA
8657  272A                            BEQ     fpMant2Int_brkTooBig
8659                  L8293
8659  81A0                            CMPA    #$A0                            ; compare to A0, i.e. $80 + 32
865B  2429                            BHS     fpMant2Int_brkTooBigIfNE        ; if so then if equal return else too big
865D  8199                            CMPA    #$99
865F  24E5                            BHS     L8280                           ; keep rolling bitwise
8661  8B08                            ADDA    #$08                            ; else roll bytewise
8663  D63F                            LDB     ZP_FPB + 4
8665  D740                            STB     ZP_FPB + 5
8667  D63E                            LDB     ZP_FPB + 3
8669  D73F                            STB     ZP_FPB + 4
866B  D63D                            LDB     ZP_FPB + 2
866D  D73E                            STB     ZP_FPB + 3
                                      
866F  D634                            LDB     ZP_FPA + 6
8671  D73D                            STB     ZP_FPB + 2
                                      
8673  D633                            LDB     ZP_FPA + 5
8675  D734                            STB     ZP_FPA + 6              
8677  D632                            LDB     ZP_FPA + 4
8679  D733                            STB     ZP_FPA + 5              
867B  D631                            LDB     ZP_FPA + 3
867D  D732                            STB     ZP_FPA + 4
                                      
867F  0F31                            CLR     ZP_FPA + 3
8681  20D6                            BRA L8293
8683                  fpMant2Int_brkTooBig
8683                                  JUMP    brkTooBig
8683  7EA37E                                  JMP     \1
8686                  fpMant2Int_brkTooBigIfNE                                ; L82C0
8686  26FB                            BNE     fpMant2Int_brkTooBig            ; Exponent>32, jump to 'Too big' error
8688  9730                            STA     ZP_FPA + 2                      ; Store +32 exponent
868A                  fpMant2Int_CheckSignAndNegate                           ; L82C4
868A  962E                            LDA     ZP_FPA                  ; sign byte
868C  2A10                            BPL     fpMant2Int_RTS                  ; If positive, jump to return
868E                  fpReal2Int_NegateMantissa                               ; L82C8
                                      ;  Negate the mantissa to get integer
868E  CC0000                          LDD     #0
8691  9333                            SUBD    ZP_FPA + 5
8693  DD33                            STD     ZP_FPA + 5
8695  CC0000                          LDD     #0
8698  D232                            SBCB    ZP_FPA + 4
869A  9231                            SBCA    ZP_FPA + 3
869C  DD31                            STD     ZP_FPA + 3
869E                  fpMant2Int_RTS                                          ; L82DF
869E  39                              RTS
869F                  L82E0
869F  9630                            LDA     ZP_FPA + 2
86A1  2B05                            BMI     L82E9
86A3  0F49                            CLR     ZP_FP_TMP + 6
86A5                                  JUMP    fpCheckMant0SetSignExp0
86A5  7EA0FF                                  JMP     \1
86A8                  L82E9           CALL    fpFPAMant2Int_remainder_inFPB
86A8                  9
86AA                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
86A8  8D91                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
86AA  9634                            LDA     ZP_FPA + 6
86AC  9749                            STA     ZP_FP_TMP + 6
86AE                                  CALL    fpCopyBManttoA_NewAPI
86AE                  9
86B0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
86AE  8D61                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
86B0  8680                            LDA     #$80
86B2  9730                            STA     ZP_FPA + 2
86B4  D631                            LDB     ZP_FPA + 3
86B6  2A0E                            BPL     L830A
86B8  982E                            EORA    ZP_FPA
86BA  972E                            STA     ZP_FPA
86BC  2A04                            BPL     L8305
86BE  0C49                            INC     ZP_FP_TMP + 6
86C0  2002                            BRA     L8307
86C2  0A49            L8305           DEC     ZP_FP_TMP + 6
86C4                  L8307           CALL    fpReal2Int_NegateMantissa
86C4                  9
86C6                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
86C4  8DC8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
86C6                  L830A           JUMP    NormaliseRealA
86C6  7E85D1                                  JMP     \1
                      
86C9                  fpIncrementFPAMantissa                                  ; L830D
86C9  0C34                            INC     ZP_FPA + 6
86CB  260C                            BNE     L831D
86CD  0C33                            INC     ZP_FPA + 5
86CF  2608                            BNE     L831D
86D1  0C32                            INC     ZP_FPA + 4
86D3  2604                            BNE     L831D
86D5  0C31                            INC     ZP_FPA + 3
86D7  27AA                            BEQ     fpMant2Int_brkTooBig
86D9                  L831D
86D9  39                              RTS
                                      ; make next random
                                      ; not order of storage is different to 6502
                                      ; 0 -> 3
                                      ; 1 -> 2
                                      ; 2 -> 1
                                      ; 3 -> 0
                                      ; 4 -> 4
86DA                  rndNext                                         ; L831E
86DA  C604                            LDB     #4
86DC  D743                            STB     ZP_FP_TMP
86DE  0611            1               ROR     ZP_RND_WA + 4
86E0  960D                            LDA     ZP_RND_WA + 0
86E2  1F89                            TFR     A,B
86E4  46                              RORA
86E5  9711                            STA     ZP_RND_WA + 4
86E7  960E                            LDA     ZP_RND_WA + 1
86E9  970D                            STA     ZP_RND_WA + 0
86EB  44                              LSRA
86EC  980F                            EORA    ZP_RND_WA + 2
86EE  840F                            ANDA    #$0F
86F0  980F                            EORA    ZP_RND_WA + 2
86F2  46                              RORA
86F3  46                              RORA
86F4  46                              RORA
86F5  46                              RORA
86F6  9811                            EORA    ZP_RND_WA + 4
86F8  D711                            STB     ZP_RND_WA + 4
86FA  D60F                            LDB     ZP_RND_WA + 2
86FC  D70E                            STB     ZP_RND_WA + 1
86FE  D610                            LDB     ZP_RND_WA + 3
8700  D70F                            STB     ZP_RND_WA + 2
8702  9710                            STA     ZP_RND_WA + 3
8704  0A43                            DEC     ZP_FP_TMP
8706  26D6                            BNE     1B
8708  39                              RTS
                      
8709                  fpCopyBtoA_NewAPI                                       ; L8349         - note TRASHES B
8709  DC3B                            LDD     ZP_FPB
870B  972E                            STA     ZP_FPA
870D  0F2F                            CLR     ZP_FPA + 1
870F  D730                            STB     ZP_FPA + 2
8711                  fpCopyBManttoA_NewAPI                                   ; L8353         - note TRASHES B
8711  DC3D                            LDD     ZP_FPB + 2
8713  DD31                            STD     ZP_FPA + 3
                      
8715  DC3F                            LDD     ZP_FPB + 4
8717  DD33                            STD     ZP_FPA + 5
                      
8719  9641                            LDA     ZP_FPB + 6
871B  9735                            STA     ZP_FPA + 7
871D                  rtsL8367
871D  39                              RTS
871E                  fpAddAtoBStoreA                                         ; L8368
871E  9631                            LDA     ZP_FPA + 3                      ; quick check if A = 0 then just move B to A
8720  27E7                            BEQ     fpCopyBtoA_NewAPI
8722  9630                            LDA     ZP_FPA + 2
8724  903C                            SUBA    ZP_FPB + 1
8726  2761                            BEQ     fpAddAtoBStoreA_sk_sameExp
8728  252D                            BCS     fpAddAtoBStoreA_skAtooSmall
872A  8125                            CMPA    #$25
872C  24EF                            BCC     rtsL8367
872E  1F89                            TFR     A,B
8730  8438                            ANDA    #$38
8732  270E                            BEQ     fpAddAtoBStoreA_shr8_B_sk
8734                  fpAddAtoBStoreA_shr8_B_lp                               ; L837F
8734  9E3F                            LDX     ZP_FPB + 4                      ; shift B right in 8's
8736  9F40                            STX     ZP_FPB + 5
8738  9E3D                            LDX     ZP_FPB + 2
873A  9F3E                            STX     ZP_FPB + 3
873C  0F3D                            CLR     ZP_FPB + 2
873E  8008                            SUBA    #$08
8740  26F2                            BNE     fpAddAtoBStoreA_shr8_B_lp
8742                  fpAddAtoBStoreA_shr8_B_sk                               ; L8395:
8742  1F98                            TFR     B,A
8744  8407                            ANDA    #$07
8746  2741                            BEQ     fpAddAtoBStoreA_sk_sameExp
8748                  fpAddAtoBStoreA_shr1_B_lp                                       ; L839A:
8748  043D                            LSR     ZP_FPB + 2
874A  063E                            ROR     ZP_FPB + 3
874C  063F                            ROR     ZP_FPB + 4
874E  0640                            ROR     ZP_FPB + 5
8750  0641                            ROR     ZP_FPB + 6
8752  4A                              DECA
8753  26F3                            BNE     fpAddAtoBStoreA_shr1_B_lp
8755  2032                            BRA     fpAddAtoBStoreA_sk_sameExp
                      
8757                  fpAddAtoBStoreA_skAtooSmall                             ; L83A9
                                      ; shift A  right until it is of same order as B
8757  88FF                            EORA    #$FF
8759  4C                              INCA
875A  8125                            CMPA    #$25
875C  24AB                            BCC     fpCopyBtoA_NewAPI
875E  D63C                            LDB     ZP_FPB + 1
8760  D730                            STB     ZP_FPA + 2
8762  1F89                            TFR     A,B
8764  8438                            ANDA    #$38
8766  270E                            BEQ     fpAddAtoBStoreA_shr8_A_sk
8768                  fpAddAtoBStoreA_shr8_A_lp                               ; L83BA:
8768  9E33                            LDX     ZP_FPA + 5
876A  9F34                            STX     ZP_FPA + 6
876C  9E31                            LDX     ZP_FPA + 3
876E  9F32                            STX     ZP_FPA + 4
8770  0F31                            CLR     ZP_FPA + 3
8772  8008                            SUBA    #$08
8774  26F2                            BNE     fpAddAtoBStoreA_shr8_A_lp
8776                  fpAddAtoBStoreA_shr8_A_sk                               ; L83D0:
8776  1F98                            TFR     B,A
8778  8407                            ANDA    #$07
877A  270D                            BEQ     fpAddAtoBStoreA_sk_sameExp
877C                  fpAddAtoBStoreA_shr1_A_lp                               ; L83D5:
877C  0431                            LSR     ZP_FPA + 3
877E  0632                            ROR     ZP_FPA + 4
8780  0633                            ROR     ZP_FPA + 5
8782  0634                            ROR     ZP_FPA + 6
8784  0635                            ROR     ZP_FPA + 7
8786  4A                              DECA
8787  26F3                            BNE     fpAddAtoBStoreA_shr1_A_lp
8789                  fpAddAtoBStoreA_sk_sameExp                              ; L83E2
8789  962E                            LDA     ZP_FPA
878B  983B                            EORA    ZP_FPB
878D  2B03                            BMI     fpAddAtoBstoreA_oppsigns        ; signs are different
878F                                  JUMP    fpAddAtoBstoreinA_sameExp
878F  7EA141                                  JMP     \1
8792                  fpAddAtoBstoreA_oppsigns                                ; L83EC
8792  DC31                            LDD     ZP_FPA + 3                      ; compare mants
8794  10933D                          CMPD    ZP_FPB + 2
8797  2610                            BNE     fpAddAtoBstoreA_oppsigns_sk
8799  DC33                            LDD     ZP_FPA + 5
879B  10933F                          CMPD    ZP_FPB + 4
879E  2609                            BNE     fpAddAtoBstoreA_oppsigns_sk
87A0  9635                            LDA     ZP_FPA + 7
87A2  9141                            CMPA    ZP_FPB + 6
87A4  2603                            BNE     fpAddAtoBstoreA_oppsigns_sk
87A6                                  JUMP    zero_FPA                        ; they're the same return 0
87A6  7EA36D                                  JMP     \1
87A9                  fpAddAtoBstoreA_oppsigns_sk                             ; L840D
87A9  241B                            BHS     fpAddAtoBstoreA_oppsigns_sk2    ; gt
87AB  963B                            LDA     ZP_FPB
87AD  972E                            STA     ZP_FPA                  ; keep B' sign
                      
87AF  DC40                            LDD     ZP_FPB + 5
87B1  9334                            SUBD    ZP_FPA + 6
87B3  9734                            STA     ZP_FPA + 6
                      
87B5  DC3E                            LDD     ZP_FPB + 3
87B7  D233                            SBCB    ZP_FPA + 5
87B9  9232                            SBCA    ZP_FPA + 4
87BB  DD32                            STD     ZP_FPA + 4
                      
87BD  963D                            LDA     ZP_FPB + 2
87BF  9231                            SBCA    ZP_FPA + 3
87C1  9731                            STA     ZP_FPA + 3
87C3                                  JUMP    NormaliseRealA_2
87C3  7E85D3                                  JMP     \1
                      
87C6                  fpAddAtoBstoreA_oppsigns_sk2                            ; L8435
87C6  DC34                            LDD     ZP_FPA + 6
87C8  9340                            SUBD    ZP_FPB + 5
87CA  DD34                            STD     ZP_FPA + 6
                      
87CC  DC32                            LDD     ZP_FPA + 4
87CE  D23F                            SBCB    ZP_FPB + 4
87D0  923E                            SBCA    ZP_FPB + 3
87D2  DD32                            STD     ZP_FPA + 4
                      
87D4  9631                            LDA     ZP_FPA + 3
87D6  923D                            SBCA    ZP_FPB + 2
87D8  9731                            STA     ZP_FPA + 3
87DA                                  JUMP    NormaliseRealA_2
87DA  7E85D3                                  JMP     \1
                      ;               
                      ;                       ;  00000000
                      ;                       ;  FUNCTION/COMMAND DISPATCH TABLE
                      ;                       ;  ===============================
87DD                  tblCmdDispatch
87DD  A7D6                             FDB fnOPENIN                   ;  $8E - OPENIN
87DF  A7B4                             FDB varGetPTR                  ;  $8F - =PTR
87E1  AABB                             FDB varGetPAGE                 ;  $90 - =PAGE
87E3  AAFF                             FDB varGetTIME                 ;  $91 - =TIME
87E5  AAE8                             FDB varGetLOMEM                ;  $92 - =LOMEM
87E7  AAEC                             FDB varGetHIMEM                ;  $93 - =HIMEM
87E9  A972                             FDB fnABS                      ;  $94 - ABS
87EB  A575                             FDB fnACS                      ;  $95 - ACS
87ED  AA9F                             FDB fnADVAL                    ;  $96 - ADVAL
87EF  A867                             FDB fnASC                      ;  $97 - ASC
87F1  A57D                             FDB fnASN                      ;  $98 - ASN
87F3  A58B                             FDB fnATN                      ;  $99 - ATN
87F5  A7CB                             FDB fnBGET                     ;  $9A - BGET
87F7  A5DF                             FDB fnCOS                      ;  $9B - COS
87F9  AAE4                             FDB fnCOUNT                    ;  $9C - COUNT
87FB  A6BC                             FDB fnDEG                      ;  $9D - DEG
87FD  AAF0                             FDB varERL                     ;  $9E - ERL
87FF  AAF4                             FDB varERR                     ;  $9F - ERR
8801  A7FA                             FDB fnEVAL                     ;  $A0 - EVAL
8803  A6C4                             FDB fnEXP                      ;  $A1 - EXP
8805  A7B0                             FDB fnEXT                      ;  $A2 - EXT
8807  A89D                             FDB varFALSE                   ;  $A3 - FALSE
8809  ACF4                             FDB fnFN                       ;  $A4 - FN
880B  AAFA                             FDB fnGET                      ;  $A5 - GET
880D  A878                             FDB fnINKEY                    ;  $A6 - INKEY
880F  A8EF                             FDB fnINSTR                    ;  $A7 - INSTR(
8811  A83A                             FDB fnINT                      ;  $A8 - INT
8813  AAC0                             FDB fnLEN                      ;  $A9 - LEN
8815  A3FF                             FDB fnLN                       ;  $AA - LN
8817  A6B4                             FDB fnLOG                      ;  $AB - LOG
8819  A77A                             FDB fnNOT                      ;  $AC - NOT
881B  A7DE                             FDB fnOPENUP                   ;  $AD - OPENUP
881D  A7DA                             FDB fnOPENOUT                  ;  $AE - OPENOUT
881F  A7F4                             FDB fnPI                       ;  $AF - PI
8821  A8C2                             FDB fnPOINT                    ;  $B0 - POINT(
8823  A789                             FDB fnPOS                      ;  $B1 - POS
8825  A6AC                             FDB fnRAD                      ;  $B2 - RAD
8827  A763                             FDB fnRND                      ;  $B3 - RND
8829  A8A9                             FDB fnSGN                      ;  $B4 - SGN
882B  A5DB                             FDB fnSIN                      ;  $B5 - SIN
882D  A47F                             FDB fnSQR                      ;  $B6 - SQR
882F  A251                             FDB fnTAN                      ;  $B7 - TAN
8831  AAAF                             FDB fnTO                       ;  $B8 - TO
8833  A891                             FDB returnINTminus1            ;  $B9 - TRUE
8835  A78E                             FDB fnUSR                      ;  $BA - USR
8837  A806                             FDB fnVAL                      ;  $BB - VAL
8839  A7A6                             FDB fnVPOS                     ;  $BC - VPOS
883B  AED0                             FDB fnCHR                      ;  $BD - CHR$
883D  AB39                             FDB fnGETDOLLAR                ;  $BE - GET$
883F  AB96                             FDB fnINKEYDOLLAR              ;  $BF - INKEY$
8841  AB48                             FDB fnLEFT                     ;  $C0 - LEFT$(
8843  ABA0                             FDB fnMIDstr                   ;  $C1 - MID$(
8845  AB4C                             FDB fnRIGHT                    ;  $C2 - RIGHT$(
8847  AC14                             FDB fnSTR                      ;  $C3 - STR$(
8849  AC43                             FDB fnSTRING                   ;  $C4 - STRING$(
884B  A883                             FDB fnEOF                      ;  $C5 - EOF
884D  92F9                             FDB cmdAUTO                    ;  $C6 - AUTO
884F  92B3                             FDB cmdDELETE                  ;  $C7 - DELETE
8851  8F4A                             FDB cmdLOAD                    ;  $C8 - LOAD
8853  B06B                             FDB cmdLIST                    ;  $C9 - LIST
8855  8F66                             FDB cmdNEW                     ;  $CA - NEW
8857  8F2D                             FDB cmdOLD                     ;  $CB - OLD
8859  92E4                             FDB cmdRENUMBER                ;  $CC - RENUMBER
885B  B9BD                             FDB cmdSAVE                    ;  $CD - SAVE
885D  B027                             FDB cmdEDIT                    ;  $CE - EDIT
885F  B9F8                             FDB varSetPTR                  ;  $CF - PTR=
8861  9467                             FDB varSetPAGE                 ;  $D0 - PAGE=
8863  94AA                             FDB varSetTIME                 ;  $D1 - TIME=
8865  9459                             FDB varSetLOMEM                ;  $D2 - LOMEM=
8867  944E                             FDB varSetHIMEM                ;  $D3 - HIMEM=
8869  AF54                             FDB cmdSOUND                   ;  $D4 - SOUND
886B  BA25                             FDB cmdBPUT                    ;  $D5 - BPUT
886D  9260                             FDB cmdCALL                    ;  $D6 - CALL
886F  8F28                             FDB cmdCHAIN                   ;  $D7 - CHAIN
8871  9471                             FDB cmdCLEAR                   ;  $D8 - CLEAR
8873  BA1B                             FDB cmdCLOSE                   ;  $D9 - CLOSE
8875  95EE                             FDB cmdCLG                     ;  $DA - CLG
8877  95F5                             FDB cmdCLS                     ;  $DB - CLS
8879  8F97                             FDB cmdREM                     ;  $DC - DATA
887B  8F97                             FDB cmdREM                     ;  $DD - DEF
887D  939F                             FDB cmdDIM                     ;  $DE - DIM
887F  95B2                             FDB cmdDRAW                    ;  $DF - DRAW
8881  8F4F                             FDB cmdEND                     ;  $E0 - END
8883  98E7                             FDB cmdENDPROC                 ;  $E1 - ENDPROC
8885  AF74                             FDB cmdENVELOPE                ;  $E2 - ENVELOPE
8887  B2B3                             FDB cmdFOR                     ;  $E3 - FOR
8889  B34D                             FDB cmdGOSUB                   ;  $E4 - GOSUB
888B  B38C                             FDB cmdGOTO                    ;  $E5 - GOTO
888D  9559                             FDB cmdGCOL                    ;  $E6 - GCOL
888F  992D                             FDB cmdIF                      ;  $E7 - IF
8891  B50F                             FDB cmdINPUT                   ;  $E8 - INPUT
8893  9024                             FDB cmdLET                     ;  $E9 - LET
8895  9522                             FDB cmdLOCAL                   ;  $EA - LOCAL
8897  9579                             FDB cmdMode                    ;  $EB - MODE
8899  95AE                             FDB cmdMOVE                    ;  $EC - MOVE
889B  B178                             FDB cmdNEXT                    ;  $ED - NEXT
889D  B3B9                             FDB cmdON                      ;  $EE - ON
889F  961C                             FDB cmdVDU                     ;  $EF - VDU
88A1  95BE                             FDB cmdPLOT                    ;  $F0 - PLOT
88A3  9146                             FDB cmdPRINT                   ;  $F1 - PRINT
88A5  950F                             FDB cmdPROC                    ;  $F2 - PROC
88A7  B5D7                             FDB cmdREAD                    ;  $F3 - READ
88A9  8F97                             FDB cmdREM                     ;  $F4 - REM
88AB  B690                             FDB cmdREPEAT                  ;  $F5 - REPEAT
88AD  9602                             FDB cmdREPORT                  ;  $F6 - REPORT
88AF  B5AE                             FDB cmdRESTORE                 ;  $F7 - RESTORE
88B1  B379                             FDB cmdRETURN                  ;  $F8 - RETURN
88B3  8F3D                             FDB cmdRUN                     ;  $F9 - RUN
88B5  905D                             FDB cmdSTOP                    ;  $FA - STOP
88B7  956F                             FDB cmdCOLOUR                  ;  $FB - COLOUR
88B9  9479                             FDB cmdTRACE                   ;  $FC - TRACE
88BB  B662                             FDB cmdUNTIL                   ;  $FD - UNTIL
88BD  AFA7                             FDB cmdWIDTH                   ;  $FE - WIDTH
88BF  B9E5                             FDB cmdOSCLI                   ;  $FF - OSCLI
                      
                                       include "./assembler_share.asm"
88C1                  assScanExit                                                     ; L891A
88C1  4A                              DECA
88C2  9728                            STA     ZP_OPT
88C4                                  JUMP    skipSpacesAtYexecImmed
88C4  7E8FEA                                  JMP     \1
88C7                  assScanEnter                                            ; L8920
88C7                                  CALL    skipSpacesY
88C7                  9
88C9                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0043                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88C7  BD8F0C                                  JSR     \1
                              ENDIF
88CA  885D                            EORA    #']'
88CC  27F3                            BEQ     assScanExit                             ;  End of assembler
88CE  335F                            LEAU    -1,U
88D0                                  CALL    storeYasTXTPTR
88D0                  9
88D2                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0031                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88D0  BD9903                                  JSR     \1
                              ENDIF
88D3  3440                            PSHS    U
88D5                                  CALL    assScanNextOp
88D5                  9
88D7                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88D5  BD8A80                                  JSR     \1
                              ENDIF
88D8  3510                            PULS    X
88DA  9F19                            STX     ZP_TXTPTR2                      ; points at start of instruction
88DC  DF2E                            STU     ZP_FPA
                      ;;              LEAU    -1,U
88DE  9628                            LDA     ZP_OPT
88E0  44                              LSRA
88E1  247D                            BCC     assSkipList
88E3  961E                            LDA     ZP_PRLINCOUNT
88E5  8B05                            ADDA    #$05
88E7  973F                            STA     ZP_FPB + 4
88E9  9637                            LDA     ZP_GEN_PTR                      ; print opcode address
88EB                                  CALL    list_printHexByte
88EB                  9
88ED                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88EB  BDB8C5                                  JSR     \1
                              ENDIF
88EE  9638                            LDA     ZP_GEN_PTR + 1
88F0                                  CALL    list_printHexByteAndSpace
88F0                  9
88F2                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88F0  BDB8EB                                  JSR     \1
                              ENDIF
88F3  C6FC                            LDB     #$FC
88F5  9639                            LDA     ZP_ASS_OPLEN                    ; get back op len
88F7  2A02                            BPL     assPrintString                  ; if negative its a string
88F9  9636                            LDA     ZP_STRBUFLEN                    ; get string len
88FB                  assPrintString                                          ; L894E
88FB  9738                            STA     ZP_ASS_LIST_OPLEN
88FD  2718                            BEQ     assPrintSk0LenOp
88FF  9E3A                            LDX     ZP_ASS_OPSAVED
8901                  assPrintOpCodeLp                
8901  5C                              INCB
8902  260A                            BNE     L8961
8904                                  CALL    PrintCRclearPRLINCOUNT
8904                  9
8906                  __XBSR                  SET 9B+2
2D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8904  BDB6BE                                  JSR     \1
                              ENDIF
8907  D63F                            LDB     ZP_FPB + 4
8909                                  CALL    list_printBSpaces
8909                  9
890B                  __XBSR                  SET 9B+2
3000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0012                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8909  BDB91D                                  JSR     \1
                              ENDIF
890C  C6FD                            LDB     #$FD
890E                  L8961
890E  A680                            LDA     ,X+
8910                                  CALL    list_printHexByteAndSpace
8910                  9
8912                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8910  BDB8EB                                  JSR     \1
                              ENDIF
8913  0A38                            DEC     ZP_ASS_LIST_OPLEN
8915  26EA                            BNE     assPrintOpCodeLp
8917                  assPrintSk0LenOp
                      ;;              TXA
                      ;;              TAY
8917                  assPrintAlignOpTxtLp                                    ;L896D
8917  5C                              INCB
8918  270B                            BEQ     assPrintAlignOpTxtSk
891A  3404                            PSHS    B
891C  C603                            LDB     #$03
891E                                  CALL    list_printBSpaces
891E                  9
8920                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
891E  BDB91D                                  JSR     \1
                              ENDIF
8921  3504                            PULS    B
8923  20F2                            BRA     assPrintAlignOpTxtLp
8925                  assPrintAlignOpTxtSk                                    ; L8977
8925  C60A                            LDB     #$0A
8927  9E19                            LDX     ZP_TXTPTR2                      ; back to start of stmt in program
8929  A680                            LDA     ,X+
892B  812E                            CMPA    #'.'                            ; if original stmt started with '.' print label
892D  260E                            BNE     assPrintLabelSk                         
892F                  assPrintLabelLp                                         ; L897F
892F                                  CALL    doListPrintTokenA
892F                  9
8931                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0070                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
892F  BDB8A1                                  JSR     \1
                              ENDIF
8932  5A                              DECB
8933  2602                            BNE     1F
8935  C601                            LDB     #$01
8937  A680            1               LDA     ,X+
8939  9C4E                            CMPX    ZP_ASS_LBLEND
893B  23F2                            BLS     assPrintLabelLp
893D                  assPrintLabelSk                                         ; L898E
893D                                  CALL    list_printBSpaces
893D                  9
893F                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
893D  BDB91D                                  JSR     \1
                              ENDIF
8940  301F                            LEAX    -1,X
8942                  L8992
8942  A180                            CMPA    ,X+                             ; skip spaces at start?
8944  27FC                            BEQ     L8992
8946  301F                            LEAX    -1,X
8948                  L8997
8948  A684                            LDA     ,X
894A  813A                            CMPA    #$3A
894C  270B                            BEQ     L89A7
894E  810D                            CMPA    #$0D
8950  270B                            BEQ     L89AB
8952                  L89A1
8952                                  CALL doListPrintTokenA
8952                  9
8954                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8952  BDB8A1                                  JSR     \1
                              ENDIF
8955  3001                            LEAX    1,X
8957  20EF                            BRA     L8997
8959  9C2E            L89A7           CMPX    ZP_FPA
895B  25F5                            BLO     L89A1
895D                  L89AB           CALL    PrintCRclearPRLINCOUNT
895D                  9
895F                  __XBSR                  SET 9B+2
2D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
895D  BDB6BE                                  JSR     \1
                              ENDIF
8960                  assSkipList     
                      ;;              LEAU    -1,U
8960  A6C0            L89B1           LDA     ,U+
8962  813A                            CMPA    #':'
8964  2704                            BEQ     L89BC
8966  810D                            CMPA    #$0D
8968  26F6                            BNE     L89B1
896A  335F            L89BC           LEAU    -1,U
896C                                  CALL    scanNextStmtFromY
896C                  9
896E                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
896C  BD98F4                                  JSR     \1
                              ENDIF
896F  A6C0                            LDA     ,U+
8971  813A                            CMPA    #':'
8973  270C                            BEQ     L89D1
8975  1F30                            TFR     U,D
                      ;;;             LDA     ZP_TXTPTR + 1
8977  8107                            CMPA    #$07
8979  2603                            BNE     L89CE
897B                                  JUMP    immedPrompt
897B  7E8F6F                                  JMP     \1
897E                  L89CE           CALL    doTraceOrEndAtELSE
897E                  9
8980                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
897E  BD991C                                  JSR     \1
                              ENDIF
8981                  L89D1           JUMP    assScanEnter
8981  7E88C7                                  JMP     \1
                      
8984                  assDecYEvalForceINT_LE
8984  335F                            LEAU    -1,U
8986                  assEvalForceINT_LE
8986                                  CALL    evalForceINT
8986                  9
8988                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8986  BD9221                                  JSR     \1
                              ENDIF
8989  3406                            PSHS    D
898B  DC2A                            LDD     ZP_INT_WA
898D  3406                            PSHS    D
898F  DC2C                            LDD     ZP_INT_WA+2
8991  1E89                            EXG     A,B
8993  DD2A                            STD     ZP_INT_WA
8995  3506                            PULS    D
8997  1E89                            EXG     A,B
8999  DD2C                            STD     ZP_INT_WA+2
899B  3586                            PULS    D,PC
                      
                              IF ASSEMBLER_6502
                                      include "./assembler6502.asm"
                      ;               
                      ;               
                      ;               
                      ;                       ;  ASSEMBLER
                      ;                       ;  =========
                      ;                       ;  Packed mnemonic table, low bytes
                      ;                       ;  --------------------------------
                      
                              ;       4       B       0       A
                              ; 0 1 0 0 1 0 1 1 0 0 0 0 1 0 1 0
                              ; *-|-------| |-------| |-------|
                              ;         $14       $18       $0A
                              ;           T         X         J
                      
                              ;       0       A       4       B
                              ; 0 0 0 0 1 0 1 0 0 1 0 0 1 0 1 1
                              ; *-|-------| |-------| |-------|
                              ;         $02       $12       $0B
                              ;           B         R         K
                      
0045                  ASM_OPCOUNT             EQU     $45
                      
899D                  assOpMungeLowBytes                                      ; L884D
899D  4B                              FCB  $4B                                ; 'BRK'
899E  83                              FCB  $83                                ; 'CLC'
899F  84                              FCB  $84                                ; 'CLD'
89A0  89                              FCB  $89                                ; 'CLI'
89A1  96                              FCB  $96                                ; 'CLV'
89A2  B8                              FCB  $B8                                ; 'DEX'
89A3  B9                              FCB  $B9                                ; 'DEY'
89A4  D8                              FCB  $D8                                ; 'INX'
89A5  D9                              FCB  $D9                                ; 'INY'
89A6  F0                              FCB  $F0                                ; 'NOP'
89A7  01                              FCB  $01                                ; 'PHA'
89A8  10                              FCB  $10                                ; 'PHP'
89A9  81                              FCB  $81                                ; 'PLA'
89AA  90                              FCB  $90                                ; 'PLP'
89AB  89                              FCB  $89                                ; 'RTI'
89AC  93                              FCB  $93                                ; 'RTS'
89AD  A3                              FCB  $A3                                ; 'SEC'
89AE  A4                              FCB  $A4                                ; 'SED'
89AF  A9                              FCB  $A9                                ; 'SEI'
89B0  38                              FCB  $38                                ; 'TAX'
89B1  39                              FCB  $39                                ; 'TAY'
89B2  78                              FCB  $78                                ; 'TSX'
89B3  01                              FCB  $01                                ; 'TXA'
89B4  13                              FCB  $13                                ; 'TXS'
89B5  21                              FCB  $21                                ; 'TYA'
89B6  A1                              FCB  $A1                                ; 'DEA'
89B7  C1                              FCB  $C1                                ; 'INA'
89B8  19                              FCB  $19                                ; 'PHY'
89B9  18                              FCB  $18                                ; 'PHX'
89BA  99                              FCB  $99                                ; 'PLY'
89BB  98                              FCB  $98                                ; 'PLX'
89BC  63                              FCB  $63                                ; 'BCC'
89BD  73                              FCB  $73                                ; 'BCS'
89BE  B1                              FCB  $B1                                ; 'BEQ'
89BF  A9                              FCB  $A9                                ; 'BMI'
89C0  C5                              FCB  $C5                                ; 'BNE'
89C1  0C                              FCB  $0C                                ; 'BPL'
89C2  C3                              FCB  $C3                                ; 'BVC'
89C3  D3                              FCB  $D3                                ; 'BVS'
89C4  41                              FCB  $41                                ; 'BRA'
89C5  C4                              FCB  $C4                                ; 'AND'
89C6  F2                              FCB  $F2                                ; 'EOR'
89C7  41                              FCB  $41                                ; 'ORA'
89C8  83                              FCB  $83                                ; 'ADC'
89C9  B0                              FCB  $B0                                ; 'CMP'
89CA  81                              FCB  $81                                ; 'LDA'
89CB  43                              FCB  $43                                ; 'SBC'
89CC  6C                              FCB  $6C                                ; 'ASL'
89CD  72                              FCB  $72                                ; 'LSR'
89CE  EC                              FCB  $EC                                ; 'ROL'
89CF  F2                              FCB  $F2                                ; 'ROR'
89D0  A3                              FCB  $A3                                ; 'DEC'
89D1  C3                              FCB  $C3                                ; 'INC'
89D2  92                              FCB  $92                                ; 'CLR'
89D3  9A                              FCB  $9A                                ; 'STZ'
89D4  18                              FCB  $18                                ; 'CPX'
89D5  19                              FCB  $19                                ; 'CPY'
89D6  62                              FCB  $62                                ; 'TSB'
89D7  42                              FCB  $42                                ; 'TRB'
89D8  34                              FCB  $34                                ; 'BIT'
89D9  B0                              FCB  $B0                                ; 'JMP'
89DA  72                              FCB  $72                                ; 'JSR'
89DB  98                              FCB  $98                                ; 'LDX'
89DC  99                              FCB  $99                                ; 'LDY'
89DD  81                              FCB  $81                                ; 'STA'
89DE  98                              FCB  $98                                ; 'STX'
89DF  99                              FCB  $99                                ; 'STY'
89E0  14                              FCB  $14                                ; 'OPT'
89E1  35                              FCB  $35                                ; 'EQU'
                                              ;  Packed mnemonic table, high bytes
                                              ;  ---------------------------------
89E2                  assOpMungeHiBytes                                       ; L8892
89E2  0A                              FCB  $0A                                ; 'BRK'
89E3  0D                              FCB  $0D                                ; 'CLC'
89E4  0D                              FCB  $0D                                ; 'CLD'
89E5  0D                              FCB  $0D                                ; 'CLI'
89E6  0D                              FCB  $0D                                ; 'CLV'
89E7  10                              FCB  $10                                ; 'DEX'
89E8  10                              FCB  $10                                ; 'DEY'
89E9  25                              FCB  $25                                ; 'INX'
89EA  25                              FCB  $25                                ; 'INY'
89EB  39                              FCB  $39                                ; 'NOP'
89EC  41                              FCB  $41                                ; 'PHA'
89ED  41                              FCB  $41                                ; 'PHP'
89EE  41                              FCB  $41                                ; 'PLA'
89EF  41                              FCB  $41                                ; 'PLP'
89F0  4A                              FCB  $4A                                ; 'RTI'
89F1  4A                              FCB  $4A                                ; 'RTS'
89F2  4C                              FCB  $4C                                ; 'SEC'
89F3  4C                              FCB  $4C                                ; 'SED'
89F4  4C                              FCB  $4C                                ; 'SEI'
89F5  50                              FCB  $50                                ; 'TAX'
89F6  50                              FCB  $50                                ; 'TAY'
89F7  52                              FCB  $52                                ; 'TSX'
89F8  53                              FCB  $53                                ; 'TXA'
89F9  53                              FCB  $53                                ; 'TXS'
89FA  53                              FCB  $53                                ; 'TYA'
89FB  10                              FCB  $10                                ; 'DEA'
89FC  25                              FCB  $25                                ; 'INA'
89FD  41                              FCB  $41                                ; 'PHY'
89FE  41                              FCB  $41                                ; 'PHX'
89FF  41                              FCB  $41                                ; 'PLY'
8A00  41                              FCB  $41                                ; 'PLX'
8A01  08                              FCB  $08                                ; 'BCC'
8A02  08                              FCB  $08                                ; 'BCS'
8A03  08                              FCB  $08                                ; 'BEQ'
8A04  09                              FCB  $09                                ; 'BMI'
8A05  09                              FCB  $09                                ; 'BNE'
8A06  0A                              FCB  $0A                                ; 'BPL'
8A07  0A                              FCB  $0A                                ; 'BVC'
8A08  0A                              FCB  $0A                                ; 'BVS'
8A09  0A                              FCB  $0A                                ; 'BRA'
8A0A  05                              FCB  $05                                ; 'AND'
8A0B  15                              FCB  $15                                ; 'EOR'
8A0C  3E                              FCB  $3E                                ; 'ORA'
8A0D  04                              FCB  $04                                ; 'ADC'
8A0E  0D                              FCB  $0D                                ; 'CMP'
8A0F  30                              FCB  $30                                ; 'LDA'
8A10  4C                              FCB  $4C                                ; 'SBC'
8A11  06                              FCB  $06                                ; 'ASL'
8A12  32                              FCB  $32                                ; 'LSR'
8A13  49                              FCB  $49                                ; 'ROL'
8A14  49                              FCB  $49                                ; 'ROR'
8A15  10                              FCB  $10                                ; 'DEC'
8A16  25                              FCB  $25                                ; 'INC'
8A17  0D                              FCB  $0D                                ; 'CLR'
8A18  4E                              FCB  $4E                                ; 'STZ'
8A19  0E                              FCB  $0E                                ; 'CPX'
8A1A  0E                              FCB  $0E                                ; 'CPY'
8A1B  52                              FCB  $52                                ; 'TSB'
8A1C  52                              FCB  $52                                ; 'TRB'
8A1D  09                              FCB  $09                                ; 'BIT'
8A1E  29                              FCB  $29                                ; 'JMP'
8A1F  2A                              FCB  $2A                                ; 'JSR'
8A20  30                              FCB  $30                                ; 'LDX'
8A21  30                              FCB  $30                                ; 'LDY'
8A22  4E                              FCB  $4E                                ; 'STA'
8A23  4E                              FCB  $4E                                ; 'STX'
8A24  4E                              FCB  $4E                                ; 'STY'
8A25  3E                              FCB  $3E                                ; 'OPT'
8A26  16                              FCB  $16                                ; 'EQU'
                                              ;  ASSEMBLER OPCODE TABLE
                                              ;  ======================
8A27                  assOpcodeBytes                                          ; L88D7
8A27  00                              FCB     $00                             ; BRK
8A28  18                              FCB     $18                             ; CLC
8A29  D8                              FCB     $D8                             ; CLD
8A2A  58                              FCB     $58                             ; CLI
8A2B  B8                              FCB     $B8                             ; CLV
8A2C  CA                              FCB     $CA                             ; DEX
8A2D  88                              FCB     $88                             ; DEY
8A2E  E8                              FCB     $E8                             ; INX
8A2F  C8                              FCB     $C8                             ; INY
8A30  EA                              FCB     $EA                             ; NOP
8A31  48                              FCB     $48                             ; PHA
8A32  08                              FCB     $08                             ; PHP
8A33  68                              FCB     $68                             ; PLA
8A34  28                              FCB     $28                             ; PLP
8A35  40                              FCB     $40                             ; RTI
8A36  60                              FCB     $60                             ; RTS
8A37  38                              FCB     $38                             ; SEC
8A38  F8                              FCB     $F8                             ; SED
8A39  78                              FCB     $78                             ; SEI
8A3A  AA                              FCB     $AA                             ; TAX
8A3B  A8                              FCB     $A8                             ; TAY
8A3C  BA                              FCB     $BA                             ; TSX
8A3D  8A                              FCB     $8A                             ; TXA
8A3E  9A                              FCB     $9A                             ; TXS
8A3F  98                              FCB     $98                             ; TYA
8A40  3A                              FCB     $3A                             ; DEC A
8A41  1A                              FCB     $1A                             ; INC A
8A42  5A                              FCB     $5A                             ; PHY
8A43  DA                              FCB     $DA                             ; PHX
8A44  7A                              FCB     $7A                             ; PLY
8A45  FA                              FCB     $FA                             ; PLX
001F                  ASM_OPLASTIMPLIED       EQU     *-assOpcodeBytes                ; $1F
8A46  90                              FCB     $90                             ; BCC
8A47  B0                              FCB     $B0                             ; BCS
8A48  F0                              FCB     $F0                             ; BEQ
8A49  30                              FCB     $30                             ; BMI
8A4A  D0                              FCB     $D0                             ; BNE
8A4B  10                              FCB     $10                             ; BPL
8A4C  50                              FCB     $50                             ; BVC
8A4D  70                              FCB     $70                             ; BVS
8A4E  80                              FCB     $80                             ; BRA
0028                  ASM_OPLASTBRA8          EQU     *-assOpcodeBytes                ;$28
8A4F  21                              FCB     $21                             ; AND
8A50  41                              FCB     $41                             ; EOR
8A51  01                              FCB     $01                             ; ORA
8A52  61                              FCB     $61                             ; ADC
8A53  C1                              FCB     $C1                             ; CMP
8A54  A1                              FCB     $A1                             ; LDA
8A55  E1                              FCB     $E1                             ; SBC
002F                  ASM_OPASL               EQU     *-assOpcodeBytes                ;$2F
8A56  06                              FCB     $06                             ; ASL
8A57  46                              FCB     $46                             ; LSR
8A58  26                              FCB     $26                             ; ROL
8A59  66                              FCB     $66                             ; ROR
0033                  ASM_OPDEC                       EQU     *-assOpcodeBytes        ;$33
8A5A  C6                              FCB     $C6                             ; DEC
8A5B  E6                              FCB     $E6                             ; INC
0035                  ASM_OPSTZ                       EQU     *-assOpcodeBytes        ;$35
8A5C  9C                              FCB     $9C                             ; STZ
8A5D  9C                              FCB     $9C                             ; CLR
0037                  ASM_OPCPX                       EQU     *-assOpcodeBytes        ;$37            
8A5E  E0                              FCB     $E0                             ; CPX
8A5F  C0                              FCB     $C0                             ; CPY
0039                  ASM_OPTSB                       EQU     *-assOpcodeBytes        ;$39            
8A60  00                              FCB     $00                             ; TSB
8A61  10                              FCB     $10                             ; TRB
003B                  ASM_OPBIT                       EQU     *-assOpcodeBytes        ;$3B            
8A62  24                              FCB     $24                             ; BIT
8A63  4C                              FCB     $4C                             ; JMP
003D                  ASM_OPJSR                       EQU     *-assOpcodeBytes        ;$3D            
8A64  20                              FCB     $20                             ; JSR
8A65  A2                              FCB     $A2                             ; LDX
8A66  A0                              FCB     $A0                             ; LDY
0040                  ASM_OPNUM_STA           EQU     *-assOpcodeBytes                ;$40
8A67  81                              FCB     $81                             ; STA
8A68  86                              FCB     $86                             ; STX
8A69  84                              FCB     $84                             ; STY
0043                  ASM_OPNUM_MAX           EQU     *-assOpcodeBytes                ;$43
                              
                      
8A6A  3341            assScanLabel    LEAU    1,U                             ; L89D4
8A6C                                  CALL    findVarOrAllocEmpty
8A6C                  9
8A6E                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0043                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8A6C  BD96B1                                  JSR     \1
                              ENDIF
8A6F  2759                            BEQ     assJmpBrkSyntax
8A71  2557                            BCS     assJmpBrkSyntax
8A73                                  CALL    pushVarPtrAndType
8A73                  9
8A75                  __XBSR                  SET 9B+2
2D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8A73  BDB7E8                                  JSR     \1
                              ENDIF
8A76                                  CALL    GetP_percent                    ;  Get P%
8A76                  9
8A78                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8A76  BDAA36                                  JSR     \1
                              ENDIF
8A79  9727                            STA     ZP_VARTYPE
8A7B                                  CALL    storeEvaledExpressioninStackedVarPTr
8A7B                  9
8A7D                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
003E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8A7B  BDAFBB                                  JSR     \1
                              ENDIF
                      ;;              CALL    copyTXTOFF2toTXTOFF
8A7E  DF4E                            STU     ZP_ASS_LBLEND           
8A80  0F39            assScanNextOp   CLR     ZP_ASS_OPLEN
8A82                                  CALL    skipSpacesY                     ; L89EB
8A82                  9
8A84                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0088                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8A82  BD8F0C                                  JSR     \1
                              ENDIF
8A85  335F                            LEAU    -1,U
8A87  0F3D                            CLR     ZP_FPB + 2                      ; clear opcode bits accumulator
8A89  813A                            CMPA    #':'
8A8B  276A                            BEQ     assScanEndOfStmt                ;  End of statement
8A8D  810D                            CMPA    #$0D
8A8F  2766                            BEQ     assScanEndOfStmt                ;  End of line
8A91  815C                            CMPA    #'\'
8A93  2762                            BEQ     assScanEndOfStmt                ;  Comment
8A95  812E                            CMPA    #'.'
8A97  27D1                            BEQ     assScanLabel                    ;  Label
8A99  8E0003                          LDX     #$03                            ;  Prepare to fetch three characters
8A9C                  assScanOpLoop                                           ; L8A06 
8A9C  A6C0                            LDA     ,U+             
8A9E  2B2D                            BMI     assScanTokFound                 ;  Token, check for tokenised AND, EOR, OR
8AA0  8120                            CMPA    #' '
8AA2  2711                            BEQ     assScanOpSkSpace                ;  Space, step past
8AA4  C605                            LDB     #$05
8AA6  48                              ASLA
8AA7  48                              ASLA
8AA8  48                              ASLA
8AA9  48              assScanOpLoop2  ASLA                                    ; L8A17
8AAA  093D                            ROL     ZP_FPB + 2                      ; roll 5 LSB's of opcode char into accum
8AAC  093E                            ROL     ZP_FPB + 3
8AAE  5A                              DECB
8AAF  26F8                            BNE     assScanOpLoop2
8AB1  301F                            LEAX    -1,X
8AB3  26E7                            BNE     assScanOpLoop
8AB5                  assScanOpSkSpace                                        ; L8A22
8AB5  8E0045                          LDX     #ASM_OPCOUNT                    ; 
8AB8  DC3D                            LDD     ZP_FPB + 2                      ; encoded opcode
8ABA                  assScanOpMatchLp
8ABA  A189899C                        CMPA    assOpMungeLowBytes-1,X
8ABE  2606                            BNE     1F
8AC0  E18989E1                        CMPB    assOpMungeHiBytes-1,X
8AC4  2722                            BEQ     assScanOpMatchFound
8AC6  301F            1               LEAX    -1,X
8AC8  26F0                            BNE     assScanOpMatchLp
8ACA                  assJmpBrkSyntax                                         ; L8A35
8ACA                                  JUMP     brkSyntax
8ACA  7E98B7                                  JMP     \1
                      
                      
8ACD                  assScanTokFound                                         ; L8A38
8ACD  8E0029                          LDX     #$29                            ;  opcode number for 'AND'
8AD0  8180                            CMPA    #tknAND
8AD2  2714                            BEQ     assScanOpMatchFound             ;  Tokenised 'AND'
8AD4  3001                            LEAX    1,X                             ;  opcode number for 'EOR'
8AD6  8182                            CMPA    #tknEOR
8AD8  270E                            BEQ     assScanOpMatchFound             ;  Tokenised 'EOR'
8ADA  3001                            LEAX    1,X
8ADC  8184                            CMPA    #tknOR                          ;  opcode number for 'ORA'
8ADE  26EA                            BNE     assJmpBrkSyntax                 ;  Not tokenised 'OR'
8AE0  A6C0                            LDA     ,U+                             ;  Get next character
8AE2  84DF                            ANDA    #$DF                            ;  Ensure upper case
8AE4  8141                            CMPA    #'A'                    
8AE6  26E2                            BNE     assJmpBrkSyntax                 ; Ensure 'OR' followed by 'A'
                      
                      
                                              ;  Tokenised opcode found
                                              ;  ----------------------
8AE8                  assScanOpMatchFound
8AE8  A6898A26                        LDA     assOpcodeBytes-1,X              ; get 6502 opcode byte
8AEC  9729                            STA     ZP_DUNNO                        ; store for later
8AEE  C601                            LDB     #$01                            ; length of opcode+postbytes
8AF0  D739                            STB     ZP_ASS_OPLEN                    ; store
8AF2  8C0020                          CMPX    #ASM_OPLASTIMPLIED + 1
8AF5  2442                            BHS     assProcessOpArgs
8AF7                  assScanEndOfStmt
8AF7  3420                            PSHS    Y                               ; L8A5E
8AF9  10BE0442                        LDY     VAR_P_PERCENT + 2
8AFD  109F37                          STY     ZP_GEN_PTR
8B00  9628                            LDA     ZP_OPT
8B02  8104                            CMPA    #$04
8B04  2504                            BLO     assSkNotOpt4                    ; check for OPT 4+
8B06  10BE043E                        LDY     VAR_O_PERCENT + 2               ; opt 4+ get O% into storage pointer
8B0A  109F3A          assSkNotOpt4    STY     ZP_ASS_OPSAVED
8B0D  8E0029                          LDX     #ZP_ASS_OPBUF                   ; source for the copy
8B10  D639                            LDB     ZP_ASS_OPLEN
8B12  2722                            BEQ     assSkNowtToStore
8B14  2A07                            BPL     assStoreLoop
8B16  D636                            LDB     ZP_STRBUFLEN                    ; i -ve then store a string...
8B18  8E0600                          LDX     #BASWKSP_STRING                 ; string buffer
8B1B  2719                            BEQ     assSkNowtToStore
8B1D                  assStoreLoop                                            ; L8A83
8B1D  A680                            LDA     ,X+
8B1F  A7A0                            STA     ,Y+
                      
8B21  7C0443                          INC     VAR_P_PERCENT + 3
8B24  2603                            BNE     1F
8B26  7C0442                          INC     VAR_P_PERCENT + 2
8B29  2408            1               BCC     assSkNotOpt4_2
8B2B  7C043F                          INC     VAR_O_PERCENT + 3
8B2E  2603                            BNE     assSkNotOpt4_2
8B30  7C043E                          INC     VAR_O_PERCENT + 2
8B33  5A              assSkNotOpt4_2  DECB
8B34  26E7                            BNE     assStoreLoop
                      
8B36                  assSkNowtToStore                                        ; L8AA5
8B36  3520                            PULS    Y                               ; restore Y
8B38  39                              RTS
8B39                  assProcessOpArgs                                        ; proccess opcode arguments
8B39  8C0029                          CMPX    #ASM_OPLASTBRA8 + 1
8B3C  2435                            BHS     assProcOpSkNotBxx
                      
                                      ; do Bxx branch instructions
                      
8B3E                                  CALL    evalForceINT
8B3E                  9
8B40                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B3E  BD9221                                  JSR     \1
                              ENDIF
8B41  DC2C                            LDD     ZP_INT_WA + 2
8B43  B30442                          SUBD    VAR_P_PERCENT + 2               ; subtract to get rel
8B46  830002                          SUBD    #2                              ; TODO CHECK - should this be 2?
8B49  1083007F                        CMPD    #$007F
8B4D  2E06                            BGT     assOutOfRange
8B4F  1083FF80                        CMPD    #$FF80
8B53  2C15                            BGE     assStorBxxOffset
8B55                  assOutOfRange                                           ; L8AC6
8B55  D628                            LDB     ZP_OPT
8B57  C402                            ANDB    #$02                            ; check to see if errors suppressed - if so store 0 in offset!
8B59  270F                            BEQ     assStorBxxOffset
8B5B                  brkOutOfRange
8B5B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8B5B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8B5C  014F7574206F662072616E676500                 FCB     $01, "Out of range", 0
8B6A                  assStorBxxOffset
8B6A  D72A                            STB     ZP_ASS_OPBUF + 1                ; store branch offset
                      
                      
8B6C                  ass2OpeLenScanEndOfStmt                                 ; L8AE1
8B6C  8602                            LDA     #2
8B6E  9739                            STA     ZP_ASS_OPLEN
8B70                                  JUMP    assScanEndOfStmt
8B70  7E8AF7                                  JMP     \1
                      
                      
8B73                  assProcOpSkNotBxx                                       ; L8AE6
8B73  8C0030                          CMPX    #ASM_OPASL+1
8B76  2416                            BHS     assProcOpASLtoINC
8B78                                  CALL    skipSpacesCheckHashAtY
8B78                  9
8B7A                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B78  BD8D42                                  JSR     \1
                              ENDIF
8B7B  2619                            BNE     assProcOpSkNotImmed             ; no # it's not an immed
8B7D                                  CALL    assOpcodeAdd8
8B7D                  9
8B7F                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B7D  BD8D31                                  JSR     \1
                              ENDIF
8B80                  assProcOpParseImmed                                     ; L8AF2
8B80                                  CALL    assEvalForceINT_LE
8B80                  9
8B82                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B80  BD8986                                  JSR     \1
                              ENDIF
8B83                  assProcOpStoreIntAsPostByte             
8B83  962B                            LDA     ZP_INT_WA + 1                   ; check to see if > 255
8B85                  ass2OpeLenScanEndOfStmtorBrkIfNE                
8B85  27E5                            BEQ     ass2OpeLenScanEndOfStmt
8B87                  brkByte                                                 ; L8AF9
8B87                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8B87  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8B88  024279746500                    FCB     $02, "Byte", 0
8B8E                  assProcOpASLtoINC                                       ; L8B00
8B8E  8C0041                          CMPX    #ASM_OPNUM_STA + 1
8B91  2667                            BNE     asmSkNotSTA
8B93                                  CALL    skipSpacesY
8B93                  9
8B95                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0077                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B93  BD8F0C                                  JSR     \1
                              ENDIF
8B96                  assProcOpSkNotImmed                                     ; L8B07
8B96  8128                            CMPA    #'('
8B98  263B                            BNE     asmSkNotIndirBrack
8B9A                                  CALL    assEvalForceINT_LE              ; get value
8B9A                  9
8B9C                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B9A  BD8986                                  JSR     \1
                              ENDIF
8B9D                                  CALL    skipSpacesY                     
8B9D                  9
8B9F                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B9D  BD8F0C                                  JSR     \1
                              ENDIF
8BA0  8129                            CMPA    #')'
8BA2  2619                            BNE     asmSkCheckIndirComma            
8BA4                                  CALL    assOpcodeAdd16                  ; is indirect, add 16 to opcode
8BA4                  9
8BA6                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BA4  BD8D2F                                  JSR     \1
                              ENDIF
8BA7                                  CALL    skipSpacesCheckCommaAtY
8BA7                  9
8BA9                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
009F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BA7  BD8D48                                  JSR     \1
                              ENDIF
8BAA  2706                            BEQ     asmSkPostIndexIndir     
8BAC  335F                            LEAU    -1,U
8BAE  0C29                            INC     ZP_ASS_OPBUF                    ; just indirect zp, inc opcode
8BB0  20D1                            BRA     assProcOpStoreIntAsPostByte     ; store post byte and continue
8BB2                  asmSkPostIndexIndir
8BB2                                  CALL    skipSpacesY
8BB2                  9
8BB4                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0058                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BB2  BD8F0C                                  JSR     \1
                              ENDIF
8BB5  84DF                            ANDA    #$DF                            ; to upper
8BB7  8159                            CMPA    #'Y'
8BB9  27C8                            BEQ     assProcOpStoreIntAsPostByte
8BBB  2010                            BRA     brkIndex
8BBD                  asmSkCheckIndirComma
8BBD  812C                            CMPA    #','
8BBF  260C                            BNE     brkIndex
8BC1                                  CALL    SkipSpaceCheckXAtY
8BC1                  9
8BC3                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0077                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BC1  BD8D3A                                  JSR     \1
                              ENDIF
8BC4  2607                            BNE     brkIndex
8BC6                                  CALL    skipSpacesY
8BC6                  9
8BC8                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BC6  BD8F0C                                  JSR     \1
                              ENDIF
8BC9  8129                            CMPA    #')'
8BCB  27B6                            BEQ     assProcOpStoreIntAsPostByte
8BCD                  brkIndex        DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8BCD  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8BCE  03496E64657800                  FCB     $03, "Index", 0
8BD5                  asmSkNotIndirBrack                                      ; L8B44
8BD5                                  CALL    assDecYEvalForceINT_LE
8BD5                  9
8BD7                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BD5  BD8984                                  JSR     \1
                              ENDIF
8BD8                                  CALL    skipSpacesCheckCommaAtY
8BD8                  9
8BDA                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
006E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BD8  BD8D48                                  JSR     \1
                              ENDIF
8BDB  2612                            BNE     assOpAdd4CheckIfZpOrAbs
8BDD                                  CALL    assOpcodeAdd16                  ; got a comma add 16 to op code for XXX,X or XXX,U
8BDD                  9
8BDF                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BDD  BD8D2F                                  JSR     \1
                              ENDIF
8BE0                                  CALL    SkipSpaceCheckXAtY
8BE0                  9
8BE2                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0058                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BE0  BD8D3A                                  JSR     \1
                              ENDIF
8BE3  270A                            BEQ     assOpAdd4CheckIfZpOrAbs                         
8BE5  8159                            CMPA    #'Y'                            ; so it should be a Y
8BE7  26E4                            BNE     brkIndex
8BE9                  assOpAdd8Len3                                           ; L8B58
8BE9                                  CALL    assOpcodeAdd8
8BE9                  9
8BEB                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0046                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BE9  BD8D31                                  JSR     \1
                              ENDIF
8BEC                                  JUMP    assScanEndOfStmtOpLen3
8BEC  7E8C96                                  JMP     \1
8BEF                  assOpAdd4CheckIfZpOrAbs                                 ; L8B5E
8BEF                                  CALL    assOpcodeAdd4
8BEF                  9
8BF1                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0042                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BEF  BD8D33                                  JSR     \1
                              ENDIF
8BF2                  assOpDecYCheckIfZpOrAbs                                 ; L8B61
                      
8BF2  335F                            LEAU    -1,U
8BF4                  assOpCheckIfZpOrAbs                                     ; L8B61
8BF4  962B                            LDA     ZP_INT_WA + 1
8BF6  26F1                            BNE     assOpAdd8Len3
8BF8  208B                            BRA     ass2OpeLenScanEndOfStmtorBrkIfNE
8BFA                  asmSkNotSTA                                             ; L8B67
8BFA  8C0036                          CMPX    #ASM_OPSTZ+1
8BFD  2434                            BHS     assSkHSSTZ                              ; HS opcode for STZ
8BFF                                  CALL    skipSpacesY
8BFF                  9
8C01                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BFF  BD8F0C                                  JSR     \1
                              ENDIF
8C02  84DF                            ANDA    #$DF
8C04  8141                            CMPA    #'A'                            ; check for ROLA etc
8C06  2712                            BEQ     assSkCheckXXX_A
8C08                  assSkNotXXX_A                                           ; L8B74
8C08                                  CALL    assDecYEvalForceINT_LE
8C08                  9
8C0A                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C08  BD8984                                  JSR     \1
                              ENDIF
8C0B                                  CALL    skipSpacesCheckCommaAtY
8C0B                  9
8C0D                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C0B  BD8D48                                  JSR     \1
                              ENDIF
8C0E  26E2                            BNE     assOpDecYCheckIfZpOrAbs         ; no comma, store as ZP or ABS
8C10                                  CALL    assOpcodeAdd16                  ; indexed
8C10                  9
8C12                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C10  BD8D2F                                  JSR     \1
                              ENDIF
8C13                                  CALL    SkipSpaceCheckXAtY              ; make sure its ,X!
8C13                  9
8C15                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0025                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C13  BD8D3A                                  JSR     \1
                              ENDIF
8C16  27DC                            BEQ     assOpCheckIfZpOrAbs             ; if it is we're off
8C18                  L8B84braBrkIndex
8C18  20B3                            BRA     brkIndex                        ; if not complain
8C1A                  assSkCheckXXX_A
8C1A  A6C4                            LDA     ,U                              ; check char after 'A'
8C1C                                  CALL    checkIsValidVariableNameChar    ; carry set if it's a variable char
8C1C                  9
8C1E                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C1C  BD8DDD                                  JSR     \1
                              ENDIF
8C1F  25E7                            BCS     assSkNotXXX_A                   ; looks like a variable name instead of A for register A
8C21  C616                            LDB     #$16                            ; opcode = INCA-4
8C23  8C0034                          CMPX    #ASM_OPDEC+1
8C26  2506                            BLO     skAssNotINCDEC
8C28  2602                            BNE     skAssNotDEC_A
8C2A  C636                            LDB     #$36                            ; opcode = DECA-4
8C2C  D729            skAssNotDEC_A   STB     ZP_ASS_OPBUF                    ; store modified code
8C2E                  skAssNotINCDEC
8C2E                                  CALL    assOpcodeAdd4
8C2E                  9
8C30                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C2E  BD8D33                                  JSR     \1
                              ENDIF
                      ;;              LDU     #$01                            ; set single byte op - not needed already set?
                      
8C31  2067                            BRA     L8C00jumpassScanEndOfStmt
8C33                  assSkHSSTZ
8C33  8C0038                          CMPX    #ASM_OPCPX + 1
8C36  2426                            BHS     assSkOpHS_CPX
                      
                                      ; do STZ 
                      
8C38                                  CALL    assEvalForceINT_LE
8C38                  9
8C3A                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C38  BD8986                                  JSR     \1
                              ENDIF
8C3B  C603                            LDB     #$03
8C3D  D739                            STB     ZP_ASS_OPLEN                    ; store len
8C3F  5A                              DECB                                    ; how much to add to opcode for ,X
8C40  962B                            LDA     ZP_INT_WA + 1
8C42  2608                            BNE     assSkSTZnotZP
8C44  C610                            LDB     #$10                            ; how much to add to opcode for ,X
8C46  8664                            LDA     #$64                            ; STZ d
8C48  9729                            STA     ZP_ASS_OPBUF                    ; store opcode
8C4A  0A39                            DEC     ZP_ASS_OPLEN
8C4C                  assSkSTZnotZP                                           ; L8BB7
8C4C                                  CALL    skipSpacesCheckCommaAtY
8C4C                  9
8C4E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C4C  BD8D48                                  JSR     \1
                              ENDIF
8C4F  2609                            BNE     assSkSTZnotIndex
8C51                                  CALL    SkipSpaceCheckXAtY
8C51                  9
8C53                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C51  BD8D3A                                  JSR     \1
                              ENDIF
8C54  26C2                            BNE     L8B84braBrkIndex
8C56  DB29                            ADDB    ZP_ASS_OPBUF                    ; correct opcode for $64 STZ d,X
8C58  D729                            STB     ZP_ASS_OPBUF
8C5A                  assSkSTZnotIndex                                        ; L8BC7
8C5A  335F                            LEAU    -1,U
8C5C  203C                            BRA     L8C00jumpassScanEndOfStmt
8C5E                  assSkOpHS_CPX
8C5E  8C003C                          CMPX    #ASM_OPBIT + 1
8C61  241E                            BHS     assSkHS_BIT
8C63  8C003A                          CMPX    #ASM_OPTSB+1
8C66  2407                            BHS     assSkTSB_TRB
                      
                                      ; do CPX/CPY
                      
8C68                                  CALL    skipSpacesCheckHashAtY
8C68                  9
8C6A                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C68  BD8D42                                  JSR     \1
                              ENDIF
8C6B  2711                            BEQ     assJumpProcOpParseImmed
8C6D  335F                            LEAU    -1,U
8C6F                  assSkTSB_TRB                                            ; L8BD9
8C6F                                  CALL    assEvalForceINT_LE
8C6F                  9
8C71                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0015                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C6F  BD8986                                  JSR     \1
                              ENDIF
8C72                  assBraOpAdd4CheckIfZpOrAbs                              ; L8BDC
8C72                                  JUMP    assOpAdd4CheckIfZpOrAbs
8C72  7E8BEF                                  JMP     \1
8C75                  assSkBIT                                                ; L8BDE
8C75                                  CALL    skipSpacesCheckHashAtY
8C75                  9
8C77                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C75  BD8D42                                  JSR     \1
                              ENDIF
8C78  268E                            BNE     assSkNotXXX_A
8C7A  C689                            LDB     #$89                            ; opcode for BIT #
8C7C  D729                            STB     ZP_DUNNO
8C7E                  assJumpProcOpParseImmed                                 ; L8BE7
8C7E                                  JUMP    assProcOpParseImmed
8C7E  7E8B80                                  JMP     \1
8C81                  assSkHS_BIT                                             ; L8BEA
8C81  27F2                            BEQ     assSkBIT
8C83  8C003E                          CMPX    #ASM_OPJSR + 1
8C86  270B                            BEQ     assSkJSR
8C88  2438                            BHS     assSkHI_JSR
                      
                                      ; jmp
                      
8C8A                                  CALL    skipSpacesY
8C8A                  9
8C8C                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C8A  BD8F0C                                  JSR     \1
                              ENDIF
8C8D  8128                            CMPA    #'('
8C8F  270C                            BEQ     assSkJMPIndir
8C91  335F                            LEAU    -1,U
8C93                  assSkJSR        CALL    assEvalForceINT_LE
8C93                  9
8C95                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C93  BD8986                                  JSR     \1
                              ENDIF
8C96                  assScanEndOfStmtOpLen3                                  ; L8BFE
8C96  C603                            LDB     #3
8C98  D739                            STB     ZP_ASS_OPLEN
8C9A                  L8C00jumpassScanEndOfStmt
8C9A                                  JUMP assScanEndOfStmt
8C9A  7E8AF7                                  JMP     \1
8C9D                  assSkJMPIndir
8C9D                                  CALL    assOpcodeAdd16
8C9D                  9
8C9F                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0090                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C9D  BD8D2F                                  JSR     \1
                              ENDIF
8CA0                                  CALL    assOpcodeAdd16
8CA0                  9
8CA2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CA0  BD8D2F                                  JSR     \1
                              ENDIF
8CA3                                  CALL    assEvalForceINT_LE
8CA3                  9
8CA5                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CA3  BD8986                                  JSR     \1
                              ENDIF
8CA6                                  CALL    skipSpacesY
8CA6                  9
8CA8                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CA6  BD8F0C                                  JSR     \1
                              ENDIF
8CA9  8129                            CMPA    #')'
8CAB  27E9                            BEQ     assScanEndOfStmtOpLen3
8CAD  812C                            CMPA    #','
8CAF  260E                            BNE     L8C26jmpbrkIndex
8CB1                                  CALL    assOpcodeAdd16
8CB1                  9
8CB3                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8CB1  8D7C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8CB3                                  CALL    SkipSpaceCheckXAtY
8CB3                  9
8CB5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0085                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CB3  BD8D3A                                  JSR     \1
                              ENDIF
8CB6  2607                            BNE     L8C26jmpbrkIndex
8CB8                                  CALL    skipSpacesY
8CB8                  9
8CBA                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0052                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CB8  BD8F0C                                  JSR     \1
                              ENDIF
8CBB  8129                            CMPA    #')'
8CBD  27D7                            BEQ     assScanEndOfStmtOpLen3
8CBF                  L8C26jmpbrkIndex
8CBF                                  JUMP    brkIndex
8CBF  7E8BCD                                  JMP     \1
8CC2                  assSkHI_JSR
8CC2  8C0044                          CMPX    #ASM_OPNUM_MAX+1
8CC5  2450                            BHS     assSkProcDirectives
8CC7  963D                            LDA     ZP_FPB + 2
8CC9  8801                            EORA    #$01
8CCB  841F                            ANDA    #$1F
8CCD  3402                            PSHS    A                               ; this now contains %000LI00X where 
                                                                              ; L = 1 for load, 0 for store
                                                                              ; I = 1 for X/U
                                                                              ; X = 1 for X, 0 for U
                                                                              ; I = 0, X = 0 for A
8CCF  8C0041                          CMPX    #ASM_OPNUM_STA+1
8CD2  2421                            BHS     assSkdoST_
8CD4                                  CALL    skipSpacesCheckHashAtY
8CD4                  9
8CD6                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8CD4  8D6C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8CD6  2604                            BNE     assSkdoLD_notImmed
8CD8  3261                            LEAS    1,S                             ; discard number from stack
8CDA  20A2                            BRA     assJumpProcOpParseImmed
8CDC                  assSkdoLD_notImmed                                      ; L8C40
8CDC                                  CALL    assDecYEvalForceINT_LE
8CDC                  9
8CDE                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CDC  BD8984                                  JSR     \1
                              ENDIF
8CDF  3502                            PULS    A
8CE1  9737                            STA     ZP_GEN_PTR
8CE3                                  CALL    skipSpacesCheckCommaAtY
8CE3                  9
8CE5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8CE3  8D63                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8CE5  268B                            BNE     assBraOpAdd4CheckIfZpOrAbs
8CE7                                  CALL    skipSpacesY
8CE7                  9
8CE9                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CE7  BD8F0C                                  JSR     \1
                              ENDIF
8CEA  841F                            ANDA    #$1F                            ; this contains the index, either X (18) or Y (19) (opposite of above)
8CEC  9137                            CMPA    ZP_GEN_PTR                      ; check LDX xxxx,Y or LDY xxxx,X
8CEE  26CF                            BNE     L8C26jmpbrkIndex
8CF0                                  CALL    assOpcodeAdd16
8CF0                  9
8CF2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8CF0  8D3D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8CF2                                  JUMP    assBraOpAdd4CheckIfZpOrAbs
8CF2  7E8C72                                  JMP     \1
8CF5                  assSkdoST_                                              ; L8C59
8CF5                                  CALL    assEvalForceINT_LE
8CF5                  9
8CF7                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CF5  BD8986                                  JSR     \1
                              ENDIF
8CF8  3502                            PULS    A                       
8CFA  9737                            STA     ZP_GEN_PTR
8CFC                                  CALL    skipSpacesCheckCommaAtY
8CFC                  9
8CFE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8CFC  8D4A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8CFE  2612                            BNE     assSkdoST_notIndex2
8D00                                  CALL    skipSpacesY
8D00                  9
8D02                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D00  BD8F0C                                  JSR     \1
                              ENDIF
8D03  841F                            ANDA    #$1F
8D05  9137                            CMPA    ZP_GEN_PTR
8D07  26B6                            BNE     L8C26jmpbrkIndex
8D09                                  CALL    assOpcodeAdd16
8D09                  9
8D0B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0024                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8D09  8D24                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8D0B  962B                            LDA     ZP_INT_WA + 1
8D0D  2705                            BEQ     assSkdoST_notIndex
8D0F                                  JUMP    brkByte
8D0F  7E8B87                                  JMP     \1
8D12                  assSkdoST_notIndex2
8D12  335F                            LEAU    -1,U            
8D14                  assSkdoST_notIndex                                      ; L8C77
8D14                                  JUMP assOpCheckIfZpOrAbs                        ; TODO: remove and use LBxx
8D14  7E8BF4                                  JMP     \1
8D17                  assSkProcDirectives
                                      ; OPT
8D17  260B                            BNE     assSkEQU
8D19                                  CALL    evalForceINT
8D19                  9
8D1B                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D19  BD9221                                  JSR     \1
                              ENDIF
8D1C  962D                            LDA     ZP_INT_WA + 3
8D1E  9728                            STA     ZP_OPT
8D20  0F39                            CLR     ZP_ASS_OPLEN
8D22  2008                            BRA     L8CB1jmpAssScanEndOfStmt
8D24                  assSkEQU
8D24                                  TODODEADEND "EQU"
8D24                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8D24  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8D25  7E443A                          FCB             $7E,"D:"
8D28  455155                          FCB             \1
8D2B  00                              FCB             0
                      ;               LDX #$01
                      ;               LDU ZP_TXTOFF
                      ;               INC ZP_TXTOFF
                      ;               LDA (ZP_TXTPTR),U
                      ;               AND #$DF
                      ;               CMP #$42
                      ;               BEQ L8CA7
                      ;               INX
                      ;               CMP #$57
                      ;               BEQ L8CA7
                      ;               LDX #$04
                      ;               CMP #$44
                      ;               BEQ L8CA7
                      ;               CMP #$53
                      ;               BEQ L8CB7
                      ;               JUMP brkSyntax
                      ;L8CA7:
                      ;               PHX
                      ;               CALL evalForceINT
                      ;               LDX #ZP_DUNNO
                      ;               CALL CopyIntA2ZPX
                      ;               PLY
8D2C                  L8CB1jmpAssScanEndOfStmt
8D2C                                  JUMP assScanEndOfStmt
8D2C  7E8AF7                                  JMP     \1
                      ;L8CB4:
                      ;               JUMP brkTypeMismatch
                      ;L8CB7:
                      ;               LDA ZP_OPT
                      ;               PHA
                      ;               CALL evalExpressionMAIN
                      ;               BNE L8CB4
                      ;               PLA
                      ;               STA ZP_OPT
                      ;               CALL copyTXTOFF2toTXTOFF
                      ;               LDU #$FF
                      ;               BRA L8CB1jmpAssScanEndOfStmt
8D2F                  assOpcodeAdd16                                          ; L8CC9
8D2F                                  CALL    assOpcodeAdd8
8D2F                  9
8D31                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8D2F  8D00                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8D31                  assOpcodeAdd8                                           ; L8CCC
8D31                                  CALL    assOpcodeAdd4
8D31                  9
8D33                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8D31  8D00                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8D33                  assOpcodeAdd4                                           ; L8CCF
8D33  9629                            LDA     ZP_DUNNO
8D35  8B04                            ADDA    #4
8D37  9729                            STA     ZP_DUNNO
8D39  39                              RTS
8D3A                  SkipSpaceCheckXAtY
8D3A                                  CALL    skipSpacesY
8D3A                  9
8D3C                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D3A  BD8F0C                                  JSR     \1
                              ENDIF
8D3D  84DF                            ANDA    #$DF
8D3F  8158                            CMPA    #'X'
8D41  39                              RTS
                              ELSE
                                      include "./assembler6x09.asm"
                              ENDIF
                      
8D42                  skipSpacesCheckHashAtY
8D42                                  CALL    skipSpacesY
8D42                  9
8D44                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D42  BD8F0C                                  JSR     \1
                              ENDIF
8D45  8123                            CMPA    #'#'
8D47  39                              RTS             
8D48                  skipSpacesCheckCommaAtY
8D48                                  CALL    skipSpacesY
8D48                  9
8D4A                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D48  BD8F0C                                  JSR     \1
                              ENDIF
8D4B  812C                            CMPA    #','
8D4D  39                              RTS
                      
8D4E                  skipSpacesCheckCommaAtYStepBack
8D4E                                  CALL    skipSpacesCheckCommaAtY
8D4E                  9
8D50                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8D4E  8DF8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8D50  2702            2               BEQ     1F
8D52  335F                            LEAU    -1,U
8D54  39              1               RTS             
8D55                  skipSpacesCheckHashAtYStepBack
8D55                                  CALL    skipSpacesCheckHashAtY
8D55                  9
8D57                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8D55  8DEB                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8D57  20F7                            BRA     2B
                      
                                      ; [ZP_GEN_PTR+2] <= A
                                      ; ZP_NAMELENORVT <= Y (last character CONSUMED i.e. before what is to be kept)
                                      ; Copy rest of line to ZP_GEN_PTR
                                      ; return with count of chars after token including $0d in B
                                      ; trashes A, X, Y
8D59                  storeTokenAndCloseUpLine
8D59  9E39                            LDX     ZP_GEN_PTR+2
8D5B  A780                            STA     ,X+
8D5D  5F                              CLRB
8D5E  5C              1               INCB
8D5F  A6C0                            LDA     ,U+
8D61  A780                            STA     ,X+             
8D63  810D                            CMPA    #$0D
8D65  26F7                            BNE     1B
8D67  DE39                            LDU     ZP_GEN_PTR+2
8D69  3341                            LEAU    1,U
8D6B  39                              RTS
                      
                      ;               CLC
                      ;               TYA
                      ;               ADC ZP_GEN_PTR
                      ;               STA ZP_NAMELENORVT
                      ;               LDU #$00
                      ;               TYA
                      ;               ADC ZP_GEN_PTR + 1
                      ;               STA ZP_NAMELENORVT + 1
                      
                      ;L8CFA:
                      ;               INY
                      ;               LDA (ZP_NAMELENORVT),Y
                      ;               STA (ZP_GEN_PTR),Y
                      ;               CMP #$0D
                      ;               BNE L8CFA
                      ;               RTS
                      
                                      ; on entry A contains a numeric digit
                                      ; parse number and store in ?????
                                      ; TODO, there may be a quicker / smaller way of doing this
                                      ; use shift and add instead of mul and add?
8D6C                  tokenizeLineNo  
8D6C  840F                            ANDA    #$0F
8D6E  973E                            STA     ZP_FPB + 3              ; low byte
8D70  0F3D                            CLR     ZP_FPB + 2              ; convert '0'-'9' to 0-9 and store as 16bit at ZP_FPB + 2       
                      
8D72  A6C0            tokLinLp        LDA     ,U+
8D74                                  CALL    checkIsNumeric
8D74                  9
8D76                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0077                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8D74  8D77                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8D76  2426                            BCC     tokLineNoSk1
8D78  840F                            ANDA    #$F
8D7A  9738                            STA     ZP_GEN_PTR+1
8D7C  0F37                            CLR     ZP_GEN_PTR+0            ; store as 16 bit no
                      
8D7E  963E                            LDA     ZP_FPB + 3              ; low byte * 10
8D80  C60A                            LDB     #10
8D82  3D                              MUL                             ; this cannot overflow or go minus so don't panic!
8D83  D337                            ADDD    ZP_GEN_PTR              ; add to current digit
8D85  2B14                            BMI     tokLinOv                ; overflowed
8D87  DD37                            STD     ZP_GEN_PTR              ; store 
                                      
8D89  963D            1               LDA     ZP_FPB + 2              ; mul old number hi byte by 10
8D8B  C60A                            LDB     #10
8D8D  3D                              MUL
8D8E  250B                            BCS     tokLinOv                ; top bit of B
8D90  4D                              TSTA                            ; or top byte of result
8D91  2608                            BNE     tokLinOv                ; causes overflow
8D93  1E89                            EXG     A,B                     ; now D = 256 * B 
8D95  D337            2               ADDD    ZP_GEN_PTR
8D97  DD3D                            STD     ZP_FPB + 2              ; store result
8D99  2AD7                            BPL     tokLinLp
8D9B                  tokLinOv
8D9B                                  SEC
8D9B  1A01                    ORCC    #CC_C
8D9D  39                              RTS                             ; unstack result
8D9E                  tokLineNoSk1                                    ; found end of number
8D9E  335F                            LEAU    -1,U                    ; point at char after last read digit
8DA0  868D                            LDA     #tknLineNo
8DA2                                  CALL    storeTokenAndCloseUpLine        ; B + ZP_GEN_PTR is end of line
8DA2                  9
8DA4                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8DA2  8DB5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8DA4  DE39                            LDU     ZP_GEN_PTR+2
8DA6  3043                            LEAX    3,U                             ; make space for line number and length (3)
8DA8  9F39                            STX     ZP_GEN_PTR+2
8DAA  5C                              INCB
8DAB  3A                              ABX
8DAC  4F                              CLRA                                    
8DAD  33CB                            LEAU    D,U                             ; point at end of strings + 1
                      ;L8D59:
8DAF                  1
8DAF  A6C2                            LDA     ,-U                     ; move end of line on 3 bytes and leave gap for rest of tokenized number
8DB1  A782                            STA     ,-X
8DB3  5A                              DECB
8DB4  26F9                            BNE     1B
                      ;L8D62: - when moving stuff to point here beware line number must be in ZP_FPB + 2,3 in bigendian, Y must point at byte before first of the three bytes
8DB6                  int16atZP_FPB2toBUFasTOKENIZED
8DB6  963D                            LDA     ZP_FPB + 2              ; see p.40 of ROM UG (note diagram is wrong see text)
8DB8  8A40                            ORA     #$40
8DBA  A743                            STA     3,U                     ; byte 3 = "01" & MSB[5 downto 0] 
8DBC  963E                            LDA     ZP_FPB + 3              ; lsb
8DBE  843F                            ANDA    #$3F
8DC0  8A40                            ORA     #$40
8DC2  A742                            STA     2,U                     ; byte 2 = "01" & MSB[5 downto 0] 
                      
8DC4  963E                            LDA     ZP_FPB + 3
8DC6  84C0                            ANDA    #$C0            
8DC8  973E                            STA     ZP_FPB + 3              ; mask off all but top two bits of LSB
                      
8DCA  963D                            LDA     ZP_FPB + 2
8DCC  84C0                            ANDA    #$C0
8DCE  44                              LSRA
8DCF  44                              LSRA
8DD0  9A3E                            ORA     ZP_FPB + 3
8DD2  44                              LSRA
8DD3  44                              LSRA
8DD4  8854                            EORA    #$54
8DD6  A741                            STA     1,U                     ; byte 1 = "01" & MSB[7 downto 6] & LSB[7 downto 6] & "00"
8DD8  3344                            LEAU    4,U                     ; pointer after tokenized number
8DDA                                  CLC
8DDA  1CFE                    ANDCC   #~CC_C
8DDC  39                              RTS
                      
                                      ; returns CY=1 if [_£a-zA-Z0-9]
8DDD                  checkIsValidVariableNameChar
8DDD  817B                            CMPA    #'z' + 1
8DDF  2416                            BCC     rtsL8D9A ; > z
8DE1  815F                            CMPA    #'_'
8DE3  2417                            BCC     setcarryRTS ; > ='_'
8DE5  815B                            CMPA    #'Z' + 1 
8DE7  240E                            BCC     rtsL8D9A ; > 'Z'
8DE9  8141                            CMPA    #'A'
8DEB  240F                            BCC     setcarryRTS
                      
                                      ; returns CY=1 if [0-9]
8DED  813A            checkIsNumeric  CMPA    #'9' + 1                        ; not difference to 6502 compares! TODO - change api for fewer jumps?
8DEF  2406                            BCC     rtsL8D9A                        ; >'9'  
8DF1  8130                            CMPA    #'0'
8DF3  2407                            BCC     setcarryRTS
8DF5                                  CLC
8DF5  1CFE                    ANDCC   #~CC_C
8DF7  39              rtsL8D9A        RTS
                      
8DF8                  checkIsDotOrNumeric
8DF8  812E                            CMPA    #'.'
8DFA  26F1                            BNE     checkIsNumeric
8DFC                  setcarryRTS     SEC
8DFC  1A01                    ORCC    #CC_C
8DFE  39                              RTS
                      
                      ;ZPPTR_GetCharIncPtr
                      ;               LDA     [ZP_GEN_PTR]
                      ;ZPPTR_Inc16                                            ; incremenet ptr and save
                      ;               LDX     ZP_GEN_PTR
                      ;               LEAX    1,X
                      ;               STX     ZP_GEN_PTR
                      ;1              RTS                     
                      ;
                      ;ZPPTR_IncThenGetNextChar
                      ;               CALL    ZPPTR_Inc16
                      ;               LDA     [ZP_GEN_PTR]
                      ;               RTS
                      
                      
                      ;                       ;  Tokenise line at $37/8
                      
8DFF                  toklp0          ;;LEAU  1,Y                             ;  Step past charac     ter
                      
8DFF                  tokenizeATY
8DFF  DF39                            STU     ZP_GEN_PTR+2                    ; where token will be stored
8E01                  toklp2
8E01  A6C0                            LDA     ,U+                             ;  Get current character
8E03  810D                            CMPA    #$0D
8E05  2724                            BEQ     rtsL8DDF                        ;  Exit with <cr>
8E07  8120                            CMPA    #' '
8E09  27F4                            BEQ     toklp0                          ;  Skip <spc>
8E0B  8126                            CMPA    #'&'
8E0D  260E                            BNE     tokNotAmper                     ;  Jump if not '&'
8E0F  A6C0            toklp1          LDA     ,U+                             ;  Get next character, check if it looks like HEX
8E11                                  CALL    checkIsNumeric                  ;  Is it a digit?
8E11                  9
8E13                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8E11  8DDA                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8E13  25FA                            BCS     toklp1                          ;  Loop back if a digit
8E15  8141                            CMPA    #'A'
8E17  24E8                            BCC     toklp2                          ;  Loop back if <'A'
8E19  8147                            CMPA    #'F' + 1
8E1B  24F2                            BCC     toklp1                          ;  Step to next if 'A'..'F'
8E1D  8122            tokNotAmper     CMPA    #'"'
8E1F  260B                            BNE     tokNotQuot                      ;  Not quote,
8E21  A6C0            tokQuotLp       LDA     ,U+                             ;  Get next character
8E23  8122                            CMPA    #'"'
8E25  27D8                            BEQ     toklp0                          ;  Jump back if closing quote
8E27  810D                            CMPA    #$0D
8E29  26F6                            BNE     tokQuotLp                       ;  Loop until <cr> or quote
8E2B  39              rtsL8DDF        RTS
                      
8E2C  813A            tokNotQuot      CMPA    #':'
8E2E  2606                            BNE     tokNotColon
                                      
8E30  0F3B            L8DE7           CLR     ZP_FPB                          ; start of statement - don't expect line num
8E32  0F3C            L8DE9           CLR     ZP_FPB + 1                      
8E34  20CB                            BRA     toklp2
                      
                      
8E36                  tokNotColon
8E36  812C                            CMPA    #','
8E38  27C5                            BEQ     toklp0                          ; if comma carry on
8E3A  812A                            CMPA    #'*'
8E3C  260C                            BNE     tokNotStar
8E3E  0D3B                            TST     ZP_FPB
8E40  27E9                            BEQ     rtsL8DDF                        ; if a * and ZP_FPB==0 return (OSCLI at start of stmt?)
                      
8E42  C6FF            tokNotKeyword   LDB     #$FF
8E44  D73B                            STB     ZP_FPB
8E46  0F3C                            CLR     ZP_FPB + 1
8E48  20B5                            BRA     toklp0
                      
8E4A  812E            tokNotStar      CMPA    #'.'
8E4C  270D                            BEQ     tokDot
8E4E                                  CALL    checkIsNumeric
8E4E                  9
8E50                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8E4E  8D9D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8E50  2425                            BCC     tokNotNum
8E52  0D3C                            TST     ZP_FPB + 1
8E54  2705                            BEQ     tokDot
8E56                                  CALL    tokenizeLineNo
8E56                  9
8E58                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E56  BD8D6C                                  JSR     \1
                              ENDIF
8E59  24A4                            BCC     toklp0
                      
8E5B  A6C0            tokDot          LDA     ,U+
8E5D                                  CALL    checkIsDotOrNumeric
8E5D                  9
8E5F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8E5D  8D99                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8E5F  25FA                            BCS     tokDot
8E61                  tokNextSetFlag0_FF
                      ;L8E1F
8E61  335F                            LEAU    -1,U
8E63  86FF            1               LDA     #$FF
8E65  973B                            STA     ZP_FPB
8E67  20C9                            BRA     L8DE9
                      
8E69                  tokNotKey2                                       ; is it a variable? if so skip over it...
8E69                                  CALL    checkIsValidVariableNameChar
8E69                  9
8E6B                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0072                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E69  BD8DDD                                  JSR     \1
                              ENDIF
8E6C  24D4                            BCC     tokNotKeyword
                      ;L8E2A
8E6E                  tokNotKey_SkipVarName
8E6E  A6C0                            LDA     ,U+
8E70                                  CALL    checkIsValidVariableNameChar
8E70                  9
8E72                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E70  BD8DDD                                  JSR     \1
                              ENDIF
8E73  24EC                            BCC     tokNextSetFlag0_FF
8E75  20F7                            BRA     tokNotKey_SkipVarName
8E77                  tokNotNum
8E77  8141                            CMPA    #'A'
8E79  25C7                            BLO     tokNotKeyword           ; if <'A'
8E7B  8157                            CMPA    #'W'                    
8E7D  22EA                            BHI     tokNotKey2              ; of >='X'
8E7F  8E8174                          LDX     #tblTOKENS
8E82  335F                            LEAU    -1,U
8E84  DF39                            STU     ZP_GEN_PTR+2
8E86                  tokKeyCmp
8E86  DE39                            LDU     ZP_GEN_PTR+2                    ; reset buffer pointer
                      ;L8E46:
8E88  A6C0                            LDA     ,U+                             ; start again with first char in A
8E8A  A180                            CMPA    ,X+                             
8E8C  25E0                            BLO     tokNotKey_SkipVarName           ; < tok char lt treat as variable name TODO: we already skipped a lot of the variable but that get wasted here
8E8E  260E                            BNE     tokSkipEndTryNext
                      ;L8E4E:
8E90                  tokKeyCmpLp
8E90  A680                            LDA     ,X+
8E92  2B1E                            BMI     tokKeyFound
8E94  A1C0                            CMPA    ,U+
8E96  27F8                            BEQ     tokKeyCmpLp
8E98  A65F                            LDA     -1,U
8E9A  812E                            CMPA    #'.'
8E9C  270A                            BEQ     tokKeyAbbrev
                      
8E9E                  tokSkipEndTryNext                                       ;L8E5D:
8E9E  A680                            LDA     ,X+
8EA0  2AFC                            BPL     tokSkipEndTryNext
8EA2  81FE                            CMPA    #tknWIDTH
8EA4  2608                            BNE     tokMoveNextTkn                  ; not the last one, increment pointer and carry on
8EA6  20C6                            BRA     tokNotKey_SkipVarName           
                      
8EA8                  tokKeyAbbrev                                            ;L8E68:
8EA8                  tokKeyAbbrevLp1                                         ;L8E69:
8EA8  A680                            LDA     ,X+                             ; skip to end of keyword, increasing X
8EAA  2B06                            BMI     tokKeyFound
8EAC  20FA                            BRA     tokKeyAbbrevLp1
8EAE                  tokMoveNextTkn                                          ;L8E75:
8EAE  3001                            LEAX    1,X                             ; move X past token and flags
                                                                              ;L8E80: (not used was a skip for add hi byte)
8EB0  20D4                            BRA     tokKeyCmp
8EB2                  tokKeyFound                                             ;L8E84:
8EB2  1F89                            TFR     A,B                             ; store token in B (TODO - use A and save a couple of swaps)
8EB4  A684                            LDA     ,X                              ; get flags in A
8EB6  973D                            STA     ZP_FPB + 2                      ; store flags
8EB8  8501                            BITA    #TOK_FLAG_CONDITIONAL                                   
8EBA  2707                            BEQ     tokKeyFound2                    ; if flags[0]='0' we've got a full keyword
8EBC  A6C4                            LDA     ,U                              ; if not check if next is a valid variable char
8EBE                                  CALL    checkIsValidVariableNameChar    
8EBE                  9
8EC0                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8EBE  BD8DDD                                  JSR     \1
                              ENDIF
8EC1  25AB                            BCS     tokNotKey_SkipVarName           ; and we have a variable name char treat it as such and skip to
                                                                              ; end of variable
8EC3                  tokKeyFound2                                            ;L8E95
8EC3  963D                            LDA     ZP_FPB + 2
8EC5  8540                            BITA    #TOK_FLAG_PSEUDO_VAR
8EC7  2706                            BEQ     tokNOTPSEUDO
8EC9  0D3B                            TST     ZP_FPB
8ECB  2602                            BNE     tokNOTPSEUDO
8ECD  CB40                            ADDB    #$40                            ; at start of line and a PSEUDO var then add $40 to token?!
8ECF                  tokNOTPSEUDO    ;L8EA0
8ECF  1F98                            TFR     B, A
8ED1                                  CALL    storeTokenAndCloseUpLine        ; attention check regs trashed
8ED1                  9
8ED3                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8ED1  BD8D59                                  JSR     \1
                              ENDIF
8ED4  963D                            LDA     ZP_FPB + 2
8ED6  8502                            BITA    #TOK_FLAG_NEXT_MID
8ED8  2706                            BEQ     tokNOTNEXTMID
8EDA  C6FF                            LDB     #$FF
8EDC  D73B                            STB     ZP_FPB
8EDE  0F3C                            CLR     ZP_FPB + 1
8EE0                  tokNOTNEXTMID                                           ;L8EB0:
8EE0  8504                            BITA    #TOK_FLAG_NEXT_START
8EE2  2704                            BEQ     tokNOTNEXTSTART
8EE4  0F3B                            CLR     ZP_FPB
8EE6  0F3C                            CLR     ZP_FPB + 1
8EE8                  tokNOTNEXTSTART                                         ;L8EB7:
8EE8  8508                            BITA    #TOK_FLAG_FNPROC
8EEA  270F                            BEQ     tokSkipNotFNPROC
8EEC  DE39                            LDU     ZP_GEN_PTR+2            
8EEE  3341                            LEAU    1,U
8EF0                  tokSkipPROCNAMElp                                       ;L8EBD:                                 
8EF0  A6C0                            LDA     ,U+
8EF2                                  CALL    checkIsValidVariableNameChar
8EF2                  9
8EF4                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8EF2  BD8DDD                                  JSR     \1
                              ENDIF
8EF5  25F9                            BCS     tokSkipPROCNAMElp
                                                                              ;L8EC9:
8EF7  335E                            LEAU    -2,U
8EF9  DF39                            STU     ZP_GEN_PTR+2                    ; now pointing at last char of name
                                      
8EFB                  tokSkipNotFNPROC                        ;L8ECA:
8EFB  963D                            LDA     ZP_FPB + 2
8EFD  8510                            BITA    #TOK_FLAG_NEXTLINENO
8EFF  2702                            BEQ     tokNotNEXTLINENO
8F01  D73C                            STB     ZP_FPB + 1                      ; FF
8F03                  tokNotNEXTLINENO        ;L8ECF:
8F03  8520                            BITA    #TOK_FLAG_SKIP_EOL
8F05  260B                            BNE     anRTS7
8F07                                  JUMP    toklp0
8F07  7E8DFF                                  JMP     \1
                      
                      ;               
                      ;               ;  Skip spaces at PTRB
                      ;               ;  ===================
                                      ;  leaves PTR unchanged returns next non white pointer + 1 in Y, char in A
8F0A                  skipSpacesPTRB
8F0A  DE19                            LDU     ZP_TXTPTR2
8F0C                  skipSpacesY                
8F0C  A6C0                            LDA     ,U+
8F0E  8120                            CMPA    #' '
8F10  27FA                            BEQ     skipSpacesY
8F12  39              anRTS7          RTS
                      
8F13                  inySkipSpacesYStepBack
8F13  3341                            LEAU    1,U
8F15                  skipSpacesYStepBack
8F15                                  CALL    skipSpacesY
8F15                  9
8F17                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8F15  8DF5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8F17  335F                            LEAU    -1,U
8F19  39                              RTS
                      
                      ;               
                      ;               ;  Skip spaces at PTRA
                      ;               ;  ===================
                                      ;  leaves PTR unchanged returns next non white pointer + 1 in Y, char in A
8F1A                  skipSpacesPTRA
8F1A  DE0B                            LDU     ZP_TXTPTR
8F1C  20EE                            BRA     skipSpacesY
                      
                      ;               
                      ;                       ;  Expect comma
                      ;                       ;  ============
8F1E                  skipSpacesCheckCommaAtYOrBRK
8F1E                                  CALL    skipSpacesCheckCommaAtY
8F1E                  9
8F20                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0028                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F1E  BD8D48                                  JSR     \1
                              ENDIF
8F21  27EF                            BEQ     anRTS7                  ;  Comma found, return
8F23                  brkMissingComma
8F23                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8F23  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8F24  058D2C00                        FCB     $05, tknMissing, ',', 0
8F28                  cmdCHAIN                ; L8EFB
                      
8F28                                  CALL    loadProg2Page
8F28                  9
8F2A                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F28  BDB930                                  JSR     \1
                              ENDIF
8F2B  2013                            BRA     L8F15
8F2D                  cmdOLD                  ; L8F00
                                              ;  OLD
8F2D                                  CALL    scanNextStmtFromY
8F2D                  9
8F2F                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F2D  BD98F4                                  JSR     \1
                              ENDIF
8F30  9618                            LDA     ZP_PAGE_H
8F32  C601                            LDB     #1
8F34  1F01                            TFR     D,X
8F36  6F84                            CLR     ,X
8F38                                  CALL    findTOP
8F38                  9
8F3A                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0005                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F38  BDB93F                                  JSR     \1
                              ENDIF
8F3B  202F                            BRA     resetVarsImmedPrompt
8F3D                  cmdRUN
                                              
                      ;                       ;  RUN
8F3D                                  CALL    scanNextStmtFromY
8F3D                  9
8F3F                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F3D  BD98F4                                  JSR     \1
                              ENDIF
8F40                  L8F15
8F40                                  CALL    ResetVars
8F40                  9
8F42                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F40  BDB770                                  JSR     \1
                              ENDIF
8F43  9618                            LDA     ZP_PAGE_H
8F45  5F                              CLRB
8F46  DD0B                            STD     ZP_TXTPTR
8F48  2035                            BRA     runFromZP_TXTPTR
8F4A                  cmdLOAD
8F4A                                  CALL    loadProg2Page
8F4A                  9
8F4C                  __XBSR                  SET 9B+2
2900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F4A  BDB930                                  JSR     \1
                              ENDIF
8F4D  201D                            BRA     resetVarsImmedPrompt
8F4F                  cmdEND                  ; L8F25!
8F4F                                  CALL    scanNextStmtFromY
8F4F                  9
8F51                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F4F  BD98F4                                  JSR     \1
                              ENDIF
8F52                                  CALL    findTOP
8F52                  9
8F54                  __XBSR                  SET 9B+2
2900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F52  BDB93F                                  JSR     \1
                              ENDIF
8F55  2018                            BRA     immedPrompt
                      
                      
                      
8F57                  reset_prog_enter_immedprompt
                                      ;TODO !!!!!!!!!!!!!!!!!!!!!!! FOR TESTING ONLY
                      *               LDD     #$00F2          ; get bytes $f2,f3 from host proc (command pointer)
                      *               LBSR    retD16asUINT_LE
                      *               LBSR    callOSWORD5INT_WA
                      *               TFR     A,B
                      *               LBSR    callOSWORD5INT_WA
                      *               EXG     B,A             ; little endian!
                      *               STD     ZP_INT_WA       ; zp_int_wa points at end of command tail in host proc
                      *               LDB     #$14
                      *1              DECB
                      *               LBEQ    cmdNEW2
                      *               LBSR    callOSWORD5INT_WA
                      *               CMPA    #$0D
                      *               BEQ     cmdNEW2
                      *               CMPA    #'@'
                      *               BNE     1B
                      *               LBSR    callOSWORD5INT_WA
                      *               CMPA    #$0D            
                      *               BNE     cmdNEW2
8F57                                  CALL    deleteProgSetTOP
8F57                  9
8F59                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F57  BDBA44                                  JSR     \1
                              ENDIF
                      
                                      ; dom bodge
8F5A  0F20                            CLR     ZP_TRACE
                      
8F5C                                  CALL    findTOP
8F5C                  9
8F5E                  __XBSR                  SET 9B+2
2900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F5C  BDB93F                                  JSR     \1
                              ENDIF
                      
8F5F  CE0700          1               LDU #BAS_InBuf
8F62  DF0B                            STU ZP_TXTPTR
8F64  2006                            BRA resetVarsImmedPrompt
                      ;;2             LDA [ZP_LOMEM]
                      ;;              BEQ resetVarsImmedPrompt
                      ;;              STA ,Y+
                      ;;              BEQ cmdNEW2
                      ;;              INC ZP_LOMEM + 1
                      ;;              BNE 1F
                      ;;              INC ZP_LOMEM
                      ;;1             CMPA #$0D
                      ;;              BNE 2B
                      ;;              LDA ZP_LOMEM
                      ;;              CMPA ZP_HIMEM
                      ;;              BCS resetVarsImmedPrompt
                      ;;              CALL tokenizeAndStore
                      ;;              BRA 1B
8F66                  cmdNEW                                                                  ;  NEW
8F66                                  CALL    scanNextStmtFromY
8F66                  9
8F68                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
008C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F66  BD98F4                                  JSR     \1
                              ENDIF
8F69                  cmdNEW2
8F69                                  CALL    deleteProgSetTOP
8F69                  9
8F6B                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F69  BDBA44                                  JSR     \1
                              ENDIF
8F6C                  resetVarsImmedPrompt
8F6C                                  CALL    ResetVars
8F6C                  9
8F6E                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F6C  BDB770                                  JSR     \1
                              ENDIF
                      
                      
8F6F  CE0700          immedPrompt     LDU     #BAS_InBuf
8F72  DF0B                            STU     ZP_TXTPTR                       ;  PtrA = BAS_InBuf - input buffer
8F74                                  CALL    ONERROROFF;                     ;  ON ERROR OFF
8F74                  9
8F76                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F74  BDAF35                                  JSR     \1
                              ENDIF
8F77  863E                            LDA     #'>'
8F79  BDFFEE                          JSR     OSWRCH                  ;  Print '>' prompt
                      
8F7C                                  CALL    ReadKeysTo_InBuf                        ;  Read input to buffer at BAS_InBuf
8F7C                  9
8F7E                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0026                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F7C  BDB6A4                                  JSR     \1
                              ENDIF
                                      
8F7F                  runFromZP_TXTPTR                                                ; L8F97
8F7F                                  RESET_MACH_STACK                
8F7F  10CE0200                                LDS     #MACH_STACK_TOP
8F83                                  CALL    ONERROROFF                              ;  Clear machine stack, ON ERROR OFF
8F83                  9
8F85                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F83  BDAF35                                  JSR     \1
                              ENDIF
8F86                                  CALL    tokenizeAndStore
8F86                  9
8F88                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F86  BDB6EA                                  JSR     \1
                              ENDIF
8F89  25E1                            BCS     resetVarsImmedPrompt                    ;  Tokenise, enter into program, loop back if program line
8F8B                                  JUMP    execImmediateLine                       ;  Jump to execute immediate line
8F8B  7E9000                                  JMP     \1
                      
8F8E                  doOSCLIAtY                                                    ; L8FA4
8F8E  30C4                            LEAX    ,U
8F90  3440                            PSHS    U
8F92  BDFFF7                          JSR     OSCLI
8F95  3540                            PULS    U
                      ;                       ;  DATA, DEF,   ;
                      ;                       ;  ==============
8F97                  cmdREM
8F97  860D                            LDA     #$0D
8F99                  1                                                       ; L8FB3:
8F99  A1C0                            CMPA    ,U+
8F9B  26FC                            BNE     1B                              ;  Loop until found <cr>
                                                                              ;L8FB8:
8F9D  335F                            LEAU    -1,U
8F9F  DF0B                            STU     ZP_TXTPTR
8FA1  2004                            BRA     stepNextLineOrImmedPrompt       ;  Update line pointer, step to next line
8FA3                  skipToNextLineOrImmedPrompt                             ; L8FBD
8FA3  810D                            CMPA    #$0D
8FA5  26F0                            BNE     cmdREM                          ;  Step to end of line
8FA7                  stepNextLineOrImmedPrompt
8FA7  960B                            LDA     ZP_TXTPTR
8FA9  8107                            CMPA    #BAS_InBuf / 256
8FAB  27C2                            BEQ     immedPrompt
8FAD  A641                            LDA     1,U                             ; if next line number top but end of prog
8FAF  2BBE                            BMI     immedPrompt
8FB1  9620                            LDA     ZP_TRACE
8FB3  2707                            BEQ     skNoTRACE
8FB5  EC41                            LDD     1,U
8FB7  DD2C                            STD     ZP_INT_WA + 2
8FB9                                  CALL    doTRACE
8FB9                  9
8FBB                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8FB9  BD9965                                  JSR     \1
                              ENDIF
8FBC                  skNoTRACE                                               ;L8FDB:
8FBC  3344                            LEAU    4,U                             ; skip over $d,line num,len to first token
8FBE  DF0B                            STU     ZP_TXTPTR
8FC0  2028                            BRA     skipSpacesAtYexecImmed
8FC2                  enterAssembler                                          ;L8FE1:
8FC2  8603                            LDA     #$03
8FC4  9728                            STA     ZP_OPT
8FC6                                  JUMP    assScanEnter                    ; enter assembler scanner, default OPT=3
8FC6  7E88C7                                  JMP     \1
8FC9                  scanTryStarAssEXTEq                                     ; L8FEB
8FC9  A65F                            LDA     -1,U
8FCB  812A                            CMPA    #'*'
8FCD  27BF                            BEQ     doOSCLIAtY
8FCF  815B                            CMPA    #'['
8FD1  27EF                            BEQ     enterAssembler
8FD3  81A2                            CMPA    #tknEXT
8FD5  10272A1B                        LBEQ    cmdEXTEq
8FD9  813D                            CMPA    #'='
8FDB  275E                            BEQ     cmdEquals
8FDD                  decYGoScanNextContinue                                  ; L9000
8FDD  335F                            LEAU  -1,U
8FDF                  scanNextContinue                                        ; L9002
8FDF                                  CALL    scanNextStmtFromY               ;  Return to execution loop
8FDF                  9
8FE1                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8FDF  BD98F4                                  JSR     \1
                              ENDIF
8FE2                  continue                                                ; L9005
8FE2  A6C4                            LDA     ,U
8FE4  813A                            CMPA    #':'
8FE6  26BB                            BNE     skipToNextLineOrImmedPrompt
8FE8                  incYskipSpacesAtYexecImmed                              ; L900B         
8FE8  3341                            LEAU    1,U
8FEA                  skipSpacesAtYexecImmed                                  ; L900D
8FEA                                  CALL    skipSpacesY
8FEA                  9
8FEC                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8FEA  BD8F0C                                  JSR     \1
                              ENDIF
8FED  813A                            CMPA    #':'            
8FEF  27F9                            BEQ     skipSpacesAtYexecImmed          ;  Skip spaces and ':'
8FF1  81CF                            CMPA    #tknPTRc
8FF3  2512                            BLO     execTryVarAssign                ;  Not command token, try variable assignment
                      ;               
                      ;                       ;  Dispatch function/command
                      ;                       ;  -------------------------
8FF5                  exeTokenInA                                             ;L9019:         TODO: move command table and make relative jump
8FF5  808E                            SUBA    #tknOPENIN                      ; first token
8FF7  1F89                            TFR     A,B
8FF9  58                              ASLB                                    ; mul by two
8FFA  8E87DD                          LDX     #tblCmdDispatch
8FFD  3A                              ABX
8FFE                                  JUMP    [,X]            ;  Index into dispatch table and jump to routine
8FFE  6E94                                    JMP     \1
                      ;               
                      ;                       ;  Command entered at immediate prompt
                      ;                       ;  -----------------------------------
9000                  execImmediateLine                       ;L901E:
9000                                  CALL    skipSpacesPTRA                  ;  Skip spaces at PtrA
9000                  9
9002                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0018                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9000  BD8F1A                                  JSR     \1
                              ENDIF
9003  81C6                            CMPA    #tknAUTO
9005  24EE                            BHS     exeTokenInA                     ;  If command token, jump to execute command
                                              
                      ;                       ;  Not command token, try variable assignment
9007                  execTryVarAssign                                        ; L9025
9007  305F                            LEAX    -1,U
9009  9F19                            STX     ZP_TXTPTR2
900B                                  CALL    findVarAtYMinus1
900B                  9
900D                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
900B  BD9703                                  JSR     \1
                              ENDIF
900E  261B                            BNE     assignVarAtZP_INT_WA            ;  Look up variable, jump if exists to assign new value
9010  25B7                            BCS     scanTryStarAssEXTEq                             ;  Invalid variable name, try =, [, *, EXT commands
                      
                      ;                       ;  Variable doesn't exist, create it
                      ;                       ;  ---------------------------------
9012                                  CALL    skipToEqualsOrBRKY              ; Check for and step past '='
9012                  9
9014                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9012  BD98D6                                  JSR     \1
                              ENDIF
9015                                  CALL    allocVAR                        ; Create new variable
9015                  9
9017                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
004C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9015  BD9663                                  JSR     \1
                              ENDIF
9018  8605                            LDA     #$05                            ; Prepare B=5
901A  912A                            CMPA    ZP_INT_WA + 0                   
901C  2601                            BNE     varAss_sk1
901E  4C                              INCA            ;                       ;  Use X=6
901F                  varAss_sk1                                              ;L9045
901F                                  CALL    AllocVarSpaceOnHeap             ;  Allocate space for variable
901F                  9
9021                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
901F  BD9695                                  JSR     \1
                              ENDIF
9022  DE19                            LDU     ZP_TXTPTR2
                      ;                       ;  LET <var> = <expression>
                      ;                       ;  ========================
9024                  cmdLET
                      
9024                                  CALL    findVarOrAllocEmpty
9024                  9
9026                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
008B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9024  BD96B1                                  JSR     \1
                              ENDIF
9027  1027088C                        LBEQ    brkSyntax                       ; Find and create variable, error if invalid name
902B                  assignVarAtZP_INT_WA                                    ; L904F         
902B  2421                            BCC     cmdSetVarNumeric                ;  CC - jump to assign numeric value
902D                                  CALL    stackINT_WAasINT
902D                  9
902F                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
902D  BDB7DA                                  JSR     \1
                              ENDIF
9030                                  CALL    skipSpacesExpectEqEvalExp       ;  Stack IntA, step past '=' and evaluate expression
9030                  9
9032                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9030  BD98A6                                  JSR     \1
                              ENDIF
9033  9627                            LDA     ZP_VARTYPE
9035  2634                            BNE     brkTypeMismatch                 ;  If not string, Type mismatch
9037                                  CALL    copyStringToVar
9037                  9
9039                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9037  8D4C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9039  20A7                            BRA     continue                        ;  Copy string result to string variable, return to execution loop
                      ;               
                      ;               ;  =<expression> - return from function
                      ;               ;  ====================================
903B                  cmdEquals
903B  118C01FB                        CMPS    #MACH_STACK_TOP - 5
903F  2423                            BHS     brkNoFN                 ;  Stack empty, not in a function
9041  B601FD                          LDA     MACH_STACK_TOP - 3
9044  81A4                            CMPA    #tknFN
9046  261C                            BNE     brkNoFN                 ;  No FN token, not in a function
9048                                  CALL    evalExpressionMAIN
9048                  9
904A                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9048  BD9A41                                  JSR     \1
                              ENDIF
904B                                  JUMP    scanNextStmtFromY                       ;  Evaluate expression, pop program pointer and continue execution
904B  7E98F4                                  JMP     \1
                      
                      
                      ;                       ;  <numvar>=<numeric>
                      ;                       ;  ------------------
904E                  cmdSetVarNumeric
904E  9E2C                            LDX     ZP_INT_WA + 2
9050  962A                            LDA     ZP_INT_WA + 0
9052  3412                            PSHS    A,X
9054                                  CALL    skipSpacesExpectEqEvalExp       ;  Step past '=' and evalute expression
9054                  9
9056                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9054  BD98A6                                  JSR     \1
                              ENDIF
9057                                  CALL    storeEvaledExpressioninStackedVarPTr
9057                  9
9059                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9057  BDAFBB                                  JSR     \1
                              ENDIF
905A                                  JUMP    continue                        ;  Copy numeric value to variable, return to execution loop
905A  7E8FE2                                  JMP     \1
                      
                      
905D                  cmdSTOP
                      
905D                                  CALL    scanNextStmtFromY               ;  Check end of statement
905D                  9
905F                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0095                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
905D  BD98F4                                  JSR     \1
                              ENDIF
9060                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9060  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9061  00FA00                          FCB     $00, tknSTOP, 0
9064                  brkNoFN
9064                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9064  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9065  074E6F20A400                    FCB  $07, "No ", tknFN, 0
906B                  brkTypeMismatch
906B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
906B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
906C  0654797065206D69736D6174636800                 FCB  $06, "Type mismatch", 0
907B                  brkNoRoom
907B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
907B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
907C  004E6F20726F6F6D00                 FCB  $00, "No room", 0
                      ;               
                      ;               ;  Copy string value to string variable
                      ;               ;  ------------------------------------
9085                  copyStringToVar CALL    popIntANew                      ;  Pop IntA which points to String Parameter Block
9085                  9
9087                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9085  BDB86C                                  JSR     \1
                              ENDIF
9088                  copyStringToVar2                                        ; L90AE
9088  3440                            PSHS    U
908A  962A                            LDA     ZP_INT_WA + 0
908C  8180                            CMPA    #$80
908E  2754                            BEQ     indStringStore                  ;  Type = $80, $<addr>=<string>, jump to store directly
9090  DE2C                            LDU     ZP_INT_WA + 2
9092  A642                            LDA     2,U                             ;  Get maximum string size
9094  9136                            CMPA    ZP_STRBUFLEN
9096  2436                            BHS     L910E                   ;  Longer than string to store, so store it
9098  DC02                            LDD     ZP_VARTOP
909A  DD2C                            STD     ZP_INT_WA + 2           ;  Copy VARTOP to $2C/D as addr of new string block
909C  9636                            LDA     ZP_STRBUFLEN
909E  8108                            CMPA    #$08
90A0  2506                            BLO     L90D0                   ; If new length<8, jump to use it
90A2  8B08                            ADDA    #$08                    ; else ADD 8 for luck!
90A4  2402                            BCC     L90D0                   ; If new length<256, use it
90A6  86FF                            LDA     #$FF                    ; Otherwise, use 255 bytes
90A8  3402            L90D0           PSHS    A                       ; Save string length to use
90AA  AEC4                            LDX     ,U                      ; get current string pointer
90AC  E642                            LDB     2,U                     ; get current string space
90AE  3A                              ABX
90AF  9C02                            CMPX    ZP_VARTOP
90B1  2604                            BNE     L90EA                   ; if this isn't at the top of the heap then we need to make a new buffer
                                      
                                      ;  The string's current string block is the last thing in the heap, so it can just be extended
                                      ;  -------------------------------------------------------------------------------------------
90B3  0F2C                            CLR     ZP_INT_WA + 2           ; Set ZP_INT_WA + 2 to zero to not change string address later
90B5  A042                            SUBA    2,U                     ; X=newstrlen - currstrlen = extra memory needed
90B7  1F89            L90EA           TFR     A,B                     ; B & A contain the ammount that VARTOP needs to be shifted by
90B9  9E02                            LDX     ZP_VARTOP
90BB  3A                              ABX
90BC  9C04                            CMPX    ZP_BAS_SP
90BE  24BB                            BHS     brkNoRoom               ;  Compare to STACKBOT, no room if new VARTOP>=STACKBOT
90C0  9F02                            STX     ZP_VARTOP               ;  Store new VARTOP
90C2  3504                            PULS    B
90C4  E742                            STB     2,U                     ;  Get string length back and store it
90C6  0D2C                            TST     ZP_INT_WA + 2
90C8  2704                            BEQ     L910E                   ;  Get string address, jump if not moved
90CA  9E2C                            LDX     ZP_INT_WA + 2
90CC  AFC4                            STX     ,U
90CE  D636            L910E           LDB     ZP_STRBUFLEN            ;  Get string length
90D0  E743                            STB     3,U
90D2  270E                            BEQ     L912B                   ;  Store string length, exit if zero length
90D4  EEC4                            LDU     0,U
90D6  DF2C                            STU     ZP_INT_WA + 2           ; store new pointer
90D8  8E0600                          LDX     #BAS_StrA
90DB                  copystr600
90DB  A680            1               LDA     ,X+
90DD  A7C0                            STA     ,U+
90DF  5A                              DECB
90E0  26F9                            BNE     1B
90E2  35C0            L912B           PULS    U,PC
                      ;
                      ;                       ;  Store fixed string at $<addr>
                      ;                       ;  -----------------------------
90E4                  indStringStore  CALL    str600CRterm                    ;  Store <cr> at end of string buffer
90E4                  9
90E6                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
90E4  BDB979                                  JSR     \1
                              ENDIF
90E7  DE2C                            LDU     ZP_INT_WA + 2
90E9  5C                              INCB                                    ; include terminating CR
90EA  20EF                            BRA     copystr600
                      
                      
90EC                  cmdPRINT_HASH                                           ; L9141
90EC                                  CALL    decYSaveAndEvalHashChannelAPI
90EC                  9
90EE                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0094                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
90EC  BDB682                                  JSR     \1
                              ENDIF
90EF  3420                            PSHS    Y                               ; save Channel #
90F1                  cmdPRINTHAS_lp          
90F1  DE0B                            LDU     ZP_TXTPTR
90F3                                  CALL    skipSpacesCheckCommaAtY
90F3                  9
90F5                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0053                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
90F3  BD8D48                                  JSR     \1
                              ENDIF
90F6  2647                            BNE     cmdPRINTHASH_exit
90F8                                  CALL    evalAtY
90F8                  9
90FA                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
90F8  BD9A41                                  JSR     \1
                              ENDIF
90FB  DF0B                            STU     ZP_TXTPTR                       ; save BASIC test pointer
90FD  10AEE4                          LDY     ,S                              ; channel
9100  9627                            LDA     ZP_VARTYPE                      ; var type, output to file
9102  BDFFD4                          JSR     OSBPUT
9105  4D                              TSTA
9106  2723                            BEQ     cmdPRINTHASH_STR
9108  2B0F                            BMI     cmdPRINTHASH_FP
910A  C603                            LDB     #$03
910C  8E002A                          LDX     #ZP_INT_WA
910F  A680            1               LDA     ,X+                             ; not it's big endian in the file!
9111  BDFFD4                          JSR     OSBPUT
9114  5A                              DECB
9115  2AF8                            BPL     1B
9117  20D8                            BRA     cmdPRINTHAS_lp
9119                  cmdPRINTHASH_FP
9119                                  CALL    fpCopyFPA_FPTEMP1               ; put eval'd FP at FPTEMP1 in 5 byte form 
9119                  9
911B                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9119  BDA1EC                                  JSR     \1
                              ENDIF
911C  C604                            LDB     #$04
911E  8E0471                          LDX     #BASWKSP_FPTEMP1+5
9121  A682            1               LDA     ,-X
9123  BDFFD4                          JSR     OSBPUT
9126  5A                              DECB
9127  2AF8                            BPL     1B
9129  20C6                            BRA     cmdPRINTHAS_lp
912B                  cmdPRINTHASH_STR
912B  9636                            LDA     ZP_STRBUFLEN
912D  BDFFD4                          JSR     OSBPUT
9130  D636                            LDB     ZP_STRBUFLEN
9132  8E0600                          LDX     #BAS_StrA
9135  27BA            1               BEQ     cmdPRINTHAS_lp
9137  A680                            LDA     ,X+
9139  BDFFD4                          JSR     OSBPUT
913C  5A                              DECB
913D  20F6                            BRA     1B
913F                  cmdPRINTHASH_exit
913F  3262                            LEAS    2,S                             ; discard stacked channel
9141  335F                            LEAU    -1,U
9143                                  JUMP    scanNextContinue
9143  7E8FDF                                  JMP     \1
                      
                      
                      ;                       ;  PRINT (<print items>)
                      ;                       ;  =====================
9146                  cmdPRINT
9146                                  CALL    skipSpacesCheckHashAtYStepBack
9146                  9
9148                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
000D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9146  BD8D55                                  JSR     \1
                              ENDIF
9149  27A1                            BEQ     cmdPRINT_HASH                   ; Get next non-space char, if '#' jump to do PRINT#
914B  201A                            BRA     cmdPRINT_skStart                ;  Jump into PRINT loop
                      
914D                  cmdPRINT_setHexFlagFromCarry2
914D                                  SEC
914D  1A01                    ORCC    #CC_C
914F  201D                            BRA     cmdPRINT_setHexFlagFromCarry
                      
                      ;                       ;  Print a comma
                      ;                       ;  -------------
9151                  cmdPRINT_padToNextField                                 ; L9196
9151  B60403                          LDA     BASWKSP_INTVAR + 3              ; get low byte of @%
9154  2711                            BEQ     cmdPRINT_skStart                ;  If field width zero, no padding needed, jump back into main loop
9156  961E                            LDA     ZP_PRLINCOUNT                   ;  Get COUNT
9158                  cmdPRINT_padToNextField_lp                              ; L919D
9158  270D                            BEQ     cmdPRINT_skStart                ;  Zero, just started a new line, no padding, jump back into main loop
915A  B00403                          SUBA    BASWKSP_INTVAR + 3              ;  Get COUNT-field width
915D  24F9                            BCC     cmdPRINT_padToNextField_lp      ;  Loop to reduce until (COUNT MOD fieldwidth)<0
915F  1F89                            TFR     A,B                             ;  B=-number of spaces to get back to (COUNT MOD width)=zero
9161                  cmdPRINT_padToNextField_lp2                             ; L91A5
9161                                  CALL    list_print1Space
9161                  9
9163                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9161  BDB8ED                                  JSR     \1
                              ENDIF
9164  5C                              INCB
9165  26FA                            BNE     cmdPRINT_padToNextField_lp2     ; Loop to print required spaces
9167                  cmdPRINT_skStart                                        ; L91AB
                                      
9167  B60403                          LDA     BASWKSP_INTVAR + 3              ; Get @%
916A  9714                            STA     ZP_PRINTBYTES                   ; Set current field width from @%
916C                                  CLC                                     ; Prepare to print decimal
916C  1CFE                    ANDCC   #~CC_C
916E                  cmdPRINT_setHexFlagFromCarry                            ; L91B1
916E  0615                            ROR     ZP_PRINTFLAG                    ; Set hex/dec flag from Carry
9170                  cmdPRINT_lp1                                            ; L91B1
9170                                  CALL    skipSpacesY                     ; Get next non-space character
9170                  9
9172                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9170  BD8F0C                                  JSR     \1
                              ENDIF
9173  813A                            CMPA    #':'
9175  2708                            BEQ     cmdPRINT_endcmd                 ; End of statement if <colon> found
9177  810D                            CMPA    #$0D
9179  2704                            BEQ     cmdPRINT_endcmd                 ; End if statement if <cr> found
917B  818B                            CMPA    #tknELSE
917D  2619                            BNE     cmdPRINT_sk0                    ; Not 'ELSE', jump to check this item
                      
                      ;                       ;  End of PRINT statement
                      ;                       ;  ----------------------
917F                  cmdPRINT_endcmd                                         ; L91C2
917F                                  CALL    PrintCRclearPRLINCOUNT          ; Output new line and set COUNT to zero
917F                  9
9181                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
003D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
917F  BDB6BE                                  JSR     \1
                              ENDIF
9182                  cmdPRINT_endcmd_noCR                                    ; L91C5
9182                                  JUMP    decYGoScanNextContinue          ; Check end of statement, return to execution loop
9182  7E8FDD                                  JMP     \1
9185                  cmdPRINT_lp2_checkendcmd                                ; L91C8
9185  0F14                            CLR     ZP_PRINTBYTES                   ;TODO: work out if BEQ->LBRA's below are better / shorter/faster than straight LBEQ's
9187  0F15                            CLR     ZP_PRINTFLAG                    ;  Set current field to zero, hex/dec flag to decimal
9189                                  CALL    skipSpacesY                     ;  Get next non-space character
9189                  9
918B                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9189  BD8F0C                                  JSR     \1
                              ENDIF
918C  813A                            CMPA    #':'
918E  27F2                            BEQ     cmdPRINT_endcmd_noCR            ;  <colon> found, finish printing
9190  810D                            CMPA    #$0D
9192  27EE                            BEQ     cmdPRINT_endcmd_noCR            ;  <cr> found, finish printing
9194  818B                            CMPA    #tknELSE
9196  27EA                            BEQ     cmdPRINT_endcmd_noCR            ;  'ELSE' found, finish printing
                      
                      ;                       ;  Otherwise, continue into main loop
9198                  cmdPRINT_sk0                                            ; L91DB
9198  817E                            CMPA    #'~'
919A  27B1                            BEQ     cmdPRINT_setHexFlagFromCarry2   ; Jump back to set hex/dec flag from Carry
919C  812C                            CMPA    #','
919E  27B1                            BEQ     cmdPRINT_padToNextField         ; Jump to pad to next print field
91A0  813B                            CMPA    #';'
91A2  27E1                            BEQ     cmdPRINT_lp2_checkendcmd        ; Jump to check for end of print statement
91A4                                  CALL    cmdPRINT_checkaposTABSPC
91A4                  9
91A6                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91A4  BD922C                                  JSR     \1
                              ENDIF
91A7  24C7                            BCC     cmdPRINT_lp1                    ; Check for ' TAB SPC, if print token found return to outer main loop
                      
                      ;                       ;  All print formatting have been checked, so it now must be an expression
                      ;                       ;  -----------------------------------------------------------------------
91A9  DC14                            LDD     ZP_PRINTBYTES                   ; TODO: assumes order ZP_PRINTBYTES precedes ZP_PRINTFLAG
                      ;; removed;             LDB     ZP_PRINTFLAG
91AB  3406                            PSHS    D
                      ;                       ;  Save field width and flags, as evaluator
                      ;                       ;   may call PRINT (eg FN, STR$, etc.)
91AD  335F                            LEAU    -1,U
91AF                                  CALL    evalAtY                         ; Evaluate expression
91AF                  9
91B1                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0090                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91AF  BD9A41                                  JSR     \1
                              ENDIF
91B2  3506                            PULS    D                               ; Restore field width and flags
91B4  DD14                            STD     ZP_PRINTBYTES
                      ;; removed;             STB     ZP_PRINTFLAG
91B6  0D27                            TST     ZP_VARTYPE                      ; DB - was from Y
91B8  2711                            BEQ     cmdPRINT_printString            ; If type=0, jump to print string
91BA                                  CALL    cmdPRINT_num2str                ; Convert Numeric value to string
91BA                  9
91BC                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91BA  BD9E1C                                  JSR     \1
                              ENDIF
91BD  9614                            LDA     ZP_PRINTBYTES                   ; Get current field width
91BF  9036                            SUBA    ZP_STRBUFLEN                    ; A=width-stringlength
91C1  2308                            BLS     cmdPRINT_printString            ; length>=width - print it
91C3  1F89                            TFR     A,B                             ; B=number of spaces needed
91C5                  cmdPRINT_padlp1                                         ; L9211
91C5                                  CALL    list_print1Space
91C5                  9
91C7                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0026                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91C5  BDB8ED                                  JSR     \1
                              ENDIF
91C8  5A                              DECB
91C9  26FA                            BNE     cmdPRINT_padlp1                 ;  Loop to print required spaces
                      
                      ;                       ;  Print string in string buffer
                      ;                       ;  -----------------------------
91CB                  cmdPRINT_printString
91CB  D636                            LDB     ZP_STRBUFLEN
91CD  27A1                            BEQ     cmdPRINT_lp1                    ; Null string, jump back to main loop
91CF  8E0600                          LDX     #BAS_StrA
91D2                  cmdPRINT_printString_lp                                 ; L921D
91D2  A680                            LDA     ,X+
91D4                                  CALL    list_printANoEDIT               ; Print the character from string buffer
91D4                  9
91D6                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91D4  BDB8F3                                  JSR     \1
                              ENDIF
91D7  5A                              DECB
91D8  26F8                            BNE     cmdPRINT_printString_lp         ;  Increment pointer, loop for full string
91DA  2094                            BRA     cmdPRINT_lp1                    ;  Jump back to main loop
                      
                      
91DC                  cmdPRINT_TAB_comma                                      ; L922D
91DC  962D                            LDA     ZP_INT_WA + 3                   ;  Save current value
91DE  3402                            PSHS    A
91E0                                  CALL    evalL1BracketAlreadyOpenConvert2INT     ;  Evaluate next integer, check for closing bracket
91E0                  9
91E2                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91E0  BD94D8                                  JSR     \1
                              ENDIF
91E3  861F                            LDA     #$1F
91E5  BDFFEE                          JSR     OSWRCH                          ;  VDU 31 - Set cursor position
91E8  3502                            PULS    A                               ;  Get first parameter back
91EA  BDFFEE                          JSR     OSWRCH                          ;  Send X parameter
91ED                                  CALL    doVDUChar_fromWA3               ;  Send Y parameter from integer accumulator
91ED                  9
91EF                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91ED  BD964E                                  JSR     \1
                              ENDIF
91F0  202C                            BRA     rtsCLC_L926A
                      
                                              ;  Clear carry flag, Set PTR A offset = PTR B offset and exit
                                              ;  PRINT TAB()
                                              ;  -----------
91F2                  cmdPRINT_TAB                                            ; L9241
91F2                                  CALL    evalAtYcheckTypeInAConvert2INT  ; Get Integer result of expression
91F2                  9
91F4                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91F2  BD94E0                                  JSR     \1
                              ENDIF
91F5                                  CALL    skipSpacesCheckCommaAtY         ; Get next non-space character, compare with ','
91F5                  9
91F7                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91F5  BD8D48                                  JSR     \1
                              ENDIF
91F8  27E2                            BEQ     cmdPRINT_TAB_comma              ; Comma, jump to TAB(x,y)
91FA  8129                            CMPA    #')'                            ; Check for closing bracket
91FC  1026FD23                        LBNE    brkMissingComma                 ; Jump to give "Missing )" error
9200  962D                            LDA     ZP_INT_WA + 3                   ; Get value
9202  901E                            SUBA    ZP_PRLINCOUNT                   ; A=tab-COUNT
9204  2718                            BEQ     rtsCLC_L926A                    ; No spaces needed, jump to clear carry, update and return
9206  1F89                            TFR     A,B                             ; B=number of spaces needed
9208  250C                            BCS     cmdPRINT_B_SPACESCLCRTS         ; Output X number of spaces, clear carry, update and return
920A                                  CALL    PrintCRclearPRLINCOUNT          ; Start new output line
920A                  9
920C                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
920A  BDB6BE                                  JSR     \1
                              ENDIF
920D  2003                            BRA     cmdPRINT_SPACESatZP_INT_WA_3    ; Output ?2A number of spaces, clear carry, update and return
                      
                      ;                       ;  PRINT SPC()
                      ;                       ;  -----------
920F                  cmdPRINT_SPC                                            ; L925B
920F                                  CALL    evalLevel1checkTypeStoreAsINT   ; Evaluate integer
920F                  9
9211                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
920F  BD94E5                                  JSR     \1
                              ENDIF
9212                  cmdPRINT_SPACESatZP_INT_WA_3                            ; L925E
9212  D62D                            LDB     ZP_INT_WA + 3                   ; Get returned value
9214  2708                            BEQ     rtsCLC_L926A                    ; If zero, clear carry, update and return
9216                  cmdPRINT_B_SPACESCLCRTS                                 ; L9262
9216                                  CALL    list_printBSpaces               ; Output X number of Spaces
9216                  9
9218                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0005                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9216  BDB91D                                  JSR     \1
                              ENDIF
9219  2003                            BRA     rtsCLC_L926A                    ; Clear carry, update and return
                      
                      ;                       ;  PRINT '
                      ;                       ;  -------
921B                  cmdPRINT_CR                                     ; L9267
921B                                          CALL PrintCRclearPRLINCOUNT                     ;  Output a new line
921B                  9
921D                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
921B  BDB6BE                                  JSR     \1
                              ENDIF
                      ;                       ;  Clear carry, update and return
                      ;                       ;  ------------------------------
921E                  rtsCLC_L926A            
921E                                  CLC
921E  1CFE                    ANDCC   #~CC_C
                      ;               ;;;; REMOVED    BRA copyTXTOFF2toTXTOFF                 ;  Update PTR A offset = PTR B offset and return
9220  39                              RTS
                      ;               
                      ;       
                      
                      ;decYEvalForceINT
                      ;               LEAU    -1,Y
9221                  evalForceINT
9221                                  CALL    evalExpressionMAIN
9221                  9
9223                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9221  BD9A41                                  JSR     \1
                              ENDIF
9224                                  CALL    checkTypeInAConvert2INT
9224                  9
9226                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9224  BD94EF                                  JSR     \1
                              ENDIF
9227                  copyTXTOFF2toTXTOFF
9227  DF0B                            STU     ZP_TXTPTR
9229  DF19                            STU     ZP_TXTPTR2
922B  39                              RTS
                      
                      ;                       ;  Check special print formatting ' TAB( SPC
                      ;                       ;  -----------------------------------------
922C                  cmdPRINT_checkaposTABSPC                                ; L927A
                      ;; REMOVED      ;               LDX ZP_TXTPTR
                      ;; REMOVED      ;               STX ZP_TXTPTR2
                      ;; REMOVED      ;               LDX ZP_TXTPTR + 1
                      ;; REMOVED      ;               STX ZP_TXTPTR2 + 1
                      ;; REMOVED      ;               LDX ZP_TXTOFF
                      ;; REMOVED      ;               STX ZP_TXTOFF2
922C  8127                            CMPA    #'''
922E  27EB                            BEQ     cmdPRINT_CR                     ;  Current char is "'", jump to print newline
9230  818A                            CMPA    #tknTAB
9232  27BE                            BEQ     cmdPRINT_TAB                    ;  Current char 'TAB(', jump to do TAB()
9234  8189                            CMPA    #tknSPC
9236  27D7                            BEQ     cmdPRINT_SPC                    ;  Current char 'SPC', jump to do SPC()
9238                  rtsSEC_L9292
9238                                  SEC                                     ;  Flag 'not formatting token'
9238  1A01                    ORCC    #CC_C
923A                  rtsL9293
923A  39                              RTS
923B                  brkMissingQuote                                         ; L9294
923B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
923B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
923C  098D2200                        FCB     $09, tknMissing, $22,
9240                  cmdINPUT_PRINT_prompt
9240                                  CALL    skipSpacesY
9240                  9
9242                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9240  BD8F0C                                  JSR     \1
                              ENDIF
9243                                  CALL    cmdPRINT_checkaposTABSPC                
9243                  9
9245                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9243  8DE7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9245  24F3                            BCC     rtsL9293                        ; 
9247  8122                            CMPA    #'"'
9249  26ED                            BNE     rtsSEC_L9292
924B  A6C0            2               LDA     ,U+
924D  810D                            CMPA    #$0D
924F  27EA                            BEQ     brkMissingQuote
9251  8122                            CMPA    #'"'
9253  2606                            BNE     1F
9255  A1C4                            CMPA    ,U                              ; double " 
9257  26C5                            BNE     rtsCLC_L926A
9259  3341                            LEAU    1,U
925B                  1               CALL    list_printANoEDIT
925B                  9
925D                  __XBSR                  SET 9B+2
2600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0096                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
925B  BDB8F3                                  JSR     \1
                              ENDIF
925E  20EB                            BRA     2B
9260                  cmdCALL                 ; L92BE!
9260                                  CALL    evalExpressionMAIN
9260                  9
9262                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9260  BD9A41                                  JSR     \1
                              ENDIF
9263                                  CALL    checkTypeInZP_VARTYPEConvert2INT
9263                  9
9265                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0088                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9263  BD94ED                                  JSR     \1
                              ENDIF
9266                                  CALL    stackINT_WAasINT
9266                  9
9268                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0072                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9266  BDB7DA                                  JSR     \1
                              ENDIF
9269  7F0600                          CLR     BAS_StrA                        ; number of parameters
926C  8E0601                          LDX     #BAS_StrA+1
926F                  L92CC
926F                                  CALL    skipSpacesCheckCommaAtYStepBack
926F                  9
9271                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
926F  BD8D4E                                  JSR     \1
                              ENDIF
9272  2612                            BNE     L92F1
9274                                  CALL    findVarAtYSkipSpaces
9274                  9
9276                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9274  BD96FD                                  JSR     \1
                              ENDIF
9277  271C                            BEQ     L9301
9279  962A                            LDA     ZP_INT_WA + 0
927B  A780                            STA     ,X+                             ; var type
927D  DC2C                            LDD     ZP_INT_WA + 2           
927F  ED81                            STD     ,X++                            ; var ptr
9281  7C0600                          INC     BAS_StrA
9284  20E9                            BRA     L92CC
9286                  L92F1           CALL    scanNextStmtFromY
9286                  9
9288                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
006C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9286  BD98F4                                  JSR     \1
                              ENDIF
9289                                  CALL    popIntANew
9289                  9
928B                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9289  BDB86C                                  JSR     \1
                              ENDIF
928C  3440                            PSHS    U
928E                                  CALL    callusrSetRegsEnterCode
928E                  9
9290                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
928E  8D08                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9290  3540                            PULS    U
9292                                  JUMP    continue
9292  7E8FE2                                  JMP     \1
9295                  L9301
9295                                  JUMP    brkNoSuchVar
9295  7EAA3C                                  JMP     \1
9298                  callusrSetRegsEnterCode                         ; L9304
9298  3440                            PSHS    U
929A  B6040F                          LDA     $040C+3                         ; C% into carry
929D  44                              LSRA
929E  B60407                          LDA     $0404+3
92A1  F6040B                          LDB     $0408+3
92A4  BE0462                          LDX     $0460+2
92A7  FE0466                          LDU     $0464+2
92AA  AD9F002C                        JSR     [ZP_INT_WA + 2]
92AE  35C0                            PULS    U,PC
92B0                  L9314JUMPbrkSyntax
92B0                                  JUMP    brkSyntax
92B0  7E98B7                                  JMP     \1
92B3                  cmdDELETE
                      
92B3                                          TODO_CMD "DELETE"
92B3                                          TODODEADEND "\1"
92B3                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
92B3  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
92B4  7E443A                          FCB             $7E,"D:"
92B7  44454C455445                    FCB             \1
92BD  00                              FCB             0
                                              
                      ;                       ;  DELETE
                      ;               CALL skipSpacesDecodeLineNumber
                      ;               BCC L9314JUMPbrkSyntax
                      ;               CALL stackINT_WAasINT
                      ;               CALL SkipSpaceCheckComma
                      ;               BNE L9314JUMPbrkSyntax
                      ;               CALL skipSpacesDecodeLineNumber
                      ;               BCC L9314JUMPbrkSyntax
                      ;               CALL scanNextStmt
                      ;               LDA ZP_INT_WA
                      ;               STA ZP_NAMELENORVT
                      ;               LDA ZP_INT_WA + 1
                      ;               STA ZP_NAMELENORVT + 1
                      ;               CALL popIntA
                      ;L9337:
                      ;               CALL findLineAndDelete  
                      ;               CALL checkForESC
                      ;               CALL inc_INT_WA
                      ;               LDA ZP_NAMELENORVT
                      ;               CMP ZP_INT_WA
                      ;               LDA ZP_NAMELENORVT + 1
                      ;               SBC ZP_INT_WA + 1
                      ;               BCS L9337
                      ;               JUMP resetVarsImmedPrompt
92BE                  AUTO_RENUM_STARTSTEP_DEF1010                            ; L934D
92BE  C60A                            LDB     #$0A
92C0                                  CALL    retB8asUINT                     ; default first param 10
92C0                  9
92C2                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92C0  BDAAD6                                  JSR     \1
                              ENDIF
92C3                                  CALL    skipSpacesDecodeLineNumberNewAPI
92C3                  9
92C5                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92C3  BD987B                                  JSR     \1
                              ENDIF
92C6                                  CALL    stackINT_WAasINT
92C6                  9
92C8                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0012                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92C6  BDB7DA                                  JSR     \1
                              ENDIF
92C9  C60A                            LDB     #$0A                            ; default second param 10
92CB                                  CALL    retB8asUINT
92CB                  9
92CD                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92CB  BDAAD6                                  JSR     \1
                              ENDIF
92CE                                  CALL    skipSpacesCheckCommaAtY
92CE                  9
92D0                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92CE  BD8D48                                  JSR     \1
                              ENDIF
92D1  260E                            BNE     L9370
92D3                                  CALL    skipSpacesDecodeLineNumberNewAPI
92D3                  9
92D5                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92D3  BD987B                                  JSR     \1
                              ENDIF
92D6  962C                            LDA     ZP_INT_WA + 2
92D8  2617                            BNE     brkSilly
92DA  962D                            LDA     ZP_INT_WA + 3
92DC  2713                            BEQ     brkSilly
92DE                                  JUMP    scanNextStmtFromY
92DE  7E98F4                                  JMP     \1
92E1                  L9370
92E1                                  JUMP    scanNextExpectColonElseCR
92E1  7E98F7                                  JMP     \1
                      ;L9373:
                      ;               LDA ZP_TOP
                      ;               STA ZP_FPB
                      ;               LDA ZP_TOP + 1
                      ;               STA ZP_FPB + 1
                      ;L937B:
                      ;               LDA ZP_PAGE_H
                      ;               STA ZP_GEN_PTR + 1
                      ;               LDU #$01
                      ;               STU ZP_GEN_PTR
                      ;               RTS
92E4                  cmdRENUMBER             ; L9384!
                      
92E4                                          TODO_CMD "RENUMBER"
92E4                                          TODODEADEND "\1"
92E4                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
92E4  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
92E5  7E443A                          FCB             $7E,"D:"
92E8  52454E554D424552                 FCB             \1
92F0  00                              FCB             0
                                              
                      ;                       ;  RENUMBER
                      ;               CALL AUTO_RENUM_STARTSTEP_DEF1010
                      ;               LDX #ZP_NAMELENORVT
                      ;               CALL popIntAtX
                      ;               CALL findTOP
                      ;               CALL L9373
                      ;L9392:
                      ;               LDA (ZP_GEN_PTR)
                      ;               BMI L93C4
                      ;               STA (ZP_FPB)
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               STA (ZP_FPB),Y
                      ;               SEC
                      ;               TYA
                      ;               ADC ZP_FPB
                      ;               STA ZP_FPB
                      ;               BCC L93A6
                      ;               INC ZP_FPB + 1
                      ;L93A6:
                      ;               CMP ZP_HIMEM
                      ;               LDA ZP_FPB + 1
                      ;               SBC ZP_HIMEM + 1
                      ;               BCS brkRENUMBERspace
                      ;               CALL L947A
                      ;               BRA L9392
                      ;brkRENUMBERspace:
                      ;               BRK
                      ;               .byte  $00
                      ;               .byte  tknRENUMBER, " space"
92F1                  brkSilly
92F1                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
92F1  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
92F2  0053696C6C7900                  FCB     $00, "Silly", 0
                      ;
                      ;L93C4:         CALL L937B
                      ;L93C7:         LDA (ZP_GEN_PTR)
                      ;               BMI L93E7
                      ;               LDA ZP_NAMELENORVT + 1
                      ;               STA (ZP_GEN_PTR)
                      ;               LDA ZP_NAMELENORVT
                      ;               STA (ZP_GEN_PTR),Y
                      ;               CLC
                      ;               LDA ZP_NAMELENORVT
                      ;               ADC ZP_INT_WA
                      ;               STA ZP_NAMELENORVT
                      ;               LDA #$00
                      ;               ADC ZP_NAMELENORVT + 1
                      ;               AND #$7F
                      ;               STA ZP_NAMELENORVT + 1
                      ;               CALL L947A
                      ;               BRA L93C7
                      ;L93E7:
                      ;               LDA ZP_PAGE_H
                      ;               STA ZP_TXTPTR + 1
                      ;               STZ ZP_TXTPTR
                      ;L93ED:
                      ;               LDU #$01
                      ;               LDA (ZP_TXTPTR),Y
                      ;               BMI L945A
                      ;               LDU #$04
                      ;               STZ ZP_INT_WA + 2
                      ;L93F7:
                      ;               LDA (ZP_TXTPTR),Y
                      ;               LDX ZP_INT_WA + 2
                      ;               BNE L9405
                      ;               CMP #$8D
                      ;               BEQ L941B
                      ;               CMP #$F4
                      ;               BEQ L9412
                      ;L9405:
                      ;               INY
                      ;               CMP #$22
                      ;               BNE L940E
                      ;               EOR ZP_INT_WA + 2
                      ;               STA ZP_INT_WA + 2
                      ;L940E:
                      ;               CMP #$0D
                      ;               BNE L93F7
                      ;L9412:
                      ;               LDU #$03
                      ;               LDA (ZP_TXTPTR),Y
                      ;               CALL L9BF4
                      ;               BRA L93ED
                      ;L941B:
                      ;               CALL decodeLineNumber
                      ;               CALL L9373
                      ;L9421:
                      ;               LDA (ZP_GEN_PTR)
                      ;               BMI L945C
                      ;               LDA (ZP_FPB)
                      ;               CMP ZP_INT_WA + 1
                      ;               BNE L944A
                      ;               LDA (ZP_FPB),Y
                      ;               CMP ZP_INT_WA
                      ;               BNE L944A
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               STA ZP_FPB + 2
                      ;               LDA (ZP_GEN_PTR)
                      ;               TAX
                      ;               LDU ZP_TXTOFF
                      ;               DEY
                      ;               LDA ZP_TXTPTR
                      ;               STA ZP_NAMELENORVT
                      ;               LDA ZP_TXTPTR + 1
                      ;               STA ZP_NAMELENORVT + 1
                      ;               CALL L8D62
                      ;L9446:
                      ;               LDU ZP_TXTOFF
                      ;               BRA L93F7
                      ;L944A:
                      ;               CLC
                      ;               CALL L947A
                      ;               LDA ZP_FPB
                      ;               ADC #$02
                      ;               STA ZP_FPB
                      ;               BCC L9421
                      ;               INC ZP_FPB + 1
                      ;               BRA L9421
                      ;L945A:
                      ;               BRA L94B6
                      ;L945C:
                      ;               PRINT_STR "Failed at "
                      ;               LDA (ZP_TXTPTR),Y
                      ;               STA ZP_INT_WA + 1
                      ;               INY
                      ;               LDA (ZP_TXTPTR),Y
                      ;               STA ZP_INT_WA
                      ;               CALL int16print_AnyLen -- API CHANGE -- API CHANGE
                      ;               CALL PrintCRclearPRLINCOUNT
                      ;               BRA L9446
                      ;L947A:
                      ;               INY
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               LDU #$01
                      ;               ADC ZP_GEN_PTR
                      ;               STA ZP_GEN_PTR
                      ;               BCC L9488
                      ;               INC ZP_GEN_PTR + 1
                      ;               CLC
                      ;L9488:
                      ;               RTS
                      ;                       ;  AUTO [num[,num]]
                      ;                       ;  ================
92F9                  cmdAUTO                 
92F9                                  CALL    AUTO_RENUM_STARTSTEP_DEF1010
92F9                  9
92FB                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
92F9  8DC3                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
92FB  962D                            LDA     ZP_INT_WA + 3
92FD  3402                            PSHS    A                               ; stack the step
92FF                                  CALL    popIntANew
92FF                  9
9301                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92FF  BDB86C                                  JSR     \1
                              ENDIF
9302                  L9492           CALL    stackINT_WAasINT
9302                  9
9304                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9302  BDB7DA                                  JSR     \1
                              ENDIF
9305                                  CALL    int16print_fmt5
9305                  9
9307                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0049                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9305  BD9D50                                  JSR     \1
                              ENDIF
9308                                  CALL    ReadKeysTo_InBuf
9308                  9
930A                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9308  BDB6A4                                  JSR     \1
                              ENDIF
930B                                  CALL    popIntANew
930B                  9
930D                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
930B  BDB86C                                  JSR     \1
                              ENDIF
930E                                  CALL    L8DE7
930E                  9
9310                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
930E  BD8E30                                  JSR     \1
                              ENDIF
9311  CE0700                          LDU     #BAS_InBuf
9314                                  CALL    tokenizeAndStoreAlreadyLineNoDecoded 
9314                  9
9316                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9314  BDB701                                  JSR     \1
                              ENDIF
9317                                  CALL    ResetVars
9317                  9
9319                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0057                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9317  BDB770                                  JSR     \1
                              ENDIF
931A  E6E4                            LDB     ,S
931C  4F                              CLRA
931D  D32C                            ADDD    ZP_INT_WA + 2
931F  DD2C                            STD     ZP_INT_WA + 2
9321  2ADF                            BPL     L9492
9323                  L94B6           JUMP    resetVarsImmedPrompt
9323  7E8F6C                                  JMP     \1
                      
                      
                      ;                       ;  DIM name - Reserve memory
                      ;                       ;  -------------------------
9326                  cmdDIM_reserve_mem                                      ; L94BC
9326                                  CALL    findVarOrAllocEmpty             ;  Step back, find/create variable
9326                  9
9328                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9326  BD96B1                                  JSR     \1
                              ENDIF
9329  276C                            BEQ brkBadDIM
932B  256A                            BCS brkBadDIM                           ;  Error if string variable or bad variable name
932D                                  CALL pushVarPtrAndType                  ;  Push IntA - address of info block
932D                  9
932F                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
932D  BDB7E8                                  JSR     \1
                              ENDIF
9330                                  CALL evalAtYcheckTypeInAConvert2INT
9330                  9
9332                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9330  BD94E0                                  JSR     \1
                              ENDIF
9333                                  CALL inc_INT_WA                         ;  Evaluate integer, IntA=IntA+1 to count zeroth byte
9333                  9
9335                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9333  BDBA35                                  JSR     \1
                              ENDIF
9336  962A                            LDA ZP_INT_WA + 0
9338  9A2B                            ORA ZP_INT_WA + 1
933A  265B                            BNE brkBadDIM                           ;  Size>$FFFF or <0, error
                      ;               CLC
                      ;               LDA ZP_INT_WA
                      ;               ADC ZP_VARTOP
                      ;               TAY                                     ;  XY=VARTOP+size
                      ;               LDA ZP_INT_WA + 1
                      ;               ADC ZP_VARTOP + 1
                      ;               TAX
933C  DC2C                            LDD     ZP_INT_WA + 2
933E  D302                            ADDD    ZP_VARTOP
9340  109304                          CMPD    ZP_BAS_SP                       ; new vartop
9343  102400FD                        LBHS    brkDIMspace                     ; check room
9347  9E02                            LDX     ZP_VARTOP
9349  9F2C                            STX     ZP_INT_WA + 2                   ; store org vartop as return value (top bytes already 0)
934B  DD02                            STD     ZP_VARTOP
934D  8640                            LDA     #$40
934F  9727                            STA     ZP_VARTYPE                      ;  Type=Integer
9351                                  CALL storeEvaledExpressioninStackedVarPTr
9351                  9
9353                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0068                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9351  BDAFBB                                  JSR     \1
                              ENDIF
9354                                  CALL copyTXTOFF2toTXTOFF                        ;  Set the variable, update PTRA
9354                  9
9356                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9354  BD9227                                  JSR     \1
                              ENDIF
9357                  cmdDIM_more_dims_q                                      ; L94FB
9357                                  CALL    skipSpacesCheckCommaAtYStepBack
9357                  9
9359                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9357  BD8D4E                                  JSR     \1
                              ENDIF
935A  2743                            BEQ     cmdDIM                          ;  Next character is comma, do another DIM
935C                                  JUMP    scanNextContinue
935C  7E8FDF                                  JMP     \1
                      ;                       ;  Return to execution loop
                                      ; multiply 15 bit contents of 2,S by 15 bits in D, return in D
                                      ; uses ZP_INT_WA_C as scratch space
                                      ;         a b === D
                                      ;       x c d === [,S]
                                      ;       =====
                                      ;         bxd
                                      ;  +    axd
                                      ;  +    bxc
                                      ;  +  axc
                                      ;  ==========
                                      ;     F F C   = bad DIM !
935F                  cmdDIM_mul_D_by_S                                       ; L9503
935F  DD3D                            STD     ZP_INT_WA_C
9361  4D                              TSTA
9362  2704                            BEQ     1F
9364  6D62                            TST     2,S
9366  262F                            BNE     brkBadDIM                       ; > &10000
                                      
9368  A663            1               LDA     3,S             ; A = d
936A  3D                              MUL                     ; res = b * d
936B  4D                              TSTA
936C  2B29                            BMI     brkBadDIM
936E  DD3F                            STD     ZP_INT_WA_C + 2
                      
9370  963D                            LDA     ZP_INT_WA_C + 0 ; B = a
9372  E663                            LDB     3,S             ; A = d
9374  3D                              MUL                     
9375  4D                              TSTA
9376  261F                            BNE     brkBadDIM       ; overflow
9378                                  CLC
9378  1CFE                    ANDCC   #~CC_C
937A  D93F                            ADCB    ZP_INT_WA_C + 2
937C  2B19                            BMI     brkBadDIM       ; overflow
937E  2517                            BCS     brkBadDIM       ; overflow
9380  D73F                            STB     ZP_INT_WA_C + 2
                      
9382  963E                            LDA     ZP_INT_WA_C + 1 ; B = b
9384  E662                            LDB     2,S             ; A = c
9386  3D                              MUL                     
9387  4D                              TSTA
9388  260D                            BNE     brkBadDIM       ; overflow
938A                                  CLC
938A  1CFE                    ANDCC   #~CC_C
938C  D93F                            ADCB    ZP_INT_WA_C + 2
938E  2B07                            BMI     brkBadDIM       ; overflow
9390  2505                            BCS     brkBadDIM       ; overflow
9392  1F98                            TFR     B,A
9394  D640                            LDB     ZP_INT_WA_C + 3
9396  39                              RTS
                                      
                      
9397                  brkBadDIM                                               ; L952C
9397                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9397  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9398  0A42616420DE00                  fcb  $0A, "Bad ", tknDIM, 0
                      
                      ;                       ;  DIM
                      ;                       ;  ===
939F                  cmdDIM
939F                                  CALL skipSpacesY
939F                  9
93A1                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
939F  BD8F0C                                  JSR     \1
                              ENDIF
93A2                  L9541
93A2  335E                            LEAU    -2,U                            ; point 1 before variable name
93A4  DF39                            STU     ZP_GEN_PTR+2
93A6  C605                            LDB     #$05
93A8  D73F                            STB     ZP_FPB + 4                      ; Real, 5 bytes needed
93AA                                  CALL    fnProcScanYplus1varname; Check variable name
93AA                  9
93AC                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93AA  BD9853                                  JSR     \1
                              ENDIF
93AD  C101                            CMPB    #1
93AF  27E6                            BEQ     brkBadDIM                       ; Bad name, jump to error
93B1  8128                            CMPA    #'('
93B3  2715                            BEQ     cmdDIM_realArray                                ; Real array
93B5  8124                            CMPA    #'$'
93B7  2706                            BEQ     cmdDIM_strArray                 ; String array
93B9  8125                            CMPA    #'%'
93BB  1026FF67                        LBNE    cmdDIM_reserve_mem              ; Not (, $, %, reserve memory
93BF                  cmdDIM_strArray                                         ; L9563
93BF  0A3F                            DEC     ZP_FPB + 4                      ; String or Integer, 4 bytes needed
93C1  5C                              INCB                                    ; length += 1
93C2  A680                            LDA     ,X+                             ; Get ext character
93C4  8128                            CMPA    #'('
93C6  1026FF5C                        LBNE    cmdDIM_reserve_mem              ; No '(', jump to reserve memory
                      
                      
                      ;                       ;  Dimension an array
                      ;                       ;  ------------------
93CA                  cmdDIM_realArray                                        ; L9570
93CA  9F0B                            STX     ZP_TXTPTR
93CC  5C                              INCB
93CD  D737                            STB     ZP_NAMELENORVT
93CF                                  CALL    findVarDynLL_NewAPI             ;  Get variable address
93CF                  9
93D1                  __XBSR                  SET 9B+2
F000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93CF  BD8499                                  JSR     \1
                              ENDIF
93D2  26C3                            BNE     brkBadDIM
93D4                                  CALL    allocVAR                        ;  Create new variable
93D4                  9
93D6                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93D4  BD9663                                  JSR     \1
                              ENDIF
93D7  8601                            LDA     #1
93D9                                  CALL    AllocVarSpaceOnHeap             ;  Allocate space
93D9                  9
93DB                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93D9  BD9695                                  JSR     \1
                              ENDIF
93DC  963F                            LDA     ZP_FPB + 4
93DE  3402                            PSHS    A
93E0  9E02                            LDX     ZP_VARTOP
93E2  3001                            LEAX    1,X                             ; leave room for 1 byte offset to first cell
93E4  3410                            PSHS    X
93E6  CC0001                          LDD     #1
93E9  3406                            PSHS    D                               ; total cells accumulator on U stack
                      
93EB  DE0B                            LDU     ZP_TXTPTR
                      
93ED                  L9589           CALL    evalForceINT                    ;  Evaluate integer
93ED                  9
93EF                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93ED  BD9221                                  JSR     \1
                              ENDIF
93F0  962C                            LDA     ZP_INT_WA + 2
93F2  84C0                            ANDA    #$C0
93F4  9A2A                            ORA     ZP_INT_WA + 0
93F6  9A2B                            ORA     ZP_INT_WA + 1
93F8  269D                            BNE     brkBadDIM                       ;  Bad DIM
                      
93FA  DC2C                            LDD     ZP_INT_WA + 2                   ; current dimension
93FC                                  CLC
93FC  1CFE                    ANDCC   #~CC_C
93FE  C30001                          ADDD    #1                              ; increment
9401  AE62                            LDX     2,S
9403  ED81                            STD     ,X++                            ; store at VARTOP...
9405  AF62                            STX     2,S
9407                  1               CALL    cmdDIM_mul_D_by_S                               ;  Multiply [,S] by D return in D
9407                  9
9409                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0056                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9407  BD935F                                  JSR     \1
                              ENDIF
940A  EDE4                            STD     ,S
940C                                  CALL    skipSpacesCheckCommaAtY         ;
940C                  9
940E                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
940C  BD8D48                                  JSR     \1
                              ENDIF
940F  27DC                            BEQ     L9589                           ;  Comma, another dimension
9411  8129                            CMPA    #')'
9413  1026FF80                        LBNE    brkBadDIM                       ;  Not ')', error
                      
                      ;                       ;  Closing ')' found
                      ;                       ;  -----------------
                                      ; calculate 1 byte pointer to 1st cell
9417  1F10                            TFR     X,D                             ; transfer X to D
9419  9302                            SUBD    ZP_VARTOP
941B  E79F0002                        STB     [ZP_VARTOP]                     ; store before the indices
                      
                                      ; calculate the array size in bytes
941F  E664                            LDB     4,S                             ; get cell size back from stack
9421  4F                              CLRA
9422                                  CALL    cmdDIM_mul_D_by_S
9422                  9
9424                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9422  BD935F                                  JSR     \1
                              ENDIF
9425  3406                            PSHS    D
9427  3410                            PSHS    X
9429  E3E1                            ADDD    ,S++                            ; add cells byte count to X
942B  2517                            BCS     brkDIMspace                     ; > 64K
942D  109304                          CMPD    ZP_BAS_SP
9430  2412                            BHS     brkDIMspace                     ; new VARTOP >= U
9432  DD02                            STD     ZP_VARTOP
9434  3506                            PULS    D                               ; get back byte count
9436  4C                              INCA                                    ; increment hi byte of count so we can do BNE
9437  6F80            1               CLR     ,X+
9439  5A                              DECB
943A  26FB                            BNE     1B
943C  4A                              DECA
943D  26F8                            BNE     1B
943F  3265                            LEAS    5,S                             ; discard cell count and cell size from stack
9441                                  JUMP    cmdDIM_more_dims_q
9441  7E9357                                  JMP     \1
                      ;                       ;  Check if another dimension
9444                  brkDIMspace                                             ; L9605
9444                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9444  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9445  0BDE20737061636500                 FCB     $0B, tknDIM, " space", 0
                      
                      ;                       ;  Program environment commands
                      ;                       ;  ============================
                      ;                       ;  HIMEM=address - Set top of BASIC memory, clearing stack
                      ;                       ;  -------------------------------------------------------
944E                  varSetHIMEM                     ; L960F!
                      
                                              
                                              
944E                                  CALL    evalAssignEqInteger             ;  Check for '=', evaluate integer
944E                  9
9450                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
944E  BD94EA                                  JSR     \1
                              ENDIF
9451  9E2C                            LDX     ZP_INT_WA + 2
9453  9F06                            STX     ZP_HIMEM
9455  9F04                            STX     ZP_BAS_SP
9457  2015                            BRA     L963B_continue                  ;  Return to execution loop
                      ;                       ;  LOMEM=address
                      ;                       ;  -------------
9459                  varSetLOMEM                     ; L9620!
9459                                  CALL    evalAssignEqInteger             ;  Check for '=', evaluate integer
9459                  9
945B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9459  BD94EA                                  JSR     \1
                              ENDIF
945C  9E2C                            LDX     ZP_INT_WA + 2
945E  9F00                            STX     ZP_LOMEM
9460  9F02                            STX     ZP_VARTOP
9462                                  CALL    InittblFPRtnAddr                ;  Clear dynamic variables
9462                  9
9464                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9462  BDB778                                  JSR     \1
                              ENDIF
9465  2007                            BRA     L963B_continue;                 ;  Return to execution loop
                      ;                       ;  PAGE=address - Set program start
                      ;                       ;  --------------------------------
9467                  varSetPAGE                      ; L9634!
9467                                  CALL    evalAssignEqInteger             ;  Check for '=', evaluate integer
9467                  9
9469                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9467  BD94EA                                  JSR     \1
                              ENDIF
946A  962C                            LDA     ZP_INT_WA + 2
946C  9718                            STA     ZP_PAGE_H                       ;  Set PAGE
946E                  L963B_continue
946E                                  JUMP    continue                        ;  Return to execution loop
946E  7E8FE2                                  JMP     \1
                      
                      ;                       ;  CLEAR
                      ;                       ;  -----
9471                  cmdCLEAR                                                ; L963E
                      
9471                                  CALL    scanNextStmtFromY       
9471                  9
9473                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9471  BD98F4                                  JSR     \1
                              ENDIF
9474                                  CALL    ResetVars                       ;  Check end of statement, clear variables
9474                  9
9476                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9474  BDB770                                  JSR     \1
                              ENDIF
9477  20F5                            BRA     L963B_continue;                 ;  Return to execution loop
                      
                      ;                       ;  TRACE [ON|OFFOFF|<linenum>]
                      ;                       ;  ---------------------------
9479                  cmdTRACE
                      
9479                                  CALL    skipSpacesDecodeLineNumberNewAPI
9479                  9
947B                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9479  BD987B                                  JSR     \1
                              ENDIF
947C  250B                            BCS     L9656                           ;  TRACE linenum
947E  81EE                            CMPA    #tknON
9480  2715                            BEQ     L9667                           ;  TRACE ON
9482  8187                            CMPA    #tknOFF
9484  271B                            BEQ     L9670                           ;  TRACE OFF
9486                                  CALL    evalForceINT                    ;  Evaluate integer
9486                  9
9488                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9486  BD9221                                  JSR     \1
                              ENDIF
9489                  L9656           CALL    scanNextStmtFromY               ;  Check end of statement
9489                  9
948B                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9489  BD98F4                                  JSR     \1
                              ENDIF
948C  DC2C                            LDD     ZP_INT_WA + 2
948E  DD21            L965F           STD     ZP_MAXTRACLINE                  ;  Set TRACE <linenum>
9490  86FF                            LDA     #$FF                            ;  Set TRACE ON
9492  9720            L9663           STA     ZP_TRACE
9494                                  JUMP    continue                        ;  Return to execution loop
9494  7E8FE2                                  JMP     \1
9497  3341            L9667           LEAU    1,U
9499                                  CALL    scanNextStmtFromY               ;  Check end of statement
9499                  9
949B                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0059                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9499  BD98F4                                  JSR     \1
                              ENDIF
949C  CCFFFF                          LDD     #$FFFF
949F  20ED                            BRA     L965F                           ;  Jump to set TRACE $FFxx and TRACE ON
94A1  3341            L9670           LEAU    1,U
94A3                                  CALL    scanNextStmtFromY               ;  Check end of statement
94A3                  9
94A5                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
004F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94A3  BD98F4                                  JSR     \1
                              ENDIF
94A6  4F                              CLRA
94A7  5F                              CLRB
94A8  20E8                            BRA     L9663
                      
                              IF FLEX = 1
                      brkFlexNotImpl  DO_BRK_B
                                      FCB     $FE, "Not implemented in FLEX OS", 0
                              ENDIF
                      
                                              ;  Jump to set TRACE OFF
                                              ;  TIME=val, TIME$=s$ - set TIME or TIME$
                                              ;  ======================================
94AA                  varSetTIME                      ; L9679!
                      
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE                    
94AA  A6C4                            LDA     ,U                              ;  Get next character
94AC  8124                            CMPA    #'$'
94AE  270F                            BEQ     varSetTime_Dollar               ;  Jump for TIME$=
94B0                                  CALL    evalAssignEqInteger
94B0                  9
94B2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0038                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
94B0  8D38                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
94B2                                  CALL    SwapEndian
94B2                  9
94B4                  __XBSR                  SET 9B+2
1600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94B2  BDAB14                                  JSR     \1
                              ENDIF
94B5  0F2F                            CLR     ZP_INT_WA+5                     ;  Check for '=', evaluate integer, set byte 5 to zero
94B7  8E002A                          LDX     #ZP_INT_WA
94BA  8602                            LDA     #$02                            ;  A=2 for Write TIME
94BC                  L968B
94BC                                  JUMP    OSWORD_continue                 ;  Call OSWORD, return to execution loop
94BC  7EAF9E                                  JMP     \1
                              ENDIF
                      ;                       ;  TIME$=string
                      ;                       ;  ------------
94BF                  varSetTime_Dollar                                       ; L968E
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
94BF  3341                            LEAU    1,U                             ; skip '$'
94C1                                  CALL    styZP_TXTPTR2_skipSpacesExectEqEvalExp
94C1                  9
94C3                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94C1  BD98A4                                  JSR     \1
                              ENDIF
94C4  9627                            LDA     ZP_VARTYPE
94C6  1026FBA1                        LBNE    brkTypeMismatch                 ;  If not string, jump to Type mismatch
94CA  860F                            LDA     #$0F                            ;  A = $0F for Write RTC
94CC  D636                            LDB     ZP_STRBUFLEN
94CE  8E05FF                          LDX     #BASWKSP_STRING-1               ;  Store string length as subfunction
94D1  E784                            STB     ,X                              ;  Point to StringBuf-1                         ; TODO: CHECK this overwrites &05FF!
94D3  20E7                            BRA     L968B                           ;  Call OSWORD, return to execution loop
                              ENDIF
94D5                  evalstackStringExpectINTCloseBracket                    ; L96A4
94D5                                  CALL    StackString
94D5                  9
94D7                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94D5  BDB7F4                                  JSR     \1
                              ENDIF
94D8                  evalL1BracketAlreadyOpenConvert2INT                             ; L96A7
94D8                                  CALL    evalL1BracketAlreadyOpen
94D8                  9
94DA                  __XBSR                  SET 9B+2
1500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0084                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94D8  BDAA5E                                  JSR     \1
                              ENDIF
94DB  2012                            BRA     checkTypeInAConvert2INT
94DD                  checkCommaThenEvalAtYcheckTypeInAConvert2INT            ; L96AC
94DD                                  CALL    skipSpacesCheckCommaAtYOrBRK
94DD                  9
94DF                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94DD  BD8F1E                                  JSR     \1
                              ENDIF
                      
94E0                  evalAtYcheckTypeInAConvert2INT                          ; L96AF
94E0                                  CALL    evalAtY
94E0                  9
94E2                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94E0  BD9A41                                  JSR     \1
                              ENDIF
94E3  200A                            BRA     checkTypeInAConvert2INT
                      
94E5                  evalLevel1checkTypeStoreAsINT
94E5                                  CALL    evalLevel1
94E5                  9
94E7                  __XBSR                  SET 9B+2
1500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94E5  BDA9F0                                  JSR     \1
                              ENDIF
94E8  2005                            BRA     checkTypeInAConvert2INT
                      ;                       ;  Evaluate =<integer>
                      ;                       ;  ===================
94EA                  evalAssignEqInteger                                     ; L96B9
94EA                                  CALL styZP_TXTPTR2_skipSpacesExectEqEvalExp                     ;  Check for '=', evaluate expression
94EA                  9
94EC                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94EA  BD98A4                                  JSR     \1
                              ENDIF
94ED                  checkTypeInZP_VARTYPEConvert2INT                ; L96BC
94ED  9627                            LDA ZP_VARTYPE                  ;  Get type and ensure is an integer
                      ;               
                      ;                       ;  Convert real to integer
                      ;                       ;  -----------------------
                                              ;  new API:
                                              ;  expect type in A
                                              ;  convert item to ZP_INT_WA
                      ;; - REMOVE THIS fpTAYcheckTypeInAConvert2INT (expected type in A)
                      ;; - REMOVE THIS fpcheckTypeInAConvert2INT (expected type in Y)
                      ;;;             TAY                                     ;  Copy type to Y to set flags
94EF                  checkTypeInAConvert2INT
94EF  4D                              TSTA
94F0  1027FB77                        LBEQ    brkTypeMismatch
94F4  2A0B                            BPL     anRTS                           ;  If string, error; if already integer, return
                                      
94F6                  fpReal2Int      
94F6                                  CALL    fpAMant2Int                     ;  Convert real to integer
94F6                  9
94F8                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94F6  BD860C                                  JSR     \1
                              ENDIF
94F9                  fpCopyAmant2intWA
94F9  DC31                            LDD     ZP_FPA + 3
94FB  DD2A                            STD     ZP_INT_WA
94FD  DC33                            LDD     ZP_FPA + 5
94FF  DD2C                            STD     ZP_INT_WA + 2
9501  39              anRTS           RTS
                      ;JUMPBrkTypeMismatch2:
                      ;               JUMP brkTypeMismatch
                      ;
9502                  evalLevel1ConvertReal
9502                                  CALL     evalLevel1
9502                  9
9504                  __XBSR                  SET 9B+2
1400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9502  BDA9F0                                  JSR     \1
                              ENDIF
9505                  checkTypeIntToReal
9505  4D                              TSTA
9506  1027FB61                        LBEQ     brkTypeMismatch
950A  2BF5                            BMI     anRTS
950C                                  JUMP     IntToReal
950C  7E856A                                  JMP     \1
                      ;               
                      ;               
950F                  cmdPROC
                      
                      ;;;                     ;  PROC
950F  DF19                            STU     ZP_TXTPTR2
9511  86F2                            LDA     #tknPROC
9513                                  CALL    doFNPROCcall
9513                  9
9515                  __XBSR                  SET 9B+2
1700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9513  BDACF6                                  JSR     \1
                              ENDIF
                      
9516                                  CALL    scanNextStmtFromY
9516                  9
9518                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9516  BD98F4                                  JSR     \1
                              ENDIF
9519                                  JUMP    continue
9519  7E8FE2                                  JMP     \1
951C                  L96FB
                      ;;              LDU #$03
                      ;;              LDA #$00
                      ;;              STA (ZP_INT_WA),Y
951C  9E2C                            LDX     ZP_INT_WA + 2           ; get var pointer
951E  6F02                            CLR     2,X                     ; store 0 in top byte of next var pointer
9520  201D                            BRA     L971F
9522                  cmdLOCAL
9522  118C01FB                        CMPS    #MACH_STACK_TOP - 5             ; Check if stack is "empty"
9526  2421                            BHS     brkNotLOCAL
9528                                  CALL    findVarOrAllocEmpty
9528                  9
952A                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9528  BD96B1                                  JSR     \1
                              ENDIF
952B  2719                            BEQ     L972F
952D                                  CALL    localVarAtIntA
952D                  9
952F                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
952D  BDAE1F                                  JSR     \1
                              ENDIF
9530  0D2A                            TST     ZP_INT_WA
9532  2BE8                            BMI     L96FB
9534                                  CALL    pushVarPtrAndType
9534                  9
9536                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9534  BDB7E8                                  JSR     \1
                              ENDIF
9537                                  CALL    varFALSE
9537                  9
9539                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9537  BDA89D                                  JSR     \1
                              ENDIF
953A  9727                            STA     ZP_VARTYPE
953C                                  CALL    storeEvaledExpressioninStackedVarPTr
953C                  9
953E                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
953C  BDAFBB                                  JSR     \1
                              ENDIF
953F  6C64            L971F           INC     4, S                    ; DB inc SP + 6
                      ;;              LDU     ZP_TXTOFF2
                      ;;              STU     ZP_TXTOFF
9541                                  CALL    skipSpacesCheckCommaAtYStepBack
9541                  9
9543                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9541  BD8D4E                                  JSR     \1
                              ENDIF
9544  27DC                            BEQ     cmdLOCAL                
9546                  L972F           JUMP    scanNextContinue
9546  7E8FDF                                  JMP     \1
9549                  brkNotLOCAL                                             ; L9732
9549                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9549  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
954A  0C4E6F7420EA00                  FCB     $0C, "Not ", tknLOCAL, 0
9551                  brkBadMode                                              ; L9739
9551                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9551  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9552  19                              FCB     $19
9553  42616420EB00                    FCB     "Bad ", tknMODE, 0
                      
                      
9559                  cmdGCOL                                                 ; L9741
9559                                  CALL    evalForceINT
9559                  9
955B                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9559  BD9221                                  JSR     \1
                              ENDIF
955C  962D                            LDA     ZP_INT_WA + 3
955E  3402                            PSHS    A
9560                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
9560                  9
9562                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9560  BD94DD                                  JSR     \1
                              ENDIF
9563                                  CALL    scanNextStmtFromY
9563                  9
9565                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9563  BD98F4                                  JSR     \1
                              ENDIF
9566  8612                            LDA     #$12
9568  BDFFEE                          JSR     OSWRCH
956B  3502                            PULS    A
956D  2038                            BRA     L979B
956F                  cmdCOLOUR
                      ;                       ;  COLOUR
956F                                  CALL    evalForceINT
956F                  9
9571                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
956F  BD9221                                  JSR     \1
                              ENDIF
9572                                  CALL    scanNextStmtFromY
9572                  9
9574                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9572  BD98F4                                  JSR     \1
                              ENDIF
9575  8611                            LDA     #$11
9577  202E                            BRA     L979B
9579                  cmdMode                 ; L975F!
                      
9579                                  CALL    evalForceINT
9579                  9
957B                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9579  BD9221                                  JSR     \1
                              ENDIF
957C                                  CALL    scanNextStmtFromY
957C                  9
957E                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
957C  BD98F4                                  JSR     \1
                              ENDIF
                              IF FLEX != 1                                            ; TODOFLEX - assuming that this either has no effect or we're on the TUBE?
957F  BDB998                          JSR     OSByte82
9582  3001                            LEAX    1,X
9584  261D                            BNE     L9797                                   ; machine high order address != $FFFF, skip memory clash check
9586  9E04                            LDX     ZP_BAS_SP
9588  9C06                            CMPX    ZP_HIMEM                                ; check if basic stack is at HIMEM
958A  26C5                            BNE     brkBadMode                              ; else "BAD MODE"
958C                                  LDX_B   ZP_INT_WA + 3                           ; mode # low byte as got by eval
958C  3406                    PSHS    D
958E  D62D                    LDB     \1
9590  8600                    LDA     #0      ;DB: changed as CLRA resets carry!
9592  1F01                    TFR     D,X
9594  3506                    PULS    D
9596  8685                            LDA     #$85
9598  BDFFF4                          JSR     OSBYTE                                  ; get mode HIMEM address in X
959B  9C02                            CMPX    ZP_VARTOP                               ; if below VARTOP
959D  25B2                            BLO     brkBadMode                              ; "BAD MODE"
959F  9F06                            STX     ZP_HIMEM
95A1  9F04                            STX     ZP_BAS_SP
95A3                  L9797
                              ENDIF
95A3  0F1E                            CLR     ZP_PRLINCOUNT
95A5  8616                            LDA     #$16
95A7                  L979B
95A7  BDFFEE                          JSR     OSWRCH
95AA  962D                            LDA     ZP_INT_WA + 3           ; not - got least sig byte
95AC  204E                            BRA     OSWRCH_then_continue
                      
95AE                  cmdMOVE                 ; L97A2!
95AE  8604                            LDA     #$04
95B0  2002                            BRA     doMOVE_DRAW
                      
95B2                  cmdDRAW                 ; L97A6!
95B2  8605                            LDA     #$05
95B4                  doMOVE_DRAW                                             ; fpFPAeq_sqr_FPA
95B4  3402                            PSHS    A
95B6                                  CALL    evalExpressionMAIN
95B6                  9
95B8                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95B6  BD9A41                                  JSR     \1
                              ENDIF
95B9                                  CALL    checkTypeInZP_VARTYPEConvert2INT
95B9                  9
95BB                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95B9  BD94ED                                  JSR     \1
                              ENDIF
95BC  200A                            BRA     doPLOT2
                      
95BE                  cmdPLOT
95BE                                  CALL    evalForceINT
95BE                  9
95C0                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95BE  BD9221                                  JSR     \1
                              ENDIF
95C1  962D                            LDA     ZP_INT_WA + 3
95C3  3402                            PSHS    A                               ; push plot code
95C5                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
95C5                  9
95C7                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0016                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95C5  BD94DD                                  JSR     \1
                              ENDIF
95C8                  doPLOT2                                                 ; L97BA
95C8                                  CALL    stackINT_WAasINT
95C8                  9
95CA                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95C8  BDB7DA                                  JSR     \1
                              ENDIF
95CB                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
95CB                  9
95CD                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95CB  BD94DD                                  JSR     \1
                              ENDIF
95CE                                  CALL    scanNextStmtFromY
95CE                  9
95D0                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0024                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95CE  BD98F4                                  JSR     \1
                              ENDIF
95D1  8619                            LDA     #$19
95D3  BDFFEE                          JSR     OSWRCH
95D6  3502                            PULS    A
95D8  BDFFEE                          JSR     OSWRCH
95DB                                  CALL    popIntAtZP_GEN_PTRNew
95DB                  9
95DD                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
009F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95DB  BDB87C                                  JSR     \1
                              ENDIF
95DE  963A                            LDA     ZP_GEN_PTR + 3
95E0  BDFFEE                          JSR     OSWRCH
95E3  9639                            LDA     ZP_GEN_PTR + 2
95E5  BDFFEE                          JSR     OSWRCH
95E8                                  CALL    doVDUChar_fromWA3
95E8                  9
95EA                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
95E8  8D64                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
95EA  962C                            LDA     ZP_INT_WA + 2
95EC  200E                            BRA     OSWRCH_then_continue
                      
                      ;                       ;  CLG - Clear graphics window
                      ;                       ;  ---------------------------
95EE                  cmdCLG                                                  ; L97E0!
95EE                                  CALL    scanNextStmtFromY               ;  Check end of statement
95EE                  9
95F0                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95EE  BD98F4                                  JSR     \1
                              ENDIF
95F1  8610                            LDA     #$10
95F3  2007                            BRA     OSWRCH_then_continue            ;  Jump to do VDU 16
                      
                      ;                       ;  CLS - Clear text window
                      ;                       ;  -----------------------
95F5                  cmdCLS                  ; L97E7!
95F5                                  CALL    scanNextStmtFromY               ;  Check end of statement
95F5                  9
95F7                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95F5  BD98F4                                  JSR     \1
                              ENDIF
95F8  0F1E                            CLR     ZP_PRLINCOUNT
95FA  860C                            LDA     #$0C                            ;  Clear COUNT, do VDU 12
95FC                  OSWRCH_then_continue                                    ; L97EE
95FC  BDFFEE                          JSR OSWRCH                              ;Send to VDU
95FF                  L97F1           JUMP continue                           ;Return to execution loop
95FF  7E8FE2                                  JMP     \1
9602                  cmdREPORT
9602                                  CALL    scanNextStmtFromY
9602                  9
9604                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9602  BD98F4                                  JSR     \1
                              ENDIF
9605                                  CALL    PrintCRclearPRLINCOUNT
9605                  9
9607                  __XBSR                  SET 9B+2
2000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9605  BDB6BE                                  JSR     \1
                              ENDIF
9608  9EFD                            LDX     ZP_MOS_ERROR_PTR_QRY
960A  3001                            LEAX    1,X                             ; skip error number
                      
960C                  cmdREPORTlp                                             ;L97FC:
960C  A680                            LDA     ,X+
960E  1027F9D0                        LBEQ    continue
9612                                  CALL    doListPrintTokenA
9612                  9
9614                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9612  BDB8A1                                  JSR     \1
                              ENDIF
9615  20F5                            BRA     cmdREPORTlp
9617                  doVDUChar_fromWA32                              ;L9808:
9617  962C                            LDA ZP_INT_WA + 2
9619  BDFFEE                          JSR OSWRCH
961C                  cmdVDU                                         ; L980D!       ;  VDU
961C                                  CALL    skipSpacesY
961C                  9
961E                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
961C  BD8F0C                                  JSR     \1
                              ENDIF
961F                  1                                               ;L9810:
961F  813A                            CMPA    #':'
9621  2728                            BEQ     skVDUend
9623  810D                            CMPA    #$0D
9625  2724                            BEQ     skVDUend
9627  818B                            CMPA    #tknELSE
9629  2720                            BEQ     skVDUend
962B  335F                            LEAU    -1,U
962D                                  CALL    evalForceINT
962D                  9
962F                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
962D  BD9221                                  JSR     \1
                              ENDIF
9630                                  CALL    doVDUChar_fromWA3
9630                  9
9632                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9630  8D1C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9632                                  CALL    skipSpacesCheckCommaAtY
9632                  9
9634                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9632  BD8D48                                  JSR     \1
                              ENDIF
9635  27E5                            BEQ     cmdVDU
9637  813B                            CMPA    #';'
9639  27DC                            BEQ     doVDUChar_fromWA32
963B  817C                            CMPA    #'|'
963D  26E0                            BNE     1B
963F  8600                            LDA     #$00
9641  C609                            LDB     #$09
9643                  2                                       ;L9835:
9643  BDFFEE                          JSR     OSWRCH
9646  5A                              DECB
9647  26FA                            BNE     2B
9649  20D1                            BRA     cmdVDU
964B                  skVDUend                                                ;L983D
964B                                  JUMP    decYGoScanNextContinue
964B  7E8FDD                                  JMP     \1
964E                  doVDUChar_fromWA3                                       ;L9840:
964E  962D                            LDA     ZP_INT_WA + 3
9650  7EFFEE                          JMP     OSWRCH
                      
                      
9653  3440            allocFNPROC     PSHS    U
9655  DE39                            LDU     ZP_GEN_PTR+2
9657  A641                            LDA     1,U                             ; get token
                      
9659  C6F6                            LDB     #BASWKSP_DYNVAR_off_PROC        ; set A to offset of var list in page 4
965B  81F2                            CMPA    #tknPROC
965D  270B                            BEQ     __allocVARint
965F  C6F8                            LDB     #BASWKSP_DYNVAR_off_FN
9661  2007                            BRA     __allocVARint
                      
                                      ; Allocate a dynamic variable 
                                      ; on entry ZP_GEN_PTR => variable name -1
                                      ; ZP_NAMELENORVT contains the length of the variable name
                      
9663  3440            allocVAR        PSHS    U
9665  DE39                            LDU     ZP_GEN_PTR+2
9667  E641                            LDB     1,U
9669  58                              ASLB                            ; get variable offset in page 4
966A                  __allocVARint
966A  8604                            LDA     #BASWKSP_INTVAR / 256
966C  1F03                            TFR     D,U                             ; Y points at DYN var head
966E                  __allocVARint_lp1
966E  DF3D                            STU     ZP_INT_WA_C                     ; look for tail of the current list
9670  6DC4                            TST     0,U                             ; if high byte of next addr = 0 then at end of list
9672  2704                            BEQ     _allocVARint_sk1
9674  EEC4                            LDU     ,U                              ; jump to next pointer
9676  20F6                            BRA     __allocVARint_lp1@lp1
9678                  _allocVARint_sk1
9678  9E02                            LDX     ZP_VARTOP
967A  AFC4                            STX     ,U                              ; store pointer to next var block in old tail ptr
967C  6F80                            CLR     ,X+
967E  6F80                            CLR     ,X+
9680  C602                            LDB     #2                              
9682  D137                            CMPB    ZP_NAMELENORVT                  ; equal to 2, don't store name
9684  270D                            BEQ     _allocVARint_sk2
9686  DE39                            LDU     ZP_GEN_PTR+2
9688  3342                            LEAU    2,U
968A                  _allocVARint_lp2
968A  A6C0                            LDA     ,U+
968C  A780                            STA     ,X+
968E  5C                              INCB
968F  D137                            CMPB    ZP_NAMELENORVT
9691  26F7                            BNE     _allocVARint_lp2
9693                  _allocVARint_sk2
9693  35C0                            PULS    U,PC
                      ;               
                      ;               
                      ;                       ;  Allocate space for variable at top of heap
                      ;                       ;  ------------------------------------------
                                              ; On entry B points after end of name (at 0 marker to be stored)
                                              ;          A contains the number of bytes to store for end of name byte and variable
                                              ; Trashes X  
9695                  AllocVarSpaceOnHeap                                     ; L9883
9695  9E02                            LDX     ZP_VARTOP
9697  3A                              ABX
9698  6F80            allheap_lp1     CLR     ,X+                             ;  (ZP_VARTOP)=>top of heap
969A  4A                              DECA
969B  26FB                            BNE     allheap_lp1                     ;  Put terminating zero and empty parameter block
969D                  CheckVarFitsX                                           ;L988B API change (Expected to add Y to ZP_VARTOP)
969D  9C04                            CMPX    ZP_BAS_SP
969F  2509                            BLO     allheap_sk_ok
                                                                              ;L989F:
96A1  9E3D                            LDX     ZP_INT_WA_C                     ; Remove this variable from heap
96A3  6F84                            CLR     0,X
96A5  6F01                            CLR     1,X                             ; by removing link from previous variable
96A7                                  JUMP    brkNoRoom                       ; Jump to No room error
96A7  7E907B                                  JMP     \1
96AA                  allheap_sk_ok                                           ;L98A8:
96AA  9F02                            STX     ZP_VARTOP                       ; Update VARTOP
96AC                  anRTS10
96AC  39                              RTS
                      ;
                      ;
                      
96AD                  L98AB           CALL    AllocVarSpaceOnHeap             
96AD                  9
96AF                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
96AD  8DE6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
96AF  DE19                            LDU     ZP_TXTPTR2
96B1                  findVarOrAllocEmpty
96B1  DF19                            STU     ZP_TXTPTR2
96B3                                  CALL    findVarAtYSkipSpaces
96B3                  9
96B5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
96B3  8D48                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
96B5  261F                            BNE     anRTS6
96B7  251D                            BCS     anRTS6
96B9  DE19                            LDU     ZP_TXTPTR2
96BB                                  CALL    allocVAR
96BB                  9
96BD                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
96BB  8DA6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
96BD  8605                            LDA     #$05
96BF  912A                            CMPA    ZP_INT_WA + 0
96C1  26EA                            BNE     L98AB
96C3  4C                              INCA
96C4  20E7                            BRA     L98AB
                      
96C6                  findVARTreatAsMemoryAccess                                      ;L98C1
96C6  8121                            CMPA  #'!'
96C8  270D                            BEQ   memacc32                          ; Jump to do !<addr>
96CA  8124                            CMPA  #'$'
96CC  2715                            BEQ   memaccStr                         ; Jump to do $<addr>
96CE  883F                            EORA  #'?'
96D0  2707                            BEQ   memacc8                           ; Jump to do ?<addr>
96D2  8600                            LDA   #$00
96D4                                  SEC                             ; Return EQ/CS for invalid name
96D4  1A01                    ORCC    #CC_C
96D6  39              anRTS6          RTS
                      
96D7                  memacc32                                                ;L98D1:
96D7  8602                            LDA     #VAR_TYPE_INT_LE                ; Little-endian integer
96D9                  memacc8                                                 ;L98D3:
96D9  3402                            PSHS    A                               ; 0 for byte on entry unless fallen through from memacc32
96DB                                  CALL    evalLevel1checkTypeStoreAsINT
96DB                  9
96DD                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96DB  BD94E5                                  JSR     \1
                              ENDIF
96DE  DF19                            STU     ZP_TXTPTR2
96E0                                  JUMP    popAasVarType
96E0  7E97A4                                  JMP     \1
96E3                  memaccStr                                               ; L98DC
96E3                                  CALL    evalLevel1checkTypeStoreAsINT
96E3                  9
96E5                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96E3  BD94E5                                  JSR     \1
                              ENDIF
96E6  962C                            LDA     ZP_INT_WA + 2                   ; if pointer at zero page fail with RANGE TODO: Is this valid on 6809?
96E8  2709                            BEQ     brkRange
96EA  DF19                            STU     ZP_TXTPTR2
96EC  8680                            LDA     #VAR_TYPE_STRING_STAT
96EE  972A                            STA     ZP_INT_WA + 0
96F0                                  SEC
96F0  1A01                    ORCC    #CC_C
96F2  39                              RTS
96F3                  brkRange                                                ;L98EB:
96F3                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
96F3  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
96F4  08242072616E676500                 FCB  $08, "$ range", 0
                      
                      ;                       ;  Find Variable
                      ;                       ;  =============
                      ;                       ;  On entry, PTRA (ZP_TXTPTR),ZP_TXTOFF=>variable name
                      ;                       ;            'variable name' can be:
                      ;                       ;            '?value' '!value' '$value' 'variable' 'variable?value' 'variable!value'
                      ;                       ;  On exit,  ZP_INT_WA=>data
                      ;                       ;            ZP_INT_WA + 2  = type
                      ;                       ;  EQ   CC      not found
                                              ;  EQ   CS      invalid name
                                              ;  NE   CS      found, dynamic string
                                              ;  NE   CC      found other
                      ;findVarAtPTRA
                      ;               LDU     ZP_TXTPTR
                      ;               STU     ZP_TXTPTR2
96FD                  findVarLp1
96FD                  findVarAtYSkipSpaces                                    ; L9901;
96FD  A6C0                            LDA     ,U+
96FF  8120                            CMPA    #' '
9701  27FA                            BEQ     findVarLp1                      ; Skip spaces
9703                  findVarAtYMinus1                                                ; L9909
                      ;               LEAX    -1,Y                            ; TODO - tidy this up!
                      ;               STX     ZP_TXTPTR2                      ; save pointer needed to try again in skfindVarDynamic
9703  8140                            CMPA    #'@'
9705  25BF                            BLO     findVARTreatAsMemoryAccess      ; <'@', not a variable, check for indirection
9707  815B                            CMPA    #'['
9709  241A                            BHS     skfindVarDynamic                ; >'Z', look for dynamic variable
970B  48                              ASLA
970C  48                              ASLA
970D  972D                            STA     ZP_INT_WA + 3                   ; Multiply by 4 in case <uc>% variable
970F  A6C4                            LDA     0,U                             ; Get next character
9711  8125                            CMPA    #'%'
9713  2610                            BNE     skfindVarDynamic                ; Not <uc>%, jump to look for dynamic variable
9715  8604                            LDA     #BASWKSP_INTVAR / 256
9717  972C                            STA     ZP_INT_WA + 2                   ; High byte of static variable address
                      ;;              LDA     #VAR_TYPE_INT                   ; both == 4
9719  972A                            STA     ZP_INT_WA + 0                   ; Type=Integer
971B  3341                            LEAU    1,U
971D  A6C4                            LDA     ,U                              ; Get next character
971F  8128                            CMPA    #'('                            ; check to see if it was an array access after all  
9721  2655                            BNE     findVarCheckForIndirectAfter
9723  335F                            LEAU    -1,U
                      ;                       ;  Not <uc>%(, so jump to check <uc>%!n and <uc>%?n
                      ;                       ;  Look for a dynamic variable
                      ;                       ;  ---------------------------
9725                  skfindVarDynamic
9725  C605                            LDB     #$05
9727  D72A                            STB     ZP_INT_WA + 0
                      ;               LDU     ZP_TXTPTR2
9729  305E                            LEAX    -2,U
972B  9F39                            STX     ZP_GEN_PTR+2                    ;  $37/8=>1 byte BEFORE start of variable name
972D  C601                            LDB     #1                              ; variable name length
                      ;               LEAU    1,Y
972F  A65F                            LDA     -1,U                            ; re-get first char
9731  8141                            CMPA    #'A'
9733  2419                            BHS     findVarDyn_sk2
9735  8130                            CMPA    #'0'
9737  2521                            BLO     findVarDyn_skEnd
9739  813A                            CMPA    #'9'+1
973B  241D                            BHS     findVarDyn_skEnd
973D                  findVarDyn_lp                                           ; L9959
973D  5C                              INCB
973E  A6C0                            LDA     ,U+
9740  8141                            CMPA    #'A'
9742  240A                            BHS     findVarDyn_sk2
9744  8130                            CMPA    #'0'
9746  2512                            BLO     findVarDyn_skEnd
9748  813A                            CMPA    #'9'+1
974A  25F1                            BLO     findVarDyn_lp
974C  200C                            BRA     findVarDyn_skEnd
974E                  findVarDyn_sk2                                          ; L996B
974E  815B                            CMPA    #'Z'+1
9750  25EB                            BLO     findVarDyn_lp
9752  815F                            CMPA    #'_'
9754  2504                            BLO     findVarDyn_skEnd
9756  817B                            CMPA    #'z'+1
9758  25E3                            BLO     findVarDyn_lp
975A                  findVarDyn_skEnd                                        ; L9977
975A  C101                            CMPB    #$01                            ; B = len + 1
975C  2727                            BEQ     findVarDyn_skInvalid            ; Checked length=1, invalid name, exit
975E  8124                            CMPA    #'$'
9760  274F                            BEQ     findVarDyn_gotDollar            ; String variable
9762  8125                            CMPA    #'%'
9764  2605                            BNE     findVarDyn_skNotInt             ; Not integer variable
9766  0A2A                            DEC     ZP_INT_WA + 0                   ; Set type=4 - Integer
9768  5C                              INCB
9769  A6C0                            LDA     ,U+                             ; Get next character
976B                  findVarDyn_skNotInt                                     ; L9989
976B  8128                            CMPA    #'('
976D  273E                            BEQ     findVarDyn_skArray              ; Jump if array
976F  335F                            LEAU    -1,U
9771                                  CALL    findVarDynLL_NewAPI
9771                  9
9773                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0026                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9771  BD8499                                  JSR     \1
                              ENDIF
9774  2713                            BEQ     findVarDyn_skNotFound           ; Search for variable, exit if not found
9776                  findVarDyn_skGotArrayTryInd                             ; L9994
9776  A6C4                            LDA     ,U                              ; Get next character
9778                  findVarCheckForIndirectAfter                            ; L9998
9778  8121                            CMPA    #'!'
977A  270F                            BEQ     findVarIndWord                  ; Jump for <var>!...
977C  883F                            EORA    #'?'
977E  270D                            BEQ     findVarIndByte                  ; Jump for <var>?...
9780                                  CLC
9780  1CFE                    ANDCC   #~CC_C
9782  DF19                            STU     ZP_TXTPTR2                      ; Update PTRB offset
                                      ;;LDA   #$FF
9784  39                              RTS                                     ; NE/CC = variable found
9785                  findVarDyn_skInvalid                                    ; L99A6
9785  4F                              CLRA
9786                                  SEC
9786  1A01                    ORCC    #CC_C
9788  39                              RTS                                     ; EQ/CS = invalid variable name
9789                  findVarDyn_skNotFound
9789  4F                              CLRA
978A  39                              RTS                                     ;  EQ/CC = valid name, not found
                      
                      ;               <var>!...
978B                  findVarIndWord                                          ; L99AE:
978B  8602                            LDA     #VAR_TYPE_INT_LE
                                      ;  <var>?...
978D                  findVarIndByte                                          ;L99B0:
978D  3402                            PSHS    A
978F                                  CALL    GetVarValNewAPI
978F                  9
9791                  __XBSR                  SET 9B+2
1600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
978F  BDAE3F                                  JSR     \1
                              ENDIF
9792                                  CALL    checkTypeInAConvert2INT
9792                  9
9794                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9792  BD94EF                                  JSR     \1
                              ENDIF
9795  9E2C                            LDX     ZP_INT_WA + 2
9797  3410                            PSHS    X
9799  3341                            LEAU    1,U
979B                                  CALL    evalLevel1checkTypeStoreAsINT
979B                  9
979D                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
979B  BD94E5                                  JSR     \1
                              ENDIF
979E  3506                            PULS    D
97A0  D32C                            ADDD    ZP_INT_WA + 2
97A2  DD2C                            STD     ZP_INT_WA + 2                           ; add stacked and eval'd addresses
97A4                  popAasVarType                                                 ;L99CE
97A4  3502                            PULS    A
97A6  972A                            STA     ZP_INT_WA + 0                           ;  Store returned type
97A8                                  CLC
97A8  1CFE                    ANDCC   #~CC_C
97AA  86FF                            LDA     #$FF
97AC  39                              RTS                                             NE/CC = variable found
                      
                      
                      ;                       ;  array(
                      ;                       ;  ------
97AD                  findVarDyn_skArray
97AD                                  CALL findVarDyn_Subscripts                      ;  get array element address
97AD                  9
97AF                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0027                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
97AD  8D27                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
97AF  20C5                            BRA findVarDyn_skGotArrayTryInd                 ;  Check for array()!... and array()?...
97B1                  findVarDyn_gotDollar
97B1  0A2A                            DEC     ZP_INT_WA + 0   ; set type to int? and return that 
97B3  5C                              INCB
97B4  A6C0                            LDA     ,U+
97B6  8128                            CMPA    #'('
97B8  2710                            BEQ     findVarDyn_skArrayStr           ; got an array
97BA  335F                            LEAU    -1,U
97BC                                  CALL    findVarDynLL_NewAPI
97BC                  9
97BE                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97BC  BD8499                                  JSR     \1
                              ENDIF
97BF  27C8                            BEQ     findVarDyn_skNotFound
97C1                  findVarDyn_retDynStr                                    ; L99EB
97C1  DF19                            STU     ZP_TXTPTR2
97C3  8681                            LDA     #VAR_TYPE_STRING_DYN
97C5  972A                            STA     ZP_INT_WA + 0
97C7                                  SEC
97C7  1A01                    ORCC    #CC_C
97C9  39                              RTS
97CA                  findVarDyn_skArrayStr                                   ; L99F1
97CA                                  CALL    findVarDyn_Subscripts
97CA                  9
97CC                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
97CA  8D0A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
97CC  20F3                            BRA     findVarDyn_retDynStr
97CE                  brkArray                                                ; L99F6
97CE                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
97CE  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
97CF  0E417272617900                  FCB     $0E, "Array", 0
                      
                      
                                              ;  Process array dimensions
                                              ;  ------------------------
                                              ;  new API
                                              ;  On entry,    B=1 + length of name
                                              ;               [ZP_GEN_PTR+2]+1=>first character of name
                                              ;               [ZP_INT_WA + 0]=type
                                              ;  On exit,     ZP_INT_WA+2 and X => data block for cell
                                              ;  ------------------------
                                              ;  old API
                                              ;  On entry,    [ZP_GEN_PTR],Y=>'('
                                              ;               ZP_INT_WA + 2=type
                                              ;  On exit,     ZP_INT_WA =>data block
                                              ;
                                              ;  DIM r(100)                           r(37)=val           ->   r(37)
                                              ;  DIM r(100,200)                       r(37,50)=val        ->   r(37*100+50)
                                              ;  DIM r(100,200,300)                   r(37,50,25)=val     ->  r((37*100+50)*200+25)
                                              ;  DIM r(100,200,300,400)               r(37,50,25,17)=val  -> r(((37*100+50)*200+25)*300+17)
                                              ;
97D6                  findVarDyn_Subscripts                                   ; L99FE
97D6  5C                              INCB
                      ;               INY                                     ; Step past '('
97D7                                  CALL findVarDynLL_NewAPI
97D7                  9
97D9                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97D7  BD8499                                  JSR     \1
                              ENDIF
97DA  27F2                            BEQ brkArray                            ; If not found, generate error
97DC  D62A                            LDB     ZP_INT_WA + 0
                      
97DE  A680                            LDA     ,X+                             ; Get offset to data (number of dimensions)*2+1
97E0  44                              LSRA
97E1  4A                              DECA
97E2  3416                            PSHS    D,X                             ; push type and pointer to array data ()
97E4  6FE2                            CLR     ,-S
97E6  6FE2                            CLR     ,-S
                      
                      
                                      ; stack now contains
                      
                                      ;       +4              pointer to DIM block
                                      ;       +3              var type (size 4/5)
                                      ;       +2              data offset (counter) i.e. n (not 2*n+1)
                                      ;       +0              0 (accumulator for previous subscript calc)
                      
97E8  6D62                            TST     2,S
97EA  273A                            BEQ     findVarDyn_Subscripts_one
97EC                  findVarDyn_Subscripts_lp
97EC  2733                            BEQ     findVarDyn_Subscripts_last
97EE                                  CALL    evalAtYcheckTypeInAConvert2INT  ;  Evaluate integer expression
97EE                  9
97F0                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97EE  BD94E0                                  JSR     \1
                              ENDIF
97F1  E6C0                            LDB     ,U+
97F3  C12C                            CMPB    #','
97F5  26D7                            BNE     brkArray                        ;  If not ',', error as must be some more dimensions
97F7                  findVarDynCalc_one_subs
97F7  AE64                            LDX     4,S
97F9                                  CALL    findVarDyn_SubsCheck
97F9                  9
97FB                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
97F9  8D3A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
97FB  EC81                            LDD     ,X++                            ; get current DIM subscript
97FD                                  CALL    cmdDIM_mul_D_by_S               ; multiply accumulator by row size
97FD                  9
97FF                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97FD  BD935F                                  JSR     \1
                              ENDIF
9800  D32C                            ADDD    ZP_INT_WA + 2                   ; add current subscript
9802  2543                            BCS     brkSubscript
9804  2B41                            BMI     brkSubscript
9806  EDE4                            STD     ,S
9808  AF64                            STX     4,S
980A  6A62                            DEC     2,S                             ; decrement subscripts counter
980C  2ADE                            BPL     findVarDyn_Subscripts_lp
980E                  findVarDyn_SubsDone
                                      ; we're done
980E  E663                            LDB     3,S                             ; cell data size
9810  D72A                            STB     ZP_INT_WA + 0                   ; restore var type
9812  4F                              CLRA
9813                                  CALL    cmdDIM_mul_D_by_S               ; multiply acc by size of cells for byte offset
9813                  9
9815                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9813  BD935F                                  JSR     \1
                              ENDIF
9816  3410                            PSHS    X                               ; use X as base of cells
9818  E3E4                            ADDD    ,S                              ; add cell byte offset
981A  3268                            LEAS    8,S                             ; unstack workspace
981C  DD2C                            STD     ZP_INT_WA + 2
981E  9E2C                            LDX     ZP_INT_WA + 2
9820  39                              RTS
                      
                      
9821                  findVarDyn_Subscripts_last
9821                                  CALL    evalL1BracketAlreadyOpenConvert2INT     ; final subscript
9821                  9
9823                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9821  BD94D8                                  JSR     \1
                              ENDIF
9824  20D1                            BRA     findVarDynCalc_one_subs
                      
9826                  findVarDyn_Subscripts_one
9826                                  CALL    evalL1BracketAlreadyOpenConvert2INT     ; final subscript
9826                  9
9828                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9826  BD94D8                                  JSR     \1
                              ENDIF
9829  AE64                            LDX     4,S
982B                                  CALL    findVarDyn_SubsCheck
982B                  9
982D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
982B  8D08                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
982D  DC2C                            LDD     ZP_INT_WA + 2
982F  EDE4                            STD     ,S
9831  3002                            LEAX    2,X
9833  20D9                            BRA     findVarDyn_SubsDone
                      
9835                  findVarDyn_SubsCheck
9835  962C                            LDA     ZP_INT_WA + 2
9837  84C0                            ANDA    #$C0
9839  9A2A                            ORA     ZP_INT_WA + 0
983B  9A2B                            ORA     ZP_INT_WA + 1
983D  2608                            BNE     brkSubscript
983F  DC2C                            LDD     ZP_INT_WA + 2
9841  10A384                          CMPD    ,X                              ; check against subscript in var block
9844  2401                            BHS     brkSubscript
9846  39                              RTS
9847                  brkSubscript
9847                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9847  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9848  0F53756273637269707400                 FCB     $0F, "Subscript", 0
                      
9853                  fnProcScanYplus1varname
9853  C601                            LDB     #$01
                                      * API:
                                      *       On Entry
                                      *               Y points at 1 before the string to be scanned
                                      *               B points at first char after ZP_GEN_PTR to be checked
                                      *       On Exit
                                      *               B index of char after last matching
                                      *               A contains unmatched char (may be "%","$","(")
                                      *               X points at char after last matching
                                      ; scans chars that are allowed in variable names
9855                  fnProcScanYplusBvarname
9855  4F                              CLRA
9856  30CB                            LEAX    D,U
9858                  1               
9858  A680                            LDA     ,X+
985A  8130                            CMPA    #'0'
985C  2517                            BLO     L9B16
985E  8140                            CMPA    #'@'
9860  240B                            BHS     L9B0E
9862  813A                            CMPA    #'9'+1
9864  240F                            BHS     L9B16
9866  C101                            CMPB    #1      ; don't allow numbers as char 1 (note when called with a FN/PROC B is 2 on entry!)
9868  270B                            BEQ     L9B16
986A                  L9B0A
986A  5C                              INCB
986B  26EB                            BNE     1B
986D                  L9B0E
986D  815F                            CMPA    #'_'
986F  2405                            BHS     L9B17
9871  815A                            CMPA    #'Z'
9873  23F5                            BLS     L9B0A
9875                  L9B16
9875  39                              RTS
9876                  L9B17
9876  817A                            CMPA    #'z'
9878  23F0                            BLS     L9B0A
987A  39                              RTS
                      ;               
                      ;               
                                      ; API changed used to scan from ZP_TXTPTR now scan from Y
987B                  skipSpacesDecodeLineNumberNewAPI
                                      ;               LDU     ZP_TXTPTR
987B                                  CALL    skipSpacesY
987B                  9
987D                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
987B  BD8F0C                                  JSR     \1
                              ENDIF
987E  818D                            CMPA    #tknLineNo
9880  2706                            BEQ     decodeLineNumber
9882  335F                            LEAU    -1,U
9884  DF0B                            STU     ZP_TXTPTR
9886  2019                            BRA     __rtsCLC                                ;  Not line number, return CC
9888                  decodeLineNumber
9888  A6C0                            LDA     ,U+
988A  48                              ASLA
988B  48                              ASLA
988C  1F89                            TFR     A,B
988E  84C0                            ANDA    #$C0
9890  A8C0                            EORA    ,U+
9892  972D                            STA     ZP_INT_WA + 3
9894  1F98                            TFR     B,A
9896  48                              ASLA
9897  48                              ASLA
9898  A8C0                            EORA    ,U+
989A  972C                            STA     ZP_INT_WA + 2
989C  DF0B                            STU     ZP_TXTPTR
989E                                  SEC
989E  1A01                    ORCC    #CC_C
98A0  39                              RTS
                      ;                       ;  Line number, return CS
98A1                  __rtsCLC
98A1                                  CLC
98A1  1CFE                    ANDCC   #~CC_C
98A3  39                              RTS
                      ;                       ;  Expression Evaluator
                      ;                       ;  ====================
                      ;                       ;  ExpectEquals - evalute =<expr>
                      ;                       ;  ------------------------------
98A4                  styZP_TXTPTR2_skipSpacesExectEqEvalExp
98A4  DF19                            STU     ZP_TXTPTR2
                      ;;              LDA ZP_TXTPTR
                      ;;              STA ZP_TXTPTR2
                      ;;              LDA ZP_TXTPTR + 1
                      ;;              STA ZP_TXTPTR2 + 1
                      ;;              LDA ZP_TXTOFF
                      ;;              STA ZP_TXTOFF2
98A6                  skipSpacesExpectEqEvalExp                               ; L9B52
98A6                                  CALL    skipSpacesPTRB                  ;  Skip spaces
98A6                  9
98A8                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98A6  BD8F0A                                  JSR     \1
                              ENDIF
98A9  813D                            CMPA    #'='
98AB  2731                            BEQ     evalAtYExpectColonElseCRThenRTS ;  '=' found, evaluate following expression
98AD                  brkMistake
98AD                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
98AD  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
98AE  04                              FCB  $04
98AF  4D697374616B6500                 FCB  "Mistake", 0
98B7                  brkSyntax
98B7                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
98B7  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
98B8  10                              FCB  $10
98B9  53796E746178206572726F7200                 FCB  "Syntax error", 0
98C6                  brkNoPROC
98C6                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
98C6  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
98C7  0D                              FCB  $0D
98C8  4E6F20F200                      FCB  "No ", tknPROC, 0
98CD                  errEscape
98CD                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
98CD  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
98CE  11                              FCB  $11
98CF  45736361706500                  FCB  "Escape", 0
                                      
                      ;               
                      ;               
98D6                  skipToEqualsOrBRKY
98D6                                  CALL    skipSpacesY
98D6                  9
98D8                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98D6  BD8F0C                                  JSR     \1
                              ENDIF
98D9  813D                            CMPA    #'='
98DB  26D0                            BNE     brkMistake
98DD  39                              RTS
98DE                  evalAtYExpectColonElseCRThenRTS                         ; L9B8E
98DE                                  CALL    evalAtY
98DE                  9
98E0                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98DE  BD9A41                                  JSR     \1
                              ENDIF
98E1  2011                            BRA     scanNextStmtFromY
98E3                  LDUZP_TXTPTR2scanNextStmtFromY                          ; L9B96
98E3  DE19                            LDU     ZP_TXTPTR2                      ; restore Y from ZP_TXTPTR2 - eg after FN/PROCcall
98E5  200D                            BRA     scanNextStmtFromY
                      
                      ;               ;  ENDPROC
                      ;               ;  =======
98E7                  cmdENDPROC
98E7  118C01FB                        CMPS    #MACH_STACK_TOP - 5
98EB  24D9                            BHS     brkNoPROC                       ; Stack too empty, not in a PROC
98ED  B601FD                          LDA     MACH_STACK_TOP - 3              ; the PROC/FN token on the stack (below pushed Y)
98F0  81F2                            CMPA    #tknPROC
98F2  26D2                            BNE     brkNoPROC                       ; No PROC on the stack
                                                                              ; drop through to an RTS
                      ;scanNextStmt   LDU ZP_TXTPTR    -- obsolete?
98F4                  scanNextStmtFromY
98F4                                  CALL    skipSpacesYStepBack
98F4                  9
98F6                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98F4  BD8F15                                  JSR     \1
                              ENDIF
98F7                  scanNextExpectColonElseCR
98F7  813A                            CMPA    #':'
98F9  2708                            BEQ     1F                                      ;  colon, end of statement
98FB  810D                            CMPA    #$0D
98FD  2704                            BEQ     1F                                      ;  <cr>, end of statement
98FF  818B                            CMPA    #tknELSE
9901  26B4                            BNE     brkSyntax                               ;  Not correctly terminated, error
9903                  1
9903  DF0B            storeYasTXTPTR  STU     ZP_TXTPTR
9905                  checkForESC     
9905  6D9F0050                        TST     [ZP_ESCPTR]
9909  2BC2                            BMI     errEscape                               ;  Escape set, give Escape error
990B  39              anRTS9          RTS
                      
                      ;
                      ;
990C                  scanNextStmtAndTrace                                            ; L9BCF
990C                                  CALL    scanNextStmtFromY
990C                  9
990E                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
990C  8DE6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
990E  A6C0                            LDA     ,U+
9910  813A                            CMPA    #':'
9912  27F7                            BEQ     anRTS9
9914  1F30                            TFR     U,D
9916  8100                            CMPA    #BAS_InBuf
9918  1027F653                        LBEQ    immedPrompt
991C                  doTraceOrEndAtELSE                                              ; L9BDE
991C  ECC4                            LDD     ,U
991E  102BF64D                        LBMI    immedPrompt                             ; is end of program?
9922  0D20                            TST     ZP_TRACE                                ; got here it must be an 0d?
9924  2704                            BEQ     skNoTrace
9926  DD2C                            STD     ZP_INT_WA + 2                           ; store line # (big endian in ZP_INT_WA)
9928                                  CALL    doTRACE
9928                  9
992A                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9928  8D3B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
992A                  skNoTrace                                                       ;L9BF2:
                                                                                      ;L9BF4: -- check API
992A  3343                            LEAU    3,U                                     ; skip to next token (after line number)
                                                                                      ;L9BFD: -- check API
992C                  L9C01rts
992C  39                              RTS
992D                  cmdIF                   ; L9C08
992D                                  CALL    evalExpressionMAIN
992D                  9
992F                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0012                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
992D  BD9A41                                  JSR     \1
                              ENDIF
9930  1027F737                        LBEQ    brkTypeMismatch
9934  2A03                            BPL     skCmdIfNotReal
9936                                  CALL    fpReal2Int
9936                  9
9938                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9936  BD94F6                                  JSR     \1
                              ENDIF
9939                  skCmdIfNotReal                                          ; L9C12:
9939                                  CALL    IntWAZero
9939                  9
993B                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9939  BDB656                                  JSR     \1
                              ENDIF
993C  2718                            BEQ     skCmdIFFALSE
993E  C18C                            CMPB    #tknTHEN
9940  2703                            BEQ     skCmdIfTHEN
9942                                  JUMP    skipSpacesAtYexecImmed
9942  7E8FEA                                  JMP     \1
9945                  skCmdIfTHEN                                             ; L9C27:
9945  3341                            LEAU    1,U                             ; skip THEN token
9947                  execTHENorELSEimpicitGOTO                               ; L9C29 
9947                                  CALL    skipSpacesDecodeLineNumberNewAPI; look for line number
9947                  9
9949                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9947  BD987B                                  JSR     \1
                              ENDIF
994A  1024F69C                        LBCC    skipSpacesAtYexecImmed          ; if not found exec after THEN/ELSE
994E                                  CALL    findProgLineOrBRK
994E                  9
9950                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
994E  BDB494                                  JSR     \1
                              ENDIF
9951                                  CALL    checkForESC
9951                  9
9953                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9951  8DB2                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9953                                  JUMP    cmdGOTODecodedLineNumber
9953  7EB392                                  JMP     \1
9956                  skCmdIFFALSE                                            ; L9C37
                                                                              ; L9C39
9956  A6C0                            LDA     ,U+                             ; look for ELSE, if not found exec as next line
9958  818B                            CMPA    #tknELSE
995A  27EB                            BEQ     execTHENorELSEimpicitGOTO
995C  810D                            CMPA    #$0D
995E  26F6                            BNE     skCmdIFFALSE
9960  335F                            LEAU    -1,U
9962                                  JUMP    stepNextLineOrImmedPrompt
9962  7E8FA7                                  JMP     \1
9965                  doTRACE                                         ; L9C4B
                      
                                      ; line number is now in WA+2 - this needs changed
                      
9965  DC2C                            LDD     ZP_INT_WA + 2
9967  109321                          CMPD    ZP_MAXTRACLINE
996A  24C0                            BHS     L9C01rts
996C  865B                            LDA     #'['
996E                                  CALL    list_printANoEDIT
996E                  9
9970                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
996E  BDB8F3                                  JSR     \1
                              ENDIF
9971                                  CALL    int16print_AnyLen
9971                  9
9973                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9971  BD9D4C                                  JSR     \1
                              ENDIF
                      
9974  865D                            LDA     #']'
9976                                  CALL    list_printANoEDIT
9976                  9
9978                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9976  BDB8F3                                  JSR     \1
                              ENDIF
9979                                  JUMP    list_print1Space
9979  7EB8ED                                  JMP     \1
                      
997C                  evalDoComparePopIntFromMachineStackConvertToRealAndCompare
997C  3516                            PULS    D,X             ; get back stacked int
997E  9F2A                            STX     ZP_INT_WA
9980  DD2C                            STD     ZP_INT_WA + 2
9982                                  CALL    fpStackWAtoStackReal            ; stack LHS real
9982                  9
9984                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0036                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9982  BDB7BA                                  JSR     \1
                              ENDIF
9985                                  CALL    IntToReal                       ; convert INT_WA to real in FPA
9985                  9
9987                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9985  BD856A                                  JSR     \1
                              ENDIF
9988                                  CALL    fpCopyFPAtoFPB                  ; copy it to FPB
9988                  9
998A                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9988  BDA118                                  JSR     \1
                              ENDIF
998B                                  CALL    popFPFromStackToPTR1
998B                  9
998D                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0021                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
998B  BDB7AE                                  JSR     \1
                              ENDIF
998E                                  CALL    fpCopyPTR1toFPA         ; get back stacked LHS real
998E                  9
9990                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
998E  BDA213                                  JSR     \1
                              ENDIF
9991                                  CALL    evalDoCompareRealFPAwithFPB     ; compare
9991                  9
9993                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9991  8D17                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9993  3584                            PULS    B,PC                            ; get back stored token and finish
                      ;                       ;  <real> <compare> ...
                      ;                       ;  --------------------
                      
                                      ; API CHANGE - alter return CC to match behaviour of 6809
9995                  evalDoCompareReal                             ;L9C82
9995                                  CALL    fpStackWAtoStackReal
9995                  9
9997                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9995  BDB7BA                                  JSR     \1
                              ENDIF
9998                                  CALL    evalLevel4
9998                  9
999A                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9998  BD9B68                                  JSR     \1
                              ENDIF
999B  3404                            PSHS    B                               ; save B (next char)
999D                                  CALL    checkTypeIntToReal
999D                  9
999F                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0066                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
999D  BD9505                                  JSR     \1
                              ENDIF
99A0                                  CALL    popFPFromStackToPTR1
99A0                  9
99A2                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
99A0  BDB7AE                                  JSR     \1
                              ENDIF
99A3                                  CALL    evalDoCompareRealFPAwithPTR1
99A3                  9
99A5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
99A3  8D02                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
99A5  3584                            PULS    B,PC
                      
99A7                  evalDoCompareRealFPAwithPTR1                            ; L9C8F
99A7                                  CALL    fpMoveRealAtPTR1toFPB
99A7                  9
99A9                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
99A7  BDA1C2                                  JSR     \1
                              ENDIF
99AA                  evalDoCompareRealFPAwithFPB                             ; L9C92
99AA  8680                            LDA     #$80
99AC  943B                            ANDA    ZP_FPB
99AE  973B                            STA     ZP_FPB                  ; make FPB sign bit top bit only
99B0  962E                            LDA     ZP_FPA
99B2  8480                            ANDA    #$80                            ; same with FPA
99B4  913B                            CMPA    ZP_FPB                  ; compare
99B6  2614                            BNE     L9CBE
99B8  963C                            LDA     ZP_FPB + 1
99BA  9130                            CMPA    ZP_FPA + 2                      ;compare exponent
99BC  260F                            BNE     L9CBF                           ;if not equal return C,Z as is
99BE  DC3D                            LDD     ZP_FPB + 2                      ;otherwise compare matissa and swap C depeding on sign if NE
99C0  109331                          CMPD    ZP_FPA + 3
99C3  2608                            BNE     L9CBF
99C5  DC3F                            LDD     ZP_FPB + 4
99C7  109333                          CMPD    ZP_FPA + 5
99CA  2601                            BNE     L9CBF
99CC                  L9CBE
99CC  39                              RTS
99CD                  L9CBF
99CD  46                              RORA                                    ; C into top bit of A
99CE  983B                            EORA    ZP_FPB                  ; if -ve swap
99D0  49                              ROLA                                    ; put it back
99D1  8601                            LDA     #$01                            ; return NE, C
99D3  39                              RTS
99D4                  L9CC6brkTypeMismatch                                    ; L9CC9:
99D4                                  JUMP brkTypeMismatch
99D4  7E906B                                  JMP     \1
                      ;;evalDoCompareTypeInB                                                          ; TODO: can be deleted?
                      ;;              TFR     B,A                             ;  Pass type to A
                      
                                      ; API CHANGE - alter return CC to match behaviour of 6809, trashes B,X
99D7                  evalDoCompare                                           ; L9CCA
99D7  4D                              TSTA
99D8  2730                            BEQ     evalDoCompareString             ;  type=0, compare strings
99DA  2BB9                            BMI     evalDoCompareReal               ;  type<0, compare reals
99DC  9E2A                            LDX     ZP_INT_WA                       ; note reverse order with least sig 
99DE  DC2C                            LDD     ZP_INT_WA + 2                   ; bytes pulled first! this meakes thing simpler below
99E0  327F                            LEAS    -1,S                            ; reserving some stack space for storing after EVAL
99E2  3416                            PSHS    D,X                             ;  stack current int 
99E4                                  CALL    evalLevel4                      ;  Call Evaluator Level 4 - +, -
99E4                  9
99E6                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0082                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
99E4  BD9B68                                  JSR     \1
                              ENDIF
99E7  E764                            STB     4,S                             ; store B in reserved stack space
99E9  4D                              TSTA
99EA  27E8                            BEQ      L9CC6brkTypeMismatch;          ;  <int> <compare> <string> - Type mismatch
99EC  2B8E                            BMI      evalDoComparePopIntFromMachineStackConvertToRealAndCompare                             ;  <int> <compare> <real> - convert and compare
99EE  962A                            LDA      ZP_INT_WA + 0
99F0  8880                            EORA     #$80
99F2  972A                            STA      ZP_INT_WA + 0                  ; swap RHS sign bit
                                                              ;  Compare current integer with stacked integer
99F4  3506                            PULS    D
99F6  932C                            SUBD    ZP_INT_WA + 2
99F8  DD2C                            STD     ZP_INT_WA + 2   ; subtract least sig
99FA  3506                            PULS    D
99FC  D22B                            SBCB    ZP_INT_WA + 1
99FE  8880                            EORA    #$80
9A00  922A                            SBCA    ZP_INT_WA + 0   ; subtract most sig
9A02  9A2B                            ORA     ZP_INT_WA + 1
9A04  9A2C                            ORA     ZP_INT_WA + 2
9A06  9A2D                            ORA     ZP_INT_WA + 3   ; set Z if all 0
9A08  3584                            PULS    B,PC
                      
                                      ; API CHANGE - alter return CC to match behaviour of 6809
9A0A                  evalDoCompareString ;                                  ; L9D02
9A0A                                  CALL    StackString
9A0A                  9
9A0C                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A0A  BDB7F4                                  JSR     \1
                              ENDIF
9A0D                                  CALL    evalLevel4
9A0D                  9
9A0F                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0059                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A0D  BD9B68                                  JSR     \1
                              ENDIF
9A10  3444                            PSHS    B,U
9A12  4D                              TSTA
9A13  26BF                            BNE     L9CC6brkTypeMismatch
9A15  9E04                            LDX     ZP_BAS_SP
9A17  E684                            LDB     0,X                             ; get stacked string length
9A19  D136                            CMPB    ZP_STRBUFLEN                    ; get shortest length in ZP_GEN_PTR
9A1B  2302                            BLS     L9D13
9A1D  D636                            LDB     ZP_STRBUFLEN
9A1F                  L9D13
9A1F  D737                            STB     ZP_NAMELENORVT
9A21  5F                              CLRB
9A22  3001                            LEAX    1,X                             ; point X at 1st byte of stacked string
9A24  CE0600                          LDU     #BASWKSP_STRING                 ; point Y at LHS string
9A27                  L9D15
9A27  D137                            CMPB    ZP_NAMELENORVT                  ; compare strings
9A29  2709                            BEQ     L9D23
9A2B  5C                              INCB
9A2C  A680                            LDA     ,X+
9A2E  A1C0                            CMPA    ,U+
9A30  27F5                            BEQ     L9D15
9A32  2006                            BRA     L9D27
9A34                  L9D23
9A34  A69F0004                        LDA     [ZP_BAS_SP]                     ; if we got here the strings matched
9A38  9136                            CMPA    ZP_STRBUFLEN                    ; so compare lengths instead
9A3A                  L9D27
9A3A  3401                            PSHS    CC
9A3C                                  CALL    unstackString
9A3C                  9
9A3E                  __XBSR                  SET 9B+2
1100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A3C  BDAC0C                                  JSR     \1
                              ENDIF
9A3F  35C5                            PULS    CC,B,U,PC
                      ;                       ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      ;                       ; ;;                                                                       ;;
                      ;                       ; ;; EXPRESSION EVALUATOR                                                  ;;
                      ;                       ; ;; --------------------                                                  ;;
                      ;                       ; ;; Recursively calls seven expression levels, evaluating expressions at  ;;
                      ;                       ; ;; each level, looping within each level until all operators at that     ;;
                      ;                       ; ;; level are exhausted.                                                  ;;
                      ;                       ; ;;                                                                       ;;
                      ;                       ; ;; On entry, Y=>start of expression to evaluate                          ;;
                      ;                       ; ;; On exit,  Y=>first character after evaluated expression               ;;
                      ;                       ; ;;           $2A/B/C/D = returned value                                  ;;
                      ;                       ; ;;           A,ZP_VARTYPE=type                                           ;;
                      ;                       ; ;;             ZP_FPB + 5 - integer                              ;;
                      ;                       ; ;;                                                                       ;;
                      ;                       ; ;; Within the evaluator, B=next character, A=current type                ;;
                      ;                       ; ;; X trampled                                                            ;;
                      ;                       ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              ; internally changed so that next token is in B instead of X
9A41                  evalExpressionMAIN
                      ;               LDA ZP_TXTPTR
                      ;               STA ZP_TXTPTR2
                      ;               LDA ZP_TXTPTR + 1
                      ;               STA ZP_TXTPTR2 + 1
                      ;               LDA ZP_TXTOFF
                      ;               STA ZP_TXTOFF2
                      
                      ;                       ;  Evaluator Level 7 - OR, EOR
                      ;                       ;  ===========================
9A41                  evalAtY         CALL     evalLevel6                     ;  Call Level 6 Evaluator - AND
9A41                  9
9A43                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A41  8D51                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A43                  evalLevel7lp0
9A43  C184                            CMPB     #tknOR
9A45  2709                            BEQ      evalLevel7OR                   ;  Jump to do OR
9A47  C182                            CMPB     #tknEOR
9A49  2728                            BEQ      evalLevel7EOR                  ;  Jump to do EOR
9A4B  9727                            STA      ZP_VARTYPE
9A4D  335F                            LEAU     -1,U
9A4F  39                              RTS                                     ;  Store type in ZP_VARTYPE and return
                      ;                       ;  OR <numeric>
                      ;                       ;  ------------
9A50                  evalLevel7OR                                            ; L9D4C
9A50                                  CALL    INTevalLevel6
9A50                  9
9A52                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A50  8D3C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A52                                  CALL    checkTypeInAConvert2INT         ;  Stack integer, call Level 6 Evaluator, ensure integer
9A52                  9
9A54                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A52  BD94EF                                  JSR     \1
                              ENDIF
9A55  3404                            PSHS    B
9A57  9E04                            LDX     ZP_BAS_SP
9A59  EC84                            LDD     0,X
                              IF CPU_6309
                                      ORD     ZP_INT_WA+0
                              ELSE
9A5B  9A2A                            ORA     ZP_INT_WA+0
9A5D  DA2B                            ORB     ZP_INT_WA+1
                              ENDIF
9A5F  DD2A                            STD     ZP_INT_WA
9A61  EC02                            LDD     2,X
                              IF CPU_6309
                                      ORD     ZP_INT_WA+2
                              ELSE
9A63  9A2C                            ORA     ZP_INT_WA+2
9A65  DA2D                            ORB     ZP_INT_WA+3
                              ENDIF
9A67  DD2C                            STD     ZP_INT_WA+2
9A69                  evalL7unstackreturnInt_evalL7lp0                        ; L9D5F
9A69  3004                            LEAX    4,X                             ;  Drop integer from stack
9A6B  9F04                            STX     ZP_BAS_SP
9A6D  8640                            LDA     #$40
9A6F  3504                            PULS    B
9A71  20D0                            BRA     evalLevel7lp0                   ;  Integer result, jump to check for more OR/EORs
                      ;                       ;  EOR <numeric>
                      ;                       ;  -------------
9A73                  evalLevel7EOR                                           ; L9D4C
9A73                                  CALL    INTevalLevel6
9A73                  9
9A75                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A73  8D19                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A75                                  CALL    checkTypeInAConvert2INT         ;  Stack integer, call Level 6 Evaluator, ensure integer
9A75                  9
9A77                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A75  BD94EF                                  JSR     \1
                              ENDIF
9A78  3404                            PSHS    B
9A7A  9E04                            LDX     ZP_BAS_SP
9A7C  EC84                            LDD     0,X
                              IF CPU_6309
                                      EORD    ZP_INT_WA+0
                              ELSE
9A7E  982A                            EORA    ZP_INT_WA+0
9A80  D82B                            EORB    ZP_INT_WA+1
                              ENDIF
9A82  DD2A                            STD     ZP_INT_WA
9A84  EC02                            LDD     2,X
                              IF CPU_6309
                                      EORD    ZP_INT_WA+2
                              ELSE
9A86  982C                            EORA    ZP_INT_WA+2
9A88  D82D                            EORB    ZP_INT_WA+3
                              ENDIF
9A8A  DD2C                            STD     ZP_INT_WA+2
9A8C  20DB                            BRA     evalL7unstackreturnInt_evalL7lp0;  Jump to drop integer from stack and loop for more OR/EORs
                      
                      ;                       
                      ;                       ;  Integer Evaluate Level 6 - xxx OR/EOR yyy
                      ;                       ;  =========================================
9A8E                  INTevalLevel6                                           ; L9D7B
9A8E                                  CALL   checkTypeInAConvert2INT
9A8E                  9
9A90                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A8E  BD94EF                                  JSR     \1
                              ENDIF
9A91                                  CALL   stackINT_WAasINT                 ;  Ensure number is integer and push onto stack
9A91                  9
9A93                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A91  BDB7DA                                  JSR     \1
                              ENDIF
                      
                      ;                       ;  Evaluator Level 6 - AND
                      ;                       ;  =======================
9A94                  evalLevel6                                              ; L9D81 
9A94                                  CALL    evalLevel5                      ;  Call Evaluator Level 5 - < <= = >= > <>
9A94                  9
9A96                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A94  8D2E                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A96                  evalLevel6Lp0                                           ; ;L9D84:               
9A96  C180                            CMPB    #tknAND
9A98  2701                            BEQ     evalDoAND                       ;  Jump to do AND
9A9A  39                              RTS
                      ;                       ;  AND <numeric>
                      ;                       ;  -------------
9A9B                  evalDoAND                                               ; L9D89
9A9B                                  CALL     checkTypeInAConvert2INT
9A9B                  9
9A9D                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0052                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A9B  BD94EF                                  JSR     \1
                              ENDIF
9A9E                                  CALL     stackINT_WAasINT                ;  Ensure number is integer and push onto stack
9A9E                  9
9AA0                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A9E  BDB7DA                                  JSR     \1
                              ENDIF
9AA1                                  CALL    evalLevel5
9AA1                  9
9AA3                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0021                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9AA1  8D21                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9AA3                                  CALL    checkTypeInAConvert2INT         ;  Call Evaluator Level 5, ensure integer
9AA3                  9
9AA5                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9AA3  BD94EF                                  JSR     \1
                              ENDIF
                      
9AA6  3404                            PSHS    B
9AA8  9E04                            LDX     ZP_BAS_SP
9AAA  EC84                            LDD     0,X
                              IF CPU_6309
                                      ANDD    ZP_INT_WA+0
                              ELSE
9AAC  942A                            ANDA    ZP_INT_WA+0
9AAE  D42B                            ANDB    ZP_INT_WA+1
                              ENDIF
9AB0  DD2A                            STD     ZP_INT_WA
9AB2  EC02                            LDD     2,X
                              IF CPU_6309
                                      ANDD    ZP_INT_WA+2
                              ELSE
9AB4  942C                            ANDA    ZP_INT_WA+2
9AB6  D42D                            ANDB    ZP_INT_WA+3
                              ENDIF
9AB8  DD2C                            STD     ZP_INT_WA+2
9ABA  3004                            LEAX    4,X                             ;  Drop integer from stack
9ABC  9F04                            STX     ZP_BAS_SP
9ABE  8640                            LDA     #$40
9AC0  3504                            PULS    B
9AC2  20D2                            BRA     evalLevel6Lp0                   ;  Loop to check for more ANDs
                      
                      ;               ; Evaluator Level 5 - < <= = >= > <>
                      ;               ; ==================================
9AC4                  evalLevel5      CALL    evalLevel4                      ;  Call Evaluator Level 4 - +, -
9AC4                  9
9AC6                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9AC4  BD9B68                                  JSR     \1
                              ENDIF
9AC7  C13E                            CMPB    #'>'
9AC9  2204                            BHI     eval5rts                        ;  Not <,=,>, exit
9ACB  C13C                            CMPB    #'<'
9ACD  2401                            BHS     evalComparison          ;  <,=,>, evaluate comparison
9ACF  39              eval5rts        RTS
                      ;                       ;  <expression> <comparison> <expression>
                      ;                       ;  --------------------------------------
9AD0                  evalComparison
9AD0  2718                            BEQ     evalCompLt1                     ;  '<' - check for <, <=, <>
9AD2  C13E                            CMPB    #'>'
9AD4  2735                            BEQ     evalComplGt1                    ;  '>' - check for >, >=
9AD6                                  CALL    evalDoCompare                   ;  Must be '=', pass type to A, compare expressions
9AD6                  9
9AD8                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9AD6  BD99D7                                  JSR     \1
                              ENDIF
9AD9  2605                            BNE     evalCompRetFALSE                ;  LHS<>RHS, jump to return 0
9ADB                  evalCompRetTRUE                                 ;  L9DC1
9ADB  8EFFFF                          LDX    #$FFFF                   ;  LHS=RHS, Y = $FF to return -1
9ADE  2003                            BRA    1F
9AE0                  evalCompRetFALSE                                ; L9DC2
9AE0  8E0000                          LDX    #0
9AE3  9F2A            1               STX ZP_INT_WA
9AE5  9F2C                            STX ZP_INT_WA + 2
9AE7  8640                            LDA #$40
9AE9  39                              RTS
                      ;                       ;  Return integer
                      ;                       ;  <, <=, <>
                      ;                       ;  ---------
9AEA                  evalCompLt1                                     ;L9DCD:
9AEA  E6C0                            LDB     ,U+                     ;  Get next character
9AEC  C13D                            CMPB    #'='
9AEE  270D                            BEQ     evalCompLtEq1           ;  Jump with <=
9AF0  C13E                            CMPB    #'>'
9AF2  2710                            BEQ     evalComplNE             ;  Jump with <>
                      ;                       ;  Compare <
                      ;                       ;  ---------
9AF4  335F                            LEAU    -1,U
9AF6                                  CALL    evalDoCompare                   ;  Must be <, compare expressions
9AF6                  9
9AF8                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9AF6  BD99D7                                  JSR     \1
                              ENDIF
9AF9  25E0                            BLO     evalCompRetTRUE
9AFB  20E3                            BRA     evalCompRetFALSE                ;  < - TRUE, >= - FALSE
                      ;               
                      ;                       ;  Compare <=
                      ;                       ;  ----------
9AFD                  evalCompLtEq1                                   ;L9DE1:
                                      
9AFD                                  CALL    evalDoCompare           ;  Step past character, compare expressions
9AFD                  9
9AFF                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9AFD  BD99D7                                  JSR     \1
                              ENDIF
9B00  23D9                            BLS     evalCompRetTRUE         ;  < or = - TRUE
9B02  20DC                            BRA     evalCompRetFALSE
                      
                      ;                       ;  > - FALSE
                      ;                       ;  Compare <>
                      ;                       ;  ----------
9B04                  evalComplNE                                     ;L9DEC:
9B04                                  CALL    evalDoCompare           ;  Step past character, compare expressions
9B04                  9
9B06                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B04  BD99D7                                  JSR     \1
                              ENDIF
9B07  26D2                            BNE     evalCompRetTRUE
9B09  20D5                            BRA     evalCompRetFALSE
                      
                      ;                       ;  <> - TRUE, = - FALSE
                      ;                       ;  > or >=
                      ;                       ;  -------
9B0B                  evalComplGt1                                      ;L9DF5:
9B0B  E6C0                            LDB    ,U+                      ;  Get next character
9B0D  C13D                            CMPB   #'='
9B0F  2709                            BEQ    evalCompGE1              ;  Jump with >=
9B11  335F                            LEAU    -1,U
                      ;                       ;  Compare >
                      ;                       ;  ---------
9B13                                  CALL    evalDoCompare                   ;  Must be >, compare expressions
9B13                  9
9B15                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B13  BD99D7                                  JSR     \1
                              ENDIF
9B16  22C3                            BHI     evalCompRetTRUE                 ;  = - FALSE, > - TRUE
9B18  20C6                            BRA     evalCompRetFALSE
                      ;                       ;  < - FALSE
                      ;                       ;  Compare >=
                      ;                       ;  ----------
9B1A                  evalCompGE1                     ;L9E07:
9B1A                                  CALL    evalDoCompare                   ;  Step past character, compare expressions
9B1A                  9
9B1C                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B1A  BD99D7                                  JSR     \1
                              ENDIF
9B1D  24BC                            BHS     evalCompRetTRUE
9B1F  20BF                            BRA     evalCompRetFALSE                ;  >= - TRUE, < - FALSE
9B21                  brkStringTooLong
9B21                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9B21  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9B22  13537472696E6720746F6F206C6F6E6700                 FCB     $13, "String too long", 0
9B33                  evalL4StringPlus                                        ; L9E22
9B33                                  CALL    StackString                     ; stack current
9B33                  9
9B35                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B33  BDB7F4                                  JSR     \1
                              ENDIF
9B36                                  CALL    evalLevel2                      ; eval next phrase
9B36                  9
9B38                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B36  BD9D2F                                  JSR     \1
                              ENDIF
9B39  3444                            PSHS    B,U                             ; B contains next token
9B3B  4D                              TSTA                                    ; if not a string
9B3C  102600B1                        LBNE    __skbrkTypeMismatch             ; error
9B40  9E04                            LDX     ZP_BAS_SP
9B42  E684                            LDB     ,X                              ; get length of stacked
9B44  DB36                            ADDB    ZP_STRBUFLEN                    ; add length of current
9B46  25D9                            BCS     brkStringTooLong                ; if there's a carry its too big
9B48  D737                            STB     ZP_NAMELENORVT                  ; store combined len
                                      ; move current string (RH) along by the length of (LH)
9B4A  8E0600                          LDX     #BASWKSP_STRING
9B4D  3A                              ABX                                     ; X points to last char of combined string + 1
9B4E  3384                            LEAU    ,X                              ; stick it in Y
9B50  8E0600                          LDX     #BASWKSP_STRING                 
9B53  D636                            LDB     ZP_STRBUFLEN                    ; length of LH
9B55  3A                              ABX
9B56  A682            1               LDA     ,-X
9B58  A7C2                            STA     ,-U
9B5A  5A                              DECB
9B5B  26F9                            BNE     1B                              ; shift current string along
9B5D                                  CALL    popStackedStringNew             ; pop stacked string
9B5D                  9
9B5F                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B5D  BDB856                                  JSR     \1
                              ENDIF
9B60  D637                            LDB     ZP_NAMELENORVT
9B62  D736                            STB     ZP_STRBUFLEN
9B64  3544                            PULS    B,U                             ; pop next token
9B66  2003                            BRA     _skEvalLevel4_noLevel3
                      ;                       ;  Evaluator Level 4 - + -
                      ;                       ;  =======================
9B68                  evalLevel4                                              ; L9E4C
9B68                                  CALL    evalLevel3                      ;  Call Evaluator Level 3 - * / DIV MOD
9B68                  9
9B6A                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B68  BD9CE0                                  JSR     \1
                              ENDIF
9B6B                  _skEvalLevel4_noLevel3                                  ; L9E4F
9B6B  C12B                            CMPB    #'+'
9B6D  2705                            BEQ     evalL4Plus                      ;  Jump to do +
9B6F  C12D                            CMPB    #'-'
9B71  2757                            BEQ     evalL4Minus                     ;  Jump to do -
9B73  39                              RTS
                      ;                       ;  <expression> + <expression>
                      ;                       ;  ---------------------------
9B74                  evalL4Plus                                              ; L9E58
9B74  4D                              TSTA
9B75  27BC                            BEQ     evalL4StringPlus                ;  <string> +
9B77  2B26                            BMI     evalL4RealPlus                  ;  <real> +
9B79                                  CALL    stackIntThenEvalL3              ;  Stack integer, call Evaluator Level 3 - * / DIV MOD
9B79                  9
9B7B                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B79  BD9CDD                                  JSR     \1
                              ENDIF
9B7C  4D                              TSTA
9B7D  1027F4EA                        LBEQ    brkTypeMismatch                 ;  <int> + <string> - Type mismatch
9B81  2B3A                            BMI     evalL4IntPlusReal               ;  <int> + <real> - convert
9B83  3404                            PSHS    B
9B85  9E04                            LDX     ZP_BAS_SP
9B87  EC02                            LDD     2,X
9B89  D32C                            ADDD    ZP_INT_WA + 2
9B8B  DD2C                            STD     ZP_INT_WA + 2
9B8D  EC84                            LDD     ,X
                              IF CPU_6309
                                      ADCD    ZP_INT_WA
                              ELSE
9B8F  D92B                            ADCB    ZP_INT_WA + 1
9B91  992A                            ADCA    ZP_INT_WA + 0
                              ENDIF
9B93  DD2A                            STD     ZP_INT_WA
9B95  3504                            PULS    B
                      ;                       ;  Drop integer from stack and return integer
                      ;                       ;  ------------------------------------------
9B97                  evalL4PopIntStackReturnIntX                             ; L9E80
9B97  3004                            LEAX    4,X
9B99  9F04                            STX     ZP_BAS_SP
9B9B  8640                            LDA     #$40
9B9D  20CC                            BRA     _skEvalLevel4_noLevel3          ;  Update SP, loop to do any more +, -
                      
9B9F                  evalL4RealPlus                                          ;L9E94
9B9F                                  CALL    fpStackWAtoStackReal
9B9F                  9
9BA1                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B9F  BDB7BA                                  JSR     \1
                              ENDIF
9BA2                                  CALL    evalLevel3
9BA2                  9
9BA4                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BA2  BD9CE0                                  JSR     \1
                              ENDIF
9BA5  D727                            STB     ZP_VARTYPE
9BA7  4D                              TSTA
9BA8  1027F4BF                        LBEQ    brkTypeMismatch
9BAC  2B03                            BMI     L9EA4
9BAE                                  CALL    IntToReal
9BAE                  9
9BB0                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BAE  BD856A                                  JSR     \1
                              ENDIF
9BB1                  L9EA4           CALL    popFPFromStackToPTR1
9BB1                  9
9BB3                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BB1  BDB7AE                                  JSR     \1
                              ENDIF
9BB4                                  CALL    fpFPAeqPTR1addFPA
9BB4                  9
9BB6                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BB4  BDA343                                  JSR     \1
                              ENDIF
9BB7                  evalTokenFromVarTypeReturnReal                          ; L9EAA
9BB7  D627                            LDB     ZP_VARTYPE                      ; Get back saved token
9BB9  86FF                            LDA     #$FF
9BBB  20AE                            BRA _skEvalLevel4_noLevel3              ;  Loop to do any more +, -
                      
                      
                      
9BBD                  evalL4IntPlusReal                                       ; L9EB0
9BBD  D727                            STB     ZP_VARTYPE
9BBF                                  CALL    popIntANew
9BBF                  9
9BC1                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BBF  BDB86C                                  JSR     \1
                              ENDIF
9BC2                                  CALL    fpStackWAtoStackReal
9BC2                  9
9BC4                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BC2  BDB7BA                                  JSR     \1
                              ENDIF
9BC5                                  CALL    IntToReal
9BC5                  9
9BC7                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BC5  BD856A                                  JSR     \1
                              ENDIF
9BC8  20E7                            BRA     L9EA4
                      
                                      ;  <expression> - <expression>
                                      ;  ---------------------------
9BCA                  evalL4Minus                                             ; L9E58
9BCA  4D                              TSTA
9BCB  1027F49C                        LBEQ    brkTypeMismatch                 ;  <string> - Type mismatch
9BCF  2B23                            BMI     evalL4RealMinus                 ;  <real> -
9BD1                                  CALL    stackIntThenEvalL3
9BD1                  9
9BD3                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BD1  BD9CDD                                  JSR     \1
                              ENDIF
9BD4  4D                              TSTA                                    ;  Stack integer, call Evaluator Level 3 - * / DIV MOD
9BD5  1027F492                        LBEQ    brkTypeMismatch                 ;  <int> - <string> - Type mismatch
9BD9  2B31                            BMI     evalL4IntMinusReal              ;  <int> - <real> - convert
9BDB  3404                            PSHS    B
9BDD  9E04                            LDX     ZP_BAS_SP
9BDF  EC02                            LDD     2,X
9BE1  932C                            SUBD    ZP_INT_WA + 2
9BE3  DD2C                            STD     ZP_INT_WA + 2
9BE5  EC84                            LDD     0,X
                              IF CPU_6309
                                      SBCD    ZP_INT_WA + 0
                              ELSE
9BE7  D22B                            SBCB    ZP_INT_WA + 1
9BE9  922A                            SBCA    ZP_INT_WA + 0
                              ENDIF
9BEB  DD2A                            STD     ZP_INT_WA + 0
9BED  3504                            PULS    B
9BEF  20A6                            BRA evalL4PopIntStackReturnIntX         ;  Drop integer from stack and return
                      
9BF1                  __skbrkTypeMismatch
9BF1                                  JUMP brkTypeMismatch
9BF1  7E906B                                  JMP     \1
                      
                      
                      ;                       ;  <real> - <expression>
                      ;                       ;  ---------------------
9BF4                  evalL4RealMinus                                         ; L9EE7
9BF4                                  CALL    fpStackWAtoStackReal
9BF4                  9
9BF6                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BF4  BDB7BA                                  JSR     \1
                              ENDIF
9BF7                                  CALL    evalLevel3
9BF7                  9
9BF9                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BF7  BD9CE0                                  JSR     \1
                              ENDIF
9BFA  D727                            STB     ZP_VARTYPE
9BFC  4D                              TSTA
9BFD  27F2                            BEQ     __skbrkTypeMismatch
9BFF  2B03                            BMI     1F
9C01                                  CALL    IntToReal
9C01                  9
9C03                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C01  BD856A                                  JSR     \1
                              ENDIF
9C04                  1                                                       ; L9EF7
9C04                                  CALL    popFPFromStackToPTR1
9C04                  9
9C06                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C04  BDB7AE                                  JSR     \1
                              ENDIF
9C07                                  CALL    fpFPAeqPTR1subFPA
9C07                  9
9C09                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C07  BDA340                                  JSR     \1
                              ENDIF
9C0A  20AB                            BRA     evalTokenFromVarTypeReturnReal
                      
                      
9C0C                  evalL4IntMinusReal                                      ; L9EFF
9C0C  D727                            STB     ZP_VARTYPE                      ; preserve token
9C0E                                  CALL    popIntANew
9C0E                  9
9C10                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C0E  BDB86C                                  JSR     \1
                              ENDIF
9C11                                  CALL    fpStackWAtoStackReal
9C11                  9
9C13                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C11  BDB7BA                                  JSR     \1
                              ENDIF
9C14                                  CALL    IntToReal
9C14                  9
9C16                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C14  BD856A                                  JSR     \1
                              ENDIF
9C17                                  CALL    popFPFromStackToPTR1
9C17                  9
9C19                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0095                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C17  BDB7AE                                  JSR     \1
                              ENDIF
9C1A                                  CALL    fpFPAeqPTR1subFPAnegFPA
9C1A                  9
9C1C                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C1A  BDA983                                  JSR     \1
                              ENDIF
9C1D  2098                            BRA     evalTokenFromVarTypeReturnReal
9C1F                  L9F12
9C1F                                  CALL    IntToReal                       ; convert RHS to real and mult
9C1F                  9
9C21                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0049                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C1F  BD856A                                  JSR     \1
                              ENDIF
9C22                  L9F15                                                   ; convert LHS to real and mult
9C22                                  CALL    popIntANew
9C22                  9
9C24                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C22  BDB86C                                  JSR     \1
                              ENDIF
9C25                                  CALL    fpStackWAtoStackReal
9C25                  9
9C27                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C25  BDB7BA                                  JSR     \1
                              ENDIF
9C28                                  CALL    IntToReal
9C28                  9
9C2A                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0040                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C28  BD856A                                  JSR     \1
                              ENDIF
9C2B  200C                            BRA     L9F2D
9C2D                  eval3Mul_IntAsRealEvalAndMul                            ; L9F20
9C2D                                  CALL    IntToReal
9C2D                  9
9C2F                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C2D  BD856A                                  JSR     \1
                              ENDIF
9C30                  eval3Mul_StackRealEvalAndMul                    ; L9F23
9C30                                  CALL    fpStackWAtoStackReal
9C30                  9
9C32                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0088                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C30  BDB7BA                                  JSR     \1
                              ENDIF
9C33                                  CALL    evalLevel2                      ; call eval level 2
9C33                  9
9C35                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C33  BD9D2F                                  JSR     \1
                              ENDIF
9C36                                  CALL    checkTypeIntToReal
9C36                  9
9C38                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C36  BD9505                                  JSR     \1
                              ENDIF
9C39                  L9F2D           CALL    popFPFromStackToPTR1
9C39                  9
9C3B                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C39  BDB7AE                                  JSR     \1
                              ENDIF
9C3C                                  CALL    fpFPAeqPTR1mulFPA
9C3C                  9
9C3E                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C3C  BDA35C                                  JSR     \1
                              ENDIF
9C3F  86FF                            LDA     #$FF
9C41  E65F                            LDB     -1,U
9C43                                  JUMP    _skevalLevel3noLevel2
9C43  7E9CE2                                  JMP     \1
                                      
                                      ;  <expression> * <expression>
                                      ;  ---------------------------
9C46                  Eval3Mul
9C46  4D                              TSTA
9C47  27A8                            BEQ     __skbrkTypeMismatch             ; can't multiply a string
9C49  2BE5                            BMI     eval3Mul_StackRealEvalAndMul
9C4B  D62A                            LDB     ZP_INT_WA + 0
9C4D  D12B                            CMPB    ZP_INT_WA + 1                   ; if top two bytes of integer aren't the same
9C4F  26DC                            BNE     eval3Mul_IntAsRealEvalAndMul
9C51  962C                            LDA     ZP_INT_WA + 2
9C53  48                              ASLA
9C54  C900                            ADCB    #$00                            ; or top byte + MS bit of 2nd byte <> 0 
9C56  26D5                            BNE     eval3Mul_IntAsRealEvalAndMul                            ; do a real mult
9C58                                  CALL    stackINTEvalLevel2
9C58                  9
9C5A                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C58  BD9D2C                                  JSR     \1
                              ENDIF
9C5B  D727                            STB     ZP_VARTYPE                      ; save B
9C5D  4D                              TSTA
9C5E  2791                            BEQ     __skbrkTypeMismatch
9C60  2BC0                            BMI     L9F15
9C62  D62A                            LDB     ZP_INT_WA + 0
9C64  D12B                            CMPB    ZP_INT_WA + 1                   ; if top two bytes aren't the same then do real multiply
9C66  26B7                            BNE     L9F12                           ; convert to real both WA and stacked and do real
9C68  962C                            LDA     ZP_INT_WA + 2
9C6A  48                              ASLA                                    ; shift top bit of 2 into A (top byte)
9C6B  C900                            ADCB    #$00
9C6D  26B0                            BNE     L9F12
                      
                              IF CPU_6309
                                      LDX     ZP_BAS_SP
                                      LDD     ZP_INT_WA+2
                                      MULD    2,X
                                      STQ     0,X
                              ELSE
                                      ; work out what sign changes (if any) we need to do at the end and pop result from stack
9C6F  962A                            LDA     ZP_INT_WA + 0
9C71  A89F0004                        EORA    [ZP_BAS_SP]
9C75  9737                            STA     ZP_GEN_PTR                      ; ZP_GEN_PTR contains sign flip bit in bit 7
                      
                      
9C77                                  CALL    intWA_ABS                       ; ABS int 
9C77                  9
9C79                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0001                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C77  BDA97A                                  JSR     \1
                              ENDIF
9C7A  8E0039                          LDX     #ZP_GEN_PTR+2
9C7D                                  CALL    CopyIntWA2X                     ; and move to temp areas
9C7D                  9
9C7F                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C7D  BDB923                                  JSR     \1
                              ENDIF
9C80  9E04                            LDX     ZP_BAS_SP
9C82  EC84                            LDD     ,X
9C84  DD2A                            STD     ZP_INT_WA
9C86  EC02                            LDD     2,X
9C88  DD2C                            STD     ZP_INT_WA + 2                   ; retrieve int from U stack but leave room (we'll place result there)
9C8A                                  CALL    intWA_ABS                       ; ABS it
9C8A                  9
9C8C                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C8A  BDA97A                                  JSR     \1
                              ENDIF
                      
9C8D  4F                              CLRA
9C8E  5F                              CLRB
9C8F  ED84                            STD     0,X
9C91  ED02                            STD     2,X
                      
                                      ; now X points to B, WA contains A both only bottom 15 bits, multiply into 4 bytes at ZP_GEN_PTR+2
9C93  962D                            LDA     ZP_INT_WA + 3
9C95  2707                            BEQ     1F
9C97  D63C                            LDB     ZP_GEN_PTR + 5
9C99  2703                            BEQ     1F
9C9B  3D                              MUL
9C9C  ED02                            STD     2,X
                      
9C9E                  1               ; now contains two LSbytes multiplied together, multiply 2nd byte of A with LSB of B and add to acc
9C9E  962C                            LDA     ZP_INT_WA + 2
9CA0  270D                            BEQ     1F
9CA2  D63C                            LDB     ZP_GEN_PTR + 5
9CA4  2709                            BEQ     1F
9CA6  3D                              MUL
9CA7  E301                            ADDD    1,X
9CA9  ED01                            STD     1,X
9CAB  2402                            BCC     1F
9CAD  6C84                            INC     0,X
9CAF                  1
                                      ;  multiply 1st byte of A with 2nd byte of B and add to acc
9CAF  962D                            LDA     ZP_INT_WA + 3
9CB1  270D                            BEQ     1F
9CB3  D63B                            LDB     ZP_GEN_PTR + 4
9CB5  2709                            BEQ     1F
9CB7  3D                              MUL
9CB8  E301                            ADDD    1,X
9CBA  ED01                            STD     1,X
9CBC  2402                            BCC     1F
9CBE  6C84                            INC     0,X
9CC0                  1
                                      ;  multiply 2nd byte of A with 2nd byte of B and add to acc
9CC0  962C                            LDA     ZP_INT_WA + 2
9CC2  2709                            BEQ     1F
9CC4  D63B                            LDB     ZP_GEN_PTR + 4
9CC6  2705                            BEQ     1F
9CC8  3D                              MUL
9CC9  E384                            ADDD    0,X
9CCB  ED84                            STD     0,X
9CCD                  1
                              ENDIF ; 6809
                                      ; no check - this should never overflow!
                                      ; now U should contain ABS result
9CCD                                  CALL    popIntANew
9CCD                  9
9CCF                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CCD  BDB86C                                  JSR     \1
                              ENDIF
9CD0                  divmodNegateWAifZP_GEN_PTR
9CD0  0D37                            TST     ZP_GEN_PTR
9CD2                  divmodNegateWAifMI
9CD2  2A03                            BPL     1F
9CD4                                  CALL    negateIntA
9CD4                  9
9CD6                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CD4  BDA99B                                  JSR     \1
                              ENDIF
9CD7  8640            1               LDA     #$40
9CD9  D627            divmodfinish    LDB     ZP_VARTYPE
9CDB  2005                            BRA     _skevalLevel3noLevel2
                      
                      
                      
                      
                      ;                       ;  Evaluator Level 3 - * / DIV MOD
                      ;                       ;  ===============================
9CDD                  stackIntThenEvalL3                                      ; L9FC4
9CDD                                  CALL stackINT_WAasINT                   ;  Stack current integer
9CDD                  9
9CDF                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CDD  BDB7DA                                  JSR     \1
                              ENDIF
9CE0                  evalLevel3                                              ; L9FC7
9CE0                                  CALL    evalLevel2                      ;  Call Evaluator Level 2 - ^
9CE0                  9
9CE2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9CE0  8D4D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9CE2                  _skevalLevel3noLevel2                                   ; L9FCA
9CE2  C12A                            CMPB    #'*'
9CE4  1027FF5E                        LBEQ    Eval3Mul                        ;  Jump with *
9CE8  C12F                            CMPB    #'/'
9CEA  2709                            BEQ     evalL3DoRealDiv                 ;  Jump with /
9CEC  C183                            CMPB    #tknMOD
9CEE  271C                            BEQ     evalL3DoMOD                     ;  Jump with MOD
9CF0  C181                            CMPB    #tknDIV
9CF2  2725                            BEQ     evalL3DoDIV                             ;  Jump with DIV
9CF4  39                              RTS
                      ;                       ;  <expression> / <expression>
                      ;                       ;  ---------------------------
9CF5                  evalL3DoRealDiv                                         ; L9FDB
9CF5                                  CALL    checkTypeIntToReal
9CF5                  9
9CF7                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
000E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CF5  BD9505                                  JSR     \1
                              ENDIF
9CF8                                  CALL    fpStackWAtoStackReal            ; Error if string, ensure real, stack real
9CF8                  9
9CFA                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CF8  BDB7BA                                  JSR     \1
                              ENDIF
9CFB                                  CALL    evalLevel2                      ; Call Evaluator Level 2 - ^
9CFB                  9
9CFD                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9CFB  8D32                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9CFD  D727                            STB     ZP_VARTYPE                      ; save current token
9CFF                                  CALL    checkTypeIntToReal
9CFF                  9
9D01                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CFF  BD9505                                  JSR     \1
                              ENDIF
9D02                                  CALL    popFPFromStackToPTR1
9D02                  9
9D04                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D02  BDB7AE                                  JSR     \1
                              ENDIF
9D05                                  CALL    fpFPAeqPTR1divFPA
9D05                  9
9D07                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D05  BDA2A5                                  JSR     \1
                              ENDIF
9D08  86FF                            LDA     #$FF
9D0A  20CD                            BRA     divmodfinish
                      ;                       ;  <expression> MOD <expression>
                      ;                       ;  -----------------------------
9D0C                  evalL3DoMOD                                             ; L9FF5
9D0C                                  CALL    evalDoIntDivide
9D0C                  9
9D0E                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D0C  BD84E3                                  JSR     \1
                              ENDIF
9D0F  8E003D                          LDX     #ZP_INT_WA_C
9D12                                  CALL    intLoadWAFromX
9D12                  9
9D14                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D12  BDA76F                                  JSR     \1
                              ENDIF
9D15  9637                            LDA     ZP_GEN_PTR
9D17  20B9                            BRA     divmodNegateWAifMI
                      ;                       ;  <expression> DIV <expression>
                      ;                       ;  -----------------------------
9D19                  evalL3DoDIV                                             ; L9FFD
9D19                                  CALL    evalDoIntDivide
9D19                  9
9D1B                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D19  BD84E3                                  JSR     \1
                              ENDIF
9D1C  093C                            ROL     ZP_INT_WA_B + 3
9D1E  093B                            ROL     ZP_INT_WA_B + 2
9D20  093A                            ROL     ZP_INT_WA_B + 1
9D22  0939                            ROL     ZP_INT_WA_B + 0
9D24  8E0039                          LDX     #ZP_INT_WA_B
9D27                                  CALL    intLoadWAFromX
9D27                  9
9D29                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0046                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D27  BDA76F                                  JSR     \1
                              ENDIF
9D2A  20A4                            BRA     divmodNegateWAifZP_GEN_PTR
                      ;
                      ;                       ;  Evaluator Level 2 - ^
                      ;                       ;  =====================
9D2C                  stackINTEvalLevel2                                      ; LA00F
9D2C                                  CALL stackINT_WAasINT                   ; Stack current integer
9D2C                  9
9D2E                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D2C  BDB7DA                                  JSR     \1
                              ENDIF
9D2F                  evalLevel2                                              ; LA012
9D2F                                  CALL evalLevel1                         ; Call Evaluator Level 1 - everything else
9D2F                  9
9D31                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D2F  BDA9F0                                  JSR     \1
                              ENDIF
9D32                  evalLevel2again                                         ; LA015
9D32  E6C0            evalL2lp1       LDB     ,U+
9D34  C120                            CMPB    #' '
9D36  27FA                            BEQ     evalL2lp1                       ;  Skip spaces
9D38  C15E                            CMPB    #'^'
9D3A  2701                            BEQ     evalDoCARET                     ;  Jump with ^
9D3C  39                              RTS
                      ;                       ;  <expression> ^ <expression>
                      ;                       ;  ---------------------------
9D3D                  evalDoCARET                                             ;LA027:
9D3D                                  CALL checkTypeIntToReal
9D3D                  9
9D3F                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D3D  BD9505                                  JSR     \1
                              ENDIF
9D40                                  TODODEADEND "evalDo^"
9D40                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9D40  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9D41  7E443A                          FCB             $7E,"D:"
9D44  6576616C446F5E                  FCB             \1
9D4B  00                              FCB             0
                      ;               CALL fpStackWAtoStackReal
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA ZP_FPA + 2
                      ;               CMP #$87
                      ;               BCS LA079
                      ;               CALL L82E0
                      ;               BNE LA049
                      ;               CALL popFPFromStackToPTR1
                      ;               CALL fpCopyPTR1toFPA
                      ;               LDA ZP_FP_TMP + 6
                      ;               CALL LA5BE
                      ;               BRA LA075
                      ;LA049:
                      ;               CALL fpCopyFPA_FPTEMP3
                      ;               LDA ZP_BAS_SP
                      ;               STA ZP_FP_TMP_PTR1
                      ;               LDA ZP_BAS_SP + 1
                      ;               STA ZP_FP_TMP_PTR1 + 1
                      ;               CALL fpCopyPTR1toFPA
                      ;               LDA ZP_FP_TMP + 6
                      ;               CALL LA5BE
                      ;LA05C:
                      ;               LDA #$71
                      ;               CALL fpCopyFPA_X----check was 400+A
                      ;               CALL popFPFromStackToPTR1
                      ;               CALL fpCopyPTR1toFPA
                      ;               CALL fnLN_FPA
                      ;               CALL fpFPAeqFPTEMP3mulFPA
                      ;               CALL LA9E2
                      ;               LDA #$71
                      ;               CALL LA9A1
                      ;LA075:
                      ;               LDA #$FF
                      ;               BRA evalLevel2again
                      ;LA079:
                      ;               CALL fpCopyFPA_FPTEMP3
                      ;               CALL fpLoad1                    ;  FloatA=1.0
                      ;               BRA LA05C
                      
                      
                                      ; formats a 16 bit integer at ZP_INT_WA + 2 to a string
                                      ; NEW API
                                      ;       A contains preferred length or 0 for any
                                      ;       Y preserved
                                      ;       X preserved                                     TODO, needed?
                                      ;       ZP_INT_WA + 2 = 0                               TODO, needed?
                                      ;       returns with B = $FF
                      
                                      ; OLD API
                                      ;       A contains preferred length or 0 for any
                                      ;       Y preserved
                                      ;       ZP_INT_WA + 2 = 0
                                      ;       returns with X = $FF
                      
9D4C                  int16print_AnyLen                               ; LA081
9D4C  8600                            LDA     #$00
9D4E  2002                            BRA     int16print_fmtA
9D50                  int16print_fmt5                                 ; LA085
9D50  8605                            LDA     #$05
9D52                  int16print_fmtA                                 ; LA087
9D52  9714                            STA     ZP_PRINTBYTES
9D54  308DE3A4                        LEAX    tblTENS_BE, PCR         ; point at tens table
9D58  3440                            PSHS    U
9D5A  CE003F                          LDU     #ZP_FPB + 4
9D5D  DC2C                            LDD     ZP_INT_WA + 2
9D5F  6F44                            CLR     4,U
9D61  6F43                            CLR     3,U
9D63  6F42                            CLR     2,U
9D65  6F41                            CLR     1,U
9D67  6FC4                            CLR     0,U
                      
9D69  A308            int16dig4_lp    SUBD    8,X                     ; try and subtract ten
9D6B  2504                            BCS     int16dig4_sk
9D6D  6C44                            INC     4,U                     ; it it doesn't overflow increment digit
9D6F  20F8                            BRA     int16dig4_lp            
9D71  E308            int16dig4_sk    ADDD    8,X                     ; add number back
9D73  272C                            BEQ     int16dig_skiprest
                      
9D75  A306            int16dig3_lp    SUBD    6,X                     ; try and subtract ten
9D77  2504                            BCS     int16dig3_sk
9D79  6C43                            INC     3,U                     ; it it doesn't overflow increment digit
9D7B  20F8                            BRA     int16dig3_lp            
9D7D  E306            int16dig3_sk    ADDD    6,X                     ; add number back
9D7F  2720                            BEQ     int16dig_skiprest
                      
9D81  A304            int16dig2_lp    SUBD    4,X                     ; try and subtract ten
9D83  2504                            BCS     int16dig2_sk
9D85  6C42                            INC     2,U                     ; it it doesn't overflow increment digit
9D87  20F8                            BRA     int16dig2_lp            
9D89  E304            int16dig2_sk    ADDD    4,X                     ; add number back
9D8B  2714                            BEQ     int16dig_skiprest
                      
9D8D  A302            int16dig1_lp    SUBD    2,X                     ; try and subtract ten
9D8F  2504                            BCS     int16dig1_sk
9D91  6C41                            INC     1,U                     ; it it doesn't overflow increment digit
9D93  20F8                            BRA     int16dig1_lp            
9D95  E302            int16dig1_sk    ADDD    2,X                     ; add number back
9D97  2708                            BEQ     int16dig_skiprest
                      
9D99  A384            int16dig0_lp    SUBD    0,X                     ; try and subtract ten
9D9B  2504                            BCS     int16dig_skiprest
9D9D  6CC4                            INC     0,U                     ; it it doesn't overflow increment digit
9D9F  20F8                            BRA     int16dig0_lp            
                      
9DA1                  int16dig_skiprest
                      
                                      ; number now decoded (reversed at ZP_FPB + 4)
                      
                      
9DA1  C605                            LDB     #$05
9DA3                  int16_scan0_lp                                  ;LA0A8
9DA3  5A                              DECB                            ; scan for first non zero element
9DA4  2704                            BEQ     int16_scan0_sk
9DA6  A6C5                            LDA     B,U
9DA8  27F9                            BEQ     int16_scan0_lp
9DAA                  int16_scan0_sk                                  ;LA0AF:
9DAA  D737                            STB     ZP_GEN_PTR
9DAC  9614                            LDA     ZP_PRINTBYTES
9DAE  270B                            BEQ     int16_printDigits
9DB0  9037                            SUBA    ZP_GEN_PTR
9DB2  2707                            BEQ     int16_printDigits
9DB4  1F89                            TFR     A,B
9DB6                                  CALL    list_printBSpaces
9DB6                  9
9DB8                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0065                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DB6  BDB91D                                  JSR     \1
                              ENDIF
9DB9  D637                            LDB     ZP_GEN_PTR
9DBB                  int16_printDigits                               ;LA0BF:
9DBB  A6C5                            LDA     B,U
9DBD  8A30                            ORA     #$30
9DBF                                  CALL    list_printA
9DBF                  9
9DC1                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DBF  BDB8EF                                  JSR     \1
                              ENDIF
9DC2  5A                              DECB
9DC3  2AF6                            BPL     int16_printDigits
9DC5  35C0                            PULS    U,PC                    ; RTS restore Y
                      
                      
                      ;                       ;  Convert number to hex string
                      ;                       ;  ----------------------------
9DC7                  cmdPRINT_num2str_hex                                    ; LA0CA
9DC7  3440                            PSHS    U
9DC9  0D27                            TST     ZP_VARTYPE                      ; real?
9DCB  2A03                            BPL     1F                              ; no
9DCD                                  CALL    fpReal2Int                      ;  Convert real to integer
9DCD                  9
9DCF                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0027                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DCD  BD94F6                                  JSR     \1
                              ENDIF
9DD0                  1                                                       ; LA0D0:
9DD0  8E003F                          LDX     #ZP_FPB + 4
9DD3  CE002E                          LDU     #ZP_INT_WA + 4
9DD6  C604                            LDB     #4
9DD8  A6C2            1               LDA     ,-U                             ; unwind nibbles into a buffer
9DDA  840F                            ANDA    #$0F
9DDC  A780                            STA     ,X+
9DDE  A6C4                            LDA     ,U                              ; reload for low nibble
9DE0  44                              LSRA
9DE1  44                              LSRA
9DE2  44                              LSRA
9DE3  44                              LSRA
9DE4  A780                            STA     ,X+
9DE6  5A                              DECB
9DE7  26EF                            BNE     1B
9DE9  C607                            LDB     #7                              ; note skip at most 7, print 0 for 0!
9DEB                  1                                                       ; LA0EA
9DEB  A682                            LDA     ,-X                             ; skip leading 0's
9DED  2603                            BNE     1F
9DEF  5A                              DECB
9DF0  2AF9                            BPL     1B
9DF2                  1                                                       ; LA0F1
9DF2  810A                            CMPA    #10                             ; Get byte from workspace
9DF4  2502                            BLO     2F
9DF6  8B07                            ADDA    #'A'-'9'-1                      ; Convert byte to hex
9DF8                  2                                                       ; LA0F9
9DF8  8B30                            ADDA    #'0'
9DFA                                  CALL    cmdPRINT_num2str_storeA         ;  Convert to digit and store
9DFA                  9
9DFC                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DFA  BD9FE3                                  JSR     \1
                              ENDIF
9DFD  5A                              DECB
9DFE  2B04                            BMI     3F
9E00  A682                            LDA     ,-X
9E02  20EE                            BRA     1B
9E04  35C0            3               PULS    U,PC
                      
                      
                      ;                       ;  Loop for all digits
                      ;                       ;  Output nonzero real number
                      ;                       ;  --------------------------
9E06                  cmdPRINT_num2str_realNon0                               ; LA102
9E06  2A07                            BPL     cmdPRINT_num2str_realNon0_lp1   ;  Jump forward if positive
9E08  862D                            LDA     #'-'
9E0A  0F2E                            CLR     ZP_FPA                  ;  A='-', clear sign flag
9E0C                                  CALL    cmdPRINT_num2str_storeA                         ;  Add '-' to string buffer
9E0C                  9
9E0E                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E0C  BD9FE3                                  JSR     \1
                              ENDIF
9E0F                  cmdPRINT_num2str_realNon0_lp1                           ;LA10B:
9E0F  9630                            LDA     ZP_FPA + 2                      ;  Get exponent
9E11  8181                            CMPA    #$81
9E13  244B                            BCC     cmdPRINT_num2str_digit                  ;  If m*2^1 or larger, number>=1, jump to output it
9E15                                  CALL    fmMulBy10                       ;  FloatA=FloatA*10
9E15                  9
9E17                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E15  BDA136                                  JSR     \1
                              ENDIF
9E18  0A48                            DEC     ZP_FP_TMP + 5
9E1A  20F3                            BRA     cmdPRINT_num2str_realNon0_lp1   ;  Loop until number is >=1
                      
                      
                      ;                       ;  Convert numeric value to string
                      ;                       ;  ===============================
                      ;                       ;  On entry, FloatA ($2E-$35)   = number
                      ;                       ;            or IntA (ZP_INT_WA)= number
                      ;                       ;               ZP_VAR_TYPE     = type
                      ;                       ;               @%              = print format
                      ;                       ;               ZP_PRINTFLAG[7] = 1 if hex
                      ;                       ;  On exit,  StrA contains string version of number
                      ;                       ;
9E1C                  cmdPRINT_num2str                                        ; LA118
9E1C  F60401                          LDB     BASWKSP_INTVAR + 1              ;  Get @% format byte
9E1F  C103                            CMPB    #$03
9E21  2502                            BCS     cmdPRINT_num2str_skFMTOK        ;  Use it if valid
9E23  C600                            LDB     #$00
                      ;                       ;  If @% invalid, use General format
9E25                  cmdPRINT_num2str_skFMTOK                                ;LA121:
9E25  D737                            STB     ZP_GEN_PTR                      ; Store format type
9E27  B60402                          LDA     BASWKSP_INTVAR + 2              ; Num dec places
9E2A  2706                            BEQ     cmdPRINT_num2str_0dp            ; If digits is zero, check format
9E2C  810A                            CMPA    #$0A
9E2E  2406                            BCC     cmdPRINT_num2str_invaldp        ; If digits>10, jump to use 10 digits
9E30  2006                            BRA     cmdPRINT_num2str_dp_sk          ; Use this number of digits
9E32                  cmdPRINT_num2str_0dp                                    ; LA12E
9E32  C102                            CMPB    #$02
9E34  2702                            BEQ     cmdPRINT_num2str_dp_sk          ; If fixed format, use zero digits
9E36                  cmdPRINT_num2str_invaldp                                ; LA132
9E36  860A                            LDA     #$0A                            ; Otherwise, use ten digits
9E38                  cmdPRINT_num2str_dp_sk                                  ; LA134
9E38  9738                            STA     ZP_GEN_PTR + 1
9E3A  974D                            STA     ZP_FP_TMP + 10                  ;  Store digit length
9E3C  0F36                            CLR     ZP_STRBUFLEN
9E3E  0F48                            CLR     ZP_FP_TMP + 5                   ;  Set initial output to 0, initial exponent to 0
9E40  0D15                            TST     ZP_PRINTFLAG
9E42  2B83                            BMI     cmdPRINT_num2str_hex            ;  Jump for hex conversion
9E44  0D27                            TST     ZP_VARTYPE
9E46  2B03                            BMI     cmdPRINT_num2str_dec_sk1
9E48                                  CALL    IntToReal                       ;  Convert integer to real
9E48                  9
9E4A                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E48  BD856A                                  JSR     \1
                              ENDIF
9E4B                  cmdPRINT_num2str_dec_sk1                                ;LA146:
9E4B                                  CALL    fpCheckMant0SetSignExp0
9E4B                  9
9E4D                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E4B  BDA0FF                                  JSR     \1
                              ENDIF
9E4E  26B6                            BNE     cmdPRINT_num2str_realNon0       ; Get sign, jump if not zero to output nonzero number
9E50  9637                            LDA     ZP_GEN_PTR
9E52  10260084                        LBNE    cmdPRINT_num2str_fmtFixedOrExp0 ; If not General format, output fixed or exponential zero
9E56  8630                            LDA     #'0'
9E58                                  JUMP    cmdPRINT_num2str_storeA         ;  Store '0' and return
9E58  7E9FE3                                  JMP     \1
9E5B                  setFloatA1_cmdPRINT_num2str_digit
9E5B                                  CALL    fpLoad1                         ;  FloatA=1.0
9E5B                  9
9E5D                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0035                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E5B  BDA292                                  JSR     \1
                              ENDIF
9E5E  200F                            BRA     cmdPRINT_num2str_digit_sk2
                      
                      
                      ;                       ;  FloatA now is >=1, check that it is <10
                      ;                       ;  ---------------------------------------
9E60                  cmdPRINT_num2str_digit                                  ; LA15C
9E60  8184                            CMPA    #$84
9E62  250F                            BCS     cmdPRINT_num2str_digit_1_9      ; Exponent<4, FloatA<10, jump to convert it
9E64  2606                            BNE     cmdPRINT_num2str_digit_sk1      ; Exponent<>4, need to divide it
9E66  9631                            LDA     ZP_FPA + 3                      ; Get mantissa top byte
9E68  81A0                            CMPA    #$A0
9E6A  2507                            BCS     cmdPRINT_num2str_digit_1_9      ; Less than $A0, less than ten, jump to convert it
9E6C                  cmdPRINT_num2str_digit_sk1                              ; LA168:
9E6C                                  CALL    fpFloatADiv10                   ; FloatA=FloatA / 10
9E6C                  9
9E6E                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E6C  BDA16A                                  JSR     \1
                              ENDIF
9E6F                  cmdPRINT_num2str_digit_sk2                              ; LA16B:
9E6F  0C48                            INC     ZP_FP_TMP + 5                   ; incremenet exponent
9E71  209C                            BRA     cmdPRINT_num2str_realNon0_lp1
                      ;                       ;  Jump back to get the number >=1 again
                      ;                       ;  FloatA is now between 1 and 9.999999999
                      ;                       ;  ---------------------------------------
9E73                  cmdPRINT_num2str_digit_1_9                              ;LA16F:
9E73  9635                            LDA     ZP_FPA + 7
9E75  9727                            STA     ZP_VARTYPE
9E77                                  CALL    fpCopyFPA_FPTEMP1                               ;  Copy FloatA to FloatTemp at $27/$046C
9E77                  9
9E79                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E77  BDA1EC                                  JSR     \1
                              ENDIF
9E7A  964D                            LDA     ZP_FP_TMP + 10
9E7C  9738                            STA     ZP_GEN_PTR + 1                  ;  Get number of digits
9E7E  D637                            LDB     ZP_GEN_PTR                      ;  Get print format
9E80  C102                            CMPB    #$02
9E82  2612                            BNE     cmdPRINT_num2str_digit_1_9_sknf                         ;  Not fixed format, jump to do exponent/general
9E84                                  SEC
9E84  1A01                    ORCC    #CC_C
9E86  9948                            ADCA    ZP_FP_TMP + 5
9E88  2B54                            BMI     cmdPRINT_num2str_clearZeroFPAandPrintFMT2
9E8A  9738                            STA     ZP_GEN_PTR + 1
9E8C  810B                            CMPA    #$0B
9E8E  2506                            BCS     cmdPRINT_num2str_digit_1_9_sknf
9E90  860A                            LDA     #$0A
9E92  9738                            STA     ZP_GEN_PTR + 1
9E94  0F37                            CLR     ZP_GEN_PTR
9E96                  cmdPRINT_num2str_digit_1_9_sknf                         ; LA190
9E96                                  CALL    zero_FPA_sign_expO_manlo        ;  Clear FloatA
9E96                  9
9E98                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E96  BDA371                                  JSR     \1
                              ENDIF
9E99  86A0                            LDA     #$A0
9E9B  9731                            STA     ZP_FPA + 3
9E9D  8683                            LDA     #$83
9E9F  9730                            STA     ZP_FPA + 2
9EA1  D638                            LDB     ZP_GEN_PTR + 1
9EA3  270A                            BEQ     LA1A5
9EA5                  LA19F
9EA5  3404                            PSHS    B
9EA7                                  CALL    fpFloatADiv10                   ;  FloatA=FloatA/10
9EA7                  9
9EA9                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EA7  BDA16A                                  JSR     \1
                              ENDIF
9EAA  3504                            PULS    B
9EAC  5A                              DECB
9EAD  26F6                            BNE     LA19F
9EAF  8E046C          LA1A5           LDX     #BASWKSP_FPTEMP1                ;  Point to $46C
9EB2                                  CALL    fpMoveRealAtXtoFPB              ;  Unpack to FloatB
9EB2                  9
9EB4                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EB2  BDA1C4                                  JSR     \1
                              ENDIF
9EB5  9627                            LDA     ZP_VARTYPE
9EB7  9741                            STA     ZP_FPB + 6
9EB9                                  CALL    fpAddAtoBStoreA                         ;  Add
9EB9                  9
9EBB                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EB9  BD871E                                  JSR     \1
                              ENDIF
9EBC                  LA1B2
9EBC  9630                            LDA     ZP_FPA + 2
9EBE  8184                            CMPA    #$84
9EC0  240E                            BHS     LA1C6                           ; if >= $84
9EC2  0431                            LSR     ZP_FPA + 3
9EC4  0632                            ROR     ZP_FPA + 4
9EC6  0633                            ROR     ZP_FPA + 5
9EC8  0634                            ROR     ZP_FPA + 6
9ECA  0635                            ROR     ZP_FPA + 7
9ECC  0C30                            INC     ZP_FPA + 2
9ECE  26EC                            BNE     LA1B2
9ED0                  LA1C6
9ED0  9631                            LDA     ZP_FPA + 3
9ED2  81A0                            CMPA    #$A0
9ED4  2485                            BHS     setFloatA1_cmdPRINT_num2str_digit
9ED6  9638                            LDA     ZP_GEN_PTR + 1
9ED8  260E                            BNE     LA1DE
9EDA                  cmdPRINT_num2str_fmtFixedOrExp0
9EDA  8101                            CMPA    #$01                            ; If format == 1 (exp)
9EDC  2742                            BEQ     cmdPRINT_numstr_strAasDigLenPrintDigs
9EDE                  cmdPRINT_num2str_clearZeroFPAandPrintFMT2               ; LA1D4
9EDE                                  CALL    zero_FPA                        ; Clear FloatA
9EDE                  9
9EE0                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EDE  BDA36D                                  JSR     \1
                              ENDIF
9EE1  0F48                            CLR     ZP_FP_TMP + 5                   ; clear 10's exponent
9EE3  964D                            LDA     ZP_FP_TMP + 10                  ; digit length
9EE5  4C                              INCA
9EE6  9738                            STA     ZP_GEN_PTR + 1
9EE8                  LA1DE
9EE8  8601                            LDA     #1
9EEA  9137                            CMPA    ZP_GEN_PTR
9EEC  2732                            BEQ     cmdPRINT_numstr_strAasDigLenPrintDigs                           ; if format == 1 (exp)
9EEE  D648                            LDB     ZP_FP_TMP + 5                   ; B = 10's exponent
9EF0  2B0B                            BMI     cmdPRINT_numstr_printLead0point ; negative 10's exponent
9EF2  D138                            CMPB    ZP_GEN_PTR + 1
9EF4  242A                            BCC     cmdPRINT_numstr_strAasDigLenPrintDigs                           ; 
9EF6  0F48                            CLR     ZP_FP_TMP + 5
9EF8  5C                              INCB
9EF9  1F98                            TFR     B,A
9EFB  2623                            BNE     cmdPRINT_numstr_strAasDigLenPrintDigs
9EFD                  cmdPRINT_numstr_printLead0point                         ; LA1F2
9EFD  9637                            LDA     ZP_GEN_PTR
9EFF  8102                            CMPA    #$02                            ; if format == 2 (fixed)
9F01  2706                            BEQ     cmdPRINT_numstr_print0point
9F03  8601                            LDA     #1
9F05  C1FF                            CMPB    #$FF
9F07  2617                            BNE     cmdPRINT_numstr_strAasDigLenPrintDigs
9F09                  cmdPRINT_numstr_print0point                             ; LA1FE
9F09  8630                            LDA     #'0'
9F0B                                  CALL    cmdPRINT_num2str_storeA         ; Output '0'
9F0B                  9
9F0D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F0B  BD9FE3                                  JSR     \1
                              ENDIF
9F0E  862E                            LDA     #'.'
9F10                                  CALL    cmdPRINT_num2str_storeA         ; Output '.'
9F10                  9
9F12                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F10  BD9FE3                                  JSR     \1
                              ENDIF
9F13  8630                            LDA     #'0'                            ; Prepare '0'
9F15                  cmdPRINT_numstr_print0point_lp                          ;LA20A:
9F15  0C48                            INC     ZP_FP_TMP + 5
9F17  2705                            BEQ     cmdPRINT_numstr_print0point_sk
9F19                                  CALL    cmdPRINT_num2str_storeA         ; Output
9F19                  9
9F1B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F19  BD9FE3                                  JSR     \1
                              ENDIF
9F1C  20F7                            BRA     cmdPRINT_numstr_print0point_lp
9F1E                  cmdPRINT_numstr_print0point_sk                          ;LA213:
9F1E  8680                            LDA     #$80
9F20                  cmdPRINT_numstr_strAasDigLenPrintDigs                   ;
9F20  974D                            STA     ZP_FP_TMP + 10
9F22                  cmdPRINT_numstr_print_lp2                               ;LA217:
9F22                                  CALL    cmdPRINT_numstr_printAhigh_nyb_asdigit_thenmul10
9F22                  9
9F24                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9F22  8D51                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9F24  0A4D                            DEC     ZP_FP_TMP + 10
9F26  2605                            BNE     cmdPRINT_numstr_print_sk2
9F28  862E                            LDA     #'.'
9F2A                                  CALL    cmdPRINT_num2str_storeA
9F2A                  9
9F2C                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F2A  BD9FE3                                  JSR     \1
                              ENDIF
9F2D                  cmdPRINT_numstr_print_sk2                               ;LA223:
9F2D  0A38                            DEC     ZP_GEN_PTR + 1
9F2F  26F1                            BNE     cmdPRINT_numstr_print_lp2
9F31  D637                            LDB     ZP_GEN_PTR
9F33  5A                              DECB
9F34  271A                            BEQ     cmdPRINT_numstr_print_exponent_exp                              ; format = 1 (exp)
9F36  5A                              DECB
9F37  2713                            BEQ     cmdPRINT_numstr_print_exponent_fix      ; format = 2 (fixed)
9F39  D636                            LDB     ZP_STRBUFLEN
9F3B  8E0600                          LDX     #BAS_StrA
9F3E                  cmdPRINT_numstr_removetrail0_lp                         ; LA231
9F3E  5A                              DECB
9F3F  A685                            LDA     B,X
9F41  8130                            CMPA    #'0'
9F43  27F9                            BEQ     cmdPRINT_numstr_removetrail0_lp
9F45  812E                            CMPA    #'.'
9F47  2701                            BEQ     cmdPRINT_numstr_removetrail0_sk
9F49  5C                              INCB
9F4A                  cmdPRINT_numstr_removetrail0_sk                         ; LA23E:
9F4A  D736                            STB     ZP_STRBUFLEN
9F4C                  cmdPRINT_numstr_print_exponent_fix                      ; LA240
9F4C  9648                            LDA     ZP_FP_TMP + 5
9F4E  2724                            BEQ     rtsLA26B
9F50                  cmdPRINT_numstr_print_exponent_exp                      ; LA244
9F50  8645                            LDA     #'E'
9F52                                  CALL    cmdPRINT_num2str_storeA         ;  Output 'E'
9F52                  9
9F54                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F52  BD9FE3                                  JSR     \1
                              ENDIF
9F55  9648                            LDA     ZP_FP_TMP + 5
9F57  2A09                            BPL     cmdPRINT_numstr_print_exponent_exp_sk
9F59  862D                            LDA     #'-'
9F5B                                  CALL    cmdPRINT_num2str_storeA         ; Output '-'
9F5B                  9
9F5D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F5B  BD9FE3                                  JSR     \1
                              ENDIF
9F5E  0048                            NEG     ZP_FP_TMP + 5                   ;  Negate
9F60  9648                            LDA     ZP_FP_TMP + 5
9F62                  cmdPRINT_numstr_print_exponent_exp_sk                   ; LA257:
9F62                                  CALL    cmdPRINT_numstr_convert_10_1
9F62                  9
9F64                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9F62  8D6B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9F64  9637                            LDA     ZP_GEN_PTR
9F66  270C                            BEQ     rtsLA26B
9F68  8620                            LDA     #$20
9F6A  D648                            LDB     ZP_FP_TMP + 5
9F6C  2B02                            BMI     LA267
9F6E                                  CALL    cmdPRINT_num2str_storeA
9F6E                  9
9F70                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9F6E  8D73                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9F70                  LA267
9F70  C100                            CMPB    #$00
9F72  276F                            BEQ     cmdPRINT_num2str_storeA
9F74                  rtsLA26B
9F74  39                              RTS
9F75                  cmdPRINT_numstr_printAhigh_nyb_asdigit_thenmul10
9F75  9631                            LDA     ZP_FPA + 3
9F77  44                              LSRA
9F78  44                              LSRA
9F79  44                              LSRA
9F7A  44                              LSRA
9F7B                                  CALL    cmdPRINT_numstr_printAlow_nyb_asdigit
9F7B                  9
9F7D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9F7B  8D64                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9F7D  860F                            LDA     #$0F
9F7F  9431                            ANDA    ZP_FPA + 3
9F81  9731                            STA     ZP_FPA + 3
                      
                      
                      ;                       ;  FloatA=FloatA*10
                      ;                       ;  ----------------
9F83                  parseDMul10                                     ;LA279 - TODO, speed up, make 16 bitted                          
9F83  3402                            PSHS    A
9F85  D634                            LDB     ZP_FPA + 6
9F87  9631                            LDA     ZP_FPA + 3
9F89  3402                            PSHS    A
9F8B  9632                            LDA     ZP_FPA + 4
9F8D  3402                            PSHS    A
9F8F  9633                            LDA     ZP_FPA + 5
9F91  3402                            PSHS    A
9F93  9635                            LDA     ZP_FPA + 7
9F95  48                              ASLA
9F96  0934                            ROL     ZP_FPA + 6
9F98  0933                            ROL     ZP_FPA + 5
9F9A  0932                            ROL     ZP_FPA + 4
9F9C  0931                            ROL     ZP_FPA + 3
9F9E  48                              ASLA
9F9F  0934                            ROL     ZP_FPA + 6
9FA1  0933                            ROL     ZP_FPA + 5
9FA3  0932                            ROL     ZP_FPA + 4
9FA5  0931                            ROL     ZP_FPA + 3
9FA7  9935                            ADCA    ZP_FPA + 7
9FA9  9735                            STA     ZP_FPA + 7
9FAB  1F98                            TFR     B,A
9FAD  9934                            ADCA    ZP_FPA + 6
9FAF  9734                            STA     ZP_FPA + 6
9FB1  3502                            PULS    A
9FB3  9933                            ADCA    ZP_FPA + 5
9FB5  9733                            STA     ZP_FPA + 5
9FB7  3502                            PULS    A
9FB9  9932                            ADCA    ZP_FPA + 4
9FBB  9732                            STA     ZP_FPA + 4
9FBD  3502                            PULS    A
9FBF  9931                            ADCA    ZP_FPA + 3
9FC1  0835                            ASL     ZP_FPA + 7
9FC3  0934                            ROL     ZP_FPA + 6
9FC5  0933                            ROL     ZP_FPA + 5
9FC7  0932                            ROL     ZP_FPA + 4
9FC9  49                              ROLA
9FCA  9731                            STA     ZP_FPA + 3
9FCC  3502                            PULS    A
9FCE  39                              RTS
                      
                      
                      
                                      ; convert number, B ends up counting 10's, A ends up containing units
9FCF                  cmdPRINT_numstr_convert_10_1                            ; LA2BC
9FCF  1F89                            TFR     A,B
9FD1  86FF                            LDA     #$FF
9FD3                  LA2BF
9FD3  4C                              INCA
9FD4  C00A                            SUBB    #$0A
9FD6  24FB                            BCC     LA2BF
9FD8  CB0A                            ADDB    #$0A
9FDA  4D                              TSTA
9FDB  2702                            BEQ     LA2CD
9FDD                                  CALL    cmdPRINT_numstr_printAlow_nyb_asdigit   ; if not 0 print 10's
9FDD                  9
9FDF                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9FDD  8D02                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9FDF                  LA2CD
9FDF  1F98                            TFR     B,A                             ; print 1's
9FE1                  cmdPRINT_numstr_printAlow_nyb_asdigit                   ; LA2CE
9FE1  8A30                            ORA     #'0'
                      
                      ;                       ;  Store character in string buffer
                      ;                       ;  --------------------------------
9FE3                  cmdPRINT_num2str_storeA                                 ; LA2D0
9FE3  3414                            PSHS    B,X
9FE5  D636                            LDB     ZP_STRBUFLEN
9FE7  8E0600                          LDX     #BAS_StrA
9FEA  3A                              ABX
9FEB  A784                            STA     ,X                              ; Store character
9FED  0C36                            INC     ZP_STRBUFLEN
9FEF  3594                            PULS    B,X,PC                          ;  Increment string length
                      
9FF1                  parseDecNAN                                             ; LA2DA
9FF1                                  CALL    fpSetSignExp0                   ;  Set IntA to zero
9FF1                  9
9FF3                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FF1  BDA111                                  JSR     \1
                              ENDIF
9FF4                                  CLC                                     ;  CLC=no number, return Real
9FF4  1CFE                    ANDCC   #~CC_C
9FF6  86FF                            LDA     #$FF
9FF8  39                              RTS
                      
                      
                      ;                       ;  Scan decimal number
                      ;                       ;  -------------------
9FF9                  parseDecimalLiteral
9FF9  0F31                            CLR     ZP_FPA + 3
9FFB  0F32                            CLR     ZP_FPA + 4
9FFD  0F33                            CLR     ZP_FPA + 5                      ;  Clear FloatA
9FFF  0F34                            CLR     ZP_FPA + 6
A001  0F35                            CLR     ZP_FPA + 7
A003  0F47                            CLR     ZP_FP_TMP + 4                   ;  Clear 'Decimal point found'
A005  0F48                            CLR     ZP_FP_TMP + 5                   ;  Set exponent to zero
A007  812E                            CMPA    #'.'
A009  272B                            BEQ     parseD_skDPFound                ;  Decimal point
A00B  8139                            CMPA    #'9'
A00D  22E2                            BHI     parseDecNAN                     ;  Not a decimal digit, return 'no number'
A00F  8030                            SUBA    #'0'
A011  25DE                            BLO     parseDecNAN                     ;  Convert to binary, if not digit, return 'no number'
A013  9735                            STA     ZP_FPA + 7                      ;  Store digit
A015  A6C0                            LDA     ,U+                             ;  Get next character
A017  8139                            CMPA    #'9'
A019  2223                            BHI     parseD_sknotdp                  ;  Not a digit, check for E or end of number
A01B  8030                            SUBA    #'0'
A01D  2511                            BLO     parseD_sknotdig                 ;  Not a digit, check for decimal point
A01F  972E                            STA     ZP_FPA                          ;  Store this digit
A021  9635                            LDA     ZP_FPA + 7
A023  48                              ASLA
A024  48                              ASLA                                    ;  A=num*4
A025  9B35                            ADDA    ZP_FPA + 7
A027  48                              ASLA                                    ;  A=(num*4+num)*2 = num*10
A028  9B2E                            ADDA    ZP_FPA
A02A  9735                            STA     ZP_FPA + 7                      ;  num=num*10+digit
A02C  A6C0            parseD_lp1      LDA     ,U+                             ;  Step to next character       
A02E  2002                            BRA     1F                              ; TODO: this is a bit of a kludge, maybe make '.' do branch?
A030  A65F            parseD_sknotdig LDA     -1,U                            ; reload previous char
A032  812E            1               CMPA    #'.'
A034  2608                            BNE     parseD_sknotdp                  ;  Not decimal point, jump to check if digit
A036                  parseD_skDPFound
A036  9647                            LDA     ZP_FP_TMP + 4
A038  2643                            BNE     parseD_skDone                           ;  If already have a decimal point, finish
A03A  0C47                            INC     ZP_FP_TMP + 4
A03C  20EE                            BRA     parseD_lp1                      ;  Set 'decimal point found', and get next digit
                      
                      
                      
                      ;                       ;  First two digits processed, scan rest of number
                      ;                       ;  -----------------------------------------------
A03E                  parseD_sknotdp
A03E  8145                            CMPA    #'E'
A040  2735                            BEQ     parseD_skScanExp        ;  Jump to scan exponent
A042  8139                            CMPA    #'9'
A044  2237                            BHI     parseD_skDone           ;  Not a digit, jump to finish
A046  8030                            SUBA    #'0'
A048  2533                            BLO     parseD_skDone           ;  Not a digit, jump to finish
A04A  D631                            LDB     ZP_FPA + 3              ;  Get mantissa top byte
A04C  C11A                            CMPB    #26
A04E  2508                            BLO     parseD_sk2              ;  If <=25, still small enough to add to
A050  0D47                            TST     ZP_FP_TMP + 4
A052  26D8                            BNE     parseD_lp1              ;  Decimal point found, skip digits until end of number
A054  0C48                            INC     ZP_FP_TMP + 5
A056  20D4                            BRA     parseD_lp1              ;  No decimal point, increment exponent and loop skip digits
A058  0D47            parseD_sk2      TST     ZP_FP_TMP + 4
A05A  2702                            BEQ     parseD_sk1
A05C  0A48                            DEC     ZP_FP_TMP + 5           ;  Decimal point found, decrement exponent
A05E                  parseD_sk1      CALL    parseDMul10             ;  Multiply FloatA by 10
A05E                  9
A060                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A05E  BD9F83                                  JSR     \1
                              ENDIF
A061  9B35                            ADDA    ZP_FPA + 7
A063  9735                            STA     ZP_FPA + 7              ;  Add digit to mantisa low byte
A065  24C5                            BCC     parseD_lp1              ;  No overflow
A067  0C34                            INC     ZP_FPA + 6
A069  26C1                            BNE     parseD_lp1              ;  Add carry through mantissa
A06B  0C33                            INC     ZP_FPA + 5
A06D  26BD                            BNE     parseD_lp1
A06F  0C32                            INC     ZP_FPA + 4
A071  26B9                            BNE     parseD_lp1
A073  0C31                            INC     ZP_FPA + 3
A075  20B5                            BRA     parseD_lp1              ;  Loop to check next digit
                                      
                      ;                       ;  Deal with Exponent in scanned number
                      ;                       ;  ------------------------------------
A077                  parseD_skScanExp
A077                                  CALL    parseD_scanExp                  ;  Scan following number
A077                  9
A079                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A077  8D5A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A079  9B48                            ADDA    ZP_FP_TMP + 5
A07B  9748                            STA     ZP_FP_TMP + 5           ;  Add to current exponent
                      
                      ;                       ;  End of number found
                      ;                       ;  -------------------
A07D  335F            parseD_skDone   LEAU    -1,U
A07F  DF19                            STU     ZP_TXTPTR2              ;  Store PtrB offset
A081  9648                            LDA     ZP_FP_TMP + 5
A083  9A47                            ORA     ZP_FP_TMP + 4           ;  Check exponent and 'decimal found'
A085  272D                            BEQ     parseD_skReturnInt      ;  No exp, no dec, jump to return integer
A087                                  CALL    fpCheckMant0SetSignExp0
A087                  9
A089                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A087  8D76                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A089  2724                            BEQ     parseD_skReturnInt0
A08B                  parseD_skNormalise
A08B  86A8                            LDA     #$A8
A08D  9730                            STA     ZP_FPA + 2
A08F  0F2F                            CLR     ZP_FPA + 1
A091  0F2E                            CLR     ZP_FPA
A093                                  CALL    NormaliseRealA
A093                  9
A095                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A093  BD85D1                                  JSR     \1
                              ENDIF
A096  9648                            LDA     ZP_FP_TMP + 5
A098  2B0B                            BMI     parseD_lp3
A09A  2710                            BEQ     parseD_sk3
A09C                  parseD_lp2      CALL    fmMulBy10
A09C                  9
A09E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0098                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A09C  BDA136                                  JSR     \1
                              ENDIF
A09F  0A48                            DEC     ZP_FP_TMP + 5
A0A1  26F9                            BNE     parseD_lp2
A0A3  2007                            BRA     parseD_sk3
A0A5                  parseD_lp3      CALL    fpFloatADiv10
A0A5                  9
A0A7                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A0A5  BDA16A                                  JSR     \1
                              ENDIF
A0A8  0C48                            INC     ZP_FP_TMP + 5
A0AA  26F9                            BNE     parseD_lp3
A0AC                  parseD_sk3              CALL fpRoundMantissaFPA
A0AC                  9
A0AE                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A0AC  BDA34B                                  JSR     \1
                              ENDIF
A0AF                  parseD_skReturnInt0
A0AF                                  SEC
A0AF  1A01                    ORCC    #CC_C
A0B1  86FF                            LDA     #$FF
A0B3  39                              RTS
A0B4                  parseD_skReturnInt
A0B4  9632                            LDA     ZP_FPA + 4             ; TODO - optimise using D - not sure if we need B preserved tho
A0B6  972A                            STA     ZP_INT_WA + 0          ; DB - endiannes change
A0B8  8480                            ANDA    #$80
A0BA  9A31                            ORA     ZP_FPA + 3
A0BC  26CD                            BNE     parseD_skNormalise
A0BE  9635                            LDA     ZP_FPA + 7
A0C0  972D                            STA     ZP_INT_WA + 3
A0C2  9634                            LDA     ZP_FPA + 6
A0C4  972C                            STA     ZP_INT_WA + 2
A0C6  9633                            LDA     ZP_FPA + 5
A0C8  972B                            STA     ZP_INT_WA + 1
A0CA  8640                            LDA     #$40
A0CC                                  SEC
A0CC  1A01                    ORCC    #CC_C
A0CE  39                              RTS
A0CF                  parseD_skNegExp                                         ;LA3B3
A0CF                                  CALL    parseD_scanExpReadDigits                                ;  Scan following number
A0CF                  9
A0D1                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A0CF  8D0C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A0D1  40                              NEGA                                    ; complement it
A0D2  39                              RTS                             ;  Negate it, return CS=Ok
                      ;                       ;  Scan exponent, allows E E+ E- followed by one or two digits
                      ;                       ;  -----------------------------------------------------------
A0D3                  parseD_scanExp
A0D3  A6C0                            LDA     ,U+                             ;  Get next character
A0D5  812D                            CMPA    #'-'
A0D7  27F6                            BEQ     parseD_skNegExp                 ;  Jump to scan and negate
A0D9  812B                            CMPA    #'+'
A0DB  2602                            BNE     parseD_scanExpSkipNotPlus       ;  If '+', just step past it
A0DD                  parseD_scanExpReadDigits                                ; LA3C5
A0DD  A6C0                            LDA     ,U+     ;                       ;  Get next character
A0DF                  parseD_scanExpSkipNotPlus                               ; LA3C8
A0DF  8139                            CMPA    #'9'
A0E1  221A                            BHI     parseD_scanExpSkipRet0          ;  Not a digit, exit with CC
A0E3  8030                            SUBA    #'0'
A0E5  2516                            BCS     parseD_scanExpSkipRet0          ;  Not a digit, exit with CC
A0E7  E6C0                            LDB     ,U+                             ;  Get next character in B!
A0E9  C139                            CMPB    #'9'
A0EB  220F                            BHI     parseD_scanExpSkipRetA          ;  Not a digit, exit with CC=Ok
A0ED  C030                            SUBB    #'0'
A0EF  250B                            BCS      parseD_scanExpSkipRetA         ;  Not a digit, exit with CC=Ok
A0F1  3404                            PSHS    B
A0F3  C60A                            LDB     #10
A0F5  3D                              MUL                                     ; multiply A by 10
A0F6  1F98                            TFR     B,A                             ; into A
A0F8  ABE0                            ADDA    ,S+                             ; add second digit
A0FA  3341                            LEAU    1,U                             ; skip forward one, it gets put back later!
A0FC                  parseD_scanExpSkipRetA
A0FC  39                              RTS
                                              ;  exp=exp*10+digit
A0FD                  parseD_scanExpSkipRet0                                  ; go back one and return 0
A0FD  4F                              CLRA
A0FE  39                              RTS
                                              ;  Return exp=0 and return CC=Ok
                                              ;  IsZero?
                                              ;  -------
A0FF                  fpCheckMant0SetSignExp0
A0FF  9631                            LDA     ZP_FPA + 3              ; Mantissa MSB  ; TODO use D?
A101  9A32                            ORA     ZP_FPA + 4              
A103  9A33                            ORA     ZP_FPA + 5
A105  9A34                            ORA     ZP_FPA + 6
A107  9A35                            ORA     ZP_FPA + 7              ; Mantissa LSB
A109  2706                            BEQ     fpSetSignExp0
A10B  962E                            LDA     ZP_FPA          ; sign
A10D  2608                            BNE     anRTS5
A10F  4C                              INCA                            ; return A=1, Z=0, PL
A110  39                              RTS
                      ;                       ;  Return zero
                      ;                       ;  -----------
A111                  fpSetSignExp0
A111  0F2E                            CLR     ZP_FPA
A113  0F30                            CLR     ZP_FPA + 2
A115  0F2F                            CLR     ZP_FPA + 1
A117  39              anRTS5          RTS
                      
A118                  fpCopyFPAtoFPB
A118  962E                            LDA     ZP_FPA
A11A  973B                            STA     ZP_FPB                  ; copy sign
A11C  DC30                            LDD     ZP_FPA + 2
A11E  DD3C                            STD     ZP_FPB + 1
A120  DC32                            LDD     ZP_FPA + 4
A122  DD3E                            STD     ZP_FPB + 3
A124  DC34                            LDD     ZP_FPA + 6
A126  DD40                            STD     ZP_FPB + 5
A128  39                              RTS
A129                  fpCopyFPAtoFPBAndShiftRight
A129                                  CALL    fpCopyFPAtoFPB
A129                  9
A12B                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00ED                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A129  8DED                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A12B                  fpShiftBMantissaRight
A12B  043D                            LSR     ZP_FPB + 2
A12D  063E                            ROR     ZP_FPB + 3
A12F  063F                            ROR     ZP_FPB + 4
A131  0640                            ROR     ZP_FPB + 5
A133  0641                            ROR     ZP_FPB + 6
A135  39                              RTS
A136                  fmMulBy10                                               ; LA436
A136  DC2F                            LDD     ZP_FPA + 1                      ; mantissa + 3 (i.e. * 8)
A138  C30003                          ADDD    #$03
A13B  DD2F                            STD     ZP_FPA + 1
A13D                                  CALL    fpCopyFPAtoFPBAndShiftRight     ; fpB = fpA / 4 i.e.
A13D                  9
A13F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A13D  8DEA                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A13F                                  CALL    fpShiftBMantissaRight           ; note C is brought in here!
A13F                  9
A141                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A13F  8DEA                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A141                  fpAddAtoBstoreinA_sameExp
A141  DC34                            LDD     ZP_FPA + 6
A143  D941                            ADCB    ZP_FPB + 6
A145  9940                            ADCA    ZP_FPB + 5
A147  DD34                            STD     ZP_FPA + 6
                      
A149  DC32                            LDD     ZP_FPA + 4              
A14B  D93F                            ADCB    ZP_FPB + 4
A14D  993E                            ADCA    ZP_FPB + 3
A14F  DD32                            STD     ZP_FPA + 4
                      
A151  9631                            LDA     ZP_FPA + 3
A153  993D                            ADCA    ZP_FPB + 2
A155  9731                            STA     ZP_FPA + 3
A157  2410                            BCC     anRTS11
A159                  fpRORMantAincExp
A159  0631                            ROR     ZP_FPA + 3
A15B  0632                            ROR     ZP_FPA + 4
A15D  0633                            ROR     ZP_FPA + 5
A15F  0634                            ROR     ZP_FPA + 6
A161  0635                            ROR     ZP_FPA + 7
A163  0C30                            INC     ZP_FPA + 2
A165  2602                            BNE     anRTS11
A167  0C2F                            INC     ZP_FPA + 1
A169  39              anRTS11         RTS
A16A                  fpFloatADiv10                                           ; LA478
A16A  9630                            LDA     ZP_FPA + 2                      ; exponent low
A16C  8004                            SUBA    #4
A16E  9730                            STA     ZP_FPA + 2
A170  2402                            BCC     fpFloatADiv10_sk1
A172  0A2F                            DEC     ZP_FPA + 1
A174                  fpFloatADiv10_sk1                                       ; LA483:
A174                                  CALL    fpCopyFPAtoFPBAndShiftRight
A174                  9
A176                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A174  8DB3                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A176                                  CALL    fpAddAtoBstoreinA_sameExp
A176                  9
A178                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A176  8DC9                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A178                                  CALL    fpCopyFPAtoFPBAndShiftRight
A178                  9
A17A                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A178  8DAF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A17A                                  CALL    fpShiftBMantissaRight
A17A                  9
A17C                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A17A  8DAF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A17C                                  CALL    fpShiftBMantissaRight
A17C                  9
A17E                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A17C  8DAD                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A17E                                  CALL    fpShiftBMantissaRight
A17E                  9
A180                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A17E  8DAB                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A180                                  CALL    fpAddAtoBstoreinA_sameExp
A180                  9
A182                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A180  8DBF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A182  0F3D                            CLR     ZP_FPB + 2
A184  DC31                            LDD     ZP_FPA + 3
A186  DD3E                            STD     ZP_FPB + 3
A188  DC33                            LDD     ZP_FPA + 5
A18A  DD40                            STD     ZP_FPB + 5
A18C  9635                            LDA     ZP_FPA + 7
A18E  49                              ROLA
A18F                                  CALL    fpAddAtoBstoreinA_sameExp
A18F                  9
A191                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A18F  8DB0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A191  0F3E                            CLR     ZP_FPB + 3                      ; TODO - 16 bit this!
                      
A193  9631                            LDA     ZP_FPA + 3
A195  973F                            STA     ZP_FPB + 4
                      
A197  9632                            LDA     ZP_FPA + 4
A199  9740                            STA     ZP_FPB + 5
A19B  9633                            LDA     ZP_FPA + 5
A19D  9741                            STA     ZP_FPB + 6              
A19F  9634                            LDA     ZP_FPA + 6
A1A1  49                              ROLA
A1A2                                  CALL    fpAddAtoBstoreinA_sameExp
A1A2                  9
A1A4                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A1A2  8D9D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A1A4  9632                            LDA     ZP_FPA + 4
A1A6  49                              ROLA
A1A7  9631                            LDA     ZP_FPA + 3
A1A9  9935                            ADCA    ZP_FPA + 7
A1AB  9735                            STA     ZP_FPA + 7
A1AD  2412                            BCC     rtsLA4DF
A1AF  0C34                            INC     ZP_FPA + 6
A1B1  260E                            BNE     rtsLA4DF
A1B3                  fpIncFPAMantMSBs                                        ; LA4D3
A1B3  0C33                            INC     ZP_FPA + 5                      ; TODO more 16 bitting?
A1B5  260A                            BNE     rtsLA4DF
A1B7  0C32                            INC     ZP_FPA + 4
A1B9  2606                            BNE     rtsLA4DF
A1BB  0C31                            INC     ZP_FPA + 3
A1BD                                  SEC
A1BD  1A01                    ORCC    #CC_C
A1BF  2798                            BEQ     fpRORMantAincExp
A1C1                  rtsLA4DF
A1C1  39                              RTS
A1C2                  fpMoveRealAtPTR1toFPB
A1C2  9E4A                            LDX     ZP_FP_TMP_PTR1
A1C4                  fpMoveRealAtXtoFPB
                      *               PSHS    B                               ; TODO - check if needed
A1C4  0F41                            CLR     ZP_FPB + 6                      ; zero overflow
A1C6  EC03                            LDD     3,X                             ; copy mantissa low bytes
A1C8  DD3F                            STD     ZP_FPB + 4
                      
A1CA  EC01                            LDD     1,X                             ; copy mantissa msb into sign bit and next into mantissa
A1CC  D73E                            STB     ZP_FPB + 3
A1CE  973B                            STA     ZP_FPB
                      
A1D0  E684                            LDB     ,X                              ; get exponent
A1D2  D73C                            STB     ZP_FPB + 1                      ; store
A1D4  2608                            BNE     fpMoveRealAtXtoFPB_sk1          ; if not 0 continue
A1D6  9A3E                            ORA     ZP_FPB + 3
A1D8  9A3F                            ORA     ZP_FPB + 4
A1DA  9A40                            ORA     ZP_FPB + 5
A1DC  2704                            BEQ     fpMoveRealAtXtoFPB_sk2          ; if rest is zero were done just store 0
A1DE                  fpMoveRealAtXtoFPB_sk1
A1DE  963B                            LDA     ZP_FPB                          ; get back mantissa MSB from sign 
A1E0  8A80                            ORA     #$80                            ; set top bit
A1E2                  fpMoveRealAtXtoFPB_sk2
A1E2  973D                            STA     ZP_FPB + 2                      ; store in mantissa
A1E4  39                              RTS
                      ;               
                      ;               
                      ;               
A1E5                  fpCopyFPA_FPTEMP3                                       ; LA50D
A1E5  8E0476                          LDX     #BASWKSP_FPTEMP3
A1E8  9F4A                            STX     ZP_FP_TMP_PTR1                  ; TODO - this may seem unnecessary but there are functions that expect PTR1 to point to last used location
A1EA  2007                            BRA     fpCopyFPA_X
A1EC                  fpCopyFPA_FPTEMP1                                       ; LA511
A1EC  8E046C                          LDX     #BASWKSP_FPTEMP1
A1EF  9F4A                            STX     ZP_FP_TMP_PTR1                  ; TODO - this may seem unnecessary but there are functions that expect PTR1 to point to last used location
                      ;;              BRA     fpCopyFPA_X
A1F1                  fpCopyFPA_PTR1
A1F1  9E4A                            LDX     ZP_FP_TMP_PTR1
A1F3                  fpCopyFPA_X
A1F3  9630                            LDA     ZP_FPA + 2
A1F5  A780                            STA     ,X+
A1F7  962E                            LDA     ZP_FPA
A1F9  9831                            EORA    ZP_FPA + 3
A1FB  8480                            ANDA    #$80
A1FD  9831                            EORA    ZP_FPA + 3
A1FF  A780                            STA     ,X+
A201  9632                            LDA     ZP_FPA + 4
A203  A780                            STA     ,X+
A205  9633                            LDA     ZP_FPA + 5
A207  A780                            STA     ,X+
A209  9634                            LDA     ZP_FPA + 6
A20B  A784                            STA     ,X
A20D  39                              RTS
                      
                      
A20E                  fpCopyFPTEMP1toFPA                              ; LA539
                                      ; note now trashes X
A20E  8E046C                          LDX     #BASWKSP_FPTEMP1
A211  2002                            BRA     fpCopyXtoFPA
                      ;;fpCopyXtoFPA--was 400+A                               ; LA53B
                      ;;;             STA ZP_FP_TMP_PTR1
                      ;;;             LDA #$04
                      ;;;             STA ZP_FP_TMP_PTR1 + 1
                      
                      
A213                  fpCopyPTR1toFPA
A213  9E4A                            LDX     ZP_FP_TMP_PTR1
A215                  fpCopyXtoFPA
                      *               PSHS    B                               ; TODO - check if needed
A215  4F                              CLRA
A216  9735                            STA     ZP_FPA + 7                      ; zero overflow
A218  972F                            STA     ZP_FPA + 1                      ; zero overflow exp
A21A  EC03                            LDD     3,X                             ; copy mantissa low bytes
A21C  DD33                            STD     ZP_FPA + 5
                      
A21E  EC01                            LDD     1,X                             ; copy mantissa msb into sign bit and next into mantissa
A220  D732                            STB     ZP_FPA + 4
A222  972E                            STA     ZP_FPA
                      
A224  E684                            LDB     ,X                              ; get exponent
A226  D730                            STB     ZP_FPA + 2                      ; store
A228  2608                            BNE     fpCopyXtoFPA_sk1                ; if not 0 continue
A22A  9A32                            ORA     ZP_FPA + 4
A22C  9A33                            ORA     ZP_FPA + 5
A22E  9A34                            ORA     ZP_FPA + 6
A230  2704                            BEQ     fpCopyXtoFPA_sk2                ; if rest is zero were done just store 0
A232                  fpCopyXtoFPA_sk1
A232  962E                            LDA     ZP_FPA                  ; get back mantissa MSB from sign 
A234  8A80                            ORA     #$80                            ; set top bit
A236                  fpCopyXtoFPA_sk2
A236  9731                            STA     ZP_FPA + 3                      ; store in mantissa
A238  39                              RTS
                      
                      
                      
A239  0F3B            fpSetRealBto0   CLR ZP_FPB
A23B  0F3C                            CLR ZP_FPB + 1
A23D  0F3D                            CLR ZP_FPB + 2
A23F                  fpSetRealBMantTo0
A23F  0F3E                            CLR ZP_FPB + 3
A241  0F3F                            CLR ZP_FPB + 4
A243  0F40                            CLR ZP_FPB + 5
A245  0F41                            CLR ZP_FPB + 6
A247  39                              RTS
                      
A248                  fpAdd5toPTR2copytoPTR1                          ; LA57F
A248  9E4C                            LDX     ZP_FP_TMP_PTR2
A24A  3005                            LEAX    5,X
A24C  9F4C                            STX     ZP_FP_TMP_PTR2
A24E  9F4A                            STX     ZP_FP_TMP_PTR1
A250  39                              RTS
                      
                      
                      
                      ;;;; TODO Check whether any of these are needed should use X and 
                      ;;;;fpPTR1==pi/2:                               ; LA589
                      ;;;;            LDA #<fpConstPiDiv2
                      ;;;;fpPTR1==constant at A (near pi/2):          ; LA58B
                      ;;;;            STA ZP_FP_TMP_PTR1
                      ;;;;            LDA #>fpConstPiDiv2
                      ;;;;            STA ZP_FP_TMP_PTR1 + 1
                      ;;;;            RTS
                      ;;;FPPTR1=BASWKSP_FPTEMP1:                      ; LA592
                      ;;;             LDA #$6C
                      ;;;FPPTR1=BASWKSP_400+A:                        ; LA594
                      ;;;             STA ZP_FP_TMP_PTR1
                      ;;;             LDA #$04
                      ;;;             STA ZP_FP_TMP_PTR1 + 1
                      ;;;             RTS
A251                  fnTAN                   ; LA59B!
A251                                  CALL    trigNormaltheta
A251                  9
A253                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A251  BDA60E                                  JSR     \1
                              ENDIF
A254  8E047B                          LDX     #BASWKSP_FPTEMP4
A257                                  CALL    fpCopyFPA_X                     ; save theta to FPTEMP4
A257                  9
A259                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A257  8D9A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A259                                  CALL    fnSIN_internal1         ; get sin theta
A259                  9
A25B                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0090                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A259  BDA5EB                                  JSR     \1
                              ENDIF
A25C  8E0476                          LDX     #BASWKSP_FPTEMP3
A25F                                  CALL    fpCopyFPA_X                     ; save sin theta to FPTEMP3
A25F                  9
A261                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A25F  8D92                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A261  8E047B                          LDX     #BASWKSP_FPTEMP4
A264                                  CALL    fpCopyXtoFPA                    ; get back theta from FPTEMP4
A264                  9
A266                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A264  8DAF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A266                                  CALL    fnCOS_internal1                 ; get cos theta
A266                  9
A268                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A266  BDA5E9                                  JSR     \1
                              ENDIF
A269                  LA5B3
A269  8E0476                          LDX     #BASWKSP_FPTEMP3
A26C  9F4A                            STX     ZP_FP_TMP_PTR1
A26E                                  CALL    fpFPAeqPTR1divFPA
A26E                  9
A270                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0035                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A26E  8D35                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A270  86FF                            LDA     #$FF
A272  39                              RTS
A273                  LA5BE
A273  1F89                            TFR     A,B
A275  5D                              TSTB
A276  2A07                            BPL     LA5C9
A278  40                              NEGA
A279  3402                            PSHS    A
A27B                                  CALL    fpFPAeq1.0divFPA
A27B                  9
A27D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A27B  8D23                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A27D  3504                            PULS    B
A27F                  LA5C9
A27F  2711                            BEQ     fpLoad1                 ;  Floata=1.0
A281                                  CALL    fpCopyFPA_FPTEMP1
A281                  9
A283                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A281  BDA1EC                                  JSR     \1
                              ENDIF
A284  5A                              DECB
A285  270A                            BEQ     LA5D7
A287  3404            LA5D1           PSHS    B
A289                                  CALL    fpFPAeqPTR1mulFPA
A289                  9
A28B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A289  BDA35C                                  JSR     \1
                              ENDIF
A28C  3504                            PULS    B
A28E  5A                              DECB
A28F  26F6                            BNE     LA5D1
A291                  LA5D7
A291  39                              RTS
                      ;                       ;  FloatA=1.0
                      ;                       ;  ----------
A292                  fpLoad1
A292  8680                            LDA     #$80
A294  9731                            STA     ZP_FPA + 3                      ;  Set mantissa = $80000000
A296  4C                              INCA
A297  9730                            STA     ZP_FPA + 2                      ;  Set exponent = $81 - exp=2^1
A299                                  JUMP    zero_FPA_sign_expO_manlo                ;  Zero rest of mantissa
A299  7EA371                                  JMP     \1
A29C                  tblDivConsts
A29C  02080808                        FCB     $02,$08,$08,$08
A2A0                  fpFPAeq1.0divFPA                                        ; LA5E9
A2A0                                  LDX_FPC fpConst1
A2A0  8EBAD1                                  LDX     #\1             ; leave as LDX for now for faster execution
A2A3  9F4A                            STX     ZP_FP_TMP_PTR1
A2A5                  fpFPAeqPTR1divFPA
                      
A2A5  9631                            LDA     ZP_FPA + 3
A2A7  1027E2AC                        LBEQ    brkDivideByZero                 ; if MSB of divisor mantissa 0 then error
A2AB                                  CALL    fpMoveRealAtPTR1toFPB           ; get dividend, if zero return 0
A2AB                  9
A2AD                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0015                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A2AB  BDA1C2                                  JSR     \1
                              ENDIF
A2AE  2603                            BNE     1F
A2B0                                  JUMP    zero_FPA
A2B0  7EA36D                                  JMP     \1
                      
A2B3                  1                                                       ;LA5FA:
                      ;;              STU     ZP_TXTPTR
                              IF CPU_6309
                                      PSHSW                                   
                              ENDIF
A2B3  DC3B                            LDD     ZP_FPB                          ; get b for use below
A2B5  982E                            EORA    ZP_FPA
A2B7  972E                            STA     ZP_FPA                          ; store quotient sign in sign of FPA
                      
                      ;;              LDB     ZP_FPB + 1                      ; B got in LDD above
A2B9  4F                              CLRA
A2BA  C30081                          ADDD    #$81
A2BD  932F                            SUBD    ZP_FPA + 1
A2BF  DD2F                            STD     ZP_FPA + 1                      ; subtract divisor exponent from quotient exponent and add 1
                      
A2C1  8E0005                          LDX     #$05
A2C4  C608                            LDB     #$08
A2C6  D73C                            STB     ZP_FPB+1
                              IF CPU_6309
                                      LDW     ZP_FPB + 2                      ; cache top bits of mantissa
                              ENDIF
A2C8  200B                            BRA     LA622
A2CA                  LA619
A2CA  E78842                          STB     ZP_FP_TMP-1,X                   ; store ZP_FPB from end of loop
A2CD  E689A29B                        LDB     tblDivConsts-1,X                ; get new loop counter value from table
A2D1  D73C                            STB     ZP_FPB+1
A2D3                  LA620
A2D3  2518                            BCS     LA638                           ; carry here has come from ROLA at POINT X
A2D5                  LA622
                              IF CPU_6309
                                      LDD     ZP_FPA + 3
                                      CMPR    W,D
                              ELSE
A2D5  9631                            LDA     ZP_FPA + 3                      ; this is kept as 8 bit for speed!
A2D7  913D                            CMPA    ZP_FPB + 2
A2D9  2610                            BNE     LA636
A2DB  9632                            LDA     ZP_FPA + 4
A2DD  913E                            CMPA    ZP_FPB + 3
                      ;;              LDD     ZP_FPA + 3                      ; or 16 bit for size?
                      ;;              CMPD    ZP_FPB + 2
                              ENDIF
                      
A2DF  260A                            BNE     LA636
A2E1  9633                            LDA     ZP_FPA + 5                      ; keep this 16 bit - unlikely to be hit?
A2E3  913F                            CMPA    ZP_FPB + 4
A2E5  2604                            BNE     LA636
A2E7  9634                            LDA     ZP_FPA + 6                      ; keep this 16 bit - unlikely to be hit?
A2E9  9140                            CMPA    ZP_FPB + 5
A2EB                  LA636
A2EB  2414                            BCC     LA64F
A2ED                  LA638
                                      
A2ED  DC3F                            LDD     ZP_FPB + 4
A2EF  9333                            SUBD    ZP_FPA + 5
A2F1  DD3F                            STD     ZP_FPB + 4
                              IF CPU_6309
                                      LDD     ZP_FPA + 3
                                      SBCR    D,W
                              ELSE
A2F3  963E                            LDA     ZP_FPB + 3
A2F5  9232                            SBCA    ZP_FPA + 4
A2F7  973E                            STA     ZP_FPB + 3
A2F9  963D                            LDA     ZP_FPB + 2
A2FB  9231                            SBCA    ZP_FPA + 3
A2FD  973D                            STA     ZP_FPB + 2
                              ENDIF
                      
A2FF                                  SEC
A2FF  1A01                    ORCC    #CC_C
A301                  LA64F
A301  093B                            ROL     ZP_FPB                          ; store result bit into FPB
A303  0840                            ASL     ZP_FPB + 5
A305  093F                            ROL     ZP_FPB + 4
                              IF CPU_6309
                                      ROLW
                              ELSE
A307  093E                            ROL     ZP_FPB + 3
A309  093D                            ROL     ZP_FPB + 2                      ;;;POINT X
                              ENDIF
A30B  0A3C                            DEC     ZP_FPB + 1                      ; B here is loop counter
A30D  26C4                            BNE     LA620
A30F  D63B                            LDB     ZP_FPB
A311  301F                            LEAX    -1,X
A313  26B5                            BNE     LA619
                              IF CPU_6309
                                      LDD     ZP_FPB + 4
                                      ORR     W,D
                              ELSE
A315  963D                            LDA     ZP_FPB + 2
A317  9A3E                            ORA     ZP_FPB + 3
A319  9A3F                            ORA     ZP_FPB + 4
A31B  9A40                            ORA     ZP_FPB + 5
                              ENDIF
A31D  2702                            BEQ     LA66B
A31F                                  SEC
A31F  1A01                    ORCC    #CC_C
A321                  LA66B
                      
                      ;;              LDU     ZP_TXTPTR                       ; restore text pointer
                              IF CPU_6309
                                      PULSW
                              ENDIF
                      
A321  56                              RORB
A322  56                              RORB
A323  56                              RORB
A324  C4E0                            ANDB    #$E0
A326  D735                            STB     ZP_FPA + 7
                      
                      
A328  DC43                            LDD     ZP_FP_TMP
A32A  9734                            STA     ZP_FPA + 6
A32C  D733                            STB     ZP_FPA + 5
                      
A32E  DC45                            LDD     ZP_FP_TMP + 2
A330  9732                            STA     ZP_FPA + 4
A332  D731                            STB     ZP_FPA + 3
                      
A334  2B15                            BMI     fpRoundMantissaFPA
A336                                  CALL    NormaliseRealA_3
A336                  9
A338                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A336  BD85D5                                  JSR     \1
                              ENDIF
                      ;;              CALL    __NormaliseRealA_sk2
A339  2010                            BRA     fpRoundMantissaFPA
                      
                      
A33B                  fpFPAeqXaddFPA
A33B                                  CALL    fpMoveRealAtXtoFPB
A33B                  9
A33D                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A33B  BDA1C4                                  JSR     \1
                              ENDIF
A33E  2008                            BRA     fpAddAtoBStoreAndRoundA
A340                  fpFPAeqPTR1subFPA
A340                                  CALL fpNegateFP_A
A340                  9
A342                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A340  BDA986                                  JSR     \1
                              ENDIF
A343                  fpFPAeqPTR1addFPA
A343                                  CALL    fpMoveRealAtPTR1toFPB
A343                  9
A345                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A343  BDA1C2                                  JSR     \1
                              ENDIF
A346  2735                            BEQ     anRTS2
A348                  fpAddAtoBStoreAndRoundA                                 ; LA692
A348                                  CALL    fpAddAtoBStoreA
A348                  9
A34A                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A348  BD871E                                  JSR     \1
                              ENDIF
A34B                  fpRoundMantissaFPA                                      ; LA695
A34B  9635                            LDA     ZP_FPA + 7
A34D  8180                            CMPA    #$80
A34F  2516                            BLO     2F
A351  270D                            BEQ     1F
A353  0C34                            INC     ZP_FPA + 6
A355  2610                            BNE     2F
A357                                  CALL    fpIncFPAMantMSBs
A357                  9
A359                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A357  BDA1B3                                  JSR     \1
                              ENDIF
A35A  200B                            BRA     2F
A35C                  fpFPAeqPTR1mulFPA
A35C                                  CALL    fpFPAeqPTR1mulFPA_internal
A35C                  9
A35E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
002A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A35C  8D2A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A35E  20EB                            BRA     fpRoundMantissaFPA
A360                  1                                                       ; LA6AB
A360                                  SEC
A360  1A01                    ORCC    #CC_C
A362  49                              ROLA
A363  9A34                            ORA     ZP_FPA + 6
A365  9734                            STA     ZP_FPA + 6
A367                  2                                                       ; LA6AE
A367  962F                            LDA     ZP_FPA + 1
A369  2710                            BEQ     zero_FPA_matLsb
A36B  2A11                            BPL     brkTooBig
                                      ; TODO - speed up with 16bits?
A36D                  zero_FPA
A36D  0F30                            CLR     ZP_FPA + 2              ; exp
A36F  0F31                            CLR     ZP_FPA + 3              ; mantissa MSB
A371                  zero_FPA_sign_expO_manlo
A371  0F2E                            CLR     ZP_FPA                  ; sign
A373  0F2F                            CLR     ZP_FPA + 1                      ; exponent overflow
A375  0F32                            CLR     ZP_FPA + 4                      ; mantissa 
A377  0F33                            CLR     ZP_FPA + 5                      ; mantissa
A379  0F34                            CLR     ZP_FPA + 6                      ; mantissa
A37B                  zero_FPA_matLsb                                         ; LA6C2
A37B  0F35                            CLR     ZP_FPA + 7                      ; mantissa LSB
A37D  39              anRTS2          RTS
                      ;
                      ;
A37E                  brkTooBig       DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A37E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A37F  14546F6F2062696700                 FCB $14, "Too big", 0
                      
                                      *************************************************
                                      *                                               *
                                      * Multiply FPA and 5 byte FP at PTR1            *
                                      * first PTR1 is unpacked to FPB in 7 byte format*
                                      * i.e. 1 byte for exponent                      *
                                      *************************************************
                                      
A388                  fpFPAeqPTR1mulFPA_internal
A388  9631                            LDA     ZP_FPA + 3                      ; check for 0 in FPA, if 0 return 0
A38A  27F1                            BEQ     anRTS2
A38C                                  CALL    fpMoveRealAtPTR1toFPB           ; unpack to FPB in 7 byte form
A38C                  9
A38E                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A38C  BDA1C2                                  JSR     \1
                              ENDIF
A38F  27DC                            BEQ     zero_FPA                        ; if that is zero, clear FPA and return
                      
A391  D63C                            LDB     ZP_FPB + 1                      ; add exponents
A393  4F                              CLRA
A394  D32F                            ADDD    ZP_FPA + 1
A396  830080                          SUBD    #$0080
A399  DD2F                            STD     ZP_FPA + 1
                      
A39B  962E                            LDA     ZP_FPA                          ; multiply signs
A39D  983B                            EORA    ZP_FPB
A39F  972E                            STA     ZP_FPA
                      
                      
A3A1  3450                            PSHS    X,U                             ; nothing to really save here but keep for later pops? X=D in BAS4128
A3A3  DC31                            LDD     ZP_FPA + 3
A3A5  DD43                            STD     ZP_FP_TMP
A3A7  DC33                            LDD     ZP_FPA + 5
A3A9  DD45                            STD     ZP_FP_TMP + 2
A3AB  4F                              CLRA
A3AC  5F                              CLRB
A3AD  DD31                            STD     ZP_FPA + 3
A3AF  DD33                            STD     ZP_FPA + 5
A3B1  9735                            STA     ZP_FPA + 7
                      
                                                                              ; do a long multiply adding result into FPA mantissa after
                                                                              ; each byte is multiplied from the "bottom" number (in tmp)
                                                                              ; shift FPA mantissa to the right by one byte, except last
                                                                              ; like long multiplication at primary school
                      
A3B3  108E0047                        LDY     #ZP_FP_TMP + 4                  ; point at current byte in "bottom" mantissa
A3B7  8E0040          mulloop         LDX     #ZP_FPB + 5                     ; point at number in "top" row (FPB)
A3BA  CE0034          mulloop3        LDU     #ZP_FPA + 6                     ; point at number in result (16 bit)
A3BD  A6A4            mulloop2        LDA     ,Y
A3BF  2719                            BEQ     mul_skip_car1
A3C1  E684                            LDB     ,X
A3C3  2715                            BEQ     mul_skip_car1
A3C5  3D                              MUL
A3C6  E3C4                            ADDD    ,U
A3C8  EDC4                            STD     ,U
A3CA  240E                            BCC     mul_skip_car1
A3CC  3440                            PSHS    U
A3CE  11830031        1               CMPU    #ZP_FPA + 3
A3D2  2304                            BLS     2F
A3D4  6CC2                            INC     ,-U
A3D6  27F6                            BEQ     1B
A3D8  3540            2               PULS    U
A3DA  335F            mul_skip_car1   LEAU    -1,U
A3DC  301F                            LEAX    -1,X
A3DE  8C003D                          CMPX    #ZP_FPB + 2
A3E1  24DA                            BHS     mulloop2
A3E3  108C0043                        CMPY    #ZP_FP_TMP
A3E7  230E                            BLS     mul_done
                                      ; shift result right one byte
A3E9  DC33                            LDD     ZP_FPA + 5
A3EB  DD34                            STD     ZP_FPA + 6
A3ED  DC31                            LDD     ZP_FPA + 3
A3EF  DD32                            STD     ZP_FPA + 4
A3F1  0F31                            CLR     ZP_FPA + 3
A3F3  313F                            LEAY    -1,Y
A3F5  20C0                            BRA     mulloop
A3F7                  mul_done
A3F7  3550                            PULS    X,U
                      ;               LDA     ZP_FPA + 3
A3F9  4D                              TSTA                                    ; top byte of mant still in A
A3FA  102AE1D7                        LBPL    NormaliseRealA_3                ; if top bit of FPA's mantissa not set then normalize it
A3FE  39                              RTS
A3FF                  fnLN                                                    ;  =LN
A3FF                                  CALL evalLevel1ConvertReal
A3FF                  9
A401                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0001                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A3FF  BD9502                                  JSR     \1
                              ENDIF
A402                  fnLN_FPA                                                ; LA749
A402  3440                            PSHS    U
A404                                  CALL    fpCheckMant0SetSignExp0
A404                  9
A406                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A404  BDA0FF                                  JSR     \1
                              ENDIF
A407  2702                            BEQ     brkLogRange
A409  2A17                            BPL     LA766
A40B                  brkLogRange
A40B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A40B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A40C  164C6F672072616E676500                 FCB     $16, "Log range", 0
A417                  brkNegRoot
A417                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A417  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A418  152D766520726F6F7400                 FCB     $15, "-ve root", 0
A422                  LA766
A422                                  CALL    fpSetRealBMantTo0
A422                  9
A424                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A422  BDA23F                                  JSR     \1
                              ENDIF
A425  8680                            LDA     #$80
A427  973B                            STA     ZP_FPB
A429  973D                            STA     ZP_FPB + 2
A42B  4C                              INCA    
A42C  973C                            STA     ZP_FPB + 1
A42E  D630                            LDB     ZP_FPA + 2
A430  2708                            BEQ     LA77C
A432  9631                            LDA     ZP_FPA + 3
A434  81B5                            CMPA    #$B5
A436  8681                            LDA     #$81
A438  2502                            BCS     LA77E
A43A                  LA77C
A43A  5C                              INCB
A43B  4A                              DECA
A43C                  LA77E
A43C  3404                            PSHS    B
A43E  9730                            STA     ZP_FPA + 2
A440                                  CALL    fpAddAtoBStoreAndRoundA
A440                  9
A442                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A440  BDA348                                  JSR     \1
                              ENDIF
A443  8E047B                          LDX     #BASWKSP_FPTEMP4
A446                                  CALL    fpCopyFPA_X
A446                  9
A448                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A446  BDA1F3                                  JSR     \1
                              ENDIF
A449  8EBA90                          LDX     #fpConst0_54625
A44C  CEBAAE                          LDU     #fpConstMin0_5
A44F  C602                            LDB     #$02
A451                                  CALL    LA861NewAPI
A451                  9
A453                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A451  BDA53F                                  JSR     \1
                              ENDIF
A454  8E047B                          LDX     #BASWKSP_FPTEMP4
A457                                  CALL    fpFPAeqXmulFPA
A457                  9
A459                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
002F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A457  BDA688                                  JSR     \1
                              ENDIF
A45A                                  CALL    fpFPAeqPTR1mulFPA
A45A                  9
A45C                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A45A  BDA35C                                  JSR     \1
                              ENDIF
A45D                                  CALL    fpFPAeqPTR1addFPA
A45D                  9
A45F                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A45D  BDA343                                  JSR     \1
                              ENDIF
A460                                  CALL    fpCopyFPA_FPTEMP1
A460                  9
A462                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A460  BDA1EC                                  JSR     \1
                              ENDIF
A463  3502                            PULS    A
A465  8081                            SUBA    #$81
A467                                  CALL    IntToReal_8signedA2real_check
A467                  9
A469                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A467  BD85B0                                  JSR     \1
                              ENDIF
A46A  8EBA8B                          LDX     #fpConst_ln_2
A46D                                  CALL    fpFPAeqXmulFPA
A46D                  9
A46F                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A46D  BDA688                                  JSR     \1
                              ENDIF
A470  8E046C                          LDX     #BASWKSP_FPTEMP1
A473  9F4A                            STX     ZP_FP_TMP_PTR1
A475                                  CALL    fpFPAeqPTR1addFPA
A475                  9
A477                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A475  BDA343                                  JSR     \1
                              ENDIF
A478  86FF                            LDA     #$FF
A47A  35C0                            PULS    U,PC
                      
A47C                  retAeqFF
A47C  86FF                            LDA     #$FF
A47E  39                              RTS
                      ;               
                      ;               
A47F                  fnSQR
                      
                                              ;  =cmd
A47F                                  CALL    evalLevel1ConvertReal
A47F                  9
A481                  __XBSR                  SET 9B+2
F000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A47F  BD9502                                  JSR     \1
                              ENDIF
A482                  fpFPAeq_sqr_FPA
A482                                  CALL    fpCheckMant0SetSignExp0
A482                  9
A484                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A482  BDA0FF                                  JSR     \1
                              ENDIF
A485  27F5                            BEQ     retAeqFF
A487  2B8E                            BMI     brkNegRoot
A489  9630                            LDA     ZP_FPA + 2
A48B  44                              LSRA
A48C  3401                            PSHS    CC
A48E  8941                            ADCA    #$41
A490  9730                            STA     ZP_FPA + 2
A492  3501                            PULS    CC
A494  240A                            BCC     fpFPAeq_sqr_FPA_sk6
A496  0431                            LSR     ZP_FPA + 3
A498  0632                            ROR     ZP_FPA + 4
A49A  0633                            ROR     ZP_FPA + 5
A49C  0634                            ROR     ZP_FPA + 6
A49E  0635                            ROR     ZP_FPA + 7
A4A0                  fpFPAeq_sqr_FPA_sk6
A4A0                                  CALL    fpSetRealBto0
A4A0                  9
A4A2                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0097                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A4A0  BDA239                                  JSR     \1
                              ENDIF
A4A3  4F                              CLRA
A4A4  9743                            STA     ZP_FP_TMP
A4A6  9744                            STA     ZP_FP_TMP + 1
A4A8  9745                            STA     ZP_FP_TMP + 2
A4AA  9746                            STA     ZP_FP_TMP + 3
A4AC  8640                            LDA     #$40
A4AE  973D                            STA     ZP_FPB + 2
A4B0  9742                            STA     ZP_FPB + 7
A4B2  8E0000                          LDX     #$0
A4B5  C610                            LDB     #$10
A4B7  D74C                            STB     ZP_FP_TMP_PTR2
A4B9  9631                            LDA     ZP_FPA + 3
A4BB  8040                            SUBA    #$40
A4BD  9731                            STA     ZP_FPA + 3
A4BF                  fpFPAeq_sqr_FPA_lp1             
A4BF  964C                            LDA     ZP_FP_TMP_PTR2
A4C1  A8883D                          EORA    ZP_FPB + 2,X
A4C4  A78842                          STA     ZP_FP_TMP - 1,X
A4C7  9631                            LDA     ZP_FPA + 3
A4C9  9142                            CMPA    ZP_FPB + 7
A4CB  2616                            BNE     fpFPAeq_sqr_FPA_sk2
A4CD  3410                            PSHS    X
A4CF  8E0000                          LDX     #$0                             
A4D2                  fpFPAeq_sqr_FPA_lp2
A4D2  A68832                          LDA     ZP_FPA + 4, X
A4D5  A18843                          CMPA    ZP_FP_TMP, X
A4D8  2607                            BNE     fpFPAeq_sqr_FPA_sk1
A4DA  3001                            LEAX    1,X
A4DC  8C0004                          CMPX    #4
A4DF  26F1                            BNE     fpFPAeq_sqr_FPA_lp2
A4E1                  fpFPAeq_sqr_FPA_sk1
A4E1  3510                            PULS    X
A4E3                  fpFPAeq_sqr_FPA_sk2
A4E3  2523                            BCS     fpFPAeq_sqr_FPA_sk3
A4E5  DC34                            LDD     ZP_FPA + 6
A4E7  9345                            SUBD    ZP_FP_TMP + 2
A4E9  DD34                            STD     ZP_FPA + 6
A4EB  DC32                            LDD     ZP_FPA + 4
A4ED  D244                            SBCB    ZP_FP_TMP + 1
A4EF  9243                            SBCA    ZP_FP_TMP + 0
A4F1  DD32                            STD     ZP_FPA + 4
A4F3  9631                            LDA     ZP_FPA + 3
A4F5  9242                            SBCA    ZP_FPB + 7
A4F7  9731                            STA     ZP_FPA + 3
A4F9  964C                            LDA     ZP_FP_TMP_PTR2
A4FB  48                              ASLA
A4FC  240F                            BCC     fpFPAeq_sqr_FPA_sk4
A4FE  4C                              INCA
A4FF  A8883C                          EORA    ZP_FPB + 1,X
A502  A7883C                          STA     ZP_FPB + 1,X
A505  A78841                          STA     ZP_FP_TMP  - 2,X
A508                  fpFPAeq_sqr_FPA_sk3
A508  A6883D                          LDA     ZP_FPB + 2,X
A50B  2006                            BRA     fpFPAeq_sqr_FPA_sk5
A50D                  fpFPAeq_sqr_FPA_sk4
A50D  A8883D                          EORA    ZP_FPB + 2,X
A510  A7883D                          STA     ZP_FPB + 2,X
A513                  fpFPAeq_sqr_FPA_sk5
A513  A78842                          STA     ZP_FP_TMP - 1,X
A516  0835                            ASL     ZP_FPA + 7
A518  0934                            ROL     ZP_FPA + 6
A51A  0933                            ROL     ZP_FPA + 5
A51C  0932                            ROL     ZP_FPA + 4
A51E  0931                            ROL     ZP_FPA + 3
A520  044C                            LSR     ZP_FP_TMP_PTR2
A522  249B                            BCC     fpFPAeq_sqr_FPA_lp1
A524  C680                            LDB     #$80
A526  D74C                            STB     ZP_FP_TMP_PTR2
A528  3001                            LEAX    1,X
A52A  8C0005                          CMPX    #5
A52D  2690                            BNE     fpFPAeq_sqr_FPA_lp1
A52F                                  CALL    fpCopyBManttoA_NewAPI
A52F                  9
A531                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A52F  BD8711                                  JSR     \1
                              ENDIF
A532                  fpNormalizeAndReturnFPA                                 ; LA854
A532  9631                            LDA     ZP_FPA + 3
A534  2B03                            BMI     1F
A536                                  CALL    NormaliseRealA_3
A536                  9
A538                  __XBSR                  SET 9B+2
E000                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A536  BD85D5                                  JSR     \1
                              ENDIF
A539                  1               CALL    fpRoundMantissaFPA
A539                  9
A53B                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A539  BDA34B                                  JSR     \1
                              ENDIF
A53C  86FF                            LDA     #$FF
A53E  39                              RTS
A53F                  LA861NewAPI
                      *               B -> # of iterations
                      *               X -> table of constants to use
                      *               Y -> constant to use if FPA is too small                ( was A )
                      * IF FPA < 0.5e-40 THEN FPA = U
                      * ELSE 
                      *       FPTEMP1 = 1/FPA
                      *       FPA     = X(0) + FPTEMP1
                      *       I%=1
                      *       REPEAT
                      *               FPA = FPTEMP1 + X(I% + 1) + X(I%) / FPA
                      *               B = B - 1
                      *               I% = I% + 2
                      *       UNTIL B = 0
                      
                      
A53F  D747                            STB     ZP_FP_TMP + 4                   ;                                               iter = B
A541  9F4C                            STX     ZP_FP_TMP_PTR2                  ;                                               PTR2 = tablestart
A543  9630                            LDA     ZP_FPA + 2                      ; get FPA exponent                              
A545  8140                            CMPA    #$40                            ;                                               if ABS(FPA)<1E-64
A547  2527                            BLO     fpYtoPTR1toFPA                  ; if <-$40 approximate as constant at Y                 RETURN default from Y
A549                                  CALL    fpFPAeq1.0divFPA                ;                                               FPA=1/FPA
A549                  9
A54B                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A549  BDA2A0                                  JSR     \1
                              ENDIF
A54C                                  CALL    fpCopyFPA_FPTEMP1               ;                                               TMP=FPA
A54C                  9
A54E                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A54C  BDA1EC                                  JSR     \1
                              ENDIF
A54F  9E4C                            LDX     ZP_FP_TMP_PTR2                  ;                       
A551  9F4A                            STX     ZP_FP_TMP_PTR1                  ;                                               PTR1 = tablestart
A553                                  CALL    fpFPAeqPTR1addFPA               ;                                               FPA = X(0) + 1/FPA
A553                  9
A555                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A553  BDA343                                  JSR     \1
                              ENDIF
A556                  LA879                                                   ;                                               REPEAT
A556                                  CALL    LA886                           ;                                                       CALL LA886
A556                  9
A558                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A556  8D0C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A558  8E046C                          LDX     #BASWKSP_FPTEMP1
A55B  9F4A                            STX     ZP_FP_TMP_PTR1
A55D                                  CALL    fpFPAeqPTR1addFPA
A55D                  9
A55F                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A55D  BDA343                                  JSR     \1
                              ENDIF
A560  0A47                            DEC     ZP_FP_TMP + 4
A562  26F2                            BNE     LA879
A564                  LA886
A564                                  CALL    fpAdd5toPTR2copytoPTR1
A564                  9
A566                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A564  BDA248                                  JSR     \1
                              ENDIF
A567                                  CALL    fpFPAeqPTR1divFPA
A567                  9
A569                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A567  BDA2A5                                  JSR     \1
                              ENDIF
A56A                                  CALL    fpAdd5toPTR2copytoPTR1
A56A                  9
A56C                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A56A  BDA248                                  JSR     \1
                              ENDIF
A56D                                  JUMP    fpFPAeqPTR1addFPA
A56D  7EA343                                  JMP     \1
A570                  fpYtoPTR1toFPA                                          ; LA896
A570  DF4A                            STU     ZP_FP_TMP_PTR1
A572                                  JUMP    fpCopyPTR1toFPA
A572  7EA213                                  JMP     \1
A575                  fnACS
                      
A575                                          TODO_CMD "ACS"
A575                                          TODODEADEND "\1"
A575                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A575  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A576  7E443A                          FCB             $7E,"D:"
A579  414353                          FCB             \1
A57C  00                              FCB             0
                                              
                      ;                       ;  =ACS
                      ;               CALL fnASN
                      ;               BRA fpFPAEqPiDiv2SubFPA
A57D                  fnASN
                      
A57D                                          TODO_CMD "ASN"
A57D                                          TODODEADEND "\1"
A57D                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A57D  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A57E  7E443A                          FCB             $7E,"D:"
A581  41534E                          FCB             \1
A584  00                              FCB             0
                                              
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA ZP_FPA
                      ;               BPL LA8AF
                      ;               STZ ZP_FPA
                      ;               CALL LA8AF
                      ;               BRA LA8D2
                      ;LA8AF:
                      ;               CALL fpCopyFPA_FPTEMP3
                      ;               CALL LA929
                      ;               LDA ZP_FPA + 3
                      ;               BEQ fpSetFPAPIdiv2
                      ;               CALL LA5B3
                      ;               BRA LA8C6
A585                  fpSetFPAPIdiv2                                          ; LA8BE
A585  8EBA6D                          LDX     #fpConstPiDiv2
A588                                  JUMP    fpCopyXtoFPA
A588  7EA215                                  JMP     \1
A58B                  fnATN
A58B                                  CALL evalLevel1ConvertReal
A58B                  9
A58D                  __XBSR                  SET 9B+2
EF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A58B  BD9502                                  JSR     \1
                              ENDIF
A58E                  LA8C6
A58E                                  CALL    fpCheckMant0SetSignExp0
A58E                  9
A590                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A58E  BDA0FF                                  JSR     \1
                              ENDIF
A591  2766                            BEQ     LA926_retFF
A593  2A07                            BPL     LA8D5
A595  0F2E                            CLR     ZP_FPA
A597                                  CALL    LA8D5
A597                  9
A599                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A597  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A599  972E            LA8D2           STA     ZP_FPA                          ; set minus result and return FF
A59B  39                              RTS
A59C                  LA8D5
A59C  9630                            LDA     ZP_FPA + 2
A59E  8181                            CMPA    #$81
A5A0  2510                            BLO     LA8EA
A5A2                                  CALL    fpFPAeq1.0divFPA
A5A2                  9
A5A4                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5A2  BDA2A0                                  JSR     \1
                              ENDIF
A5A5                                  CALL    LA8EA
A5A5                  9
A5A7                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5A5  8D0B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5A7                  fpFPAEqPiDiv2SubFPA                                     ; LA8E1
A5A7  8EBA6D                          LDX     #fpConstPiDiv2
A5AA  9F4A                            STX     ZP_FP_TMP_PTR1
A5AC                                  CALL    fpFPAeqPTR1subFPA
A5AC                  9
A5AE                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5AC  BDA340                                  JSR     \1
                              ENDIF
A5AF  86FF                            LDA     #$FF
A5B1  39                              RTS
A5B2                  LA8EA
A5B2  9630                            LDA     ZP_FPA + 2
A5B4  8173                            CMPA    #$73
A5B6  2541                            BLO     LA926_retFF
A5B8                                  CALL    fpCopyFPA_FPTEMP3
A5B8                  9
A5BA                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5B8  BDA1E5                                  JSR     \1
                              ENDIF
A5BB                                  CALL    fpSetRealBMantTo0
A5BB                  9
A5BD                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0082                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5BB  BDA23F                                  JSR     \1
                              ENDIF
A5BE  8680                            LDA     #$80
A5C0  973C                            STA     ZP_FPB + 1
A5C2  973D                            STA     ZP_FPB + 2
A5C4  973B                            STA     ZP_FPB
A5C6                                  CALL    fpAddAtoBStoreAndRoundA
A5C6                  9
A5C8                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5C6  BDA348                                  JSR     \1
                              ENDIF
A5C9  3440                            PSHS    U
A5CB  8EBAD6                          LDX     #fpConstMin0_08005
A5CE  CEBB08                          LDU     #fpConst0_9273
A5D1  C604                            LDB     #$04
A5D3                                  CALL    LA861NewAPI
A5D3                  9
A5D5                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5D3  BDA53F                                  JSR     \1
                              ENDIF
A5D6                                  CALL    fpFPAeqFPTEMP3mulFPA
A5D6                  9
A5D8                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5D6  BDA685                                  JSR     \1
                              ENDIF
A5D9  35C0                            PULS    U,PC
                      
                      
                      
A5DB                  fnSIN                   ; LA90D!
                      
                      ;                       ;  =SIN
A5DB                                  CLC
A5DB  1CFE                    ANDCC   #~CC_C
A5DD  2002                            BRA     fnSINenter
                      
A5DF                  fnCOS
A5DF                                  SEC
A5DF  1A01                    ORCC    #CC_C
                      ;                       ;  =COS
A5E1                  fnSINenter
A5E1  3401                            PSHS    CC                      ; Save CC to see whether its sin or cos
A5E3                                  CALL    trigNormaltheta
A5E3                  9
A5E5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0029                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5E3  8D29                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5E5  3501                            PULS    CC
A5E7  2402                            BCC     fnSIN_internal1
A5E9                  fnCOS_internal1                                 ; LA915
A5E9  0C49                            INC     ZP_FP_TMP + 6
A5EB                  fnSIN_internal1                                 ; LA917
A5EB  9649                            LDA     ZP_FP_TMP + 6
A5ED  8502                            BITA    #$02
A5EF  2705                            BEQ     LA923
A5F1                                  CALL    LA923
A5F1                  9
A5F3                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5F1  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5F3                                  JUMP    fpNegateFP_A
A5F3  7EA986                                  JMP     \1
A5F6                  LA923
A5F6  44                              LSRA
A5F7  2503                            BCS     LA929
A5F9                  LA926_retFF                                     ; LA926
A5F9  86FF                            LDA     #$FF
A5FB  39                              RTS
A5FC                  LA929
A5FC                                  CALL    fpCopyFPA_FPTEMP1
A5FC                  9
A5FE                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5FC  BDA1EC                                  JSR     \1
                              ENDIF
A5FF                                  CALL    fpFPAeqPTR1mulFPA
A5FF                  9
A601                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5FF  BDA35C                                  JSR     \1
                              ENDIF
A602                                  LDX_FPC fpConst1
A602  8EBAD1                                  LDX     #\1             ; leave as LDX for now for faster execution
A605  9F4A                            STX     ZP_FP_TMP_PTR1
A607                                  CALL    fpFPAeqPTR1subFPA
A607                  9
A609                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A607  BDA340                                  JSR     \1
                              ENDIF
A60A                                  CALL    fpFPAeq_sqr_FPA
A60A                  9
A60C                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A60A  BDA482                                  JSR     \1
                              ENDIF
A60D  39                              RTS
A60E                  trigNormaltheta                                                 ; LA93A
A60E                                  CALL    evalLevel1ConvertReal
A60E                  9
A610                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A60E  BD9502                                  JSR     \1
                              ENDIF
A611  9630                            LDA     ZP_FPA + 2
A613  8198                            CMPA    #$98
A615  2479                            BHS     brkAccuracyLost
A617                                  CALL    fpCopyFPA_FPTEMP1
A617                  9
A619                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A617  BDA1EC                                  JSR     \1
                              ENDIF
A61A                                  LDX_FPC fpConstPiDiv2
A61A  8EBA6D                                  LDX     #\1             ; leave as LDX for now for faster execution
A61D                                  CALL    fpMoveRealAtXtoFPB                      ; FPB = PI/2
A61D                  9
A61F                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A61D  BDA1C4                                  JSR     \1
                              ENDIF
A620  962E                            LDA     ZP_FPA
A622  973B                            STA     ZP_FPB                          ; change FPB's sign to same as FPA
A624  0A3C                            DEC     ZP_FPB + 1                              ; decrement exponent FPB = PI
A626                                  CALL    fpAddAtoBStoreAndRoundA                 ; add to FPA
A626                  9
A628                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A626  BDA348                                  JSR     \1
                              ENDIF
A629                                  LDX_FPC fpConst2DivPi                           ; multiply by 2/PI
A629  8EBA72                                  LDX     #\1             ; leave as LDX for now for faster execution
A62C                                  CALL    fpFPAeqXmulFPA
A62C                  9
A62E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A62C  8D5A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A62E                                  CALL    fpReal2Int                              ; take the real part
A62E                  9
A630                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A62E  BD94F6                                  JSR     \1
                              ENDIF
A631  962D                            LDA     ZP_INT_WA + 3                           ; get low byte
A633  9749                            STA     ZP_FP_TMP + 6                           ; store number of PIs (gets inc'd for sin in main routine...)
A635  9A2B                            ORA     ZP_INT_WA + 1
A637  9A2C                            ORA     ZP_INT_WA + 2
A639  272C                            BEQ     LA98D
A63B                                  CALL    IntToReal2                              ; if not zero then store
A63B                  9
A63D                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A63B  BD856F                                  JSR     \1
                              ENDIF
A63E  8E0471                          LDX     #BASWKSP_FPTEMP2                        ; integer part (as real)
A641                                  CALL    fpCopyFPA_X                             ; to BASWKSP_FPTEMP2
A641                  9
A643                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A641  BDA1F3                                  JSR     \1
                              ENDIF
A644                                  LDX_FPC fpConstMinPiDiv2
A644  8EBA63                                  LDX     #\1             ; leave as LDX for now for faster execution
A647                                  CALL    fpFPAeqXmulFPA                          ; now equals number of PI/2's to add to original param
A647                  9
A649                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A647  8D3F                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ;;;;?           CALL    FPPTR1=BASWKSP_FPTEMP1
A649  8E046C                          LDX     #BASWKSP_FPTEMP1
A64C  9F4A                            STX     ZP_FP_TMP_PTR1
A64E                                  CALL    fpFPAeqPTR1addFPA                       ; add them to normalize param
A64E                  9
A650                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A64E  BDA343                                  JSR     \1
                              ENDIF
A651                                  CALL    fpCopyFPA_PTR1                          ; store normalized param at FPTEMP1
A651                  9
A653                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A651  BDA1F1                                  JSR     \1
                              ENDIF
A654  8E0471                          LDX     #BASWKSP_FPTEMP2
A657                                  CALL    fpCopyXtoFPA
A657                  9
A659                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A657  BDA215                                  JSR     \1
                              ENDIF
A65A                                  LDX_FPC fpConst4_454e_6                         ; multiply number of cycles by 4.454e-6??? correction???
A65A  8EBA68                                  LDX     #\1             ; leave as LDX for now for faster execution
A65D                                  CALL    fpFPAeqXmulFPA
A65D                  9
A65F                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0029                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A65D  8D29                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A65F  8E046C                          LDX     #BASWKSP_FPTEMP1
A662                                  CALL    fpFPAeqXaddFPA
A662                  9
A664                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A662  BDA33B                                  JSR     \1
                              ENDIF
A665  2003                            BRA     LA990
A667                  LA98D
A667                                  CALL fpCopyFPTEMP1toFPA
A667                  9
A669                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A667  BDA20E                                  JSR     \1
                              ENDIF
A66A                  LA990
A66A  8E0476                          LDX     #BASWKSP_FPTEMP3
A66D  9F4A                            STX     ZP_FP_TMP_PTR1
A66F                                  CALL    fpCopyFPA_PTR1
A66F                  9
A671                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A66F  BDA1F1                                  JSR     \1
                              ENDIF
A672                                  CALL    fpFPAeqPTR1mulFPA                       ; FPA = FPA * FPA ???
A672                  9
A674                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A672  BDA35C                                  JSR     \1
                              ENDIF
A675                                  LDX_FPC fpConstMin0_011909
A675  8EBAB3                                  LDX     #\1             ; leave as LDX for now for faster execution
A678  3440                            PSHS    U
A67A                                  LDU_FPC fpConst1
A67A  108EBAD1                                LDY     #\1             ; leave as LDX for now for faster execution
A67E  C602                            LDB     #$02
A680                                  CALL    LA861NewAPI
A680                  9
A682                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A680  BDA53F                                  JSR     \1
                              ENDIF
A683  3540                            PULS    U
A685                  fpFPAeqFPTEMP3mulFPA
A685  8E0476                          LDX     #BASWKSP_FPTEMP3
                      
                      **      NOTE: API change here was YA not X
                      ;;LA9A1 removed was A + $400, now X
                      
A688                  fpFPAeqXmulFPA
A688  9F4A                            STX     ZP_FP_TMP_PTR1
A68A                                  CALL    fpFPAeqPTR1mulFPA
A68A                  9
A68C                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A68A  BDA35C                                  JSR     \1
                              ENDIF
A68D  86FF                            LDA     #$FF
A68F  39                              RTS
A690                  brkAccuracyLost                                         ; LA9AD
A690                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A690  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A691  174163637572616379206C6F737400                 FCB     $17, "Accuracy lost", 0
A6A0                  brkExpRange                                             ; LA9BC
A6A0                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A6A0  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A6A1  184578702072616E676500                 FCB     $18, "Exp range", 0
                      
A6AC                  fnRAD                   ; LA9C8!
                      
A6AC                                          TODO_CMD "RAD"
A6AC                                          TODODEADEND "\1"
A6AC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A6AC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A6AD  7E443A                          FCB             $7E,"D:"
A6B0  524144                          FCB             \1
A6B3  00                              FCB             0
                                              
                      ;                       ;  =RAD
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA #<fpConstDeg2Rad
                      ;               BRA fpFPAeqXmulFPA_checkusingX!
A6B4                  fnLOG
                      
A6B4                                          TODO_CMD "LOG"
A6B4                                          TODODEADEND "\1"
A6B4                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A6B4  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A6B5  7E443A                          FCB             $7E,"D:"
A6B8  4C4F47                          FCB             \1
A6BB  00                              FCB             0
                                              
                      ;                       ;  =LOG
                      ;?              CALL    fnLN
                      ;?              LDX     #fpConst0_43429
                      ;?              BRA     fpFPAeqXmulFPA
A6BC                  fnDEG
                      
A6BC                                          TODO_CMD "DEG"
A6BC                                          TODODEADEND "\1"
A6BC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A6BC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A6BD  7E443A                          FCB             $7E,"D:"
A6C0  444547                          FCB             \1
A6C3  00                              FCB             0
                                              
                      ;                       ;  =DEG
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA #<fpConstRad2Deg
                      ;               BRA fpFPAeqXmulFPA_checkusingX!
A6C4                  fnEXP                   ;  =EXP
A6C4                                  CALL    evalLevel1ConvertReal
A6C4                  9
A6C6                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6C4  BD9502                                  JSR     \1
                              ENDIF
A6C7  3440                            PSHS    U
A6C9                  LA9E2
A6C9  9630                            LDA     ZP_FPA + 2
A6CB  8187                            CMPA    #$87
A6CD  250F                            BLO     LA9F7
A6CF  2606                            BNE     LA9F0
A6D1  D631                            LDB     ZP_FPA + 3
A6D3  C1B3                            CMPB    #$B3
A6D5  2507                            BLO     LA9F7
A6D7  962E            LA9F0           LDA     ZP_FPA
A6D9  2AC5                            BPL     brkExpRange
A6DB                                  JUMP    zero_FPA
A6DB  7EA36D                                  JMP     \1
A6DE                  LA9F7           CALL    L82E0
A6DE                  9
A6E0                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6DE  BD869F                                  JSR     \1
                              ENDIF
A6E1  8EBB0D                          LDX     #fpConst0_07121
A6E4  CEBB35                          LDU     #fpConst1__2
A6E7  C603                            LDB     #$03
A6E9                                  CALL    LA861NewAPI
A6E9                  9
A6EB                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6E9  BDA53F                                  JSR     \1
                              ENDIF
A6EC                                  CALL    fpCopyFPA_FPTEMP3
A6EC                  9
A6EE                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6EC  BDA1E5                                  JSR     \1
                              ENDIF
A6EF  CEBA86                          LDU     #fpConst_e
A6F2                                  CALL    fpYtoPTR1toFPA
A6F2                  9
A6F4                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6F2  BDA570                                  JSR     \1
                              ENDIF
A6F5  9649                            LDA     ZP_FP_TMP + 6
A6F7                                  CALL    LA5BE
A6F7                  9
A6F9                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6F7  BDA273                                  JSR     \1
                              ENDIF
A6FA                                  CALL    fpFPAeqFPTEMP3mulFPA
A6FA                  9
A6FC                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A6FA  8D89                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A6FC  35C0                            PULS    U,PC
                      
                              IF FLEX != 1
A6FE                  callOSByte81withXYfromINT
A6FE                                  CALL    evalLevel1checkTypeStoreAsINT
A6FE                  9
A700                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6FE  BD94E5                                  JSR     \1
                              ENDIF
A701  8681                            LDA     #$81
A703  9E2C                            LDX     ZP_INT_WA + 2
A705  109E2B                          LDY     ZP_INT_WA + 1
A708  7EFFF4                          JMP     OSBYTE
                                                              ; Returns X=16bit OSBYTE return value
                      
                                      ; note: the RND accumulator is in a different order to 6502
                                      ; 0->3
                                      ; 1->2
                                      ; 2->1
                                      ; 3->0
                                      ; 4->4
                                      ; this makes integer ops easier but adds slight complexity to loading into FPA 
                              ENDIF
                      
A70B                  fnRND_1                                                 ; LAA1E
A70B                                  CALL    rndNext
A70B                  9
A70D                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A70B  BD86DA                                  JSR     \1
                              ENDIF
A70E                  fnRND_0                                                 ; LAA21
A70E  0F2E                            CLR     ZP_FPA
A710  0F2F                            CLR     ZP_FPA + 1
A712  0F35                            CLR     ZP_FPA + 7
A714  8680                            LDA     #$80
A716  9730                            STA     ZP_FPA + 2
                      ;               PSHS    U
                      ;               LDB     #3
                      ;               LDX     #ZP_RND_WA + 4                  ; copy random accumulator
                      ;               LDU     #ZP_FPA + 7                     ; int mantissa 6 downto 3
A718                  1;              EORA    ,-X
                      ;               STA     ,-U
                      ;               DECB
                      ;               BPL     1B
                      ;               PULS    U
A718  9610                            LDA     ZP_RND_WA+3
A71A  9731                            STA     ZP_FPA+3
A71C  960F                            LDA     ZP_RND_WA+2
A71E  9732                            STA     ZP_FPA+4
A720  960E                            LDA     ZP_RND_WA+1
A722  9733                            STA     ZP_FPA+5
A724  960D                            LDA     ZP_RND_WA+0
A726  9734                            STA     ZP_FPA+6
A728                                  JUMP    fpNormalizeAndReturnFPA
A728  7EA532                                  JMP     \1
A72B                  fnRND_int                                               ; RND(X)
A72B  3341                            LEAU    1,U
A72D                                  CALL    evalL1BracketAlreadyOpenConvert2INT
A72D                  9
A72F                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A72D  BD94D8                                  JSR     \1
                              ENDIF
A730  962A                            LDA     ZP_INT_WA + 0                   ; see if sign is -ve, if so randomize
A732  2B24                            BMI     fnRND_randomize
A734  9A2C                            ORA     ZP_INT_WA + 2
A736  9A2B                            ORA     ZP_INT_WA + 1
A738  2608                            BNE     LAA52                           ; >255
A73A  962D                            LDA     ZP_INT_WA + 3   
A73C  27D0                            BEQ     fnRND_0                         ; ==0
A73E                  LAA4E
A73E  8101                            CMPA    #$01
A740  27C9                            BEQ     fnRND_1
A742                  LAA52
A742                                  CALL    IntToReal
A742                  9
A744                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0026                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A742  BD856A                                  JSR     \1
                              ENDIF
A745                                  CALL    fpStackWAtoStackReal
A745                  9
A747                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A745  BDB7BA                                  JSR     \1
                              ENDIF
A748                                  CALL    fnRND_1
A748                  9
A74A                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A748  8DC1                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A74A                                  CALL    popFPFromStackToPTR1
A74A                  9
A74C                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A74A  BDB7AE                                  JSR     \1
                              ENDIF
A74D                                  CALL    fpFPAeqPTR1mulFPA_internal
A74D                  9
A74F                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0039                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A74D  BDA388                                  JSR     \1
                              ENDIF
A750                                  CALL    fpReal2Int
A750                  9
A752                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A750  BD94F6                                  JSR     \1
                              ENDIF
A753                                  CALL    inc_INT_WA
A753                  9
A755                  __XBSR                  SET 9B+2
1200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A753  BDBA35                                  JSR     \1
                              ENDIF
A756  201F                            BRA     LAA90_rtsA40
A758                  fnRND_randomize                                         ; LAA69
A758  8E000D                          LDX     #ZP_RND_WA
A75B                                  CALL    CopyIntWA2X
A75B                  9
A75D                  __XBSR                  SET 9B+2
1100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A75B  BDB923                                  JSR     \1
                              ENDIF
A75E  8640                            LDA     #$40
A760  9711                            STA     ZP_RND_WA + 4
A762  39                              RTS
A763                  fnRND                   ; LAA73!
A763  A6C4                            LDA     ,U
A765  8128                            CMPA    #'('
A767  27C2                            BEQ     fnRND_int
A769                                  CALL    rndNext
A769                  9
A76B                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A769  BD86DA                                  JSR     \1
                              ENDIF
A76C  8E000D                          LDX     #ZP_RND_WA
A76F                  intLoadWAFromX
A76F  EC84                            LDD     0,X
A771  DD2A                            STD     ZP_INT_WA + 0
A773  EC02                            LDD     2,X
A775  DD2C                            STD     ZP_INT_WA + 2
A777                  LAA90_rtsA40
A777  8640                            LDA     #$40
A779  39                              RTS
                      ;                       ;  =NOT
A77A                  fnNOT
                      
A77A                                  CALL    evalLevel1checkTypeStoreAsINT
A77A                  9
A77C                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A77A  BD94E5                                  JSR     \1
                              ENDIF
A77D  C603                            LDB     #$03
A77F  8E002A                          LDX     #ZP_INT_WA
A782  6385            LAA98           COM     B,X
A784  5A                              DECB
A785  2AFB                            BPL     LAA98
A787  20EE                            BRA     LAA90_rtsA40
A789                  fnPOS                   ; LAAA3!
A789                                  CALL    fnVPOS
A789                  9
A78B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A789  8D1B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A78B  9F2C                            STX     ZP_INT_WA+2
A78D  39                              RTS
A78E                  fnUSR                   ; LAAA9!
                      
                                              
                                              ;  =USR
A78E                                  CALL    evalLevel1checkTypeStoreAsINT
A78E                  9
A790                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A78E  BD94E5                                  JSR     \1
                              ENDIF
A791  3440                            PSHS    U
A793                                  CALL    callusrSetRegsEnterCode
A793                  9
A795                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A793  BD9298                                  JSR     \1
                              ENDIF
A796  3401                            PSHS    CC
A798  DF2B                            STU     ZP_INT_WA + 1                   ; note store 16 bit regs one less to get low bytes
A79A  9F2A                            STX     ZP_INT_WA + 0
A79C  972D                            STA     ZP_INT_WA + 3
A79E  3502                            PULS    A
A7A0  972A                            STA     ZP_INT_WA + 0
A7A2  3540                            PULS    U
A7A4  20D1                            BRA     LAA90_rtsA40
A7A6                  fnVPOS                  ; LAABC!
                              IF FLEX
                                      JUMP    brkFlexNotImpl
                              ELSE
A7A6  8686                            LDA     #$86
A7A8  BDFFF4                          JSR     OSBYTE
A7AB  1F20                            TFR     Y,D
A7AD                                  JUMP    retB8asUINT
A7AD  7EAAD6                                  JMP     \1
                              ENDIF
                      
                                              ;  =EXT#channel - read open file extent
                                              ; -------------------------------------
A7B0                  fnEXT
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7B0  8602                            LDA     #$02                    ; 02=Read EXT
A7B2  2001                            BRA     varGetFInfo
                              ENDIF
                                              ;  =PTR#channel - read open file pointer
                                              ; --------------------------------------
A7B4                  varGetPTR
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7B4  4F                              CLRA                            ; 00=Read PTR
A7B5                  varGetFInfo
A7B5  3402                            PSHS    A
A7B7                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
A7B7                  9
A7B9                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7B7  BDB684                                  JSR     \1
                              ENDIF
A7BA  8E002A                          LDX     #ZP_INT_WA
A7BD  3502                            PULS    A
A7BF  BDFFDA                          JSR     OSARGS                  ; Read to INTA
A7C2  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
A7C4  0D54                            TST     ZP_BIGEND
A7C6  102B034A                        LBMI    SwapEndian              ; Swap INTA
A7CA  39                              RTS
                              ENDIF
                                              ;  =BGET#channel - get byte from open file
                                              ; ----------------------------------------
A7CB                  fnBGET
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7CB                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
A7CB                  9
A7CD                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7CB  BDB684                                  JSR     \1
                              ENDIF
A7CE  BDFFD7                          JSR     OSBGET                  ; Read byte
A7D1  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
A7D3                                  JUMP    retA8asUINT
A7D3  7EAAD4                                  JMP     \1
                              ENDIF
                                              ;  =OPENIN f$ - open file for input
                                              ;  ================================
A7D6                  fnOPENIN
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7D6  8640                            LDA #$40
A7D8  2006                            BRA fileOpen                    ;  OPENIN is OSFIND $40
                              ENDIF
                                              ;  =OPENOUT f$ - open file for output
                                              ;  ==================================
A7DA                  fnOPENOUT
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7DA  8680                            LDA #$80
A7DC  2002                            BRA fileOpen                    ;  OPENOUT is OSFIND $80
                              ENDIF
                      ;                       ;  =OPENUP f$ - open file for update
                      ;                       ;  =================================
A7DE                  fnOPENUP
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7DE  86C0                            LDA #$C0                        ;  OPENUP is OSFIND $C0
                              ENDIF
A7E0                  fileOpen
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A7E0  3402                            PSHS    A
A7E2                                  CALL    evalLevel1
A7E2                  9
A7E4                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7E2  BDA9F0                                  JSR     \1
                              ENDIF
A7E5  1026E882                        LBNE    brkTypeMismatch
A7E9                                  CALL    str600CRterm
A7E9                  9
A7EB                  __XBSR                  SET 9B+2
1100                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7E9  BDB979                                  JSR     \1
                              ENDIF
A7EC  3502                            PULS    A
A7EE  BDFFCE                          JSR     OSFIND
A7F1                                  JUMP    retA8asUINT
A7F1  7EAAD4                                  JMP     \1
                              ENDIF
                      ;
A7F4                  fnPI                                                    ; LAAFF!
A7F4                                  CALL    fpSetFPAPIdiv2                  ; load PI/2 into FPA and increment exponent for PI
A7F4                  9
A7F6                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7F4  BDA585                                  JSR     \1
                              ENDIF
A7F7  0C30                            INC     ZP_FPA + 2
A7F9  39                              RTS
                      
                      ;                       ;  =EVAL string$ - Tokenise and evaluate expression
                      ;                       ;  ================================================
A7FA                  fnEVAL
                      
A7FA                                  TODO_CMD "EVAL"
A7FA                                          TODODEADEND "\1"
A7FA                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A7FA  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A7FB  7E443A                          FCB             $7E,"D:"
A7FE  4556414C                        FCB             \1
A802  00                              FCB             0
                                              
                      ;               CALL evalLevel1
                      ;               BNE JUMPBrkTypeMismatch3                ;  Evaluate value, error if not string
                      ;               INC ZP_STRBUFLEN
                      ;               LDU ZP_STRBUFLEN                        ;  Increment string length to add a <cr>
                      ;               LDA #$0D
                      ;               STA $0600 - 1,Y                         ;  Put in terminating <cr>
                      ;               CALL StackString                                ;  Stack the string
                      ;                       ;  String has to be stacked as otherwise would
                      ;                       ;   be overwritten by any string operations
                      ;                       ;   called by Evaluator
                      ;               rep             #PF_I16
                      ;               .i16
                      ;               ldx             ZP_TXTPTR2
                      ;               phx
                      ;               lda             ZP_TXTOFF2
                      ;               pha
                      ;               ldx             ZP_BAS_SP
                      ;               inx
                      ;               stx             ZP_TXTPTR2
                      ;               stx             ZP_GEN_PTR
                      ;               sep             #PF_I16
                      ;               .i8
                      ;               CALL L8E1F                              ;  Tokenise string on stack at GPTR
                      ;               STZ ZP_TXTOFF2                          ;  Point PTRB offset back to start
                      ;               CALL evalAtY                            ;  Call expression evaluator
                      ;               CALL LBCE1                              ;  Drop string from stack
                      ;pullPTRBandRTS:
                      ;               rep                     #PF_I16
                      ;               .i16
                      ;               PLA
                      ;               STA ZP_TXTOFF2                          ;  Restore PTRB
                      ;               PLX
                      ;               STX ZP_TXTPTR
                      ;               sep                     #PF_A16
                      ;               .i8
                      ;               LDA ZP_VARTYPE                          ;  Get expression return value
                      ;               RTS                                     ;  And return
A803                  JUMPBrkTypeMismatch3
A803                                  JUMP brkTypeMismatch
A803  7E906B                                  JMP     \1
                      ;
                      ;
A806                  fnVAL
                      
                                              ;  =VAL
A806                                  CALL    evalLevel1
A806                  9
A808                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A806  BDA9F0                                  JSR     \1
                              ENDIF
A809  26F8                            BNE     JUMPBrkTypeMismatch3
A80B  D636            str2Num         LDB     ZP_STRBUFLEN
A80D  8E0600                          LDX     #BASWKSP_STRING
A810  3A                              ABX
A811  6F84                            CLR     ,X
A813  3440                            PSHS    U
A815  CE0600                          LDU     #BASWKSP_STRING
A818                                  CALL    skipSpacesY
A818                  9
A81A                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A818  BD8F0C                                  JSR     \1
                              ENDIF
A81B  812D                            CMPA    #'-'
A81D  270C                            BEQ     1F
A81F  812B                            CMPA    #'+'
A821  2603                            BNE     2F
A823                                  CALL    skipSpacesY
A823                  9
A825                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A823  BD8F0C                                  JSR     \1
                              ENDIF
A826                  2               CALL    parseDecimalLiteral
A826                  9
A828                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A826  BD9FF9                                  JSR     \1
                              ENDIF
A829  200B                            BRA     3F
A82B                  1               CALL    skipSpacesY
A82B                  9
A82D                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A82B  BD8F0C                                  JSR     \1
                              ENDIF
A82E                                  CALL    parseDecimalLiteral
A82E                  9
A830                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A82E  BD9FF9                                  JSR     \1
                              ENDIF
A831  2403                            BCC     3F
A833                                  CALL    evalLevel1CheckNotStringAndNegate
A833                  9
A835                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A833  BDA995                                  JSR     \1
                              ENDIF
A836  9727            3               STA     ZP_VARTYPE
A838  35C0                            PULS    U,PC
                      ;               
                      ;               
A83A                  fnINT
                      
A83A                                  CALL    evalLevel1
A83A                  9
A83C                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A83A  BDA9F0                                  JSR     \1
                              ENDIF
A83D  1027E82A                        LBEQ    brkTypeMismatch
A841  2A23                            BPL     1F                      ; already an INT
A843  962E                            LDA     ZP_FPA
A845  3401                            PSHS    CC                      ; get sign in Z flag and save
A847                                  CALL    fpFPAMant2Int_remainder_inFPB
A847                  9
A849                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A847  BD863B                                  JSR     \1
                              ENDIF
A84A  3501                            PULS    CC
A84C  2A13                            BPL     LABAD                   ; if positive don't round down, just return FPA mant as int
A84E  963D                            LDA     ZP_FPB + 2
A850  9A3E                            ORA     ZP_FPB + 3
A852  9A3F                            ORA     ZP_FPB + 4
A854  9A40                            ORA     ZP_FPB + 5
A856  2709                            BEQ     LABAD                   ; if remainder is 0 don't round down
A858                                  CALL    fpReal2Int_NegateMantissa       ; round down by decrementing mantissa - TODO: speed this up if room
A858                  9
A85A                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A858  BD868E                                  JSR     \1
                              ENDIF
A85B                                  CALL    fpIncrementFPAMantissa
A85B                  9
A85D                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A85B  BD86C9                                  JSR     \1
                              ENDIF
A85E                                  CALL    fpReal2Int_NegateMantissa
A85E                  9
A860                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A85E  BD868E                                  JSR     \1
                              ENDIF
A861                  LABAD
A861                                  CALL    fpCopyAmant2intWA
A861                  9
A863                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0096                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A861  BD94F9                                  JSR     \1
                              ENDIF
A864  8640                            LDA     #$40
A866  39              1               RTS                             ;LABB2:
                      
                      
                      
A867                  fnASC
A867                                  CALL    evalLevel1
A867                  9
A869                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A867  BDA9F0                                  JSR     \1
                              ENDIF
A86A  1026E7FD                        LBNE    brkTypeMismatch
A86E  9636                            LDA     ZP_STRBUFLEN
A870  271F                            BEQ     returnINTminus1
A872  F60600                          LDB     BAS_StrA
A875                                  JUMP    retB8asUINT
A875  7EAAD6                                  JMP     \1
                      
A878                  fnINKEY         ;  =INKEY
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A878                                  CALL    callOSByte81withXYfromINT
A878                  9
A87A                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0084                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A878  BDA6FE                                  JSR     \1
                              ENDIF
A87B  8C8000                          CMPX    #$8000                          ; Check if X<0
A87E  2411                            BHS     returnINTminus1
A880                                  JUMP    retX16asUINT
A880  7EAAE0                                  JMP     \1
                              ENDIF
                      
                                              ;  =EOF#channel - return EndOfFile status - here to be near fnTRUE and fnFALSE
                                              ;  ===========================================================================
A883                  fnEOF
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
A883                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
A883                  9
A885                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A883  BDB684                                  JSR     \1
                              ENDIF
A886  30A4                            LEAX    ,Y                      ; X=channel
A888  867F                            LDA     #$7F
A88A  BDFFF4                          JSR     OSBYTE                  ; OSBYTE $7F to read EOF
A88D  3084                            LEAX    0,X                     ; Test X
A88F  270C                            BEQ     varFALSE                ; If &00, return FALSE
                                                                      ; Otherwise, return TRUE
                                                                      ;  Otherwise, return TRUE
                              ENDIF
                                              ;  =TRUE
                                              ;  =====
A891                  returnINTminus1                                 ; TODO - possibly use D?
A891  C6FF                            LDB #$FF                        ;  Return -1
A893  1D              returnB8asINT_S SEX
A894  972A                            STA ZP_INT_WA
A896  972B                            STA ZP_INT_WA + 1
A898  DD2C                            STD ZP_INT_WA + 2
A89A  8640            returnINT       LDA #$40
A89C  39                              RTS                             ;  Return Integer
                                              ;  =FALSE
                                              ;  ======
A89D                  varFALSE                        
A89D  5F                              CLRB
A89E  20F3                            BRA returnB8asINT_S                     ;  Jump to return 0
                      
                      
A8A0                  fnSGN_real                                              ; LABEC
A8A0                                  CALL    fpCheckMant0SetSignExp0
A8A0                  9
A8A2                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8A0  BDA0FF                                  JSR     \1
                              ENDIF
A8A3  27F8                            BEQ     varFALSE
A8A5  2A17                            BPL     fnSGN_pos
A8A7  20E8                            BRA     returnINTminus1
A8A9                  fnSGN                                                   ; LABF5!
A8A9                                  CALL    evalLevel1
A8A9                  9
A8AB                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0045                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8A9  BDA9F0                                  JSR     \1
                              ENDIF
A8AC  1027E7BB                        LBEQ    brkTypeMismatch
A8B0  2BEE                            BMI     fnSGN_real
A8B2  962A                            LDA     ZP_INT_WA + 0
A8B4  2BDB                            BMI     returnINTminus1
A8B6  9A2B                            ORA     ZP_INT_WA + 1
A8B8  9A2C                            ORA     ZP_INT_WA + 2
A8BA  9A2D                            ORA     ZP_INT_WA + 3
A8BC  27DC                            BEQ     returnINT
A8BE  C601            fnSGN_pos       LDB     #1
A8C0  20D1                            BRA     returnB8asINT_S
                      
                      
A8C2                  fnPOINT                 ; LAC0E!
                                              ; TODO: use hw stack?
A8C2                                  CALL    evalAtYcheckTypeInAConvert2INT
A8C2                  9
A8C4                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8C2  BD94E0                                  JSR     \1
                              ENDIF
A8C5                                  CALL    stackINT_WAasINT                ; stack X coord
A8C5                  9
A8C7                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8C5  BDB7DA                                  JSR     \1
                              ENDIF
A8C8                                  CALL    skipSpacesCheckCommaAtYOrBRK
A8C8                  9
A8CA                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8C8  BD8F1E                                  JSR     \1
                              ENDIF
A8CB                                  CALL    evalL1BracketAlreadyOpenConvert2INT
A8CB                  9
A8CD                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8CB  BD94D8                                  JSR     \1
                              ENDIF
A8CE  DC2C                            LDD     ZP_INT_WA+2                     ; get Y coordinate big-endian
A8D0  3406                            PSHS    D
A8D2                                  CALL    popIntANew
A8D2                  9
A8D4                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0098                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8D2  BDB86C                                  JSR     \1
                              ENDIF
A8D5  DC2C                            LDD     ZP_INT_WA+2                     ; get X coordinate big-endian
A8D7  1E89                            EXG     A,B
A8D9  DD2A                            STD     ZP_INT_WA                       ; store X coordinate little-endian
A8DB  3506                            PULS    D
A8DD  1E89                            EXG     A,B
A8DF  DD2C                            STD     ZP_INT_WA+2                     ; store Y coordinate little-endian
A8E1  8E002A                          LDX     #ZP_INT_WA
A8E4  8609                            LDA     #9
A8E6  BDFFF1                          JSR     OSWORD
A8E9  D62E                            LDB     ZP_INT_WA+4
A8EB  2BA4                            BMI     returnINTminus1
A8ED  20A4                            BRA     returnB8asINT_S
A8EF                  fnINSTR
                      
A8EF                                  CALL    evalAtY
A8EF                  9
A8F1                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8EF  BD9A41                                  JSR     \1
                              ENDIF
A8F2  4D                              TSTA
A8F3  1026E774                        LBNE    brkTypeMismatch
A8F7  C12C                            CMPB    #','
A8F9  1026E626                        LBNE    brkMissingComma
A8FD  0C1B                            INC     ZP_TXTOFF2
A8FF                                  CALL    StackString
A8FF                  9
A901                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8FF  BDB7F4                                  JSR     \1
                              ENDIF
A902  3341                            LEAU    1,U
A904                                  CALL    evalAtY
A904                  9
A906                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A904  BD9A41                                  JSR     \1
                              ENDIF
A907  4D                              TSTA
A908  1026E75F                        LBNE    brkTypeMismatch
A90C                                  CALL    StackString
A90C                  9
A90E                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A90C  BDB7F4                                  JSR     \1
                              ENDIF
A90F  8601                            LDA     #$01
A911  972D                            STA     ZP_INT_WA + 3                   ; Default starting index (rest of INT_WA ignored)
A913  3341                            LEAU    1,U
                      ;;              INC     ZP_TXTOFF2
A915  C129                            CMPB    #')'
A917  2709                            BEQ     fnINSTR_sk_nop3
A919  C12C                            CMPB    #','
A91B  1026E604                        LBNE    brkMissingComma
A91F                                  CALL    evalL1BracketAlreadyOpenConvert2INT
A91F                  9
A921                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A91F  BD94D8                                  JSR     \1
                              ENDIF
                      
A922  0D2D            fnINSTR_sk_nop3 TST     ZP_INT_WA + 3
A924  2602                            BNE     1F
A926  0C2D                            INC     ZP_INT_WA + 3                   ; if 0 make 1
A928  0A2D            1               DEC     ZP_INT_WA + 3                   ; now make it 0 based!
                      
A92A  3440                            PSHS    U                               ; save Y we're about to use it for matching
A92C  4F                              CLRA
A92D  DE04                            LDU     ZP_BAS_SP
A92F  E6C0                            LDB     ,U+                             ; D now contains length of second string
A931  D72A                            STB     ZP_INT_WA
A933  30C4                            LEAX    ,U                              ; X now points to start of second string
A935  33CB                            LEAU    D,U                             ; unstack string but leave in place for tests below
A937  E6C0                            LDB     ,U+                             ; D now contains length of first string
A939  D72B                            STB     ZP_INT_WA + 1
A93B  31C4                            LEAY    ,U                              ; U points to start of 1st string
A93D  33CB                            LEAU    D,U                             ; unstack string but leave in place
A93F  DF04                            STU     ZP_BAS_SP
A941  D62D                            LDB     ZP_INT_WA + 3
A943  31AB                            LEAY    D,Y                             ; skip to param 3 offset
                      
A945                  fnINSTR_lp1     
A945  962D                            LDA     ZP_INT_WA + 3
A947  9B2A                            ADDA    ZP_INT_WA
A949  912B                            CMPA    ZP_INT_WA + 1
A94B  221F                            BHI     fnINSTR_notfound                ; if length of match and offset > length of 1st param no match
A94D  3430                            PSHS    X,Y                             ; save X,Y
A94F  D62A                            LDB     ZP_INT_WA
A951  A680            1               LDA     ,X+
A953  A1A0                            CMPA    ,Y+
A955  260D                            BNE     fnINSTR_sknom                   ; nomatch try moving on one
A957  5A                              DECB
A958  26F7                            BNE     1B
                                      ; we have a match
A95A  3264                            LEAS    4,S                             ; discard saved X,Y
A95C  3540                            PULS    U                               ; get back original Y
A95E  962D                            LDA     ZP_INT_WA + 3
A960  4C                              INCA                                    ; make back to 1 based
A961                                  JUMP    retA8asUINT
A961  7EAAD4                                  JMP     \1
A964  3530            fnINSTR_sknom   PULS    X,Y
A966  3121                            LEAY    1,Y
A968  0C2D                            INC     ZP_INT_WA + 3
A96A  20D9                            BRA     fnINSTR_lp1
                      
A96C                  fnINSTR_notfound
A96C  3540                            PULS    U
A96E  4F                              CLRA
A96F                                  JUMP    retA8asUINT
A96F  7EAAD4                                  JMP     \1
                      
                      
                      ;               CALL    popStackedString
                      ;LAC60:
                      ;               LDX ZP_INT_WA
                      ;               BNE LAC66
                      ;               LDX #$01
                      ;LAC66:
                      ;               STX ZP_INT_WA
                      ;               TXA
                      ;               DEX
                      ;               STX ZP_INT_WA + 3
                      ;               CLC
                      ;               ADC ZP_BAS_SP
                      ;               STA ZP_GEN_PTR
                      ;               LDA #$00
                      ;               ADC ZP_BAS_SP + 1
                      ;               STA ZP_GEN_PTR + 1
                      ;               LDA (ZP_BAS_SP)
                      ;               SEC
                      ;               SBC ZP_INT_WA + 3
                      ;               BCC LAC9F
                      ;               SBC ZP_STRBUFLEN
                      ;               BCC LAC9F
                      ;               ADC #$00
                      ;               STA ZP_INT_WA + 1
                      ;               CALL LBCE1
                      ;LAC89:
                      ;               LDU #$00
                      ;               LDX ZP_STRBUFLEN
                      ;               BEQ LAC9A
                      ;LAC8F:
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               CMP $0600,Y
                      ;               BNE LACA6
                      ;               INY
                      ;               DEX
                      ;               BNE LAC8F
                      ;LAC9A:
                      ;               LDA ZP_INT_WA
                      ;LAC9C:
                      ;               LBRA retA8asUINT
                      ;LAC9F:
                      ;               CALL LBCE1
                      ;LACA2:
                      ;               LDA #$00
                      ;               BRA LAC9C
                      ;LACA6:
                      ;               INC ZP_INT_WA
                      ;               DEC ZP_INT_WA + 1
                      ;               BEQ LACA2
                      ;               INC ZP_GEN_PTR
                      ;               BNE LAC89
                      ;               INC ZP_GEN_PTR + 1
                      ;               BRA LAC89
                      ;JUMPBrkTypeMismatch:
                      ;               JUMP brkTypeMismatch
                      ;               
A972                  fnABS                   ;  =ABS
A972                                  CALL    evalLevel1
A972                  9
A974                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A972  8D7C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A974  1027E6F3                        LBEQ    brkTypeMismatch
A978  2B06                            BMI     fpClearWA_A_sign
A97A  0D2A            intWA_ABS       TST     ZP_INT_WA + 0
A97C  2B1D                            BMI     negateIntA
A97E  202B                            BRA     A_eq_40_rts
A980                  fpClearWA_A_sign
A980  0F2E                            CLR     ZP_FPA
A982  39                              RTS
                      ;                       ;  Negate real
                      ;                       ;  -----------
A983                  fpFPAeqPTR1subFPAnegFPA                                 ; LACC7
A983                                  CALL    fpFPAeqPTR1subFPA               ; A = PTR1 - A, then negate A == A - PTR1
A983                  9
A985                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A983  BDA340                                  JSR     \1
                              ENDIF
A986                  fpNegateFP_A
A986  9631                            LDA     ZP_FPA + 3
A988  2706                            BEQ     1F                              ;  Mantissa=0 - zero
A98A  962E                            LDA     ZP_FPA
A98C  8880                            EORA    #$80
A98E  972E                            STA     ZP_FPA                  ;  Negate sign fp sign
A990  86FF            1               LDA #$FF
A992  39                              RTS                                     ;  Return real
                      
                      ;                       ;  -<value>
                      ;                       ;  --------
A993                  evalLevel1UnaryMinus
A993                                  CALL    evalLevel1UnaryPlus             ;  Call Level 1 Evaluator, get next value
A993                  9
A995                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A993  8D6D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A995                  evalLevel1CheckNotStringAndNegate                       ; LACDA
A995  1027E6D2                        LBEQ    brkTypeMismatch                 ;  -<string> - Type mismatch
A999  2BEB                            BMI     fpNegateFP_A                    ;  -<real> - Jump to negate real
                      ;               
A99B                  negateIntA      
A99B  CC0000                          LDD     #0
A99E  932C                            SUBD    ZP_INT_WA + 2
A9A0  DD2C                            STD     ZP_INT_WA + 2
A9A2  CC0000                          LDD     #0
A9A5  D22B                            SBCB    ZP_INT_WA + 1
A9A7  922A                            SBCA    ZP_INT_WA + 0
A9A9  DD2A                            STD     ZP_INT_WA + 0
A9AB  8640            A_eq_40_rts     LDA     #$40
A9AD  39                              RTS
                      ;               
                      ;               
A9AE                  readCommaSepString                                      ; LACF8
A9AE                                  CALL    skipSpacesY
A9AE                  9
A9B0                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
005C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9AE  BD8F0C                                  JSR     \1
                              ENDIF
A9B1  8122                            CMPA    #'"'
A9B3  271B                            BEQ     evalLevel1StringLiteral
A9B5  8E0600                          LDX     #BAS_StrA
A9B8  335F                            LEAU    -1,U
A9BA  A6C0            1               LDA     ,U+
A9BC  A780                            STA     ,X+
A9BE  810D                            CMPA    #$0D
A9C0  2704                            BEQ     LAD10
A9C2  812C                            CMPA    #','
A9C4  26F4                            BNE     1B
A9C6  335F            LAD10           LEAU    -1,U
A9C8  1F10                            TFR     X,D
A9CA  5A                              DECB
A9CB  D736                            STB     ZP_STRBUFLEN
A9CD  8600                            LDA #$00
A9CF  39                              RTS
                      ;                       ;  String value
                      ;                       ;  ------------
A9D0                  evalLevel1StringLiteral                         ;LAD19:
A9D0  8E0600                          LDX     #BAS_StrA
A9D3                  evalLevel1StringLiteral_lp                      ;LAD1C:
A9D3  A6C0                            LDA     ,U+
A9D5  810D                            CMPA    #$0D
A9D7  1027E860                        LBEQ    brkMissingQuote
A9DB  A780                            STA     ,X+
A9DD  8122                            CMPA    #'"'
A9DF  26F2                            BNE     evalLevel1StringLiteral_lp
A9E1  A6C0                            LDA     ,U+
A9E3  8122                            CMPA    #'"'
A9E5  27EC                            BEQ     evalLevel1StringLiteral_lp
A9E7  335F                            LEAU    -1,U
A9E9  1F10                            TFR     X,D
A9EB  5A                              DECB
A9EC  D736                            STB     ZP_STRBUFLEN
A9EE  4F                              CLRA
A9EF  39                              RTS
                      ;               
                      ;                       ;  Evaluator Level 1 - $ - + () " ? ! | $ function variable
                      ;                       ;  ========================================================
                      ;                       ;  Evaluate a value - called by functions for value parameters
                      ;                       ;
A9F0                  evalLevel1                                              ; LAD36
                      ;                               LEAU    1,Y             ; TODO - not sure whether to inc here or after
A9F0  A6C0                            LDA     ,U+                             ;  Get next character
A9F2  8120                            CMPA    #' '
A9F4  27FA                            BEQ     evalLevel1                      ;  Skip spaces
A9F6  812D                            CMPA    #'-'
A9F8  2799                            BEQ     evalLevel1UnaryMinus            ;  Unary minus
A9FA  8122                            CMPA    #'"'
A9FC  27D2                            BEQ     evalLevel1StringLiteral         ;  String
A9FE  812B                            CMPA    #'+'
AA00  2603                            BNE     _sk2NotUnPlus                   ;  Not unary plus
                      ;                       
                      ;               ;  +<value>
                      ;               ;  --------                
AA02                  evalLevel1UnaryPlus                                     ; LAD4C
AA02                                  CALL    skipSpacesY
AA02                  9
AA04                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA02  BD8F0C                                  JSR     \1
                              ENDIF
AA05  818E            _sk2NotUnPlus   CMPA    #tknOPENIN
AA07  2507                            BLO     evalL1_sk1                      ;  Not a function, try indirection and immediate value
AA09  81C6                            CMPA    #tknAUTO
AA0B  242F                            BHS     brkNoSuchVar                    ;  A command, not a function
AA0D                                  JUMP    exeTokenInA                     ;  Jump to dispatch function
AA0D  7E8FF5                                  JMP     \1
AA10  813F            evalL1_sk1      CMPA    #'?'
AA12  240C                            BHS     evalL1MemOrVar                  ;  ?, @, A+ - variable or ?value
AA14  812E                            CMPA    #'.'
AA16  2410                            BHS     evalL1ImmedNum                  ;  ./0-9    - decimal number
AA18  8126                            CMPA    #'&'
AA1A  274D                            BEQ     evalL1ImmedHex                  ;  Jump for &hex
AA1C  8128                            CMPA    #'('
AA1E  273E                            BEQ     evalL1BracketAlreadyOpen                ;  Jump for (expression
                                                                              ; Fall through with !value
                      
                      ;               ;  !value, ?value, variable
                      ;               ;  ------------------------
AA20                  evalL1MemOrVar                                          ;LAD6A
                                                                              ;  Point to start of name + 1
AA20                                  CALL    findVarAtYMinus1                ;  Search for !value ?value or variable
AA20                  9
AA22                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA20  BD9703                                  JSR     \1
                              ENDIF
AA23  2709                            BEQ     NoSuchVar                       ;  Look for variable, jump if doesn't exist
AA25                                  JUMP    GetVarValNewAPI                 ;  Fetch variable's value
AA25  7EAE3F                                  JMP     \1
                      ;               ;  Immediate number
                      ;               ;  ----------------
AA28                  evalL1ImmedNum                                          ;LAD74:
AA28                                  CALL    parseDecimalLiteral             ;  Scan in decimal number
AA28                  9
AA2A                  __XBSR                  SET 9B+2
F500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA28  BD9FF9                                  JSR     \1
                              ENDIF
AA2B  240F                            BCC     brkNoSuchVar
AA2D  39                              RTS                             ;  Error if not a decimal number
                      ;               
                      ;               ;  Variable not found
                      ;               ;  ------------------
AA2E  9628            NoSuchVar       LDA     ZP_OPT                  ;  Get assembler OPTion
AA30  8402                            ANDA    #$02
AA32  2608                            BNE     brkNoSuchVar            ;  If OPT 2 set, give No such variable error
AA34  2506                            BCS     brkNoSuchVar            ;  If invalid variable name, also give error
                      ;;              TODODEADEND "NoSuchVar - assembler OPT 2 - skip TXTPTR2?"
                      ;;              STX ZP_TXTOFF2                  ;  Store
AA36  FC0442          GetP_percent    LDD     VAR_P_PERCENT+2
AA39                                  JUMP    retD16asUINT
AA39  7EAAD7                                  JMP     \1
AA3C                  brkNoSuchVar
AA3C                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA3C  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA3D  1A4E6F2073756368207661726961626C6500                 FCB     $1A, "No such variable", 0
AA4F                  brkMissingEndBracket                            ; LAD9E
AA4F                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA4F  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA50  1B8D2900                        FCB     $1B, tknMissing, ")", 0
AA54                  brkBadHex                                       ; LADA2
AA54                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA54  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA55  1C4261642048657800                 FCB     $1C, "Bad Hex", 0
                      
                      ;                       ;  (expression
                      ;                       ;  -----------
AA5E                  evalL1BracketAlreadyOpen                                        ; LADAC
AA5E                                  CALL    evalAtY                         ;  Call Level 7 Expression Evaluator
AA5E                  9
AA60                  __XBSR                  SET 9B+2
EF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA5E  BD9A41                                  JSR     \1
                              ENDIF
AA61  3341                            LEAU    1,U
AA63  C129                            CMPB    #')'
AA65  26E8                            BNE     brkMissingEndBracket            ;  No terminating ')'
AA67  4D                              TSTA
AA68  39                              RTS                                     ;  Return result
                      
                      
AA69                  evalL1ImmedHex                        ;LADB7
AA69                                  CALL    varFALSE                        ; 0 intA
AA69                  9
AA6B                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA69  BDA89D                                  JSR     \1
                              ENDIF
AA6C  5F                              CLRB
AA6D                  evalL1ImmedHex_lp                                       ; LADBB
AA6D  A6C0                            LDA     ,U+                             ; get digit
AA6F  8130                            CMPA    #'0'
AA71  2522                            BLO     evalL1ImmedHex_skNotDig
AA73  8139                            CMPA    #'9'
AA75  230A                            BLS     evalL1ImmedHex_skGotDig
AA77  8037                            SUBA    #'A' - $A                       ; hopefully got 'A-F', subtract to make 10-15
AA79  810A                            CMPA    #$0A
AA7B  2518                            BLO     evalL1ImmedHex_skNotDig
AA7D  8110                            CMPA    #$10
AA7F  2414                            BHS     evalL1ImmedHex_skNotDig
AA81                  evalL1ImmedHex_skGotDig
AA81  48                              ASLA
AA82  48                              ASLA
AA83  48                              ASLA
AA84  48                              ASLA                                    ; shift into top nybble
AA85  C603                            LDB     #$03
AA87                  evalL1ImmedHex_lpShiftAcc
AA87  48                              ASLA                                    ; shift into IntA
AA88  092D                            ROL     ZP_INT_WA + 3
AA8A  092C                            ROL     ZP_INT_WA + 2
AA8C  092B                            ROL     ZP_INT_WA + 1
AA8E  092A                            ROL     ZP_INT_WA + 0
AA90  5A                              DECB
AA91  2AF4                            BPL     evalL1ImmedHex_lpShiftAcc
AA93  20D8                            BRA     evalL1ImmedHex_lp
AA95                  evalL1ImmedHex_skNotDig                                 ; LADE4
AA95  5D                              TSTB
AA96  2ABC                            BPL     brkBadHex
AA98  335F                            LEAU    -1,U
AA9A  DF19                            STU     ZP_TXTPTR2
AA9C  8640                            LDA     #$40
AA9E  39                              RTS
                      
AA9F                  fnADVAL
                              IF FLEX  = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AA9F                                  CALL    evalLevel1checkTypeStoreAsINT
AA9F                  9
AAA1                  __XBSR                  SET 9B+2
EA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA9F  BD94E5                                  JSR     \1
                              ENDIF
AAA2  3420                            PSHS    y
AAA4  9E2C                            LDX     ZP_INT_WA + 2                                   
AAA6  8680                            LDA     #$80
AAA8  BDFFF4                          JSR     OSBYTE
AAAB  3540                            PULS    U
AAAD  2031                            BRA     retX16asUINT
                              ENDIF
AAAF                  fnTO                    ; LADF9!
                      
AAAF  A6C0                            LDA     ,U+
AAB1  8150                            CMPA    #'P'
AAB3  1026FF85                        LBNE    brkNoSuchVar
AAB7  DC12                            LDD     ZP_TOP
AAB9  201C                            BRA retD16asUINT
AABB                  varGetPAGE
                      
                      ;                       ;  =PAGE
AABB  9618                            LDA     ZP_PAGE_H
AABD  5F                              CLRB
AABE  2017                            BRA     retD16asUINT
                      ;JUMPBrkTypeMismatch4:
                      ;               JUMP brkTypeMismatch
AAC0                  fnLEN
                      ;                       ;  =LEN
AAC0                                  CALL    evalLevel1
AAC0                  9
AAC2                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAC0  BDA9F0                                  JSR     \1
                              ENDIF
AAC3  1026E5A4                        LBNE    brkTypeMismatch
AAC7  D636                            LDB     ZP_STRBUFLEN
AAC9  200B                            BRA     retB8asUINT
                      
                      
AACB  0F2C            retD16asUINT_LE CLR     ZP_INT_WA + 2           ; little endian version!
AACD  0F2D                            CLR     ZP_INT_WA + 3           
AACF  DD2A                            STD     ZP_INT_WA + 0
AAD1  8640                            LDA     #$40
AAD3  39                              RTS
                      
                      
AAD4  1E89            retA8asUINT     EXG     A,B
AAD6  4F              retB8asUINT     CLRA
AAD7  DD2C            retD16asUINT    STD     ZP_INT_WA + 2
AAD9  0F2A            retWA16asUINT   CLR     ZP_INT_WA + 0
AADB  0F2B                            CLR     ZP_INT_WA + 1
AADD  8640                            LDA     #$40
AADF  39                              RTS
AAE0  9F2C            retX16asUINT    STX     ZP_INT_WA + 2
AAE2  20F5                            BRA     retWA16asUINT
                      
AAE4                  fnCOUNT
                      
AAE4  D61E                            LDB ZP_PRLINCOUNT
AAE6  20EE                            BRA retB8asUINT
                      
AAE8                  varGetLOMEM
                      
AAE8  DC00                            LDD ZP_LOMEM
AAEA  20EB                            BRA retD16asUINT
AAEC                  varGetHIMEM
                      
AAEC  DC06                            LDD ZP_HIMEM
AAEE  20E7                            BRA retD16asUINT
AAF0                  varERL
                                              ;  =ERL
AAF0  DC08                            LDD     ZP_ERL
AAF2  20E3                            BRA     retD16asUINT
AAF4                  varERR
                                              ;  =ERR
AAF4  E69F00FD                        LDB     [ZP_MOS_ERROR_PTR_QRY]
AAF8  20DC                            BRA     retB8asUINT
AAFA                  fnGET
                                              ;  =GET
AAFA  BDFFE0                          JSR     OSRDCH
AAFD  20D5                            BRA     retA8asUINT
AAFF                  varGetTIME
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
                                              ;  =TIME
AAFF  A6C4                            LDA     ,U      
AB01  8124                            CMPA    #'$'
AB03  2720                            BEQ     varGetTIME_DOLLAR
AB05  3440                            PSHS    U
AB07  8E002A                          LDX     #ZP_INT_WA
AB0A  CE0000                          LDU     #$00                            ;DP
AB0D  8601                            LDA     #$01
AB0F  BDFFF1                          JSR     OSWORD
AB12  3540                            PULS    U
                                      
                      ; Swap endianness of Integer Accumulator
AB14                  SwapEndian                                              
                      ;;;             LDD     ZP_INT_WA                       ; 5     2
                      ;;;             PSHS    D                               ; 6     2
                      ;;;             LDD     ZP_INT_WA + 2                   ; 5     2
                      ;;;             EXG     A,B                             ; 7     2
                      ;;;             STD     ZP_INT_WA                       ; 5     2
                      ;;;             PULS    D                               ; 6     2
                      ;;;             EXG     A,B                             ; 7     2
                      ;;;             STD     ZP_INT_WA + 2                   ; 5     2
                                                                              ; 46    16
                      
AB14  9E2A                            LDX     ZP_INT_WA                       ; 5     2
AB16  DC2C                            LDD     ZP_INT_WA + 2                   ; 5     2
AB18  1E89                            EXG     A,B                             ; 7     2
AB1A  DD2A                            STD     ZP_INT_WA                       ; 5     2
AB1C  1F10                            TFR     X,D                             ; 7     2
AB1E  1E89                            EXG     A,B                             ; 7     2
AB20  DD2C                            STD     ZP_INT_WA + 2                   ; 5     2
                                                                              ;41     14
                      
AB22  8604                            LDA     #VAR_TYPE_INT
AB24  39                              RTS
                              ENDIF
                      
AB25                  varGetTIME_DOLLAR
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB25  3341                            LEAU    1,U
AB27  3440                            PSHS    U
AB29  860E                            LDA     #$0E
AB2B  8E0600                          LDX     #BASWKSP_STRING
AB2E  6F84                            CLR     ,X
AB30  BDFFF1                          JSR     OSWORD
AB33  8618                            LDA     #$18
AB35  3540                            PULS    U
AB37  2037                            BRA     staZpStrBufLen
                              ENDIF
AB39                  fnGETDOLLAR             ; LAE69!
                      
                                              
                      ;                       ;  =GET$
AB39  BDFFE0                          JSR     OSRDCH
AB3C                  returnAAsString                                         ; LAE6C
AB3C  B70600                          STA     BASWKSP_STRING
AB3F                  returnString1
AB3F  8601                            LDA     #$01
AB41  202D                            BRA     staZpStrBufLen
AB43  F70600          returnBAsString STB     BASWKSP_STRING
AB46  20F7                            BRA     returnString1
                      
AB48                  fnLEFT                  ; LAE73!
AB48                                  CLC
AB48  1CFE                    ANDCC   #~CC_C
AB4A  2002                            BRA     1F
AB4C                  fnRIGHT                 ; LAE74!
                      
AB4C                                  SEC
AB4C  1A01                    ORCC    #CC_C
AB4E  3401            1               PSHS    CC                      ; flag we want LEFT$ below
AB50                                  CALL    evalAtY
AB50                  9
AB52                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB50  BD9A41                                  JSR     \1
                              ENDIF
AB53  4D                              TSTA
AB54  1026E513                        LBNE    brkTypeMismatch
AB58  C12C                            CMPB    #','
AB5A  1026E3C5                        LBNE    brkMissingComma
AB5E  3341                            LEAU    1,U
AB60                                  CALL    evalstackStringExpectINTCloseBracket
AB60                  9
AB62                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB60  BD94D5                                  JSR     \1
                              ENDIF
AB63                                  CALL    popStackedStringNew
AB63                  9
AB65                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB63  BDB856                                  JSR     \1
                              ENDIF
AB66  3501                            PULS    CC
AB68  250B                            BCS     fnRIGHT_do_RIGHT                ; DO RIGHT$
AB6A  962D                            LDA     ZP_INT_WA + 3
AB6C  9136                            CMPA    ZP_STRBUFLEN
AB6E  2402                            BCC     retAeq0
AB70  9736            staZpStrBufLen  STA     ZP_STRBUFLEN
AB72  8600            retAeq0         LDA     #$00
AB74  39              rts_AE93        RTS
                      
                      
AB75                  fnRIGHT_do_RIGHT                                        ; LAE94
AB75  D636                            LDB     ZP_STRBUFLEN                    ; length of string
AB77  D02D                            SUBB    ZP_INT_WA + 3                   ; minus length of amount to copy == length to skip
AB79  25F7                            BCS     retAeq0
AB7B  27F7                            BEQ     rts_AE93
AB7D  962D                            LDA     ZP_INT_WA + 3
AB7F  9736                            STA     ZP_STRBUFLEN
AB81  27F1                            BEQ     rts_AE93
                      
AB83  108E0600                        LDY     #BASWKSP_STRING
AB87  8E0600                          LDX     #BASWKSP_STRING
AB8A  3A                              ABX
AB8B  D62D                            LDB     ZP_INT_WA + 3
AB8D                  LAEA5
AB8D  A680                            LDA     ,X+
AB8F  A7A0                            STA     ,Y+
AB91  5A                              DECB
AB92  26F9                            BNE     LAEA5
AB94  20DC                            BRA retAeq0
                      
                      
AB96                  fnINKEYDOLLAR           ; LAEB3!
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
                                              ;  =INKEY$
AB96                                  CALL callOSByte81withXYfromINT
AB96                  9
AB98                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0066                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB96  BDA6FE                                  JSR     \1
                              ENDIF
AB99  1F10                            TFR     X,D
AB9B  24A6                            BCC     returnBAsString
                              ENDIF
AB9D                  strRet0LenStr                                                   ; LAEBB
AB9D  4F                              CLRA    
AB9E  20D0                            BRA     staZpStrBufLen
                              
                                      ; YUSWAP - use Y and no push?
ABA0                  fnMIDstr
ABA0                                  CALL    evalAtY
ABA0                  9
ABA2                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABA0  BD9A41                                  JSR     \1
                              ENDIF
ABA3  4D                              TSTA
ABA4  1026E4C3                        LBNE    brkTypeMismatch                         ; must be a string!
ABA8  C12C                            CMPB    #','
ABAA  1026E375                        LBNE    brkMissingComma                         ; expect ,
ABAE                                  CALL    StackString
ABAE                  9
ABB0                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABAE  BDB7F4                                  JSR     \1
                              ENDIF
ABB1  3341                            LEAU    1,U                                     ; skip ,
ABB3                                  CALL    evalAtYcheckTypeInAConvert2INT
ABB3                  9
ABB5                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
002B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABB3  BD94E0                                  JSR     \1
                              ENDIF
ABB6  962D                            LDA     ZP_INT_WA + 3                           ; store low byte on stack
ABB8  3402                            PSHS    A
ABBA  86FF                            LDA     #$FF
ABBC  972A                            STA     ZP_INT_WA                               ; default length to 255
ABBE  E6C4                            LDB     ,U                                      ; reload this, it may have been eaten converting to INT above
ABC0  3341                            LEAU    1,U                                     ; skip next char
ABC2  C129                            CMPB    #')'
ABC4  2709                            BEQ     LAEEA                                   ; don't eval length
ABC6  C12C                            CMPB    #','
ABC8  1026E357                        LBNE    brkMissingComma
ABCC                                  CALL    evalL1BracketAlreadyOpenConvert2INT
ABCC                  9
ABCE                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABCC  BD94D8                                  JSR     \1
                              ENDIF
ABCF  3504            LAEEA           PULS    B                                       ; get back 2nd param (start 1-based index)
ABD1  3440                            PSHS    U                                       ; remember Y
ABD3  2601                            BNE     1F
ABD5  5C                              INCB                                            ; if 0 passed as index bump to 1
ABD6  E19F0004        1               CMPB    [ZP_BAS_SP]
ABDA  222C                            BHI     strRet0LenStrPopYU                      ; branch if 2nd param > strlen
ABDC  D72C                            STB     ZP_INT_WA + 2
ABDE  9E04                            LDX     ZP_BAS_SP
ABE0  3A                              ABX                                             ; X points at start of string to return
ABE1  E69F0004                        LDB     [ZP_BAS_SP]
ABE5  D02C                            SUBB    ZP_INT_WA + 2                           ; A=orig.len-ix
ABE7  5C                              INCB
ABE8  D12D                            CMPB    ZP_INT_WA + 3                           ; compare to 3rd param
ABEA  2402                            BHS     LAF08                                   ; if >= continue
ABEC  D72D                            STB     ZP_INT_WA + 3                           ; if < use that as required len
ABEE  D62D            LAF08           LDB     ZP_INT_WA + 3
ABF0  2716                            BEQ     strRet0LenStrPopYU
ABF2  D736                            STB     ZP_STRBUFLEN
ABF4  8C0600                          CMPX    #BASWKSP_STRING
ABF7  270A                            BEQ     unstackStringMIDS                               ; pointless copy?
ABF9  CE0600                          LDU     #BASWKSP_STRING
ABFC  A680            LAF0C           LDA     ,X+
ABFE  A7C0                            STA     ,U+
AC00  5A                              DECB
AC01  26F9                            BNE     LAF0C
AC03                  unstackStringMIDS
AC03                                  CALL    unstackString
AC03                  9
AC05                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0007                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AC03  8D07                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AC05  4F                              CLRA
AC06  35C0                            PULS    U,PC
AC08                  strRet0LenStrPopYU
AC08  0F36                            CLR     ZP_STRBUFLEN
AC0A  20F7                            BRA     unstackStringMIDS
                      
AC0C  9E04            unstackString   LDX     ZP_BAS_SP
AC0E  E680                            LDB     ,X+                                     ; get stack str len to unstack
AC10  3A                              ABX                                             ; discard string and length byte
AC11  9F04                            STX     ZP_BAS_SP
AC13  39                              rts
                      
                      
AC14                  fnSTR                   ; LAF1C!
                      
AC14                                  CALL    skipSpacesY
AC14                  9
AC16                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC14  BD8F0C                                  JSR     \1
                              ENDIF
AC17  C6FF                            LDB     #$FF
AC19  817E                            CMPA    #'~'
AC1B  2703                            BEQ     LAF29
AC1D  5F                              CLRB
AC1E  335F                            LEAU    -1,U
AC20                  LAF29
AC20  3404                            PSHS    B
AC22                                  CALL    evalLevel1
AC22                  9
AC24                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC22  BDA9F0                                  JSR     \1
                              ENDIF
AC25  9727                            STA     ZP_VARTYPE
AC27  2717                            BEQ     LAF44brkTypeMismatch
AC29  3504                            PULS    B
AC2B  3440                            PSHS    U
AC2D  D715                            STB     ZP_PRINTFLAG                    ; dec/hex flag
AC2F  B60400                          LDA     BASWKSP_INTVAR + 0              ; high byte of @%
AC32  2607                            BNE     LAF3F
AC34  9737                            STA     ZP_GEN_PTR
AC36                                  CALL    cmdPRINT_num2str_invaldp
AC36                  9
AC38                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC36  BD9E36                                  JSR     \1
                              ENDIF
AC39  2048                            BRA     LAF7AclrArts
AC3B                  LAF3F
AC3B                                  CALL    cmdPRINT_num2str
AC3B                  9
AC3D                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC3B  BD9E1C                                  JSR     \1
                              ENDIF
AC3E  2043                            BRA     LAF7AclrArts
AC40                  LAF44brkTypeMismatch
AC40                                  JUMP brkTypeMismatch
AC40  7E906B                                  JMP     \1
AC43                  fnSTRING                        ; LAF47!
                                              
                      ;                       ;  =STRING$
AC43                                  CALL    evalAtYcheckTypeInAConvert2INT
AC43                  9
AC45                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
009B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC43  BD94E0                                  JSR     \1
                              ENDIF
AC46                                  CALL    stackINT_WAasINT
AC46                  9
AC48                  __XBSR                  SET 9B+2
0B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC46  BDB7DA                                  JSR     \1
                              ENDIF
AC49                                  CALL    skipSpacesCheckCommaAtYOrBRK
AC49                  9
AC4B                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC49  BD8F1E                                  JSR     \1
                              ENDIF
AC4C                                  CALL    evalL1BracketAlreadyOpen
AC4C                  9
AC4E                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC4C  BDAA5E                                  JSR     \1
                              ENDIF
AC4F  26EF                            BNE     LAF44brkTypeMismatch
AC51  3440                            PSHS    U
AC53                                  CALL    popIntANew
AC53                  9
AC55                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC53  BDB86C                                  JSR     \1
                              ENDIF
AC56  D636                            LDB     ZP_STRBUFLEN
AC58  2729                            BEQ     LAF7AclrArts
AC5A  962D                            LDA     ZP_INT_WA + 3
AC5C  2728                            BEQ     fnStringRetBlank                ; 0 copies return ""
AC5E  0A2D                            DEC     ZP_INT_WA + 3
AC60  2721                            BEQ     LAF7AclrArts                    ; 1 copy return string in buffer
AC62  8E0600                          LDX     #BASWKSP_STRING
AC65  D636                            LDB     ZP_STRBUFLEN
AC67  3A                              ABX
AC68                  fnStringCopyOuterLoop                                   ; copy string at end of buffer
AC68  CE0600                          LDU     #BASWKSP_STRING
AC6B                  fnStringCopyInnerLoop                                   ; LAF66
AC6B  A6C0                            LDA     ,U+
AC6D  A780                            STA     ,X+
AC6F  8C0700                          CMPX    #BASWKSP_STRING + $100
AC72  1027EEAB                        LBEQ    brkStringTooLong
AC76  5A                              DECB
AC77  26F2                            BNE     fnStringCopyInnerLoop
AC79  D636                            LDB     ZP_STRBUFLEN
AC7B  0A2D                            DEC     ZP_INT_WA + 3                   ; decrement outer loop counter
AC7D  26E9                            BNE     fnStringCopyOuterLoop
AC7F  1F10                            TFR     X,D                             ; get back low part of Y in B
AC81  D736                            STB     ZP_STRBUFLEN                    ; use that as new string len
AC83                  LAF7AclrArts
AC83  4F                              CLRA
AC84  35C0                            PULS    U,PC
AC86                  fnStringRetBlank                                        ; LAF7D
AC86  9736                            STA ZP_STRBUFLEN
AC88  35C0                            PULS    U,PC
AC8A                  brkNoSuchFN                             ; LAF83
                      ;;;;            PLA
                      ;;;;            STA ZP_TXTPTR + 1
                      ;;;;            PLA
                      ;;;;            STA ZP_TXTPTR
AC8A  EE61                            LDU     1,S             ; get back stacked Y pointer (from callproc)
AC8C  DF0B                            STU     ZP_TXTPTR       ; point back at caller so that ERL is reported correctly
AC8E                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AC8E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AC8F  1D4E6F207375636820A42FF200                 FCB     $1D,"No such ", tknFN, "/", tknPROC,0
                      
                              *****************************************************************
                              *       Search Program For DEF PROC/FN                          *
                              *       On entry                                                *
                              *               [ZP_GEN_PTR + 2] + 1 = tknFN or tknPROC         *
                              *               [ZP_GEN_PTR + 2] + 2 = proc name                *
                              *               ZP_NAMELENORVT is proc name length + 2          *
                              *       Trashes A,B,X,U                                         *
                              *****************************************************************
                      
AC9C                  progFndDEF_skNxtLinPULSU
AC9C                  progFndDEF_skNxtLin                                     ; LAFB0
AC9C  E603                            LDB     3,X                             ; line length add to X
AC9E  3A                              ABX
AC9F  2005                            BRA     progFndDEF_linLp
                      
ACA1                  progFindDEFPROC                                         ; LAF97
ACA1  9618                            LDA ZP_PAGE_H
ACA3  5F                              CLRB
ACA4  1F01                            TFR     D,X
ACA6                  progFndDEF_linLp                                        ; LAF9D
ACA6  6D01                            TST     1,X
ACA8  2BE0                            BMI     brkNoSuchFN                     ; check for end of program
ACAA  3304                            LEAU    4,X                             ; point Y after 0D and line number
ACAC                                  CALL    skipSpacesY
ACAC                  9
ACAE                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
005E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ACAC  BD8F0C                                  JSR     \1
                              ENDIF
ACAF  81DD                            CMPA    #tknDEF
ACB1  26E9                            BNE     progFndDEF_skNxtLin
ACB3                  progFndDEF_skDefFnd                                     ; LAFBF
ACB3  BD8F15                          JSR     skipSpacesYStepBack
ACB6  109E39                          LDY     ZP_GEN_PTR + 2
ACB9  3121                            LEAY    1,Y                             ; point at FN/PROC token, Y already points at one hopefully
ACBB  C601                            LDB     #1
ACBD  DF0B                            STU     ZP_TXTPTR
ACBF  A6C0            1               LDA     ,U+
ACC1  A1A0                            CMPA    ,Y+
ACC3  26D7                            BNE     progFndDEF_skNxtLinPULSU        ; compare caller / DEF token and name
ACC5  5C                              INCB
ACC6  D137                            CMPB    ZP_NAMELENORVT
ACC8  26F5                            BNE     1B
ACCA  A6C4                            LDA     ,U                              ; get next char
ACCC                                  CALL    checkIsValidVariableNameChar    ; if it looks like a variable name char
ACCC                  9
ACCE                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
000F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ACCC  BD8DDD                                  JSR     \1
                              ENDIF
ACCF  25CB                            BCS     progFndDEF_skNxtLinPULSU        ; then the DEF is for a longer name, keep searching
                      
                                      ; Y now points at parameters or whatever after DEFFNname
                                      ; ZP_TXTPTR starts at FN/PROC token
                                      ; X points at start of DEFFN line 
                      
                      
                      ;;;             INY
                      ;;;             STU ZP_TXTOFF
ACD1                                  CALL    skipSpacesYStepBack
ACD1                  9
ACD3                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0042                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ACD1  BD8F15                                  JSR     \1
                              ENDIF
ACD4  DF0B                            STU     ZP_TXTPTR
                      ;;;             TYA
                      ;;;             TAX
                      ;;;             CLC
                      ;;;             ADC ZP_TXTPTR
                      ;;;             LDU ZP_TXTPTR + 1
                      ;;;             BCC LAFD0
                      ;;;             INY
                      ;;;             CLC
                      ;;;LAFD0:
                      ;;;             SBC #$00
                      ;;;             STA ZP_FPB + 1
                      ;;;             TYA
                      ;;;             SBC #$00
                      ;;;             STA ZP_FPB + 2
                      ;;;             LDU #$01
                      ;LAFDB:
                      
                      ;;;             INX
                      ;;;             LDA (ZP_FPB + 1),Y
                      ;;;             CMP (ZP_GEN_PTR),Y
                      ;;;             BNE progFndDEF_skNxtLin
                      ;;;             INY
                      ;;;             CPY ZP_NAMELENORVT
                      ;;;             BNE LAFDB
                      ;;;             LDA (ZP_FPB + 1),Y
                      ;;;             CALL checkIsValidVariableNameChar
                      ;;;             BCS progFndDEF_skNxtLin
                      ;               TXA
                      ;               TAY
                      ;               CALL storeYasTXTPTR
                      
ACD6                                  CALL    allocFNPROC
ACD6                  9
ACD8                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ACD6  BD9653                                  JSR     \1
                              ENDIF
ACD9  8601                            LDA     #$01
ACDB                                  CALL    AllocVarSpaceOnHeap
ACDB                  9
ACDD                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ACDB  BD9695                                  JSR     \1
                              ENDIF
ACDE  DC0B                            LDD     ZP_TXTPTR
ACE0  9E02                            LDX     ZP_VARTOP
ACE2  ED81                            STD     ,X++
                      ;;;             LDA ZP_TXTPTR
                      ;;;             STA (ZP_VARTOP)
                      ;;;             LDU #$01
                      ;;;             LDA ZP_TXTPTR + 1
                      ;;;             STA (ZP_VARTOP),Y
                      ;;;             INY
ACE4                                  CALL    CheckVarFitsX
ACE4                  9
ACE6                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ACE4  BD969D                                  JSR     \1
                              ENDIF
ACE7  204A                            BRA     LB072                           ; back to main PROC call routine
                      ;
ACE9                  brkBadCall                                              ; LB00C
ACE9                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
ACE9  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
ACEA  1E4261642063616C6C00                 FCB     $1E,"Bad call",0
                      
                      ;               ;  =FN / PROC
                      ;               ; ====
ACF4                  fnFN
                      ;                       
ACF4  86A4                            LDA     #tknFN
ACF6  9727            doFNPROCcall    STA     ZP_VARTYPE                      ;  Save PROC/FN token
ACF8  1F40                            TFR     S,D                             ; calculate new BASIC stack pointer 
ACFA  830202                          SUBD    #MACH_STACK_TOP+2               ; by subtracting size of used machine stack + 2 (to store original stack pointer)
ACFD  9E04                            LDX     ZP_BAS_SP
ACFF  308B                            LEAX    D,X                             
AD01                                  CALL    UpdStackFromXCheckFull          ;  Store new BASIC stack pointer, checking for free space
AD01                  9
AD03                  __XBSR                  SET 9B+2
0B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD01  BDB894                                  JSR     \1
                              ENDIF
AD04  10EF81                          STS     ,X++                            ; Store current machine stack pointer
AD07  118C0200        1               CMPS    #MACH_STACK_TOP                 ; Copy machine stack contents to BASIC stack
AD0B  2406                            BHS     2F                              ; TODO: use 16bit copy? Require test on first/last loop for single byte tfr
AD0D  3502                            PULS    A
AD0F  A780                            STA     ,X+
AD11  20F4                            BRA     1B
AD13                  2               ; S now points at top of stack X points at OLD U value
                                      ; stack active variables on machine stack
                                      ; note this is different to 6502!
AD13  9627                            LDA     ZP_VARTYPE
AD15  3442                            PSHS    A,U                             ; store PROC/FN token on the stack
                      ;;;             LDA ZP_VARTYPE
                      ;;;             PHA                                     ;  Push PROC/FN token
                      ;;;             LDA ZP_TXTOFF
                      ;;;             PHA
                      ;;;             LDA ZP_TXTPTR
                      ;;;             PHA                                     ;  Push PtrA line pointer
                      ;;;             LDA ZP_TXTPTR + 1
                      ;;;             PHA                                     ;  Push Prea line offset
                      ;;;             LDA ZP_TXTOFF2
                      ;;;             TAX
                      ;;;             CLC
                      ;;;             ADC ZP_TXTPTR2
                      ;;;             LDU ZP_TXTPTR2 + 1
                      ;;;             BCC LB04C
                      ;;;             INY
                      ;;;             CLC
                      ;;;;LB04C:
AD17  335E                            LEAU    -2,U                            ; step back scan pointer
AD19  DF39                            STU     ZP_GEN_PTR+2                    ; this is picked up in findFNPROC below
AD1B  C602                            LDB     #$02
                      *               LEAU    1,U
AD1D                                  CALL    fnProcScanYplusBvarname; Check name is valid
AD1D                  9
AD1F                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0036                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD1D  BD9855                                  JSR     \1
                              ENDIF
AD20  C102                            CMPB    #2
AD22  27C5                            BEQ     brkBadCall                      ; No valid characters
AD24  301F                            LEAX    -1,X                            ; point ZP_TXTPTR2 at char after name
AD26  9F19                            STX     ZP_TXTPTR2
AD28                                  CALL    findFNPROC                      ; note: this also saves length in B at ZP_NAMELENORVT
AD28                  9
AD2A                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD28  BD8487                                  JSR     \1
                              ENDIF
                                                                              ; Look for PROC/FN in heap
AD2B  1027FF72                        LBEQ    progFindDEFPROC                 ; Not in heap, jump to look in program
                                                                              ; LB068
AD2F  EE9F002C                        LDU     [ZP_INT_WA + 2]
AD33                  LB072
AD33  6FE2                            CLR     ,-S                             ; Store a 0 on the stack to mark 0 params
                      ;               STZ ZP_TXTOFF
AD35                                  CALL    skipSpacesY
AD35                  9
AD37                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD35  BD8F0C                                  JSR     \1
                              ENDIF
AD38  8128                            CMPA    #'('
AD3A  273A                            BEQ     doFNPROCargumentsEntry
AD3C  335F                            LEAU    -1,U
AD3E                  LB080
AD3E  9E19                            LDX     ZP_TXTPTR2
AD40  3410                            PSHS    X
AD42                                  CALL    skipSpacesAtYexecImmed          ; execute PROC/FN body
AD42                  9
AD44                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD42  BD8FEA                                  JSR     \1
                              ENDIF
AD45  3510                            PULS    X
AD47  9F19                            STX     ZP_TXTPTR2
AD49  9F0B                            STX     ZP_TXTPTR
AD4B  A6E0                            LDA     ,S+                             ; get back params flag (use LD for flags)
AD4D  270C                            BEQ     doFnProcExit_NoParams
AD4F  973F                            STA     ZP_FPB + 4                      ; get number of "params" (and locals) to reset
AD51                  LB09A
AD51                                  CALL    popIntAtZP_GEN_PTRNew           ; get back variable pointer etc
AD51                  9
AD53                  __XBSR                  SET 9B+2
0B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0029                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD51  BDB87C                                  JSR     \1
                              ENDIF
AD54                                  CALL    delocaliseAtZP_GEN_PTR
AD54                  9
AD56                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD54  BDB814                                  JSR     \1
                              ENDIF
AD57  0A3F                            DEC     ZP_FPB + 4
AD59  26F6                            BNE     LB09A
AD5B                  doFnProcExit_NoParams
                      ;;;             PULS    A,Y
                      ;;;             LEAU    -1,Y
                      ;;;             LEAS    3,S                     ; discard stacked 
                      
                      ;               
                      ;               stz     $fef0                   ; TODO - TUBE ????
                      
AD5B  109E04                          LDY     ZP_BAS_SP
AD5E  10EEA1                          LDS     ,Y++                    ; get old machine stack pointer from
                                                                      ; BASIC stack
AD61  30E4                            LEAX    ,S
AD63  8C0200          1               CMPX    #MACH_STACK_TOP         ; copy bytes from BASIC stack to machine stack
AD66  2406                            BHS     2F
AD68  A6A0                            LDA     ,Y+
AD6A  A780                            STA     ,X+
AD6C  20F5                            BRA     1B
AD6E                  2
AD6E  DE0B                            LDU     ZP_TXTPTR
AD70  9627                            LDA     ZP_VARTYPE              ; from FN =
AD72  109F04                          STY     ZP_BAS_SP
AD75  39                              RTS
                      
                      
                      
AD76                  doFNPROCargumentsEntry
                                      ; Y is pointing at first char of params (after bracket) in DEF
                                      ; ZP_TXTPTR     at opening bracket of params in DEF
                                      ; ZP_TXTPTR2    at opening bracket of call
AD76  9E19                            LDX     ZP_TXTPTR2
AD78  3410                            PSHS    X
AD7A                                  CALL    findVarOrAllocEmpty
AD7A                  9
AD7C                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0035                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD7A  BD96B1                                  JSR     \1
                              ENDIF
AD7D  2749                            BEQ     doBrkArguments
AD7F  3510                            PULS    X
AD81  9F19                            STX     ZP_TXTPTR2
AD83  3502                            PULS    A                               ; bet back "params flag"
AD85  9E2C                            LDX     ZP_INT_WA + 2
AD87  D62A                            LDB     ZP_INT_WA
AD89  4C                              INCA
AD8A  3416                            PSHS    D,X                             ; push back incremented var ptr, var type, params flag
AD8C                                  CALL    localVarAtIntA                  ; push the variable value and pointer onto the BASIC stack
AD8C                  9
AD8E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD8C  BDAE1F                                  JSR     \1
                              ENDIF
AD8F                                  CALL    skipSpacesCheckCommaAtY         ; try and get another parameter
AD8F                  9
AD91                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD8F  BD8D48                                  JSR     \1
                              ENDIF
AD92  27E2                            BEQ     doFNPROCargumentsEntry
AD94  8129                            CMPA    #')'
AD96  2630                            BNE     doBrkArguments                  ; check for closing bracket
AD98  DF56                            STU     ZP_EXTRA_SAVE_PROC              ; TODO, stack this or get from somewhere else?
AD9A  6FE2                            CLR     ,-S                             ; store a 0 on stack (to be used as another arguments counter)
AD9C                                  CALL    skipSpacesPTRB
AD9C                  9
AD9E                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
006C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD9C  BD8F0A                                  JSR     \1
                              ENDIF
AD9F  8128                            CMPA    #'('
ADA1  2625                            BNE     doBrkArguments
ADA3                  LB108
ADA3                                  CALL    evalAtY                         ; get value of argument
ADA3                  9
ADA5                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADA3  BD9A41                                  JSR     \1
                              ENDIF
ADA6  4D                              TSTA
ADA7                                  CALL    stackVarTypeInFlags             ; push it to BASIC stack
ADA7                  9
ADA9                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADA7  BDB7D6                                  JSR     \1
                              ENDIF
ADAA  9627                            LDA     ZP_VARTYPE                      ; store "shadow" var type
ADAC  972B                            STA     ZP_INT_WA + 1                   ; TODO: check we actually need all this, can probably just store ZP_VARTYPE on stack as rest is discarded!
ADAE                                  CALL    stackINT_WAasINT                ; stack intA on BASIC stack
ADAE                  9
ADB0                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADAE  BDB7DA                                  JSR     \1
                              ENDIF
ADB1  6CE4                            INC     ,S                              ; increment arguments counter
ADB3                                  CALL    skipSpacesCheckCommaAtY
ADB3                  9
ADB5                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADB3  BD8D48                                  JSR     \1
                              ENDIF
ADB6  27EB                            BEQ     LB108
ADB8  8129                            CMPA    #')'
ADBA  260C                            BNE     doBrkArguments
ADBC  DF19                            STU     ZP_TXTPTR2
ADBE  3506                            PULS    A,B                             ; get back two arguments counters
ADC0  D74C                            STB     ZP_FP_TMP + 9
ADC2  D74D                            STB     ZP_FP_TMP + 10
ADC4  914C                            CMPA    ZP_FP_TMP + 9                   ; check they're the same
ADC6  2714                            BEQ     LB140                           ; if so continue
ADC8                  doBrkArguments
ADC8  10CE01FE                        LDS     #MACH_STACK_TOP - 2
ADCC  EEC1                            LDU     ,U++
ADCE  DF0B                            STU     ZP_TXTPTR
ADD0                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
ADD0  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
ADD1  1F417267756D656E747300                 FCB     $1F,"Arguments",0
ADDC                  LB140
ADDC                                  CALL    popIntANew                      ; get back eval'd type from stack
ADDC                  9
ADDE                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADDC  BDB86C                                  JSR     \1
                              ENDIF
ADDF  3512                            PULS    A,X                             ; get back var type and variable pointer for argument variable
ADE1  972A                            STA     ZP_INT_WA + 0
ADE3  9F2C                            STX     ZP_INT_WA + 2
ADE5  4D                              TSTA
ADE6  2B20                            BMI     LB16D                           ; do string arg
ADE8  9737                            STA     ZP_NAMELENORVT
ADEA  962B                            LDA     ZP_INT_WA + 1
ADEC  27DA                            BEQ     doBrkArguments
ADEE  9727                            STA     ZP_VARTYPE
ADF0  9E2C                            LDX     ZP_INT_WA + 2
ADF2  9F39                            STX     ZP_GEN_PTR+2                    ; stick var pointer at ZP_GEN_PTR+2
ADF4  9627                            LDA     ZP_VARTYPE
ADF6  2A08                            BPL     LB165
ADF8                                  CALL    popFPFromStackToPTR1
ADF8                  9
ADFA                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADF8  BDB7AE                                  JSR     \1
                              ENDIF
ADFB                                  CALL    fpCopyPTR1toFPA
ADFB                  9
ADFD                  __XBSR                  SET 9B+2
F400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0016                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADFB  BDA213                                  JSR     \1
                              ENDIF
ADFE  2003                            BRA     LB168
AE00                  LB165           CALL    popIntANew
AE00                  9
AE02                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE00  BDB86C                                  JSR     \1
                              ENDIF
AE03                  LB168           CALL    storeEvaledExpressioninVarAtZP_GEN_PTR
AE03                  9
AE05                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE03  BDAFC9                                  JSR     \1
                              ENDIF
AE06  200A                            BRA     LB177
AE08  962B            LB16D           LDA     ZP_INT_WA + 1
AE0A  26BC                            BNE     doBrkArguments
AE0C                                  CALL    popStackedStringNew
AE0C                  9
AE0E                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE0C  BDB856                                  JSR     \1
                              ENDIF
AE0F                                  CALL    copyStringToVar2
AE0F                  9
AE11                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0077                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE0F  BD9088                                  JSR     \1
                              ENDIF
AE12  0A4C            LB177           DEC     ZP_FP_TMP + 9
AE14  26C6                            BNE     LB140
AE16  964D                            LDA     ZP_FP_TMP + 10
AE18  3402                            PSHS    A
AE1A  DE56                            LDU     ZP_EXTRA_SAVE_PROC
AE1C                                  JUMP    LB080
AE1C  7EAD3E                                  JMP     \1
                      
                      
AE1F                  localVarAtIntA                                          ; LB181
AE1F  D62A                            LDB     ZP_INT_WA + 0                   ; get variable type
AE21  C105                            CMPB    #VAR_TYPE_REAL
AE23  3401                            PSHS    CC
AE25  2406                            BHS     1F                              ; for not int
AE27  8E0037                          LDX     #ZP_GEN_PTR
AE2A                                  CALL    CopyIntWA2X                     ; copy pointer to ZP_GEN_PTR, GetVarVal will overwrite it!
AE2A                  9
AE2C                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE2A  BDB923                                  JSR     \1
                              ENDIF
AE2D                  1                                                       ; LB18C
AE2D                                  CALL    GetVarValNewAPI
AE2D                  9
AE2F                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AE2D  8D10                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AE2F                                  CALL    stackVarTypeInFlags
AE2F                  9
AE31                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE2F  BDB7D6                                  JSR     \1
                              ENDIF
AE32  3501                            PULS    CC
AE34  2406                            BHS     1F
AE36  8E0037                          LDX     #ZP_GEN_PTR                     ; restore var pointer
AE39                                  CALL    intLoadWAFromX                  ; get back variable pointer if we saved it
AE39                  9
AE3B                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE39  BDA76F                                  JSR     \1
                              ENDIF
AE3C                  1               JUMP    stackINT_WAasINT                ; and stack pointer
AE3C  7EB7DA                                  JMP     \1
                      
                                      ; trashses A, B, X
                      
AE3F                  GetVarValNewAPI                                         ; LB1A0
AE3F  962A                            LDA     ZP_INT_WA + 0                   ; Get type
AE41  2B55                            BMI     GetVarValStr                    ; b7=String
AE43  2726                            BEQ     store_wa_byte                   ; &00=Byte
AE45  8105                            CMPA    #VAR_TYPE_REAL
AE47  2729                            BEQ     GetVarValReal                   ; &05=Real
                      ;;JGH
AE49  8104                            CMPA    #VAR_TYPE_INT
AE4B  2711                            BEQ     GetVarValInt                    ; &04=Integer
                      ; little-endian integer
AE4D  9E2C                            LDX     ZP_INT_WA + 2                   ; &02=Little-endian integer, TODO: check speed / size trade off with swapendian defined elsewhere if short of space
AE4F  EC81                            LDD     ,X++
AE51  1E89                            EXG     A,B
AE53  DD2C                            STD     ZP_INT_WA + 2
AE55  EC81                            LDD     ,X++
AE57  1E89                            EXG     A,B
AE59  DD2A                            STD     ZP_INT_WA + 0
AE5B  8604                            LDA     #VAR_TYPE_INT
AE5D  39                              RTS
                      ;;^^^
                      
AE5E                  GetVarValInt
AE5E  9E2C                            LDX     ZP_INT_WA + 2
AE60  EC81                            LDD     ,X++
AE62  DD2A                            STD     ZP_INT_WA + 0
AE64  EC81                            LDD     ,X++
AE66  DD2C                            STD     ZP_INT_WA + 2
AE68  8604                            LDA     #VAR_TYPE_INT
AE6A  39                              RTS
                      
AE6B  E69F002C        store_wa_byte   LDB     [ZP_INT_WA + 2]
AE6F                                  JUMP    retB8asUINT
AE6F  7EAAD6                                  JMP     \1
                      
AE72                  GetVarValReal                                           ; LB1C7
AE72  4F                              CLRA
AE73  9735                            STA     ZP_FPA + 7                      ; zero overflow mantissa and exponent bytes
AE75  972F                            STA     ZP_FPA + 1
AE77  EC03                            LDD     3,X
AE79  DD33                            STD     ZP_FPA + 5
AE7B  EC01                            LDD     1,X
AE7D  D732                            STB     ZP_FPA + 4
AE7F  972E                            STA     ZP_FPA
AE81  E684                            LDB     ,X
AE83  D730                            STB     ZP_FPA + 2
AE85  2608                            BNE     LB1EF
AE87  9A32                            ORA     ZP_FPA + 4
AE89  9A33                            ORA     ZP_FPA + 5
AE8B  9A34                            ORA     ZP_FPA + 6
AE8D  2704                            BEQ     LB1F2
AE8F                  LB1EF
AE8F  962E                            LDA     ZP_FPA
AE91  8A80                            ORA     #$80
AE93                  LB1F2
AE93  9731                            STA     ZP_FPA + 3
AE95  86FF                            LDA     #$FF
AE97  39                              RTS                     ;  Return real
                      
                      
                      
AE98  3440            GetVarValStr    PSHS    U               ; LB1F7
AE9A  8180                            CMPA    #$80            ; check type of string
AE9C  2717                            BEQ     GetVarValStr_Ind
AE9E  DE2C                            LDU     ZP_INT_WA + 2   ; get address of param block
AEA0  A643                            LDA     3,U             ; get string len
AEA2  9736                            STA     ZP_STRBUFLEN
AEA4  270C                            BEQ     1F
AEA6  EEC4                            LDU     ,U              ; get address of actual string
AEA8  8E0600                          LDX     #BASWKSP_STRING
AEAB                  2                                       ; LB20F:
AEAB  E6C0                            LDB     ,U+
AEAD  E780                            STB     ,X+
AEAF  4A                              DECA
AEB0  26F9                            BNE     2B
AEB2                  1                                       ;LB218:
AEB2  4F                              CLRA                    ; indicate string returned
AEB3  35C0                            PULS    U,PC
                      
                                      ; read string from memory
AEB5                  GetVarValStr_Ind                                        ; LB219
AEB5  962C                            LDA     ZP_INT_WA + 2                   ; if MSB of string addr is 0 treat as a single char!
AEB7  271A                            BEQ     GetVarValStr_SingleCharAtINTWA3
AEB9  5F                              CLRB
AEBA  9E2C                            LDX     ZP_INT_WA + 2
AEBC  CE0600                          LDU     #BASWKSP_STRING
AEBF                  1                                                       ; LB21F
AEBF  A680                            LDA     ,X+
AEC1  A7C0                            STA     ,U+
AEC3  880D                            EORA    #$0D                            ; eor here ensures 0 A on exit
AEC5  2704                            BEQ     2F
AEC7  5C                              INCB
AEC8  26F5                            BNE     1B
AECA  4F                              CLRA
AECB                  2                                                       ; LB22C:
AECB  D736                            STB     ZP_STRBUFLEN
AECD  4F                              CLRA                    ; indicate string returned
AECE  35C0                            PULS    U,PC
                      
                      
AED0                  fnCHR                   ; LB22F!
                      ;                       ;  =CHR$
AED0                                  CALL    evalLevel1checkTypeStoreAsINT
AED0                  9
AED2                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AED0  BD94E5                                  JSR     \1
                              ENDIF
AED3                  GetVarValStr_SingleCharAtINTWA3                         ; LB232
AED3  962D                            LDA     ZP_INT_WA + 3                   ; get single char and return in ZP_STR_BUF
AED5                                  JUMP    returnAAsString
AED5  7EAB3C                                  JMP     \1
                      
                      
AED8                  HandleBRKFindERL                                        ; LB237
AED8  0F08                            CLR     ZP_ERL
AEDA  0F09                            CLR     ZP_ERL + 1
AEDC  9618                            LDA     ZP_PAGE_H
AEDE  C600                            LDB     #0
AEE0  1F01                            TFR     D,X                     ; X points at start of program
AEE2  D60B                            LDB     ZP_TXTPTR
AEE4  C107                            CMPB    #BAS_InBuf / 256
AEE6  271C                            BEQ     HandleBRKFindERL_sk1
                      
AEE8                  HandleBRKFindERL_lp                             ;LB251:
AEE8  A680                            LDA     ,X+
AEEA  810D                            CMPA    #$0D
AEEC  2612                            BNE     HandleBRKFindERL_sk2
AEEE  9C0B                            CMPX    ZP_TXTPTR
AEF0  2412                            BHS     HandleBRKFindERL_sk1
AEF2  A680                            LDA     ,X+
AEF4  8A00                            ORA     #$00                    ; check end of program
AEF6  2B0C                            BMI     HandleBRKFindERL_sk1
AEF8  9708                            STA     ZP_ERL
AEFA  A680                            LDA     ,X+
AEFC  9709                            STA     ZP_ERL + 1
AEFE  A680                            LDA     ,X+
AF00                  HandleBRKFindERL_sk2                                    ;LB270:
AF00  9C0B                            CMPX    ZP_TXTPTR
AF02  25E4                            BLO     HandleBRKFindERL_lp
AF04                  HandleBRKFindERL_sk1                                    ;LB277:
AF04  39                              RTS
AF05                  HandleBRK
                              IF FLEX = 1
                                      LDX     ,S                              ; get stacked PC TODOFLEX: check for 6309?
                              ENDIF
AF05  9FFD                            STX     ZP_MOS_ERROR_PTR_QRY            ; TODO: look at JGH API?
AF07  C6FF                            LDB     #$FF
AF09  D728                            STB     ZP_OPT
AF0B                                  RESET_MACH_STACK
AF0B  10CE0200                                LDS     #MACH_STACK_TOP
                              IF FLEX = 1
                              ELSE
AF0F  3410                            PSHS    X
AF11  8E0000                          LDX     #0
AF14  CE0000                          LDU     #$00
AF17  86DA                            LDA     #$DA
AF19  BDFFF4                          JSR     OSBYTE                          ; clear VDU queue
AF1C  867E                            LDA     #$7E
AF1E  BDFFF4                          JSR     OSBYTE                          ; Acknowledge any Escape state
                              ENDIF
                      
AF21                                  CALL    HandleBRKFindERL
AF21                  9
AF23                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AF21  8DB5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AF23  0F20                            CLR     ZP_TRACE
                      ;;              LDA     [ZP_MOS_ERROR_PTR_QRY]
AF25  A6F1                            LDA     [,S++]
AF27  2602                            BNE     HandleBRKsk1
AF29                                  CALL    ONERROROFF
AF29                  9
AF2B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AF29  8D0A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AF2B                  HandleBRKsk1                                            ; LB296
AF2B  DE16                            LDU     ZP_ERR_VECT
AF2D  DF0B                            STU     ZP_TXTPTR
AF2F                                  CALL    ResetStackProgStartRepeatGosubFor
AF2F                  9
AF31                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF2F  BDB798                                  JSR     \1
                              ENDIF
AF32                                  JUMP    skipSpacesAtYexecImmed
AF32  7E8FEA                                  JMP     \1
AF35                  ONERROROFF
AF35  308C03                          LEAX    defErrBas, PCR
AF38  9F16                            STX     ZP_ERR_VECT
AF3A  39                              RTS
                      ;                       ;  Default error handler
                      ;                       ;  ---------------------
AF3B                  defErrBas
AF3B  F63AE79EF122206174206C696E6520223B                 FCB  tknREPORT, ':', tknIF, tknERL, tknPRINT, $22, " at line ", $22, ';'
AF4C  9E3AE08BF13AE0                  FCB  tknERL, ':', tknEND, tknELSE, tknPRINT, ":", tknEND
AF53  0D                              FCB  13
                      
AF54                  cmdSOUND                                                ; LB2C8
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AF54                                  CALL    evalForceINT
AF54                  9
AF56                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF54  BD9221                                  JSR     \1
                              ENDIF
AF57  8607                            LDA     #OSWORD_SOUND
AF59  3402                            PSHS    A                               ; store OSWORD # on stack
AF5B  C604                            LDB     #$04                            ; read 4 params
AF5D  9E2C            LB2CD           LDX     ZP_INT_WA + 2                   ; store 16 bit number on stack - reversing bytes
AF5F  3410                            PSHS    X
AF61  5A                              DECB
AF62  2709                            BEQ     1F
AF64  3404                            PSHS    B
AF66                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
AF66                  9
AF68                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF66  BD94DD                                  JSR     \1
                              ENDIF
AF69  3504                            PULS    B
AF6B  20F0                            BRA     LB2CD
AF6D                  1               CALL    LDUZP_TXTPTR2scanNextStmtFromY
AF6D                  9
AF6F                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF6D  BD98E3                                  JSR     \1
                              ENDIF
AF70  C607                            LDB     #$07                            ; # bytes to restore minus 1
AF72  201E                            BRA     sndPullBthenAtoZP_SAVE_BUF_OSWORD_A
                              ENDIF
AF74                  cmdENVELOPE                     ; LB2EC!
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AF74                                  CALL    evalForceINT
AF74                  9
AF76                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF74  BD9221                                  JSR     \1
                              ENDIF
AF77  8608                            LDA     #OSWORD_ENVELOPE
AF79  3402                            PSHS    A                               ; store OSWORD #
AF7B  C60E                            LDB     #14                             ; read 14 params
AF7D  962D            LB2F1           LDA     ZP_INT_WA + 3                   ; get low byte of int
AF7F  3402                            PSHS    A
AF81  5A                              DECB
AF82  2709                            BEQ     1F
AF84  3404                            PSHS    B
AF86                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
AF86                  9
AF88                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF86  BD94DD                                  JSR     \1
                              ENDIF
AF89  3504                            PULS    B
AF8B  20F0                            BRA     LB2F1
AF8D                  1               CALL    LDUZP_TXTPTR2scanNextStmtFromY
AF8D                  9
AF8F                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF8D  BD98E3                                  JSR     \1
                              ENDIF
AF90  C60D                            LDB     #13
AF92                  sndPullBthenAtoZP_SAVE_BUF_OSWORD_A                             ; LB307
AF92  8E0037                          LDX     #ZP_SAVE_BUF
AF95  3502            1               PULS    A
AF97  A785                            STA     B,X
AF99  5A                              DECB
AF9A  2AF9                            BPL     1B
AF9C  3502                            PULS    A                               ; get back OSWORD #
AF9E                  OSWORD_continue
AF9E  3440                            PSHS    U
AFA0  BDFFF1                          JSR     OSWORD
AFA3  3540                            PULS    U
AFA5  200B                            BRA     LB322continue                   ; Call OSWORD, return to execution loop
                              ENDIF
                      
                      
AFA7                  cmdWIDTH
                      
AFA7                                  CALL    evalForceINT
AFA7                  9
AFA9                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFA7  BD9221                                  JSR     \1
                              ENDIF
AFAA                                  CALL    scanNextStmtFromY
AFAA                  9
AFAC                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFAA  BD98F4                                  JSR     \1
                              ENDIF
AFAD  D62D                            LDB     ZP_INT_WA+3
AFAF  5A                              DECB
AFB0  D723                            STB     ZP_WIDTH
AFB2                  LB322continue
AFB2                                  JUMP    continue
AFB2  7E8FE2                                  JMP     \1
AFB5                  LB325brkMismatch
AFB5                                  JUMP    brkTypeMismatch
AFB5  7E906B                                  JMP     \1
AFB8                  evalAtYAndStoreEvaledExpressioninStackedVarPTr          ; LB328
AFB8                                  CALL evalAtY
AFB8                  9
AFBA                  __XBSR                  SET 9B+2
EA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFB8  BD9A41                                  JSR     \1
                              ENDIF
                                      ; the pointer to the variable (and it's type) are on the stack above the return pointer
AFBB                  storeEvaledExpressioninStackedVarPTr                    ; LB32B
                      ;               PLY
                      ;               PLX
                      ;               PLA
                      ;               STA ZP_NAMELENORVT
                      ;               PLA
                      ;               STA ZP_GEN_PTR + 1
                      ;               PLA
                      ;               STA ZP_GEN_PTR
                      ;               PHX
                      ;               PHY
AFBB  A662                            LDA     2,S
AFBD  9737                            STA     ZP_NAMELENORVT
AFBF  AE63                            LDX     3,S
AFC1  9F39                            STX     ZP_GEN_PTR+2
AFC3  3510                            PULS    X
AFC5  3263                            LEAS    3,S
AFC7  3410                            PSHS    X
AFC9                  storeEvaledExpressioninVarAtZP_GEN_PTR                  ; LB338
AFC9  9637                            LDA     ZP_NAMELENORVT
AFCB  8105                            CMPA    #VAR_TYPE_REAL
AFCD  2732                            BEQ     storeEvaledExpressioninRealVarAtZP_GEN_PTR
AFCF  9627                            LDA     ZP_VARTYPE
AFD1  27E2                            BEQ     LB325brkMismatch
AFD3  2A03                            BPL     storeInt1
AFD5                                  CALL    fpReal2Int
AFD5                  9
AFD7                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFD5  BD94F6                                  JSR     \1
                              ENDIF
AFD8                  storeInt1                                               ;LB347:
                      ;;;JGH
                      ;               TST     ZP_NAMELENORVT
AFD8  9637                            LDA     ZP_NAMELENORVT
AFDA  271E                            BEQ     storeByte
AFDC  8102                            CMPA    #$02
AFDE  270B                            BEQ     storeInt2                       ; little-endian word
AFE0  9E39                            LDX     ZP_GEN_PTR+2
AFE2  DC2A                            LDD     ZP_INT_WA
AFE4  ED84                            STD     0,X
AFE6  DC2C                            LDD     ZP_INT_WA + 2
AFE8  ED02                            STD     2,X
AFEA  39                              RTS
AFEB                  storeInt2                                               ; Store little-endian word
AFEB  9E39                            LDX     ZP_GEN_PTR+2
AFED  DC2A                            LDD     ZP_INT_WA
AFEF  1E89                            EXG     A,B
AFF1  ED02                            STD     2,X
AFF3  DC2C                            LDD     ZP_INT_WA + 2
AFF5  1E89                            EXG     A,B
AFF7  ED84                            STD     0,X
AFF9  39                              RTS
                      ;;;^^^
AFFA                  storeByte
AFFA  962D                            LDA     ZP_INT_WA + 3
AFFC  A79F0039                        STA     [ZP_GEN_PTR+2]
B000  39                              RTS
B001                  storeEvaledExpressioninRealVarAtZP_GEN_PTR              ; LB360
B001  9627                            LDA     ZP_VARTYPE
B003  27B0                            BEQ     LB325brkMismatch
B005  2B03                            BMI     skIntToReal1
B007                                  CALL    IntToReal
B007                  9
B009                  __XBSR                  SET 9B+2
D500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B007  BD856A                                  JSR     \1
                              ENDIF
B00A                  skIntToReal1                                            ; LB369
B00A  9E39                            LDX     ZP_GEN_PTR+2
B00C                  fpCopyFPAtoX
B00C  9630                            LDA     ZP_FPA + 2
B00E  A780                            STA     ,X+
B010  962E                            LDA     ZP_FPA                  ; get mantissa sign back from sign byte
B012  9831                            EORA    ZP_FPA + 3
B014  8480                            ANDA    #$80
B016  9831                            EORA    ZP_FPA + 3
B018  A780                            STA     ,X+
B01A  9632                            LDA     ZP_FPA + 4
B01C  A780                            STA     ,X+
B01E  9633                            LDA     ZP_FPA + 5
B020  A780                            STA     ,X+
B022  9634                            LDA     ZP_FPA + 6
B024  A780                            STA     ,X+
B026  39                              RTS
                      
B027                  cmdEDIT                 
B027                                  CALL    ResetVars
B027                  9
B029                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B027  BDB770                                  JSR     \1
                              ENDIF
B02A  8680                            LDA     #$80
B02C  971F                            STA     ZP_LISTO
                      
B02E                  doLIST
B02E  0F3B                            CLR     ZP_FPB
B030  0F3C                            CLR     ZP_FPB + 1
B032                                  CALL    varFALSE                        ; set start line no to 0
B032                  9
B034                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B032  BDA89D                                  JSR     \1
                              ENDIF
B035                                  CALL    skipSpacesDecodeLineNumberNewAPI
B035                  9
B037                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B035  BD987B                                  JSR     \1
                              ENDIF
B038  3401                            PSHS    CC
B03A                                  CALL    stackINT_WAasINT                ; stack start line no
B03A                  9
B03C                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B03A  BDB7DA                                  JSR     \1
                              ENDIF
B03D                                  CALL    returnINTminus1                 ; set end line no to FFFF
B03D                  9
B03F                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0052                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B03D  BDA891                                  JSR     \1
                              ENDIF
B040  042C                            LSR     ZP_INT_WA + 2                   ; note line number in +2,3, clear top bit end 
                                                                              ; line no. max is 32767
                                                                              ; LB3AD:
B042  3501                            PULS    CC
B044  240D                            BCC     doListSkNoLineSpec
B046                                  CALL    skipSpacesCheckCommaAtYStepBack         ; look for a comma, 
B046                  9
B048                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B046  BD8D4E                                  JSR     \1
                              ENDIF
B049  270B                            BEQ     doListSkLineSpec2
                                      ; no second spec, pop first speccd line and use as 2nd param
B04B                                  CALL    popIntANew                      ; unstack then stack - TODO: check if can load using off,U
B04B                  9
B04D                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B04B  BDB86C                                  JSR     \1
                              ENDIF
B04E                                  CALL    stackINT_WAasINT
B04E                  9
B050                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B04E  BDB7DA                                  JSR     \1
                              ENDIF
B051  2006                            BRA     doListSkStart
B053                  doListSkNoLineSpec                                      ;LB3BF:
B053                                  CALL    skipSpacesCheckCommaAtYStepBack ; if there's a comma skip it 
B053                  9
B055                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B053  BD8D4E                                  JSR     \1
                              ENDIF
B056                  doListSkLineSpec2                                       ;LB3C6:
B056                                  CALL    skipSpacesDecodeLineNumberNewAPI; this will return $FFFF if no match (i.e. go to the end!)
B056                  9
B058                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B056  BD987B                                  JSR     \1
                              ENDIF
B059                  doListSkStart                                           ;LB3C9:
B059  8E0031                          LDX     #ZP_FPA + 3
B05C                                  CALL    CopyIntWA2X
B05C                  9
B05E                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B05C  BDB923                                  JSR     \1
                              ENDIF
B05F                                  CALL    skipSpacesYStepBack
B05F                  9
B061                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B05F  BD8F15                                  JSR     \1
                              ENDIF
B062  81E7                            CMPA    #tknIF
B064  261A                            BNE     doListSkStart2
B066                                  CALL    inySkipSpacesYStepBack
B066                  9
B068                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B066  BD8F13                                  JSR     \1
                              ENDIF
B069  2018                            BRA     doListSkStart3
B06B                  cmdLIST
                      
                                              
                      ;                       ;  LIST
B06B  A6C4                            LDA     ,U
                      
B06D  814F                            CMPA    #'O'
B06F  26BD                            BNE     doLIST
B071  3341                            LEAU    1,U
B073                                  CALL    evalForceINT
B073                  9
B075                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B073  BD9221                                  JSR     \1
                              ENDIF
B076                                  CALL    scanNextStmtFromY
B076                  9
B078                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B076  BD98F4                                  JSR     \1
                              ENDIF
B079  962D                            LDA     ZP_INT_WA + 3
B07B  971F                            STA     ZP_LISTO
B07D                                  JUMP    immedPrompt
B07D  7E8F6F                                  JMP     \1
B080                  doListSkStart2                                          ; LB3F3:
B080                                  CALL    scanNextExpectColonElseCR
B080                  9
B082                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B080  BD98F7                                  JSR     \1
                              ENDIF
B083                  doListSkStart3                                          ; LB3F6:
B083  DF19                            STU     ZP_TXTPTR2                      ; point at first non-space after IF token or <CR> if not LIST IF
B085                                  CALL    findTOP
B085                  9
B087                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B085  BDB93F                                  JSR     \1
                              ENDIF
B088                                  CALL    popIntANew                      ; intWA now contains ending line no
B088                  9
B08A                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B088  BDB86C                                  JSR     \1
                              ENDIF
B08B                                  CALL    findProgLineNewAPI
B08B                  9
B08D                  __XBSR                  SET 9B+2
D400                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B08B  BD84C9                                  JSR     \1
                              ENDIF
B08E  2515                            BCS     doListSkGotCorrectLine
B090  200F                            BRA     doListSkGotNearestLine
B092                  doListPrintLFThenLoop                                   ; LB410
B092                                  CALL    list_printA
B092                  9
B094                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B092  BDB8EF                                  JSR     \1
                              ENDIF
B095  0D1F                            TST     ZP_LISTO
B097  2B05                            BMI     doListLoop
B099  860A                            LDA     #$0A
B09B  BDFFEE                          JSR     OSWRCH
B09E                  doListLoop                                              ;LB41C
                      ;;              CALL storeYasTXTPTR
B09E                                  CALL    checkForESC
B09E                  9
B0A0                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0065                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B09E  BD9905                                  JSR     \1
                              ENDIF
B0A1                  doListSkGotNearestLine                                  ;LB41F:
B0A1  AE41                            LDX     1,U                              ; get the actual line number found
B0A3  9F2C                            STX     ZP_INT_WA + 2
B0A5                  doListSkGotCorrectLine                                  ;LB428:
B0A5  9E2C                            LDX     ZP_INT_WA + 2
B0A7  9C33                            CMPX    ZP_FPA + 5      
B0A9  2316                            BLS     doListStartLine
B0AB  0D1F                            TST     ZP_LISTO
B0AD  102ADEBE                        LBPL    immedPrompt
B0B1  308C03                          LEAX    strEdit12_2,PCR
B0B4  7EFFF7                          JMP     OSCLI
                      
                      ;                       ;  EDIT
                      ;                       ;  ====
B0B7                  strEdit12_2                             ;LB389:
B0B7  454449542031322C320D                 FCB     "EDIT 12,2", $0d
                      
                      
B0C1                  doListStartLine                                         ; LB43E:
B0C1  0F4C                            CLR     ZP_FP_TMP + 9                   ; flag Quote/REM open
B0C3  0F4D                            CLR     ZP_FP_TMP + 10                  ; flag whether to display line
B0C5  3344                            LEAU    4,U                             ; point at first char/token of actual line 
B0C7  DF0B                            STU     ZP_TXTPTR                       ; store pointer for later after scan
                      
                                      ; scan the line for UNTIL/NEXT for indents
                                      ; scan the line for matches if doing LIST IF
                      
                                      ; reset indent levels if -ve
B0C9  0D3B                            TST     ZP_FPB
B0CB  2A02                            BPL     doListSk0
B0CD  0F3B                            CLR     ZP_FPB
B0CF                  doListSk0                                               ;LB44E:
B0CF  0D3C                            TST     ZP_FPB + 1
B0D1  2A02                            BPL     doListSk1
B0D3  0F3C                            CLR     ZP_FPB + 1
B0D5                  doListSk1                                               ;LB454:
B0D5                  doListScanLoop
B0D5  A6C4                            LDA     ,U                              ;  Get character
B0D7  810D                            CMPA    #$0D
B0D9  2738                            BEQ     doListScanDone                  ;  End of line
B0DB  81F4                            CMPA    #tknREM
B0DD  2706                            BEQ     doListSkREM                     ; ignore quotes in REMs
B0DF  8122                            CMPA    #'"'
B0E1  2604                            BNE     doListSkREMQuot
B0E3  984C                            EORA    ZP_FP_TMP + 9                   ;  Toggle quote flag (no effect after REM!)
B0E5                  doListSkREM                                             ;LB464:
B0E5  974C                            STA     ZP_FP_TMP + 9                   ; if a REM store tknREM, if a Quote toggle
B0E7                  doListSkREMQuot                                         ; LB466
B0E7  0D4C                            TST     ZP_FP_TMP + 9
B0E9  260C                            BNE     doListSkUntil                   ;  Within quotes / REM
B0EB  81ED                            CMPA    #tknNEXT
B0ED  2602                            BNE     doListSkNext
B0EF  0A3B                            DEC     ZP_FPB                          ; decrement NEXT indent level
B0F1                  doListSkNext                                            ; LB470
B0F1  81FD                            CMPA    #tknUNTIL
B0F3  2602                            BNE     doListSkUntil
B0F5  0A3C                            DEC     ZP_FPB + 1                      ; decrement UNTIL indent level
B0F7                  doListSkUntil                                           ; LB476
                      
                                      ; LIST IF
                      
B0F7  9E19                            LDX     ZP_TXTPTR2                      ; LIST IF 
B0F9  3440                            PSHS    U                               
B0FB                  doListLp_Uk1                                            ; LB478
B0FB  A684                            LDA     ,X                              ; scan line after LIST IF and try and match within the current line
B0FD  810D                            CMPA    #$0D
B0FF  270A                            BEQ     doListSk_Uk1
B101  A1C4                            CMPA    ,U
B103  2608                            BNE     doListSk_Uk2
B105  3341                            LEAU    1,U
B107  3001                            LEAX    1,X
B109  20F0                            BRA     doListLp_Uk1
                      
B10B                  doListSk_Uk1                                            ; LB489:
B10B  974D                            STA     ZP_FP_TMP + 10                  ; matched LIST IF (or there wasn't one) do print this line
B10D                  doListSk_Uk2                                            ; LB48B:
B10D  3540                            PULS    U
B10F  3341                            LEAU    1,U
B111  20C2                            BRA     doListScanLoop
B113                  doListScanDone                                          ;LB491:
B113  964D                            LDA     ZP_FP_TMP + 10
B115  2787                            BEQ     doListLoop
B117                                  CALL    int16print_fmt5                 ; print line number
B117                  9
B119                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B117  BD9D50                                  JSR     \1
                              ENDIF
B11A  8601                            LDA     #$01
B11C  5C                              INCB                                    ; set to 0
B11D                                  SEC
B11D  1A01                    ORCC    #CC_C
B11F                                  CALL    doLISTOSpaces                   ; LISTO1 - space after Line no
B11F                  9
B121                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B11F  BDB914                                  JSR     \1
                              ENDIF
B122  D63B                            LDB     ZP_FPB
B124  8602                            LDA     #$02
B126                                  CALL    doLISTOSpacesCLC                ; LISTO2 - NEXT indents
B126                  9
B128                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B126  BDB912                                  JSR     \1
                              ENDIF
B129  D63C                            LDB     ZP_FPB + 1
B12B  8604                            LDA     #$04                            ; LISTO4 - REPEAT/UNTIL indents
B12D                                  CALL    doLISTOSpacesCLC
B12D                  9
B12F                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B12D  BDB912                                  JSR     \1
                              ENDIF
B130  0F4C                            CLR     ZP_FP_TMP + 9
B132                  doListNextTok2                                          ;LB4AF:
B132  DE0B                            LDU     ZP_TXTPTR                       ; TODO reset Y pointer here?
B134                  doListNextTok                                           ; LB4B1:
B134  A6C4                            LDA     ,U
B136  810D                            CMPA    #$0D
B138  1027FF56                        LBEQ    doListPrintLFThenLoop
B13C  8122                            CMPA    #'"'
B13E  260D                            BNE     doListSkNotQuot2
B140  984C                            EORA    ZP_FP_TMP + 9
B142  974C                            STA     ZP_FP_TMP + 9                   ; Toggle quote flag
B144  8622                            LDA     #'"'
B146                  doListQuoteLp2                                          ; LB4C1
B146                                  CALL    list_printA
B146                  9
B148                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B146  BDB8EF                                  JSR     \1
                              ENDIF
B149  3341                            LEAU    1,U
B14B  20E7                            BRA     doListNextTok
B14D                  doListSkNotQuot2                                        ; LB4C7:
B14D  0D4C                            TST     ZP_FP_TMP + 9
B14F  26F5                            BNE     doListQuoteLp2
B151  818D                            CMPA    #tknLineNo
B153  260A                            BNE     doList_sknotLineNo
B155  3341                            LEAU    1,U
B157                                  CALL    decodeLineNumber
B157                  9
B159                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
002F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B157  BD9888                                  JSR     \1
                              ENDIF
                                                                              ;               STU ZP_TXTOFF - don't think this is needed any longer
B15A                                  CALL    int16print_AnyLen
B15A                  9
B15C                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B15A  BD9D4C                                  JSR     \1
                              ENDIF
B15D  20D5                            BRA     doListNextTok                   ;               DB: changes to not restore Y as int16print not longer trashes it
B15F                  doList_sknotLineNo                                      ; LB4D9:
B15F  81E3                            CMPA    #tknFOR
B161  2602                            BNE     doList_sknotFOR
B163  0C3B                            INC     ZP_FPB
B165                  doList_sknotFOR                                         ; LB4DF:
B165  81F5                            CMPA    #tknREPEAT
B167  2602                            BNE     doList_sknotREPEAT
B169  0C3C                            INC     ZP_FPB + 1
B16B                  doList_sknotREPEAT                                      ; LB4E5:
B16B  81F4                            CMPA    #tknREM
B16D  2602                            BNE     doList_sknotREM
B16F  974C                            STA     ZP_FP_TMP + 9
B171                  doList_sknotREM                                         ;LB4EB:
B171                                  CALL    doListPrintTokenA
B171                  9
B173                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B171  BDB8A1                                  JSR     \1
                              ENDIF
B174  3341                            LEAU    1,U
B176  20BC                            BRA     doListNextTok
                      
                      
                                              ; cmdNEXT
                                              ; =======
B178                  cmdNEXT
B178                                  CALL    findVarAtYSkipSpaces
B178                  9
B17A                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B178  BD96FD                                  JSR     \1
                              ENDIF
B17B  2609                            BNE     cmdNextSkSpecdLoopVar
B17D  D626                            LDB     ZP_FOR_LVL_X_15
B17F  273B                            BEQ     brkNoFOR
B181  2542                            BCS     cmdNEXTTopLoopVar
B183                  cmdNextskSyntax JUMP    brkSyntax
B183  7E98B7                                  JMP     \1
B186                  cmdNextSkSpecdLoopVar                                   ; LB4FF
B186  25FB                            BCS     cmdNextskSyntax                 ; TODO: should this not be can't match for? Bug in original BASIC?
B188  3440                            PSHS    U                               ; use Y as gen ptr, remember to pop before BRKs
B18A  D626                            LDB     ZP_FOR_LVL_X_15
B18C  8E0519                          LDX     #BASWKSP_FORSTACK-FORSTACK_ITEM_SIZE
B18F  3A                              ABX     
B190  3384                            LEAU    ,X                              ; Y points at last item on FOR stack
B192  2728                            BEQ     brkNoFOR
B194                  cmdNEXTstacklp                                          ; LB505
B194  9E2C                            LDX     ZP_INT_WA + 2                   ; search FOR stack for a loop with matching variable pointer and type
B196  ACC4                            CMPX    FORSTACK_OFFS_VARPTR,U
B198  2608                            BNE     cmdNEXTstacklpsk1
B19A  962A                            LDA     ZP_INT_WA + 0
B19C  A142                            CMPA    FORSTACK_OFFS_VARTYPE,U
B19E  2602                            BNE     cmdNEXTstacklpsk1
B1A0  2034                            BRA     cmdNEXTfoundLoopVar             
B1A2                  cmdNEXTstacklpsk1                                       ; LB51A
B1A2  3351                            LEAU    -FORSTACK_ITEM_SIZE,U
B1A4  C00F                            SUBB    #FORSTACK_ITEM_SIZE
B1A6  D726                            STB     ZP_FOR_LVL_X_15
B1A8  26EA                            BNE     cmdNEXTstacklp
B1AA  3540                            PULS    U
B1AC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B1AC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B1AD  2143616E2774206D6174636820E300                 FCB     $21, "Can't match ", tknFOR, 0
B1BC                  brkNoFOR
B1BC  3540                            PULS    U
B1BE                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B1BE  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B1BF  204E6F20E300                    FCB     $20, "No ", tknFOR, 0
B1C5                  cmdNEXTTopLoopVar                                       ; LB539
B1C5  335F                            LEAU    -1,U                            ; if no var found go back a char : TODO - check whether we can change API
B1C7  3440                            PSHS    U                               ; use Y as gen ptr, remember to pop before BRKs
B1C9  CE0519                          LDU     #BASWKSP_FORSTACK - FORSTACK_ITEM_SIZE
B1CC  33C5                            LEAU    B,U
B1CE  AEC4                            LDX     FORSTACK_OFFS_VARPTR,U
B1D0  A642                            LDA     FORSTACK_OFFS_VARTYPE,U
B1D2  972A                            STA     ZP_INT_WA + 0
B1D4  9F2C                            STX     ZP_INT_WA + 2
B1D6                  cmdNEXTfoundLoopVar
                                      ; X => variable
                                      ; Y => FOR stack
                                      ; B => ZP_FOR_LVL_X_15
                                      ; A is var type
B1D6  8105                            CMPA    #VAR_TYPE_REAL
B1D8  10270091                        LBEQ    cmdNEXTdoREAL
B1DC  8102                            CMPA    #VAR_TYPE_INT_LE
B1DE  2741                            BEQ     cmdNEXTdoINT_LE
                      
                                      ; 32 bit add of integer control VAR, also store at ZP_GEN_PTR (bigendian)
B1E0  EC02                            LDD     2,X
B1E2  E345                            ADDD    (2+FORSTACK_OFFS_STEP),U
B1E4  ED02                            STD     2,X
B1E6  EC84                            LDD     ,X
B1E8  E944                            ADCB    (1+FORSTACK_OFFS_STEP),U
B1EA  A943                            ADCA    (0+FORSTACK_OFFS_STEP),U
B1EC  ED84                            STD     0,X
                      
B1EE  EC02                            LDD     2,X                             ;6
B1F0  A34A                            SUBD    (2+FORSTACK_OFFS_TO),U          ;7
B1F2  260D                            BNE     cmdNEXTnoZ                      ;3
B1F4  EC84                            LDD     0,X                             ;5
B1F6  E249                            SBCB    (1+FORSTACK_OFFS_TO),U          ;5
B1F8  A248                            SBCA    (0+FORSTACK_OFFS_TO),U          ;5
B1FA  260B                            BNE     cmdNEXTnoZ2                     ;3
B1FC  5D                              TSTB                                    ;2
B1FD  2608                            BNE     cmdNEXTnoZ2                     ;3
                      ;                                                       ;=39
B1FF  2014                            BRA     cmdNEXTexecLoop                 ;3
B201                  cmdNEXTnoZ
B201  EC84                            LDD     0,X                             ;5
B203  E249                            SBCB    (1+FORSTACK_OFFS_TO),U          ;5
B205  A248                            SBCA    (0+FORSTACK_OFFS_TO),U          ;5
                                                                              ;=31
B207                  cmdNEXTnoZ2
B207  A684                            LDA     0,X
B209  A848                            EORA    (0+FORSTACK_OFFS_TO),U
B20B  A843                            EORA    (0+FORSTACK_OFFS_STEP),U
B20D  2A04                            BPL     cmdNEXTcksign2
B20F  2404                            BCC     cmdNEXTexecLoop
B211  2048                            BRA     cmdNEXTloopFinished
B213                  cmdNEXTcksign2                                          ; LB59C
B213  2446                            BCC     cmdNEXTloopFinished
B215                  cmdNEXTexecLoop                                         ; LB59E
B215  3262                            LEAS    2,S                             ; don't pull Y we don't want it
B217  EE4D                            LDU     FORSTACK_OFFS_LOOP,U
B219  DF0B                            STU     ZP_TXTPTR
B21B                                  CALL    checkForESC
B21B                  9
B21D                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B21B  BD9905                                  JSR     \1
                              ENDIF
B21E                                  JUMP    skipSpacesAtYexecImmed
B21E  7E8FEA                                  JMP     \1
                      
B221                  cmdNEXTdoINT_LE                                         ; TODO: see about shortening / sharing this!
                                      ; 32 bit add of integer control VAR, also store at ZP_GEN_PTR (bigendian)
B221  EC84                            LDD     0,X
B223  AB46                            ADDA    (3+FORSTACK_OFFS_STEP),U
B225  E945                            ADCB    (2+FORSTACK_OFFS_STEP),U
B227  ED84                            STD     0,X
B229  EC02                            LDD     2,X
B22B  A944                            ADCA    (1+FORSTACK_OFFS_STEP),U
B22D  E943                            ADCB    (0+FORSTACK_OFFS_STEP),U
B22F  ED02                            STD     2,X
                      
B231  EC84                            LDD     0,X                             ;6
B233  A04B                            SUBA    (3+FORSTACK_OFFS_TO),U          ;7
B235  E24A                            SBCB    (2+FORSTACK_OFFS_TO),U          ;7
B237  2610                            BNE     cmdNEXTnoZLE                    ;3
B239  4D                              TSTA
B23A  260D                            BNE     cmdNEXTnoZLE                    ;3
B23C  EC02                            LDD     2,X                             ;5
B23E  A249                            SBCA    (1+FORSTACK_OFFS_TO),U          ;5
B240  E248                            SBCB    (0+FORSTACK_OFFS_TO),U          ;5
B242  260B                            BNE     cmdNEXTnoZ2LE                   ;3
B244  4D                              TSTA                                    ;2
B245  2608                            BNE     cmdNEXTnoZ2LE                   ;3
                      ;                                                       ;=39
B247  20CC                            BRA     cmdNEXTexecLoop                 ;3
B249                  cmdNEXTnoZLE
B249  EC02                            LDD     2,X                             ;5
B24B  A249                            SBCA    (1+FORSTACK_OFFS_TO),U          ;5
B24D  E248                            SBCB    (0+FORSTACK_OFFS_TO),U          ;5
                                                                              ;=31
B24F                  cmdNEXTnoZ2LE
B24F  A603                            LDA     3,X
B251  A848                            EORA    (0+FORSTACK_OFFS_TO),U
B253  A843                            EORA    (0+FORSTACK_OFFS_STEP),U
B255  2ABC                            BPL     cmdNEXTcksign2
B257  24BC                            BCC     cmdNEXTexecLoop
B259  2000                            BRA     cmdNEXTloopFinished
                      
B25B                  cmdNEXTloopFinished                                     ; LB5AE
B25B  D626                            LDB     ZP_FOR_LVL_X_15
B25D  C00F                            SUBB    #FORSTACK_ITEM_SIZE
B25F  D726                            STB     ZP_FOR_LVL_X_15
B261  3540                            PULS    U
B263                                  CALL    skipSpacesCheckCommaAtY
B263                  9
B265                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B263  BD8D48                                  JSR     \1
                              ENDIF
B266  1026DD73                        LBNE    decYGoScanNextContinue
B26A                                  JUMP    cmdNEXT                         ; found a comma, do another round of NEXTing
B26A  7EB178                                  JMP     \1
                      
B26D                  cmdNEXTdoREAL                                           ; LB5C0
B26D                                  CALL    GetVarValReal                   ; get current variable value
B26D                  9
B26F                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B26D  BDAE72                                  JSR     \1
                              ENDIF
B270  3043                            LEAX    FORSTACK_OFFS_STEP,U            ; get STEP value
B272  9F4A                            STX     ZP_FP_TMP_PTR1
B274                                  CALL    fpFPAeqPTR1addFPA               ; TODO jump straight in with X?
B274                  9
B276                  __XBSR                  SET 9B+2
F000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B274  BDA343                                  JSR     \1
                              ENDIF
                      
B277  9E2C                            LDX     ZP_INT_WA + 2                   ; Get variable pointer
B279                                  CALL    fpCopyFPAtoX                    ; store result of STEP add
B279                  9
B27B                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B279  BDB00C                                  JSR     \1
                              ENDIF
                      
B27C  3048                            LEAX    FORSTACK_OFFS_TO,U              ; Get pointer to TO value
B27E  9F4A                            STX     ZP_FP_TMP_PTR1
B280                                  CALL    evalDoCompareRealFPAwithPTR1    ; TODO: use X direct
B280                  9
B282                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0025                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B280  BD99A7                                  JSR     \1
                              ENDIF
B283  2790                            BEQ     cmdNEXTexecLoop
B285  6D44                            TST     FORSTACK_OFFS_STEP + 1,U        ; if STEP -ve
B287  2B04                            BMI     LB5F1
B289  248A                            BCC     cmdNEXTexecLoop
B28B  20CE                            BRA     cmdNEXTloopFinished
B28D                  LB5F1
B28D  2586                            BCS     cmdNEXTexecLoop
B28F  20CA                            BRA     cmdNEXTloopFinished
                      
B291                  brkFORVariable
B291                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B291  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B292  22E3207661726961626C6500                 FCB     $22, tknFOR, " variable", 0
B29E                  brkTooManyFORs
B29E                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B29E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B29F  23546F6F206D616E7920E37300                 FCB     $23, "Too many ", tknFOR, "s", 0
B2AC                  brkNoTO
B2AC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B2AC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B2AD  244E6F20B800                    FCB     $24, "No ", tknTO, 0
                                              ;============================
                                              ; FOR
                                              ;============================
B2B3                  cmdFOR
                                      ; TODO some recalcs of X could be done by LEAX?
                                              ;  FOR
B2B3                                  CALL    findVarOrAllocEmpty
B2B3                  9
B2B5                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2B3  BD96B1                                  JSR     \1
                              ENDIF
B2B6  27D9                            BEQ     brkFORVariable
B2B8  25D7                            BCS     brkFORVariable
B2BA                                  CALL    pushVarPtrAndType
B2BA                  9
B2BC                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
002C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2BA  BDB7E8                                  JSR     \1
                              ENDIF
B2BD                                  CALL    skipToEqualsOrBRKY
B2BD                  9
B2BF                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2BD  BD98D6                                  JSR     \1
                              ENDIF
B2C0                                  CALL    evalAtYAndStoreEvaledExpressioninStackedVarPTr
B2C0                  9
B2C2                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2C0  BDAFB8                                  JSR     \1
                              ENDIF
B2C3                                  CALL    skipSpacesY
B2C3                  9
B2C5                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2C3  BD8F0C                                  JSR     \1
                              ENDIF
B2C6  81B8                            CMPA    #tknTO
B2C8  26E2                            BNE     brkNoTO
B2CA  D626                            LDB     ZP_FOR_LVL_X_15
B2CC  C196                            CMPB    #FORSTACK_ITEM_SIZE*FORSTACK_MAX_ITEMS
B2CE  24CE                            BCC     brkTooManyFORs
B2D0  8E0528                          LDX     #BASWKSP_FORSTACK
B2D3  3A                              ABX
B2D4  9F52                            STX     ZP_EXTRA_SAVE
B2D6  D626                            LDB     ZP_FOR_LVL_X_15
B2D8  CB0F                            ADDB    #FORSTACK_ITEM_SIZE
B2DA  D726                            STB     ZP_FOR_LVL_X_15
B2DC  DC39                            LDD     ZP_GEN_PTR+2                    ; addr of control var
B2DE  ED84                            STD     FORSTACK_OFFS_VARPTR,X
B2E0  9637                            LDA     ZP_NAMELENORVT
B2E2  A702                            STA     FORSTACK_OFFS_VARTYPE,X         ; type of control var
B2E4  8105                            CMPA    #$05
B2E6  2739                            BEQ     cmdFORskipskReal
B2E8                                  CALL    evalAtYcheckTypeInAConvert2INT
B2E8                  9
B2EA                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2E8  BD94E0                                  JSR     \1
                              ENDIF
B2EB  9E52                            LDX     ZP_EXTRA_SAVE
B2ED  DC2A                            LDD     ZP_INT_WA                       ; store INT TO val at +8
B2EF  ED08                            STD     FORSTACK_OFFS_TO,X
B2F1  DC2C                            LDD     ZP_INT_WA + 2
B2F3  ED0A                            STD     FORSTACK_OFFS_TO+2,X
B2F5  8601                            LDA     #$01
B2F7                                  CALL    retA8asUINT                     ; default STEP to 1
B2F7                  9
B2F9                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2F7  BDAAD4                                  JSR     \1
                              ENDIF
B2FA                                  CALL    skipSpacesY             
B2FA                  9
B2FC                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2FA  BD8F0C                                  JSR     \1
                              ENDIF
B2FD  8188                            CMPA    #tknSTEP
B2FF  2609                            BNE     cmdFORskINTnoSTEP
B301  3410                            PSHS    X
B303                                  CALL    evalAtYcheckTypeInAConvert2INT
B303                  9
B305                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B303  BD94E0                                  JSR     \1
                              ENDIF
B306  3510                            PULS    X
B308  3341                            LEAU    1,U                             ; TODO - sort this back and forth out?
B30A                  cmdFORskINTnoSTEP                                       ; LB677
B30A  335F                            LEAU    -1,U
B30C  DC2A                            LDD     ZP_INT_WA                       ; store INT STEP val at + 5
B30E  ED03                            STD     FORSTACK_OFFS_STEP,X
B310  DC2C                            LDD     ZP_INT_WA + 2
B312  ED05                            STD     FORSTACK_OFFS_STEP + 2,X
B314                  cmdFORskipExecBody                                      ; LB68F
B314                                  CALL    scanNextStmtAndTrace
B314                  9
B316                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B314  BD990C                                  JSR     \1
                              ENDIF
B317  D626                            LDB     ZP_FOR_LVL_X_15
B319  8E0526                          LDX     #BASWKSP_FORSTACK + FORSTACK_OFFS_LOOP - FORSTACK_ITEM_SIZE
B31C  EF85                            STU     B,X                             ; store Y pointer to body statement in FOR stack (2 before next pointer!)
B31E                                  JUMP    skipSpacesAtYexecImmed
B31E  7E8FEA                                  JMP     \1
B321                  cmdFORskipskReal                                        ; LB6A1
                      
B321                                  CALL    evalAtY
B321                  9
B323                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B321  BD9A41                                  JSR     \1
                              ENDIF
B324                                  CALL    checkTypeIntToReal
B324                  9
B326                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B324  BD9505                                  JSR     \1
                              ENDIF
B327  9E52                            LDX     ZP_EXTRA_SAVE
B329  C608                            LDB     #FORSTACK_OFFS_TO
B32B  3A                              ABX
B32C                                  CALL    fpCopyFPA_X                     ; store TO value (real)
B32C                  9
B32E                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B32C  BDA1F3                                  JSR     \1
                              ENDIF
B32F                                  CALL    fpLoad1                         ; FloatA=1.0 (load default STEP)
B32F                  9
B331                  __XBSR                  SET 9B+2
EF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B32F  BDA292                                  JSR     \1
                              ENDIF
B332                                  CALL    skipSpacesY
B332                  9
B334                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B332  BD8F0C                                  JSR     \1
                              ENDIF
B335  8188                            CMPA    #tknSTEP
B337  2608                            BNE     cmdFORrealNoStep
B339                                  CALL    evalAtY
B339                  9
B33B                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B339  BD9A41                                  JSR     \1
                              ENDIF
B33C                                  CALL    checkTypeIntToReal
B33C                  9
B33E                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B33C  BD9505                                  JSR     \1
                              ENDIF
B33F  3341                            LEAU    1,U
B341                  cmdFORrealNoStep                                        ; LB6C7
B341  335F                            LEAU    -1,U
B343  9E52                            LDX     ZP_EXTRA_SAVE
B345  C603                            LDB     #FORSTACK_OFFS_STEP
B347  3A                              ABX
B348                                  CALL    fpCopyFPA_X
B348                  9
B34A                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B348  BDA1F3                                  JSR     \1
                              ENDIF
B34B  20C7                            BRA     cmdFORskipExecBody
                      
                                              ;============================
                                              ; GOSUB         
                                              ;============================
B34D                  cmdGOSUB
B34D                                  CALL    decodeLineNumberFindProgLine
B34D                  9
B34F                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B34D  BDB486                                  JSR     \1
                              ENDIF
B350                  intGOSUB_FPB_2  CALL    scanNextStmtFromY               ; LB6DC
B350                  9
B352                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B350  BD98F4                                  JSR     \1
                              ENDIF
B353  D625                            LDB     ZP_GOSUB_LVL                    ; Get GOSUB index
B355  C111                            CMPB    #GOSUBSTACK_MAX                 ; Check whether stack is full
B357  240B                            BHS     brkTooManyGosubs
B359  8E05CC                          LDX     #BASWKSP_GOSUBSTACK
B35C  58                              ASLB
B35D  3A                              ABX
B35E  EF84                            STU     ,X                              ; store text pointer on stack
B360  0C25                            INC     ZP_GOSUB_LVL
B362  202E                            BRA     cmdGOTODecodedLineNumber
B364                  brkTooManyGosubs
B364                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B364  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B365  25546F6F206D616E7920E47300                 FCB     $25, "Too many ", tknGOSUB, "s", 0
B372                  brknoGOSUB
B372                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B372  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B373  264E6F20E400                    FCB     $26, "No ", tknGOSUB, 0
                      
                                              ;============================
                                              ; RETURN
                                              ;============================
B379                  cmdRETURN
B379                                  CALL    scanNextStmtFromY
B379                  9
B37B                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0079                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B379  BD98F4                                  JSR     \1
                              ENDIF
B37C  D625                            LDB     ZP_GOSUB_LVL
B37E  27F2                            BEQ     brknoGOSUB
B380  0A25                            DEC     ZP_GOSUB_LVL
B382  8E05CA                          LDX     #BASWKSP_GOSUBSTACK-2
B385  58                              ASLB
B386  3A                              ABX
B387  EE84                            LDU     ,X
B389                  LB71A           JUMP    continue
B389  7E8FE2                                  JMP     \1
                      
                                              ;============================
                                              ; GOTO
                                              ;============================
B38C                  cmdGOTO                                                 ; LB71D!
                      
B38C                                  CALL    decodeLineNumberFindProgLine
B38C                  9
B38E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B38C  BDB486                                  JSR     \1
                              ENDIF
                                      ;;LDU   ZP_TXTPTR
B38F                                  CALL    scanNextStmtFromY
B38F                  9
B391                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B38F  BD98F4                                  JSR     \1
                              ENDIF
B392                  cmdGOTODecodedLineNumber                                ; LB723
B392  9620                            LDA     ZP_TRACE
B394  2703                            BEQ     cmdGOTOskTrace
B396                                  CALL    doTRACE
B396                  9
B398                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B396  BD9965                                  JSR     \1
                              ENDIF
B399                  cmdGOTOskTrace                                          ; LB72A
B399  DE3D                            LDU     ZP_FPB + 2
B39B  3344                            LEAU    4,U
B39D                  STUZPTXTPTR_continue                                    ; LB732
B39D  DF0B                            STU     ZP_TXTPTR
B39F                                  JUMP    skipSpacesAtYexecImmed
B39F  7E8FEA                                  JMP     \1
                      
B3A2                  cmdONERROROFF                                           ; LB739
B3A2                                  CALL    scanNextStmtFromY
B3A2                  9
B3A4                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3A2  BD98F4                                  JSR     \1
                              ENDIF
B3A5                                  CALL    ONERROROFF
B3A5                  9
B3A7                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3A5  BDAF35                                  JSR     \1
                              ENDIF
B3A8                                  JUMP    continue
B3A8  7E8FE2                                  JMP     \1
B3AB                  cmdONERROR                                              ; LB741
B3AB                                  CALL    skipSpacesY
B3AB                  9
B3AD                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3AB  BD8F0C                                  JSR     \1
                              ENDIF
B3AE  8187                            CMPA    #tknOFF
B3B0  27F0                            BEQ     cmdONERROROFF
B3B2  335F                            LEAU    -1,U
B3B4  DF16                            STU     ZP_ERR_VECT
B3B6                                  JUMP    cmdREM                          ; skip rest
B3B6  7E8F97                                  JMP     \1
                      ;                       ;  ON [ERROR][GOTO][GOSUB]
                      ;                       ;  =======================
B3B9                  cmdON                                                   ; LB75B!
                      
B3B9                                  CALL    skipSpacesY
B3B9                  9
B3BB                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3B9  BD8F0C                                  JSR     \1
                              ENDIF
B3BC  8185                            CMPA    #tknERROR
B3BE  27EB                            BEQ     cmdONERROR                              ;  ON ERROR
                      
B3C0  335F                            LEAU    -1,U
B3C2                                  CALL    evalForceINT                            ;  Evaluate ON <num>
B3C2                  9
B3C4                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3C2  BD9221                                  JSR     \1
                              ENDIF
B3C5  C1F2                            CMPB    #tknPROC
B3C7  270A                            BEQ     cmdOnGSP                                ;  ON <num> PROC
B3C9  3341                            LEAU    1,U
B3CB  C1E5                            CMPB    #tknGOTO
B3CD  2704                            BEQ     cmdOnGSP                                ;  ON <num> GOTO
B3CF  C1E4                            CMPB    #tknGOSUB
B3D1  2679                            BNE     brkONSyntax                             ;  ON <num> GOSUB
B3D3                  cmdOnGSP                                                        ; LB774
B3D3  3404                            PSHS    B                                       ;  Save token
B3D5  962A                            LDA     ZP_INT_WA + 0
B3D7  9A2B                            ORA     ZP_INT_WA + 1
B3D9  9A2C                            ORA     ZP_INT_WA + 2           
B3DB  2657                            BNE     cmdOnSkipNoMatch                        ; if >255
B3DD  0A2D                            DEC     ZP_INT_WA + 3                           ; make 0-based
B3DF  2734                            BEQ     cmdOnFound
B3E1  2B51                            BMI     cmdOnSkipNoMatch
B3E3                  cmdOnCharloop                                                   ; LB783
B3E3  A6C0                            LDA     ,U+
B3E5  810D                            CMPA    #$0D
B3E7  2749                            BEQ     cmdOnSkipNoMatch2
B3E9  813A                            CMPA    #':'
B3EB  2745                            BEQ     cmdOnSkipNoMatch2
B3ED  818B                            CMPA    #tknELSE
B3EF  2741                            BEQ     cmdOnSkipNoMatch2
B3F1  8122                            CMPA    #'"'
B3F3  2604                            BNE     1F
B3F5  982B                            EORA    ZP_INT_WA + 1
B3F7  972B                            STA     ZP_INT_WA + 1                           ; quotes flag
B3F9  0D2B            1               TST     ZP_INT_WA + 1                           ; LB79A
B3FB  26E6                            BNE     cmdOnCharloop                           ; skip over quotes PROC params
B3FD  8129                            CMPA    #')'
B3FF  2602                            BNE     1F
B401  0A2C                            DEC     ZP_INT_WA + 2
B403  8128            1               CMPA    #'('                                    ; LB7A4
B405  2602                            BNE     1F
B407  0C2C                            INC     ZP_INT_WA + 2
B409  812C            1               CMPA    #','                                    ; LB7AA
B40B  26D6                            BNE      cmdOnCharloop
B40D  0D2C                            TST      ZP_INT_WA + 2                          ; brackets
B40F  26D2                            BNE      cmdOnCharloop
B411  0A2D                            DEC      ZP_INT_WA + 3
B413  26CE                            BNE      cmdOnCharloop
B415                  cmdOnFound                                                      ; LB7B6
B415  3502                            PULS    A       
B417  81F2                            CMPA    #tknPROC
B419  274B                            BEQ     cmdOnFoundPROC
B41B  DF0A                            STU     ZP_TXTOFF
B41D  81E4                            CMPA    #tknGOSUB
B41F  2708                            BEQ     cmdOnFoundGOSUB
B421                                  CALL    decodeLineNumberFindProgLine
B421                  9
B423                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B421  8D63                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B423                                  CALL    checkForESC
B423                  9
B425                  __XBSR                  SET 9B+2
E400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B423  BD9905                                  JSR     \1
                              ENDIF
B426                                  JUMP    cmdGOTODecodedLineNumber
B426  7EB392                                  JMP     \1
B429                  cmdOnFoundGOSUB                                                 ; LB7CA
B429                                  CALL    decodeLineNumberFindProgLine
B429                  9
B42B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B429  8D5B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B42B  DE0A                            LDU     ZP_TXTOFF
B42D                                  CALL    findNextStmt                            ; find $0D or ':' to use as return from GOSUB
B42D                  9
B42F                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B42D  8D4A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B42F                                  JUMP    intGOSUB_FPB_2
B42F  7EB350                                  JMP     \1
B432                  cmdOnSkipNoMatch2
B432  335F                            LEAU    -1,U
B434                  cmdOnSkipNoMatch                                                ; LB7D5
B434  3261                            LEAS    1,S                                     ; remove token from stack
B436  A6C0            1               LDA     ,U+                                     ; search for ELSE or end of statement
B438  818B                            CMPA    #tknELSE
B43A  1027E509                        LBEQ    execTHENorELSEimpicitGOTO
B43E  810D                            CMPA    #$0D
B440  26F4                            BNE     1B
B442                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B442  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B443  28EE2072616E676500                 FCB     $28, tknON, " range", 0
B44C                  brkONSyntax
B44C                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B44C  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B44D  27EE2073796E74617800                 FCB     $27, tknON, " syntax", 0
B457                  brkNoSuchLine
B457                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B457  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B458  294E6F2073756368206C696E6500                 FCB     $29, "No such line", 0
B466                  cmdOnFoundPROC                                                  ; LB803
B466  3440                            PSHS    U
B468                                  CALL    skipSpacesY
B468                  9
B46A                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B468  BD8F0C                                  JSR     \1
                              ENDIF
B46B  81F2                            CMPA    #tknPROC
B46D  26DD                            BNE     brkONSyntax
B46F                                  CALL    doFNPROCcall
B46F                  9
B471                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0085                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B46F  BDACF6                                  JSR     \1
                              ENDIF
B472  3540                            PULS    U
B474                                  CALL    findNextStmt
B474                  9
B476                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B474  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B476                                  JUMP    scanNextContinue
B476  7E8FDF                                  JMP     \1
                      ;;LB81C:
                      ;;              INY
                      ;;LB81D:
                      ;;              LDA (ZP_TXTPTR),Y
                      ;;              CMP #$0D
                      ;;              BEQ LB827
                      ;;              CMP #$3A
                      ;;              BNE LB81C
                      ;;LB827:
                      ;;              STU ZP_TXTOFF
                      ;;              RTS
                      ;;              
B479  A6C0            findNextStmt    LDA     ,U+
B47B  813A                            CMPA    #':'
B47D  2704                            BEQ     1F
B47F  810D                            CMPA    #$0D
B481  26F6                            BNE     findNextStmt
B483  335F            1               LEAU    -1,U
B485  39                              RTS
                      
                      
B486                  decodeLineNumberFindProgLine
B486                                  CALL    skipSpacesDecodeLineNumberNewAPI
B486                  9
B488                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B486  BD987B                                  JSR     \1
                              ENDIF
B489  2509                            BCS     findProgLineOrBRK                       ; tokenised line number found
B48B                                  CALL    evalForceINT
B48B                  9
B48D                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0094                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B48B  BD9221                                  JSR     \1
                              ENDIF
B48E  867F                            LDA     #$7F                                    ; clear top bit of line number
B490  942C                            ANDA    ZP_INT_WA + 2
B492  972C                            STA     ZP_INT_WA + 2
B494                  findProgLineOrBRK
B494  3440                            PSHS    U
B496                                  CALL    findProgLineNewAPI
B496                  9
B498                  __XBSR                  SET 9B+2
D000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0031                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B496  BD84C9                                  JSR     \1
                              ENDIF
B499  24BC                            BCC     brkNoSuchLine
B49B  35C0                            PULS    U,PC
                      ;LB83C:
                      ;               JUMP brkTypeMismatch
                      ;;LB83F:
                      ;;              JUMP brkSyntax
                      
                      ;;cmdINPUT_HASH_exit
                      ;;              STU ZP_TXTOFF
                      ;;;LB844:
                      ;;              JUMP scanNextContinue
                      
B49D                  cmdINPUTBGETtoX
B49D  BDFFD7          1               JSR     OSBGET
B4A0  A780                            STA     ,X+
B4A2  5A                              DECB            
B4A3  26F8                            BNE     1B
B4A5  39                              RTS
                      
B4A6                  cmdINPUT_HASH                                           ; LB847
B4A6                                  CALL    decYSaveAndEvalHashChannelAPI
B4A6                  9
B4A8                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4A6  BDB682                                  JSR     \1
                              ENDIF
B4A9  3420                            PSHS    Y                               ; save channel #
B4AB                  cmdINPUT_HASH_lp                                        ; LB84F
B4AB  DE0B                            LDU     ZP_TXTPTR
B4AD                                  CALL    skipSpacesCheckCommaAtY
B4AD                  9
B4AF                  __XBSR                  SET 9B+2
D800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4AD  BD8D48                                  JSR     \1
                              ENDIF
B4B0  1026DC8B                        LBNE    cmdPRINTHASH_exit
B4B4                                  CALL    findVarOrAllocEmpty
B4B4                  9
B4B6                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4B4  BD96B1                                  JSR     \1
                              ENDIF
B4B7  1027E3FC                        LBEQ    brkSyntax
                      ;;              CALL copyTXTOFF2toTXTOFF
B4BB  DF0B                            STU     ZP_TXTPTR
                      ;;              PLA
                      ;;              STA ZP_FP_TMP + 9
B4BD  3401                            PSHS    CC
B4BF                                  CALL    stackINT_WAasINT                ; pointer to variable on stack
B4BF                  9
B4C1                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4BF  BDB7DA                                  JSR     \1
                              ENDIF
B4C2  EE61                            LDU     1,S                             ; channel
B4C4  BDFFD7                          JSR     OSBGET
B4C7  9727                            STA     ZP_VARTYPE                      ; get VARTYPE as stored in file
B4C9  3501                            PULS    CC                              ; get back var flags
B4CB  2419                            BCC     cmdINPUT_HASH_notdynstr         ; branc if not a dyn string
B4CD  0D27                            TST     ZP_VARTYPE                      ; check var type (we want 0 for string!)
B4CF  1026DB98                        LBNE    brkTypeMismatch
B4D3  BDFFD7                          JSR     OSBGET
B4D6  9736                            STA     ZP_STRBUFLEN
B4D8  D636                            LDB     ZP_STRBUFLEN                    ; counter
B4DA  2705                            BEQ     2F
B4DC  8E0600                          LDX     #BASWKSP_STRING
B4DF                                  CALL    cmdINPUTBGETtoX
B4DF                  9
B4E1                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B4DF  8DBC                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B4E1                  2               CALL    copyStringToVar
B4E1                  9
B4E3                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4E1  BD9085                                  JSR     \1
                              ENDIF
B4E4  20C5                            BRA     cmdINPUT_HASH_lp
B4E6                  cmdINPUT_HASH_notdynstr                                 ; LB88A
B4E6  0D27                            TST     ZP_VARTYPE
B4E8  1027DB7F                        LBEQ    brkTypeMismatch
B4EC  2B09                            BMI     cmdINPUT_HASH_FP
B4EE  C604                            LDB     #$04
B4F0  8E002A                          LDX     #ZP_INT_WA
B4F3                                  CALL    cmdINPUTBGETtoX
B4F3                  9
B4F5                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B4F3  8DA8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B4F5  2010                            BRA     cmdINPUT_HASH_StoreAtVarPtr
B4F7                  cmdINPUT_HASH_FP                                        ;
B4F7  C605                            LDB     #$05
B4F9  8E0471                          LDX     #BASWKSP_FPTEMP1 + 5
B4FC  BDFFD7          1               JSR     OSBGET
B4FF  A782                            STA     ,-X
B501  5A                              DECB
B502  26F8                            BNE     1B
B504                                  CALL    fpCopyFPTEMP1toFPA
B504                  9
B506                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B504  BDA20E                                  JSR     \1
                              ENDIF
B507                  cmdINPUT_HASH_StoreAtVarPtr
B507                                  CALL    popIntAtZP_GEN_PTRNew
B507                  9
B509                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B507  BDB87C                                  JSR     \1
                              ENDIF
B50A                                  CALL    storeEvaledExpressioninVarAtZP_GEN_PTR
B50A                  9
B50C                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B50A  BDAFC9                                  JSR     \1
                              ENDIF
B50D  209C                            BRA     cmdINPUT_HASH_lp
                      ;LB8B2:
                      ;               PLA
                      ;               PLA
                      ;               BRA LB844
B50F                  cmdINPUT                        ; LB8B6!
B50F                                  CALL    skipSpacesCheckHashAtY
B50F                  9
B511                  __XBSR                  SET 9B+2
D800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0031                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B50F  BD8D42                                  JSR     \1
                              ENDIF
B512  2792                            BEQ     cmdINPUT_HASH
                      
B514  8186                            CMPA    #tknLINE
B516  2704                            BEQ     1F
B518  335F                            LEAU    -1,U
B51A                                  SEC                                     ; note the LINE bit is the opposite sense to 6502
B51A  1A01                    ORCC    #CC_C
B51C  064C            1               ROR     ZP_FP_TMP + 9
B51E  044C                            LSR     ZP_FP_TMP + 9
B520  86FF                            LDA     #$FF
B522  974D                            STA     ZP_FP_TMP + 10                  ; flag "first" item after a prompt?
B524                  cmdINPUT_LINE_lp                                        ; LB8CA
B524  084C                            ASL     ZP_FP_TMP + 9
B526                                  CALL    cmdINPUT_PRINT_prompt
B526                  9
B528                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0018                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B526  BD9240                                  JSR     \1
                              ENDIF
B529  250B                            BCS     LB8D9
B52B                  1               CALL    cmdINPUT_PRINT_prompt
B52B                  9
B52D                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B52B  BD9240                                  JSR     \1
                              ENDIF
B52E  24FB                            BCC     1B
B530  C6FF                            LDB     #$FF
B532  D74D                            STB     ZP_FP_TMP + 10                  ; flag "first" item after a prompt?
B534                                  CLC
B534  1CFE                    ANDCC   #~CC_C
B536  064C            LB8D9           ROR     ZP_FP_TMP + 9                   ; bit 7 set if had prompt, bit 6 set if LINE
B538  812C                            CMPA    #','
B53A  27E8                            BEQ     cmdINPUT_LINE_lp                                ; check again for prompts
B53C  813B                            CMPA    #';'
B53E  27E4                            BEQ     cmdINPUT_LINE_lp                                ; check again for prompts
B540  335F                            LEAU    -1,U
B542  DC4C                            LDD     ZP_FP_TMP + 9                   ; stack our flags
B544  3406                            PSHS    D
B546                                  CALL    findVarOrAllocEmpty
B546                  9
B548                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B546  BD96B1                                  JSR     \1
                              ENDIF
B549  1027DBF2                        LBEQ    cmdPRINTHASH_exit               ; "invalid" i.e. no varaible found
B54D  3506                            PULS    D
B54F  DD4C                            STD     ZP_FP_TMP+9
                      ;;              CALL    copyTXTOFF2toTXTOFF
B551  3441                            PSHS    CC,U                            ; store carry flag (set if a string var) and current Y
B553  C640                            LDB     #$40
B555  D54C                            BITB    ZP_FP_TMP + 9                   ; branch if 
B557  2706                            BEQ     LB908                           ; note opposite sense! branch for LINE
B559  D64D                            LDB     ZP_FP_TMP + 10
B55B  C1FF                            CMPB    #$FF
B55D  261F                            BNE     cmdINPUT_LINE_readCommaStrItem
B55F                  LB908
B55F  0D4C                            TST     ZP_FP_TMP + 9
B561  2A05                            BPL     1F
B563  863F                            LDA     #'?'
B565  BDFFEE                          JSR     OSWRCH
B568  8606            1               LDA     #BASWKSP_STRING / $100
B56A                                  CALL    ReadKeysTo_PageInA
B56A                  9
B56C                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B56A  BDB6A6                                  JSR     \1
                              ENDIF
B56D  1F20                            TFR     Y,D
B56F  D736                            STB     ZP_STRBUFLEN                    ; length of line read in
B571  084C                            ASL     ZP_FP_TMP + 9
B573                                  CLC
B573  1CFE                    ANDCC   #~CC_C
B575  064C                            ROR     ZP_FP_TMP + 9                   ; clear "had prompt" flag
B577  8640                            LDA     #$40
B579  954C                            BITA    ZP_FP_TMP + 9
B57B  2718                            BEQ     cmdINPUT_LINE_INPUT
B57D  5F                              CLRB
B57E                  cmdINPUT_LINE_readCommaStrItem                          ; LB91F
B57E  8606                            LDA     #$06
B580  1F03                            TFR     D,U
B582                                  CALL    readCommaSepString
B582                  9
B584                  __XBSR                  SET 9B+2
F400                  __XBSR2                 SET (\1-__XBSR) & $FF00
002A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B582  BDA9AE                                  JSR     \1
                              ENDIF
B585                  LB92A
B585                                  CALL    skipSpacesCheckCommaAtY
B585                  9
B587                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B585  BD8D48                                  JSR     \1
                              ENDIF
B588  2707                            BEQ     LB935
B58A  810D                            CMPA    #$0D
B58C  26F7                            BNE     LB92A
B58E  CEFFFF                          LDU     #$FFFF
B591  1F30            LB935           TFR     U,D
B593  D74D            1               STB     ZP_FP_TMP + 10
B595                  cmdINPUT_LINE_INPUT                                     ; LB938
B595  3501                            PULS    CC
B597  250E                            BCS     cmdINPUT_LINE_INPUT_STR
B599                                  CALL    pushVarPtrAndType
B599                  9
B59B                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
004D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B599  BDB7E8                                  JSR     \1
                              ENDIF
B59C                                  CALL    str2Num
B59C                  9
B59E                  __XBSR                  SET 9B+2
F200                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B59C  BDA80B                                  JSR     \1
                              ENDIF
B59F                                  CALL    storeEvaledExpressioninStackedVarPTr
B59F                  9
B5A1                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B59F  BDAFBB                                  JSR     \1
                              ENDIF
B5A2  3540            1               PULS    U
B5A4                                  JUMP    cmdINPUT_LINE_lp
B5A4  7EB524                                  JMP     \1
B5A7                  cmdINPUT_LINE_INPUT_STR                                 ;LB946:
B5A7  0F27                            CLR     ZP_VARTYPE
B5A9                                  CALL    copyStringToVar2
B5A9                  9
B5AB                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5A9  BD9088                                  JSR     \1
                              ENDIF
B5AC  20F4                            BRA     1B
                      
                      
                      
B5AE                  cmdRESTORE
B5AE  0F3E                            CLR     ZP_FPB + 3
B5B0  9618                            LDA     ZP_PAGE_H
B5B2  973D                            STA     ZP_FPB + 2                      ; FPB+2=>start of program
B5B4                                  CALL    skipSpacesYStepBack
B5B4                  9
B5B6                  __XBSR                  SET 9B+2
D900                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5B4  BD8F15                                  JSR     \1
                              ENDIF
B5B7  813A                            CMPA    #':'
B5B9  270B                            BEQ     LB967
B5BB  810D                            CMPA    #$0D
B5BD  2707                            BEQ     LB967
B5BF  818B                            CMPA    #tknELSE
B5C1  2703                            BEQ     LB967
B5C3                                  CALL    decodeLineNumberFindProgLine    ; expect program line number, find it or BRK
B5C3                  9
B5C5                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5C3  BDB486                                  JSR     \1
                              ENDIF
B5C6                  LB967           CALL    scanNextStmtFromY               ; scan to start of next statement
B5C6                  9
B5C8                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
002C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5C6  BD98F4                                  JSR     \1
                              ENDIF
B5C9  DC3D                            LDD     ZP_FPB + 2                      ; now pointing at start of line specified or start of program
B5CB  DD1C                            STD     ZP_READ_PTR
B5CD                                  JUMP    continue
B5CD  7E8FE2                                  JMP     \1
                      
                      
B5D0                  cmdREAD_next                                            ; LLB975
B5D0                                  CALL    skipSpacesCheckCommaAtYStepBack         ; look for comma
B5D0                  9
B5D2                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5D0  BD8D4E                                  JSR     \1
                              ENDIF
B5D3  1026DA08                        LBNE    scanNextContinue                ; if not found continue
                                                                              ; or fall through for next READ var
B5D7                  cmdREAD
B5D7                                  CALL    findVarOrAllocEmpty
B5D7                  9
B5D9                  __XBSR                  SET 9B+2
E000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5D7  BD96B1                                  JSR     \1
                              ENDIF
B5DA  27F4                            BEQ     cmdREAD_next                    ; bad var name, skip
B5DC  250C                            BCS     cmdREAD_readString              ; string ?
B5DE  3440                            PSHS    U
B5E0                                  CALL    cmdREAD_findNextDataItem
B5E0                  9
B5E2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B5E0  8D1D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B5E2                                  CALL    pushVarPtrAndType
B5E2                  9
B5E4                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5E2  BDB7E8                                  JSR     \1
                              ENDIF
B5E5                                  CALL    evalAtYAndStoreEvaledExpressioninStackedVarPTr
B5E5                  9
B5E7                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5E5  BDAFB8                                  JSR     \1
                              ENDIF
B5E8  200F                            BRA     LB99D
B5EA                  cmdREAD_readString
B5EA  3440                            PSHS    U
B5EC                                  CALL    cmdREAD_findNextDataItem
B5EC                  9
B5EE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0011                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B5EC  8D11                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B5EE                                  CALL    stackINT_WAasINT
B5EE                  9
B5F0                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5EE  BDB7DA                                  JSR     \1
                              ENDIF
B5F1                                  CALL    readCommaSepString
B5F1                  9
B5F3                  __XBSR                  SET 9B+2
F300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5F1  BDA9AE                                  JSR     \1
                              ENDIF
B5F4  9727                            STA     ZP_VARTYPE
B5F6                                  CALL    copyStringToVar
B5F6                  9
B5F8                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5F6  BD9085                                  JSR     \1
                              ENDIF
B5F9                  LB99D
B5F9  DF1C                            STU     ZP_READ_PTR
B5FB  3540                            PULS    U
B5FD  20D1                            BRA     cmdREAD_next
                      
B5FF                  cmdREAD_findNextDataItem
B5FF  DE1C                            LDU     ZP_READ_PTR
B601                                  CALL    skipSpacesCheckCommaAtY
B601                  9
B603                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0045                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B601  BD8D48                                  JSR     \1
                              ENDIF
B604  274F                            BEQ     cmdREAD_dataItemFound
B606  81DC                            CMPA    #tknDATA
B608  274B                            BEQ     cmdREAD_dataItemFound
B60A  810D                            CMPA    #$0D
B60C  2709                            BEQ     cmdREAD_CR
B60E                  LB9C6
B60E                                  CALL    skipSpacesCheckCommaAtY
B60E                  9
B610                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0038                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B60E  BD8D48                                  JSR     \1
                              ENDIF
B611  2742                            BEQ     cmdREAD_dataItemFound
B613  810D                            CMPA    #$0D
B615  26F7                            BNE     LB9C6
B617                  cmdREAD_CR
B617  30C4                            LEAX    ,U                              ; save start of line for skip
B619  A6C0                            LDA     ,U+
B61B  2B13                            BMI     brkOutOfDATA
B61D  3341                            LEAU    1,U                             ; skip 2nd byte of 
B61F  E6C0                            LDB     ,U+                             ; line length
B621                  LB9DA
B621  A6C0                            LDA     ,U+
B623  8120                            CMPA    #' '
B625  27FA                            BEQ     LB9DA                           ; skip spaces
B627  81DC                            CMPA    #tknDATA                        ; found DATA token that'll do
B629  272A                            BEQ     cmdREAD_dataItemFound
B62B  3A                              ABX                                     ; if not add line length to start of line and continue
B62C  3384                            LEAU    ,X              
B62E  20E7                            BRA cmdREAD_CR
B630                  brkOutOfDATA
B630                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B630  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B631  2A4F7574206F6620DC00                 FCB     $2A, "Out of ", tknDATA, 0
B63B                  brkNoREPEAT
B63B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B63B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B63C  2B4E6F20F500                    FCB     $2B, "No ", tknREPEAT, 0
B642                  brkMissingHash
B642                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B642  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B643  2D8D2300                        FCB     $2D, tknMissing, "#", 0
B647                  brkTooManyREPEATs
B647                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B647  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B648  2C546F6F206D616E7920F57300                 FCB     $2C, "Too many ", tknREPEAT, "s", 0
                      ;;LBA13:
                      ;;              INY
                      ;;              STU ZP_TXTOFF2
B655                  cmdREAD_dataItemFound
                      ;               LEAU    ,X
B655  39                              RTS
                      
B656                  IntWAZero
B656  3402                            PSHS    A
B658  962A                            LDA     ZP_INT_WA
B65A  9A2B                            ORA     ZP_INT_WA + 1
B65C  9A2C                            ORA     ZP_INT_WA + 2
B65E  9A2D                            ORA     ZP_INT_WA + 3
B660  3582                            PULS    A,PC
                      
                      
B662                  cmdUNTIL
                                              
                      ;                       ;  UNTIL
B662                                  CALL    evalExpressionMAIN
B662                  9
B664                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B662  BD9A41                                  JSR     \1
                              ENDIF
B665                                  CALL    scanNextStmtFromY
B665                  9
B667                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B665  BD98F4                                  JSR     \1
                              ENDIF
B668                                  CALL    checkTypeInZP_VARTYPEConvert2INT
B668                  9
B66A                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B668  BD94ED                                  JSR     \1
                              ENDIF
B66B  D624                            LDB     ZP_REPEAT_LVL
B66D  27CC                            BEQ     brkNoREPEAT
B66F                                  CALL    IntWAZero
B66F                  9
B671                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B66F  8DE5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B671  2705                            BEQ     1F
B673  0A24                            DEC     ZP_REPEAT_LVL                   ; discard top of repeat stack
B675                                  JUMP    continue                        ; continue
B675  7E8FE2                                  JMP     \1
B678                  1                                                       ; LBA33
B678  5A                              DECB
B679  58                              ASLB
B67A  8E0500                          LDX     #BASWKSP_REPEATSTACK
B67D  EE85                            LDU     B,X
B67F                                  JUMP    STUZPTXTPTR_continue
B67F  7EB39D                                  JMP     \1
                              ; API Change - no longer saves to TXTPTR2
                              ; TODO: TEST: callers don't push Y
B682                  decYSaveAndEvalHashChannelAPI                           ; LBA3C
B682  335F                            LEAU    -1,U
B684                  evalHashChannel                                         ; LBA4A
B684                                  CALL    skipSpacesCheckHashAtY
B684                  9
B686                  __XBSR                  SET 9B+2
D600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B684  BD8D42                                  JSR     \1
                              ENDIF
B687  26B9                            BNE     brkMissingHash
B689                                  CALL    evalLevel1checkTypeStoreAsINT
B689                  9
B68B                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B689  BD94E5                                  JSR     \1
                              ENDIF
B68C  109E2C                          LDY     ZP_INT_WA+2
B68F  39                              RTS
                      
                      
B690                  cmdREPEAT
                                              ;  REPEAT
B690  D624                            LDB     ZP_REPEAT_LVL
B692  C114                            CMPB    #$14
B694  24B1                            BHS     brkTooManyREPEATs
                      ;;              CALL    storeYasTXTPTR
B696                                  CALL    checkForESC
B696                  9
B698                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B696  BD9905                                  JSR     \1
                              ENDIF
B699  58                              ASLB
B69A  8E0500                          LDX     #BASWKSP_REPEATSTACK
B69D  EF85                            STU     B,X
B69F  0C24                            INC     ZP_REPEAT_LVL
B6A1                                  JUMP    skipSpacesAtYexecImmed
B6A1  7E8FEA                                  JMP     \1
                      
                      
B6A4                  ReadKeysTo_InBuf
B6A4  8607                            LDA     #BAS_InBuf / $100
                              IF FLEX = 1
                                      CLRB
                                      CALL    FLEX_READLINE
                              ELSE
B6A6                  ReadKeysTo_PageInA
B6A6  5F                              CLRB
B6A7  DD37                            STD     ZP_GEN_PTR
B6A9  CCEE20                          LDD     #$EE20
B6AC  DD39                            STD     ZP_GEN_PTR + 2
B6AE  C6FF                            LDB     #$FF
B6B0  D73B                            STB     ZP_GEN_PTR + 4
B6B2  8E0037                          LDX     #ZP_GEN_PTR
                      ;;              LDU     #0
B6B5  4F                              CLRA
B6B6  BDFFF1                          JSR     OSWORD          ; OSWORD 0 - read line to buf at XY
                              ENDIF
B6B9  2406                            BCC     clearPRLINCOUNT
B6BB                                  JUMP    errEscape
B6BB  7E98CD                                  JMP     \1
B6BE                  PrintCRclearPRLINCOUNT                                  ; LBA92
B6BE  BDFFE7                          JSR     OSNEWL
B6C1                  clearPRLINCOUNT                                         ; LBA95
B6C1  0F1E                            CLR     ZP_PRLINCOUNT
B6C3  39                              RTS
                      
B6C4                  findLineAndDelete                                       ;LBA98
B6C4                                  CALL    findProgLineNewAPI
B6C4                  9
B6C6                  __XBSR                  SET 9B+2
CE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6C4  BD84C9                                  JSR     \1
                              ENDIF
B6C7  2420                            BCC     rtsLBAEA
B6C9  DF12                            STU     ZP_TOP                          ; we found the line - replace it
B6CB  30C4                            LEAX    ,U
B6CD  E643                            LDB     3,U                             ; get length of existing line
B6CF  4F                              CLRA
                      ;;              ADDD    ZP_TOP          
                      ;;              TFR     D,Y
B6D0  33CB                            LEAU    D,U
B6D2                  floCopyLp                                               ; LBAB8
B6D2                                  CALL    floCopy1bytes
B6D2                  9
B6D4                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0011                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B6D2  8D11                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B6D4  810D                            CMPA    #$0D
B6D6  26FA                            BNE     floCopyLp
                                                                              ;LBAC7:
B6D8                                  CALL    floCopy1bytes                   ; copy first (line number byte - big endian)
B6D8                  9
B6DA                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B6D8  8D0B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B6DA  2B06                            BMI     floCopySk1                      ; end of program detected
B6DC                                  CALL    floCopy1bytes                   ; copy line numbers bytes 
B6DC                  9
B6DE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0007                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B6DC  8D07                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B6DE                                  CALL    floCopy1bytes                   ; copy length byte
B6DE                  9
B6E0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0005                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B6DE  8D05                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B6E0  20F0                            BRA     floCopyLp
B6E2                  floCopySk1                                              ;LBAD3:
                      ;LBADC:
B6E2  9F12                            STX     ZP_TOP
B6E4  39                              RTS
B6E5                  floCopy1bytes
B6E5  A6C0                            LDA     ,U+
B6E7  A780                            STA     ,X+
B6E9  39              rtsLBAEA        RTS
                                              
                                      ;  Tokenise line, enter into program if program line
                                      ;  returns CY=1 if this is a program line
                      
B6EA                  tokenizeAndStore
B6EA  86FF                            LDA     #$FF
B6EC  9728                            STA     ZP_OPT
B6EE  973C                            STA     ZP_FPB + 1
B6F0                                  CALL    ResetStackProgStartRepeatGosubFor               ;  do various CLEARs
B6F0                  9
B6F2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6F0  BDB798                                  JSR     \1
                              ENDIF
B6F3  DE0B                            LDU     ZP_TXTPTR
B6F5  0F3B                            CLR     ZP_FPB
B6F7                                  CALL    tokenizeATY
B6F7                  9
B6F9                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6F7  BD8DFF                                  JSR     \1
                              ENDIF
B6FA  DE0B                            LDU     ZP_TXTPTR
B6FC                                  CALL    skipSpacesDecodeLineNumberNewAPI
B6FC                  9
B6FE                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6FC  BD987B                                  JSR     \1
                              ENDIF
B6FF  24E8                            BCC     rtsLBAEA
B701                  tokenizeAndStoreAlreadyLineNoDecoded                                    ; LBB08
B701  5F                              CLRB
B702  0D1F                            TST     ZP_LISTO
B704  2703                            BEQ     tokAndStoreListo0
B706  BD8F15                          JSR     skipSpacesYStepBack             
B709                  tokAndStoreListo0                                                       ;LBB15:
B709  DF3B                            STU     ZP_FPB
B70B                                  CALL    findLineAndDelete  
B70B                  9
B70D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B70B  8DB7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B70D  DE3B                            LDU     ZP_FPB
B70F  860D                            LDA     #$0D
B711  C601                            LDB     #1                                              ; count line length
B713  A1C0                            CMPA    ,U+             
B715  27D2                            BEQ     rtsLBAEA                                        ; line was nowt but white space, return
B717  5C              tokas_lp2       INCB                                                    ;LBB26:
B718  A1C0                            CMPA    ,U+
B71A  26FB                            BNE     tokas_lp2                                       ; move to EOL marker $D
B71C  8620                            LDA     #' '
B71E  335F                            LEAU    -1,U
B720  5A              tokas_lp3       DECB                                                    ;LBB2D:
B721  A1C2                            CMPA    ,-U
B723  27FB                            BEQ tokas_lp3                                           ; skip back over spaces
B725  3341            tokas_sk1       LEAU    1,U                                             ;LBB34:
B727  860D                            LDA     #$0D
B729  A7C4                            STA     ,U                                              ; another EOL marker remove trailing whitespace
B72B  CB04                            ADDB    #4
B72D  D73F                            STB     ZP_FPB + 4
B72F  9E12                            LDX     ZP_TOP
B731  4F                              CLRA
B732  D312                            ADDD    ZP_TOP
B734  DD12                            STD     ZP_TOP          
B736  109306                          CMPD    ZP_HIMEM
B739  230F                            BLS     tokas_sk2_spaceok
B73B                                  CALL    findTOP
B73B                  9
B73D                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B73B  BDB93F                                  JSR     \1
                              ENDIF
B73E                                  CALL    ResetVars
B73E                  9
B740                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0030                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B73E  8D30                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B740                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B740  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B741  008620737061636500                 FCB  0, tknLINE, " space", 0
                      
                      
B74A                  tokas_sk2_spaceok                                                       ;LBB6B:
B74A  1F03                            TFR     D,U
B74C  3341                            LEAU    1,U
B74E  3001                            LEAX    1,X
B750                  tokas_lp4
B750  A682                            LDA     ,-X
B752  A7C2                            STA     ,-U
B754  9C3D                            CMPX    ZP_FPB + 2
B756  26F8                            BNE     tokas_lp4
                      
                      
B758  3001                            LEAX    1,X                                             ; move past 0d marker
B75A  DC2C                            LDD     ZP_INT_WA + 2                                   ; get decoded big endian line number
B75C  ED81                            STD     ,X++
B75E  D63F                            LDB     ZP_FPB + 4                                      ; line length
B760  E780                            STB     ,X+     
                      
B762  C004                            SUBB    #4                                              ; reduce line length counter by 4
B764  DE3B                            LDU     ZP_FPB
B766  A6C0            tokas_lp5       LDA     ,U+                                             ; copy from $700 to program memory
B768  A780                            STA     ,X+
B76A  5A                              DECB
B76B  26F9                            BNE     tokas_lp5
B76D                                  SEC
B76D  1A01                    ORCC    #CC_C
B76F  39                              RTS
                      ;               
B770  DC12            ResetVars       LDD ZP_TOP
B772  DD00                            STD ZP_LOMEM
B774  DD02                            STD ZP_VARTOP                                   ;  LOMEM=TOP, VARTOP=TOP
B776                                  CALL ResetStackProgStartRepeatGosubFor
B776                  9
B778                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B776  8D20                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ;                       ;  Reset DATA, REPEAT, FOR, GOSUB
                      ;                       ;  Clear dynamic variables
                      ;                       ;  -----------------------
B778                  InittblFPRtnAddr
B778  3440                            PSHS    U
B77A  8E0010                          LDX     #$10
B77D  EC89BA51        1               LDD     tblFPRtnAddr_const-2,X
B781  ED8907EE                        STD     $07F0-2,X                               ;  Copy entry addresses to $07F0-$07FF
B785  301E                            LEAX     -2, X
B787  26F4                            BNE     1B
B789  8640                            LDA     #$40
B78B  8E0000                          LDX     #0
B78E  CE0480                          LDU     #BASWKSP_DYNVAR_HEADS
B791  AFC1            1               STX     ,U++
B793  4A                              DECA    
B794  26FB                            BNE     1B                                      ;  Clear dynamic variables
B796  35C0                            PULS    U,PC
B798                  ResetStackProgStartRepeatGosubFor
B798  9618                            LDA     ZP_PAGE_H
B79A  5F                              CLRB
B79B  DD1C                            STD     ZP_READ_PTR                             ;  DATA pointer = PAGE
B79D  DC06                            LDD     ZP_HIMEM                                ;  STACKBOT=HIMEM
B79F  DD04                            STD     ZP_BAS_SP
B7A1  961F                            LDA     ZP_LISTO
B7A3  847F                            ANDA    #$7F
B7A5  971F                            STA     ZP_LISTO
B7A7  0F24                            CLR     ZP_REPEAT_LVL
B7A9  0F26                            CLR     ZP_FOR_LVL_X_15
B7AB  0F25                            CLR     ZP_GOSUB_LVL;                   ;  Clear REPEAT, FOR, GOSUB stacks
B7AD  39                              RTS                                     ;  DATA pointer = PAGE
                      ;               
                      ;               
B7AE                  popFPFromStackToPTR1                    ; pop FP from stack, set out old stack pointer in PTR1
B7AE  109E04                          LDY     ZP_BAS_SP
B7B1  109F4A                          STY     ZP_FP_TMP_PTR1
B7B4  3125                            LEAY    5,Y
B7B6  109F04                          STY     ZP_BAS_SP
B7B9  39                              RTS
                      
B7BA                  fpStackWAtoStackReal    
B7BA  C6FB                            LDB     #-5
B7BC                                  CALL    UpdStackByBCheckFull            ; make room for a float on the stack
B7BC                  9
B7BE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B7BC  BDB88F                                  JSR     \1
                              ENDIF
B7BF  9630                            LDA     ZP_FPA + 2
B7C1  A784                            STA     0,X
B7C3  962E                            LDA     ZP_FPA
B7C5  9831                            EORA    ZP_FPA + 3
B7C7  8480                            ANDA    #$80
B7C9  9831                            EORA    ZP_FPA + 3                      ; Get top bit of sign byte and seven other bits of mantissa MSB
B7CB  A701                            STA     1,X
                      
B7CD  DC32                            LDD     ZP_FPA + 4
B7CF  ED02                            STD     2,X
                      
B7D1  9634                            LDA     ZP_FPA + 6
B7D3  A704                            STA     4,X
B7D5  39                              RTS
B7D6                  stackVarTypeInFlags
B7D6  271C                            BEQ     StackString
B7D8  2BE0                            BMI     fpStackWAtoStackReal
B7DA                  stackINT_WAasINT                                ; LBC26
B7DA  C6FC                            LDB     #-4
B7DC                                  CALL    UpdStackByBCheckFull
B7DC                  9
B7DE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B7DC  BDB88F                                  JSR     \1
                              ENDIF
B7DF  DC2A                            LDD     ZP_INT_WA
B7E1  ED84                            STD     ,X
B7E3  DC2C                            LDD     ZP_INT_WA + 2
B7E5  ED02                            STD     2,X
B7E7  39                              RTS
B7E8                  pushVarPtrAndType                               ; was pullRETpushIntAtoIntAplus2pushRET
B7E8  3510                            PULS    X
B7EA  DC2C                            LDD     ZP_INT_WA + 2
B7EC  3406                            PSHS    D
B7EE  962A                            LDA     ZP_INT_WA + 0
B7F0  3402                            PSHS    A
B7F2  6E84                            JMP     0,X
                      
                      
                      ;               ;  Stack the current string
                      ;               ;  ========================
B7F4                  StackString
B7F4  3454                            PSHS    B,X,U
B7F6  D636                            LDB     ZP_STRBUFLEN                    ; Calculate new stack pointer address
B7F8  86FF                            LDA     #$FF
B7FA  53                              COMB                                    ; D now contains -(ZP_STRBUFLEN + 1)
B7FB  9E04                            LDX     ZP_BAS_SP
B7FD  308B                            LEAX    D,X
B7FF                                  CALL    UpdStackFromXCheckFull
B7FF                  9
B801                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B7FF  BDB894                                  JSR     \1
                              ENDIF
B802  D636                            LDB     ZP_STRBUFLEN                    ; store len as first byte of stacked data
B804  E780                            STB     ,X+
B806  270A                            BEQ     stackstrsk0
B808  CE0600                          LDU     #BAS_StrA                       ; followed by the string data
B80B  A6C0            stackstrlp0     LDA     ,U+
B80D  A780                            STA     ,X+
B80F  5A                              DECB
B810  26F9                            BNE     stackstrlp0
B812  35D4            stackstrsk0     PULS    B,X,U,PC
                      
                      ;       
                      ;               
B814                  delocaliseAtZP_GEN_PTR
B814  3440                            PSHS    U
B816  DE04                            LDU     ZP_BAS_SP
B818  9637                            LDA     ZP_NAMELENORVT                  ; get variable type
B81A  8180                            CMPA    #VAR_TYPE_STRING_STAT
B81C  2717                            BEQ     delocalizeStaticString          ; was a static string
B81E  2528                            BLO     delocalizeNum
                      
                                      ;delocalise Dynamic String
                      
B820  E6C0                            LDB     ,U+                             ; get stacked string length
B822  270D                            BEQ     2F
B824  9E39                            LDX     ZP_GEN_PTR + 2                  ; string params pointer
B826  E703                            STB     3,X
B828  AE84                            LDX     ,X                              ; string pointer
                      
B82A  A6C0            1               LDA     ,U+
B82C  A780                            STA     ,X+
B82E  5A                              DECB
B82F  26F9                            BNE     1B
B831                  2                                                       ; LBC8D:
B831                  delocExit
B831  DF04                            STU     ZP_BAS_SP
B833  35C0                            PULS    U,PC
                      
B835                  delocalizeStaticString                                  ; LBC95
B835  E6C0                            LDB     ,U+                             ; get stacked string length
B837  272A                            BEQ     2F
B839  9E39                            LDX     ZP_GEN_PTR + 2                  ; get address to restore string to 
B83B                  1                                                       ; LBC9C
B83B  A6C0                            LDA     ,U+
B83D  A780                            STA     ,X+
B83F  5A                              DECB
B840  26F9                            BNE     1B
B842  860D                            LDA     #$0D
B844  A780                            STA     ,X+
B846  20E9                            BRA     delocExit
B848                  delocalizeNum                                           ; LBCAA
B848  9E39                            LDX     ZP_GEN_PTR + 2
B84A  D637                            LDB     ZP_NAMELENORVT                  ; get var type
B84C  5A                              DECB
B84D  A6C0            1               LDA     ,U+                             ; for 0 (do 1 byte), for 4,5 do 4,5 bytes
B84F  A780                            STA     ,X+
B851  5A                              DECB
B852  2AF9                            BPL     1B
B854  20DB                            BRA     delocExit
                      
                                      ; new API - trashes A, X
B856                  popStackedStringNew                                     ; LBCD2
                      
B856  3440                            PSHS    U
B858  DE04                            LDU     ZP_BAS_SP
B85A  A6C0                            LDA     ,U+                             ; first byte contains length
B85C  9736                            STA     ZP_STRBUFLEN
B85E  27D1                            BEQ     delocExit
B860  8E0600                          LDX     #BASWKSP_STRING
B863  E6C0            2               LDB     ,U+
B865  E780                            STB     ,X+
B867  4A                              DECA
B868  26F9                            BNE     2B
B86A  20C5                            BRA     delocExit               
                      
                      
                                      ; New API - after call all regs preserved
B86C                  popIntANew
B86C  3446                            PSHS    D,U
B86E  DE04                            LDU     ZP_BAS_SP
B870  ECC1                            LDD     ,U++
B872  DD2A                            STD     ZP_INT_WA
B874  ECC1                            LDD     ,U++
B876  DD2C                            STD     ZP_INT_WA+2
B878  DF04                            STU     ZP_BAS_SP
B87A  35C6                            PULS    D,U,PC
B87C                  popIntAtZP_GEN_PTRNew                           ; LBD06
B87C  8E0037                          LDX #ZP_GEN_PTR                 ; TODO - WORK THIS LOT OUT!
                                      ; NOTE: trashes A,B
B87F                  popIntAtXNew                                    ; LBD08
B87F  3440                            PSHS    U
B881  DE04                            LDU     ZP_BAS_SP
B883  ECC1                            LDD     ,U++
B885  ED84                            STD     0,X
B887  ECC1                            LDD     ,U++
B889  ED02                            STD     2,X
B88B  DF04                            STU     ZP_BAS_SP
B88D  35C0                            PULS    U,PC
B88F                  UpdStackByBCheckFull
B88F  9E04                            LDX     ZP_BAS_SP
B891  1D                              SEX
B892  308B                            LEAX    D,X
B894                  UpdStackFromXCheckFull
B894  9C12                            CMPX    ZP_TOP
B896  2506                            BLO     brabrkNoRoom
B898  9F04                            STX     ZP_BAS_SP
B89A  39                              RTS
                      ;
B89B                  ResetVarsBrkNoRoom
B89B                                  CALL ResetVars
B89B                  9
B89D                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B89B  BDB770                                  JSR     \1
                              ENDIF
B89E                  brabrkNoRoom    JUMP brkNoRoom
B89E  7E907B                                  JMP     \1
                      ;
                      ;
                      ;
B8A1                  doListPrintTokenA                                       ; LBD37
B8A1  8180                            CMPA    #$80
B8A3  254A                            BLO     list_printA                             ; just a normal char print it and continue
B8A5  9737                            STA     ZP_GEN_PTR
B8A7  3450                            PSHS    X,U
B8A9  308DC8C7                        LEAX    tblTOKENS,PCR
                      
B8AD                  doListTryNextTok                                                ; LBD46
B8AD  3384                            LEAU    ,X                                      ; Y points to name of current token
B8AF                  doListSkipKey                                                   ;LBD48:
B8AF  A680                            LDA     ,X+                                     ; TODO probably can skip first and 2nd char every time?
B8B1  2AFC                            BPL     doListSkipKey                           ; not a token skip it
B8B3  9137                            CMPA    ZP_GEN_PTR
B8B5  2704                            BEQ     doListKeyLp                             ; it's the right token
B8B7  3001                            LEAX    1,X                                     ; skip flags
B8B9  20F2                            BRA     doListTryNextTok
B8BB                  doListKeyLp                                                     ;LBD60:
B8BB  A6C0                            LDA     ,U+
B8BD  2B04                            BMI     doListKeyFinished
B8BF                                  CALL    list_printA
B8BF                  9
B8C1                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B8BF  8D2E                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B8C1  20F8                            BRA     doListKeyLp
B8C3                  doListKeyFinished                                               ;LBD6A:
B8C3  35D0                            PULS    X,U,PC
                      
                      
B8C5                  list_printHexByte                                       ; LBD6C
B8C5  3402                            PSHS    A
B8C7  44                              LSRA
B8C8  44                              LSRA
B8C9  44                              LSRA
B8CA  44                              LSRA
B8CB                                  CALL    list_printHexNybble
B8CB                  9
B8CD                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B8CB  8D04                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B8CD  3502                            PULS    A
B8CF  840F                            ANDA    #$0F
B8D1                  list_printHexNybble                                     ; LBD77
B8D1  810A                            CMPA    #$0A
B8D3  2502                            BLO     list_printAasDigit
B8D5  8B07                            ADDA    #$07
B8D7                  list_printAasDigit                                      ; LBD7D
B8D7  8B30                            ADDA    #$30
B8D9                  list_printCheckPRLINCOUNT                               ; LBD7F
B8D9  3402                            PSHS    A
B8DB  9623                            LDA     ZP_WIDTH
B8DD  911E                            CMPA    ZP_PRLINCOUNT
B8DF  2403                            BCC     list_printCheckPRLINCOUNT_sk1
B8E1                                  CALL    PrintCRclearPRLINCOUNT
B8E1                  9
B8E3                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B8E1  BDB6BE                                  JSR     \1
                              ENDIF
B8E4                  list_printCheckPRLINCOUNT_sk1                           ; LBD89:
B8E4  3502                            PULS    A
B8E6  0C1E                            INC     ZP_PRLINCOUNT
B8E8  7EFFEE                          JMP     OSWRCH
B8EB                  list_printHexByteAndSpace                               ; LBD8F
B8EB                                  CALL list_printHexByte
B8EB                  9
B8ED                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B8EB  8DD8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B8ED                  list_print1Space                                        ; LBD92
B8ED  8620                            LDA     #$20
B8EF                  list_printA                                             ; LBD94
B8EF  0D1F                            TST     ZP_LISTO
B8F1  2B0A                            BMI     list_printToVARTOP
B8F3                  list_printANoEDIT                                       ; LBD98
B8F3  810D                            CMPA    #$0D
B8F5  26E2                            BNE     list_printCheckPRLINCOUNT
B8F7  BDFFEE                          JSR     OSWRCH
B8FA                                  JUMP    clearPRLINCOUNT
B8FA  7EB6C1                                  JMP     \1
B8FD                  list_printToVARTOP                                      ; LBDA2
B8FD  A79F0002                        STA     [ZP_VARTOP]                     ; store at VARTOP for EDIT
B901  0C02                            INC     ZP_VARTOP
B903  261D                            BNE     rtsLBDC5
B905  0C03                            INC     ZP_VARTOP + 1
B907  3402                            PSHS    A
B909  9603                            LDA     ZP_VARTOP + 1
B90B  9807                            EORA    ZP_HIMEM + 1
B90D  278C                            BEQ     ResetVarsBrkNoRoom              ; out of space for listing
B90F  3502                            PULS    A
B911  39                              RTS
B912                  doLISTOSpacesCLC                                        ; LBDB3
B912                                  CLC
B912  1CFE                    ANDCC   #~CC_C
B914                  doLISTOSpaces                                           ; LBDB4
B914  941F                            ANDA    ZP_LISTO
B916  270A                            BEQ     rtsLBDC5
B918  59                              ROLB
B919  2507                            BCS     rtsLBDC5        
B91B  2705                            BEQ     rtsLBDC5
B91D                  list_printBSpaces                       ;LBDBF:
B91D                                  CALL    list_print1Space
B91D                  9
B91F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B91D  8DCE                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B91F  5A                              DECB
B920  26FB                            BNE     list_printBSpaces
B922                  rtsLBDC5
B922  39                              RTS
                      ;               
                      ;               
B923                  CopyIntWA2X                                ; DB: Changed this to use 16 bit reg and X can point anywhere!
B923  3406                            PSHS    D
B925  DC2A                            LDD     ZP_INT_WA + 0
B927  ED84                            STD     ,X
B929  DC2C                            LDD     ZP_INT_WA + 2
B92B  ED02                            STD     2,X
B92D  3506                            PULS    D
B92F  39                              RTS
                      
                              IF FLEX
                      brkBadFileName  DO_BRK_B
                                      FCB     100                             ; TODOFLEX - made up error number
                                      FCB     "Bad filename", 0
                      
                      
                      FMS_ERR         LDA     FCBOFFS_ERR,X
                                      PSHS    A
                                      LDA     #FMS_CLOSE
                                      STA     ,X
                                      JSR     FMS
                                      PULS    B
                                      ORB     #$40                                    ; TODOFLEX - arbitrary number here!
                                      JMP     FLEXERROR
                              ENDIF
                      
                      
                      ;               
                      ;                       ;  Load program to PAGE
                      ;                       ;  --------------------
B930                  loadProg2Page
                              IF FLEX = 1
                                      CALL    evalYExpectString
                                      LDB     ZP_STRBUFLEN
                                      BEQ     brkBadFileName
                                      BMI     brkBadFileName
                                      ; copy filename to LINBUF
                                      LDU     #BASWKSP_STRING
                                      LDX     #LINBUF
                                      STX     CBUFPT
                      1               LDA     ,U+
                                      STA     ,X+
                                      DECB
                                      BNE     1B
                                      LDA     #$D
                                      STA     ,X+
                                      LDX     #SYSFCB
                                      JSR     GETFIL
                                      BCS     brkBadFileName
                                      LDA     #SETEXT_BAS
                                      JSR     SETEXT
                                      LDA     #FMS_OPENRD
                                      STA     ,X
                                      JSR     FMS
                                      BNE     FMS_ERR
                                      LDA     #$FF
                                      STA     FCBOFFS_COMPRESS,X                      ; BINary file
                                      LDA     ZP_PAGE_H
                                      CLRB
                                      TFR     D,U
                                      LDA     #FMS_RDWR
                                      STA     ,X
                      1               JSR     FMS
                                      BNE     FMS_CK_EOF
                                      STA     ,U+
                                      CMPU    ZP_HIMEM
                                      BLO     1B
                                      BRA     1F
                      FMS_CK_EOF      LDA     FCBOFFS_ERR,X                           ; Get error number
                                      CMPA    #FMS_ERR_EOF
                                      BNE     FMS_ERR
                      1               LDA     #FMS_CLOSE
                                      STA     ,X
                                      JSR     FMS
                              ELSE
B930                                  CALL    GetFileNamePageAndHighOrderAddr ; get cr-string, FILE_NAME=STRA, FILE_LOAD=PAGE/memhigh
B930                  9
B932                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B930  8D6B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ; Returns FILE_NAME=>string
                      ;         FILE_EXEC=&00000000
                      ;         X=machine high address
                      ;         D=page
                      ;         Cy=big/little
                      ;
B932  CE0039                          LDU     #ZP_GEN_PTR+2
B935                                  CALL    StoreFileAddress                ; Store PAGE at ctrl+2/3/4/5
B935                  9
B937                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B935  8D78                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B937  86FF                            LDA     #OSFILE_LOAD
B939  8E0037                          LDX     #ZP_GEN_PTR                     ;  Point to OSFILE block
B93C  BDFFDD                          JSR     OSFILE                          ;  Continue into FindTOP
                              ENDIF
B93F  9618            findTOP         LDA     ZP_PAGE_H
B941  5F                              CLRB
B942  1F01                            TFR     D,X
B944  DD12                            STD     ZP_TOP  
B946  E684            ftop_lp1        LDB     ,X
B948  C10D                            CMPB    #$0D
B94A  2616                            BNE     printBadProgram                 ; check for CR
B94C  E601                            LDB     1,X                             ; check for -ve line number (end of program)
B94E  2B0D                            BMI     ftop_sk1
B950  E603                            LDB     3,X                             ; check line length and add for next line
B952  270E                            BEQ     printBadProgram
B954  4F                              CLRA
B955  D312                            ADDD    ZP_TOP
B957  DD12                            STD     ZP_TOP
B959  1F01                            TFR     D, X
B95B  20E9                            BRA     ftop_lp1
B95D                  ftop_sk1        
B95D  3002                            LEAX    2,X
B95F  9F12                            STX     ZP_TOP
B961  39                              RTS
B962                  printBadProgram
B962  308C06                          LEAX    str_bad_prog,PCR
B965  BDFF9B                          JSR     PRSTRING
B968                                  JUMP    immedPrompt
B968  7E8F6F                                  JMP     \1
                      
B96B  0D4261642070726F6772616D0D00 str_bad_prog    FCN     "\rBad program\r"
                      
                      ;               
B979  8E0600          str600CRterm    LDX     #BAS_StrA
B97C  D636            1               LDB     ZP_STRBUFLEN                    ;  Get length of string in buffer
B97E  860D                            LDA     #$0D
B980  3410                            PSHS    X
B982  3A                              ABX
B983  A784                            STA     ,X
B985  3590                            PULS    X,PC                            ;  Store <cr> at end of string
                      
B987                  evalYExpectString                                       ; LBE36
B987                                  CALL    evalExpressionMAIN              ;  Call expression evaluator
B987                  9
B989                  __XBSR                  SET 9B+2
E000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B987  BD9A41                                  JSR     \1
                              ENDIF
B98A  4D                              TSTA
B98B  1026D6DC                        LBNE    brkTypeMismatch                 
B98F                                  CALL    str600CRterm                    ; put terminating <cr> in
B98F                  9
B991                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B98F  8DE8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B991  9F37                            STX     ZP_SAVE_BUF                     ; Point 37/8 to STRA, TODO: check needed!
B993  A6C4                            LDA     ,U
B995                                  JUMP    scanNextExpectColonElseCR
B995  7E98F7                                  JMP     \1
                      
                              IF FLEX != 1
B998  8682            OSByte82        LDA     #$82
B99A  7EFFF4                          JMP     OSBYTE
B99D                  GetFileNamePageAndHighOrderAddr                         ; LBE41
B99D                                  CALL    evalYExpectString               ; Get CR-string
B99D                  9
B99F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B99D  8DE8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B99F                                  CALL    OSByte82
B99F                  9
B9A1                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B99F  8DF7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B9A1  4F                              CLRA
B9A2  5F                              CLRB
B9A3  DD3D                            STD     ZP_GEN_PTR+6                    ; exec=0 regardless of endianness
B9A5  DD3F                            STD     ZP_GEN_PTR+8
B9A7  9654                            LDA     ZP_BIGEND
B9A9  48                              ASLA                                    ; Cy=big/little
B9AA  9618                            LDA     ZP_PAGE_H                       ; D=PAGE
B9AC  39                              RTS
B9AD                  StoreFileAddressNext
B9AD  3344                            LEAU    4,U                             ; Point to next address
B9AF                  StoreFileAddress
B9AF  3410                            PSHS    X
B9B1  2404                            BCC     StoreFileBigAddr
B9B3  1E89                            EXG     A,B                             ; Swap to make little-endian
B9B5  1E10                            EXG     X,D
B9B7                  StoreFileBigAddr
B9B7  AFC4                            STX     0,U
B9B9  ED42                            STD     2,U
B9BB  3590                            PULS    X,PC
                              ENDIF
                      
B9BD                  cmdSAVE                                                 ; LBE55
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
B9BD  3440                            PSHS    U
B9BF                                  CALL    findTOP
B9BF                  9
B9C1                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B9BF  BDB93F                                  JSR     \1
                              ENDIF
B9C2                                  CALL    GetFileNamePageAndHighOrderAddr         
B9C2                  9
B9C4                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B9C2  8DD9                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ; Returns FILE_NAME=>string
                      ;         FILE_EXEC=&00000000
                      ;         X=machine high address
                      ;         D=page
                      ;         Cy=big/little
                      ;
B9C4  CE0041                          LDU     #ZP_SAVE_BUF+10
B9C7                                  CALL    StoreFileAddress                ; FILE_START=PAGE
B9C7                  9
B9C9                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B9C7  8DE6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B9C9  DC12                            LDD     ZP_TOP
B9CB                                  CALL    StoreFileAddressNext            ; FILE_END=TOP
B9CB                  9
B9CD                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B9CB  8DE0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B9CD  CE0039                          LDU     #ZP_SAVE_BUF+2
B9D0  8EFFFF                          LDX     #$FFFF
B9D3  CCFB00                          LDD     #$FB00
B9D6                                  CALL    StoreFileAddress                ; FILE_LOAD=FFFFFB00 = filetyped to BASIC
B9D6                  9
B9D8                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B9D6  8DD7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      
                      ;+;             LDX     #ZP_SAVE_BUF+5                  ; Implement this bit later
                      ;+;             LDA     #3
                      ;+;             STX     0,X
                      ;+;             LDA     #14
                      ;+;             CALL    varGetTime2                     ; Read RTC datestamp to FILE_EXEC
                      
B9D8  8600                            LDA     #OSFILE_SAVE                    ; OSFILE 0
B9DA  8E0037                          LDX     #ZP_SAVE_BUF
B9DD  BDFFDD                          JSR     OSFILE
B9E0  3540                            PULS    U
B9E2                                  JUMP    continue
B9E2  7E8FE2                                  JMP     \1
                              ENDIF
B9E5                  cmdOSCLI
B9E5                                  CALL    evalYExpectString
B9E5                  9
B9E7                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B9E5  8DA0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B9E7  8E0600                          LDX     #BASWKSP_STRING
B9EA  3440                            PSHS    U
B9EC  BDFFF7                          JSR     OSCLI
B9EF  3540                            PULS    U
B9F1                                  JUMP    continue
B9F1  7E8FE2                                  JMP     \1
                      
                                              ; EXT#channel=number
                                              ; ------------------
B9F4                  cmdEXTEq                                        ; LBE93
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
B9F4  8603                            LDA     #$03                    ; 03=Set extent
B9F6  2002                            BRA     varSetFInfo
                              ENDIF
                      
                                              ; PTR#channel=number
                                              ; ------------------
B9F8                  varSetPTR                                       ; LBE97
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
B9F8  8601                            LDA     #$01                    ; 01=Set pointer
B9FA                  varSetFInfo                                     ; LBE99
B9FA  3402                            PSHS    A
B9FC                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
B9FC                  9
B9FE                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B9FC  BDB684                                  JSR     \1
                              ENDIF
B9FF                                  CALL    skipSpacesExpectEqEvalExp
B9FF                  9
BA01                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B9FF  BD98A6                                  JSR     \1
                              ENDIF
BA02                                  CALL    checkTypeInZP_VARTYPEConvert2INT
BA02                  9
BA04                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA02  BD94ED                                  JSR     \1
                              ENDIF
BA05  0D54                            TST     ZP_BIGEND
BA07  2B03                            BMI     1F
BA09                                  CALL    SwapEndian              ; Swap INTA
BA09                  9
BA0B                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA09  BDAB14                                  JSR     \1
                              ENDIF
BA0C  DF0B            1               STU     ZP_TXTPTR               ; Save TXTPTR
BA0E  8E002A                          LDX     #ZP_INT_WA
BA11  3502                            PULS    A                       ; Get action and channel
BA13  BDFFDA                          JSR     OSARGS                  ; Write from INTA
BA16  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
BA18                                  JUMP    continue                ; Return to main execution loop
BA18  7E8FE2                                  JMP     \1
                              ENDIF
                                              ; CLOSE#channel
                                              ; -------------
BA1B                  cmdCLOSE                                        ; LBEAE
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BA1B                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
BA1B                  9
BA1D                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA1B  BDB684                                  JSR     \1
                              ENDIF
BA1E  4F                              CLRA                            ; A=$00 for CLOSE
BA1F  BDFFCE                          JSR     OSFIND
BA22                                  JUMP    continue                ; Return to main execution loop
BA22  7E8FE2                                  JMP     \1
                              ENDIF
                                              ; BPUT#channel,number
                                              ; -------------------
BA25                  cmdBPUT                                         ; LBEBD
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BA25                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
BA25                  9
BA27                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA25  BDB684                                  JSR     \1
                              ENDIF
BA28                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
BA28                  9
BA2A                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA28  BD94DD                                  JSR     \1
                              ENDIF
BA2B  962D                            LDA     ZP_INT_WA+3             ; Get low byte of number
BA2D  BDFFD4                          JSR     OSBPUT                  ; Write to channel
BA30  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
BA32                                  JUMP    continue                ; Return to main execution loop
BA32  7E8FE2                                  JMP     \1
                              ENDIF
                      
                      
                      ;;callOSWORD5INT_WA                             ; get a byte from host processor
                      ;;; not actually needed, 6809 BBC API defined to pass X=>command line on entry
                      ;;              TODODEADEND "callOSWORD5INT_WA - endianness, sort out"
                      ;;              LDA     #$05
                      ;;              PSHU    X
                      ;;              LDX     #ZP_INT_WA
                      ;;              LDU     #0                      ; DP
                      ;;              JSR     OSWORD
                      ;;              PULU    X
                      ;;              LDA     ZP_INT_WA + 4           ; return value in A
BA35  0C2D            inc_INT_WA      INC     ZP_INT_WA + 3           ; increment - note big endianness
BA37  260A                            BNE     1F
BA39  0C2C                            INC     ZP_INT_WA + 2
BA3B  2606                            BNE     1F
BA3D  0C2B                            INC     ZP_INT_WA + 1
BA3F  2602                            BNE     1F
BA41  0C2A                            INC     ZP_INT_WA + 0
BA43  39              1               RTS
                      
                      
BA44                  deleteProgSetTOP
BA44  9618                            LDA     ZP_PAGE_H
BA46  5F                              CLRB
BA47  0F20                            CLR     ZP_TRACE
BA49  1F01                            TFR     D, X
BA4B  CC0DFF                          LDD     #$0DFF                  ; 0 length program
BA4E  ED81                            STD     ,X++                    ; store at page
BA50  9F12                            STX     ZP_TOP
BA52  39                              RTS
                      
                      ;                       ;  Floating-Point Routine Entries
                      ;                       ;  ==============================
                      ;                       ;  Copied to $07F0-$07FF
                      ;                       ;
                      ;               .segment "BF14"
                      ;               .org    $BF14
BA53                  tblFPRtnAddr_const
BA53  A482                            FDB     fpFPAeq_sqr_FPA         ;  FloatA = SQR(FloatA)
BA55  A2A5                            FDB     fpFPAeqPTR1divFPA       ;  FloatA = ArgP / FloatA
BA57  A35C                            FDB     fpFPAeqPTR1mulFPA       ;  FloatA = ArpP * FloatA
BA59  A343                            FDB     fpFPAeqPTR1addFPA       ;  FloatA = ArgP + FloatA
BA5B  A986                            FDB     fpNegateFP_A            ;  FloatA = -FloatA
BA5D  A213                            FDB     fpCopyPTR1toFPA         ;  FloatA = (ArgP)
BA5F  A1F1                            FDB     fpCopyFPA_PTR1          ;  (ArgP) = FloatA
BA61  4A                              FCB     ZP_FP_TMP_PTR1          ;  Zero page address of ArgP
BA62  2E                              FCB     ZP_FPA          ;  Zero page address of FloatA
                      ;FPCONST:
BA63  81C9100000      fpConstMinPiDiv2        FCB     $81, $C9, $10, $00, $00 ; -PI/2
BA68  6F15777A61      fpConst4_454e_6         FCB     $6F, $15, $77, $7A, $61 ; 4.4544551105e-06
BA6D  81490FDAA2      fpConstPiDiv2           FCB     $81, $49, $0F, $DA, $A2 ; PI/2
BA72  8022F9836E      fpConst2DivPi           FCB     $80, $22, $F9, $83, $6E ; 2/PI = 0.6366
BA77  7B0EFA3512      fpConstDeg2Rad          FCB     $7B, $0E, $FA, $35, $12 ;  1.74E-2 - 1 deg in rads
BA7C  86652EE0D3      fpConstRad2Deg          FCB     $86, $65, $2E, $E0, $D3 ;  57.29 - 1 rad in degrees
BA81  7F5E5BD8AA      fpConst0_43429          FCB     $7F, $5E, $5B, $D8, $AA ;  4.3429448199e-01
BA86  822DF85458      fpConst_e               FCB     $82, $2D, $F8, $54, $58 ;  e = 2.7182818279e+00
BA8B  80317217F8      fpConst_ln_2            FCB     $80, $31, $72, $17, $F8 ;  ln(2) = 6.9314718130e-01
BA90  800BD75029      fpConst0_54625          FCB     $80, $0B, $D7, $50, $29 ;  5.4625416757e-01
BA95  7CD27C8605                              FCB     $7C, $D2, $7C, $86, $05 ;  -5.1388286127e-02
BA9A  801552B636                              FCB     $80, $15, $52, $B6, $36 ;  5.8329333132e-01 ;  $BF60
BA9F  7C99983604                              FCB     $7C, $99, $98, $36, $04 ;  -3.7498675345e-02
BAA4  8040000110                              FCB     $80, $40, $00, $01, $10 ;   3/4  (7.5000006333e-01)
BAA9  7F2AAAAAE3                              FCB     $7F, $2A, $AA, $AA, $E3 ;   1/3  (3.3333333989e-01)
BAAE  7FFFFFFFFF      fpConstMin0_5           FCB     $7F, $FF, $FF, $FF, $FF ;  -1/2
BAB3  7AC31E18BE      fpConstMin0_011909      FCB     $7A, $C3, $1E, $18, $BE ; -1.1909031069e-02 ; Used in SIN/COS
BAB8  736171552D                              FCB     $73, $61, $71, $55, $2D ;  1.074994592E-4
BABD  7B8C9B9188                              FCB     $7B, $8C, $9B, $91, $88 ; -1.716402458E-2
BAC2  772BA4C453                              FCB     $77, $2B, $A4, $C4, $53 ;  1.309536901e-3
BAC7  7C4CCCCAB7                              FCB     $7C, $4C, $CC, $CA, $B7 ;  4.999999223e-2
BACC  7EAAAAAAA6                              FCB     $7E, $AA, $AA, $AA, $A6 ; -0.1666666664
BAD1  8100000000      fpConst1                FCB     $81, $00, $00, $00, $00 ; 1
BAD6  7DA3F2EF44      fpConstMin0_08005       FCB     $7D, $A3, $F2, $EF, $44 ;  -8.0053204787e-02
BADB  7E1F01A14D                              FCB     $7E, $1F, $01, $A1, $4D ; 0.155279656
BAE0  7F616DF43F                              FCB     $7F, $61, $6D, $F4, $3F ; 0.440292008
BAE5  7E5C9123AC                              FCB     $7E, $5C, $91, $23, $AC ; 0.215397413
BAEA  7E76B88D1A                              FCB     $7E, $76, $B8, $8D, $1A ; 0.240938382
                      ;                       ;  $BFB0
BAEF  7D1D3EAB2C                              FCB     $7D, $1D, $3E, $AB, $2C ; 7.67796872e-02
BAF4  81094181D2                              FCB     $81, $09, $41, $81, $D2 ; 1.07231162
BAF9  8074DFBD20                              FCB     $80, $74, $DF, $BD, $20 ; 0.956538983
BAFE  80838B1FB5                              FCB     $80, $83, $8B, $1F, $B5 ; -0.513841612
BB03  7F8259ADAB                              FCB     $7F, $82, $59, $AD, $AB ; -0.254590442
BB08  806D63382C      fpConst0_9273           FCB     $80, $6D, $63, $38, $2C ;  9.2729521822e-01
BB0D  7D11D4B1D1      fpConst0_07121          FCB     $7D, $11, $D4, $B1, $D1 ;  7.1206463996e-02
BB12  7968BC4F59                              FCB     $79, $68, $BC, $4F, $59 ; 7.10252642e-03
BB17  75052C9E39                              FCB     $75, $05, $2C, $9E, $39 ; 2.54009799e-04
BB1C  7B08883BA6                              FCB     $7B, $08, $88, $3B, $A6 ; 1.66665235e-02
BB21  6C31CFD18C                              FCB     $6C, $31, $CF, $D1, $8C ;  6.6240054064e-07
BB26  7D2AAAAA89                              FCB     $7D, $2A, $AA, $AA, $89 ;   8.33
BB2B  7FFFFFFFE8                              FCB     $7F, $FF, $FF, $FF, $E8 ;  -0.5
BB30  8100000000                              FCB     $81, $00, $00, $00, $00 ;   1.0
BB35  8100000000      fpConst1__2             FCB     $81, $00, $00, $00, $00 ;   1.0
                      
BB3A                  __CODE_END
                      
04C6                  __FREESPACE     EQU $C000-__CODE_END
                      
