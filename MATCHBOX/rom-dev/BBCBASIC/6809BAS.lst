                      ;                       (c) Dominic Beesley 2017 - translated BAS4816 - forked from BAS432JGH to 6809
                      ;                       ;  > Basic4/src
                      ;                       ;  Source code for 6502 BBC BASIC IV for the BBC
                      ;                       
                      ;                       ; ZP pointers are all in big endian
                      ;                       ; INTs in ZP_WA are in big endian
                      ;                       ; when address of variables and type are in ZP_WA then pointer is at +2, type at + 0
                      ;                       ; when line numbers in ZP_WA then stored at WA+2
                      ;
                      ;
                      
0433                  VERSION                 EQU $0433       ; Version 4.33
                      VERSIONSTR      MACRO
                                              FCB     "2022 Dossy",0
                                      ENDM
                      
                                              INCLUDE         "../../includes/common.inc"
                                      ; processor flags
0001                  CC_C            EQU     $01
0002                  CC_V            EQU     $02
0004                  CC_Z            EQU     $04
0008                  CC_N            EQU     $08
0010                  CC_I            EQU     $10
0020                  CC_H            EQU     $20
0040                  CC_F            EQU     $40
0080                  CC_E            EQU     $80
                      
                      m_tax           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    X
                                      ENDM
                      
                      m_tax_se        MACRO
                                      jsr     _m_tax_se
                                      ENDM
                      
                      
                      m_tay           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      m_tay_c         MACRO
                                      pshs    A
                                      lda     #0
                                      sta     ,-S
                                      lda     1,S
                                      puls    Y
                                      ENDM
                      
                      
                      m_tbx           MACRO
                                      pshs    B                       ;6
                                      clr     ,-S                     ;8
                                      puls    X                       ;7 = 21
                                      ENDM
                      
                      m_tby           MACRO
                                      pshs    B
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      
                      m_txa           MACRO
                                      pshs    X
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_tya           MACRO
                                      pshs    Y
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_txb           MACRO
                                      pshs    X
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      m_tyb           MACRO
                                      pshs    Y
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      
                      
0002                  BRKSIZE         EQU     2
                      
                      
                      DEBUG_INST      MACRO
                                      SWI
                                      ENDM
                      
                      BRK     MACRO
                              swi3
                              ENDM
                      
                      DO_BRK  MACRO
                              BRK
                              FCB     \1
                              FCB     \2,0
                              ENDM
                      
                      
                      CLI     MACRO
                              ANDCC   #~(CC_I)
                              ENDM
                      
                      SEI     MACRO
                              ORCC    #CC_I
                              ENDM
                      
                      CLC     MACRO
                              ANDCC   #~CC_C
                              ENDM
                      
                      SEC     MACRO
                              ORCC    #CC_C
                              ENDM
                      
                      CLV     MACRO
                              ANDCC   #~CC_V
                              ENDM
                      
                      SEV     MACRO
                              ORCC    #CC_V
                              ENDM
                      
                      CLZ     MACRO
                              ANDCC   #~CC_Z
                              ENDM
                      
                      SEZ     MACRO
                              ORCC    #CC_Z
                              ENDM
                      
                      
                      STX_B   MACRO
                              PSHS    D
                              TFR     X,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      
                      STY_B   MACRO
                              PSHS    D
                              TFR     Y,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      LDX_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,X
                              PULS    D
                              ENDM
                      
                      LDY_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,Y
                              PULS    D
                              ENDM
                      
                      OSCALL  MACRO
                              JSR     \1
                              ENDM
                      
                      OSJMP   MACRO
                              JMP     \1
                              ENDM
                      
                              IF      FLEX=1
                                              INCLUDE         "../../includes/flex/flexlib.inc"
                              ELSE
                                              INCLUDE         "../../includes/mosrom.inc"
0063                  mos_MACHINE_TYPE_BYTE                   EQU $63
                      
                      * Address of MOS ROM base
C000                  MOSROMBASE                              EQU $C000
F500                  MOSSTRINGS                              EQU $F500
                      
                      * default direct page for MOS ROM
0000                  MOSROMSYS_DP                            EQU $0
                      
                      * OSENTRIESLOC - this is the area that contains the OS call JSRs
                      * to mimic the published BBC MOS API
FFB6                  OSENTRIESLOC                            EQU $FFB6
                      
FF98                  JGH_OSENTRIESLOC                        EQU OSENTRIESLOC-3*10
                      
FF8C                  DOM_DEBUG_ENTRIES                       EQU JGH_OSENTRIESLOC-3*4
                      
                      * BOUNCELOC - an area of "bounces" where the indirected jumps and
                      * jsrs are stored - these need an extra instruction byte to 6502
                      * so must indirect through here
FF6C                  BOUNCELOC                               EQU JGH_OSENTRIESLOC-4*11
                      
                      
                      
0003                  FSCV_CODE_OSCLI_UK                      EQU $03
                      
                      
0000                  zp_lang                                 EQU $0000
0090                  zp_eco                                  EQU $0090
00A0                  zp_nmi                                  EQU $00A0
00A9                  L00A9                                   EQU $00A9
00B0                  zp_fs_s                                 EQU $00B0
00C0                  zp_fs_w                                 EQU $00C0
00D0                  zp_vdu_status                           EQU $00D0       ; VDU Status as read by OSBYTE &75
00D1                  zp_vdu_grpixmask                        EQU $00D1       ; Graphics pixel mask
00D2                  zp_vdu_txtcolourOR                      EQU $00D2       ; Text colour OR mask
00D3                  zp_vdu_txtcolourEOR                     EQU $00D3       ; Text colour EOR mask
00D4                  zp_vdu_gracolourOR                      EQU $00D4       ; Graphics colour OR mask
00D5                  zp_vdu_gracolourEOR                     EQU $00D5       ; Graphics colour EOR mask
00D6                  zp_vdu_gra_char_cell                    EQU $00D6       ; Graphics character cell
00D8                  zp_vdu_top_scanline                     EQU $00D8       ; Top scan line
00DA                  zp_vdu_wksp                             EQU $00DA       ; Temporary workspace
                      ;;;;removed !zp_rom_mul                 EQU $00E0       ; BBC, Electron: Row multiplication
00E2                  zp_cfs_w                                EQU $00E2
00E3                  zp_opt_val                              EQU $00E3       ; DB? check
00E4                  zp_mos_GSREAD_quoteflag                 EQU $00E4       ; GSREAD quote flag
00E5                  zp_mos_GSREAD_characc                   EQU $00E5       ; GSREAD character accumulator
00E6                  zp_mos_OS_wksp                          EQU $00E6       ; General OS workspace
00E7                  zp_mos_autorep_countdown                EQU $00E7       ; Auto repeat countdown timer
00E8                  zp_mos_input_buf                        EQU $00E8       ; Input buffer pointer for OSWORD 0
00EA                  zp_mos_rs423timeout                     EQU $00EA       ; RS423 timeout counter, unused if no RS423
00EB                  zp_mos_cfs_critical                     EQU $00EB       ; CFS/RFS 'critical' flag
00EC                  zp_mos_keynumlast                       EQU $00EC       ; Internal key number (last)
00ED                  zp_mos_keynumfirst                      EQU $00ED       ; Internal key number (first)
00EE                  zp_mos_jimdevsave                       EQU $00EE       ; Internal key number of character to be ignored by OSBYTE &79, also the 1MHz bus paging register
00EF                  zp_mos_OSBW_A                           EQU $00EF       ; OSBYTE/OSWORD A reg value
                              ***** NOTE: zp_mos_OSBW_Y&X swapped for endiannedss
00F0                  zp_mos_OSWORD_X                         EQU $00F0
00F0                  zp_mos_OSBW_Y                           EQU $00F0       ; OSBYTE/OSWORD Y reg value
00F1                  zp_mos_OSBW_X                           EQU $00F1       ; OSBYTE/OSWORD X reg value
                      
00F2                  zp_mos_txtptr                           EQU $00F2       ; OS Text pointer (eg star commands and filenames)
00F4                  zp_mos_curROM                           EQU $00F4       ; Currently selected ROM
00F5                  zp_mos_curPHROM                         EQU $00F5       ; Current PHROM or RFS ROM number or OSRDSC/OSWRSC number
00F6                  zp_mos_genPTR                           EQU $00F6       ; PHROM/RFSROM/OSRDSC/OSWRSC pointer
00F8                  zp_mos_X                                EQU $00F8       ; BBC, Electron: Unused, Master: Soft key expansion pointer
00FA                  zp_mos_OS_wksp2                         EQU $00FA       ; General OS workspace, used by buffer access code in interrupts
00FC                  zp_mos_INT_A                            EQU $00FC       ; Interrupt Temp A reg store
00FD                  zp_mos_error_ptr                        EQU $00FD       ; Error message pointer, initially set to language version string
00FF                  zp_mos_ESC_flag                         EQU $00FF       ; Escape flag (bit 7)
                      
0100                  stack                                   EQU $0100
0200                  STACKTOP                                EQU $0200
                      
0236                  sysvar_OSVARADDR                        EQU $0236       ; fx166/7 &A6/7 Address of OS variables
0238                  sysvar_ROMPTRTAB                        EQU $0238       ; fx168/9 &A8/9 Address of ROM pointer table
023A                  sysvar_ROMINFOTAB                       EQU $023A       ; fx170/1 &AA/B Address of ROM info table
023C                  sysvar_KEYB_ADDRTRANS                   EQU $023C       ; fx172/3 &AC/D Address of key translation table
023E                  sysvar_ADDRVDUVARS                      EQU $023E       ; fx174/5 &AE/F Address of VDU variables
0240                  sysvar_CFSTOCTR                         EQU $0240       ; fx176   &B0   CFS timeout counter, decremented every frame flyback
0241                  sysvar_CURINSTREAM                      EQU $0241       ; fx177   &B1   Currently selected input stream set with FX2
0242                  sysvar_KEYB_SEMAPHORE                   EQU $0242       ; fx178   &B2   BBC, Master: Keyboard semaphore
0243                  sysvar_PRI_OSHWM                        EQU $0243       ; fx179   &B3   Primary OSHWM
0244                  sysvar_CUR_OSHWM                        EQU $0244       ; fx180   &B4   Current OSHWM
0245                  sysvar_RS423_MODE                       EQU $0245       ; fx181   &B5   RS423 mode
0246                  sysvar_EXPLODESTATUS                    EQU $0246       ; fx182   &B6   BBC, Electron: Character definition explosion status
0247                  sysvar_CFSRFS_SWITCH                    EQU $0247       ; fx183   &B7   CFS/RFS switch
0248                  sysvar_VIDPROC_CTL_COPY                 EQU $0248       ; fx184   &B8   BBC, Master: RAM copy of VIDPROC control register
0249                  sysvar_VIDPROC_PAL_COPY                 EQU $0249       ; fx185   &B9   BBC, Master: RAM copy of VIDPROC palette register
024A                  sysvar_ROMNO_ATBREAK                    EQU $024A       ; fx186   &BA   ROM active last BRK
024B                  sysvar_ROMNO_BASIC                      EQU $024B       ; fx187   &BB   BASIC ROM number
024C                  sysvar_ADC_CUR                          EQU $024C       ; fx188   &BC   Current ADC Channel
024D                  sysvar_ADC_MAX                          EQU $024D       ; fx189   &BD   Maximum ADC Channel number
024E                  sysvar_ADC_ACCURACY                     EQU $024E       ; fx190   &BE   ADC conversion type/accuracy
024F                  sysvar_RS423_USEFLAG                    EQU $024F       ; fx191   &BF   RS423 use flag
0250                  sysvar_RS423_CTL_COPY                   EQU $0250       ; fx192   &C0   RAM copy of RS423 control register
0251                  sysvar_FLASH_CTDOWN                     EQU $0251       ; fx193   &C1   Flashing colour countdown timer
0252                  sysvar_FLASH_SPACE_PERIOD               EQU $0252       ; fx194   &C2   Flashing colour space period count set by FX9
0253                  sysvar_FLASH_MARK_PERIOD                EQU $0253       ; fx195   &C3   Flashing colour mark period count set by FX10
0254                  sysvar_KEYB_AUTOREP_DELAY               EQU $0254       ; fx196   &C4   Keyboard auto-repeat delay set by FX11
0255                  sysvar_KEYB_AUTOREP_PERIOD              EQU $0255       ; fx197   &C5   Keyboard auto-repeat period set by FX12
0256                  sysvar_EXEC_FILE                        EQU $0256       ; fx198   &C6   *EXEC file
0257                  sysvar_SPOOL_FILE                       EQU $0257       ; fx199   &C7   *SPOOL file handle
0258                  sysvar_BREAK_EFFECT                     EQU $0258       ; fx200   &C8   ESCAPE, BREAK effect
0259                  sysvar_KEYB_DISABLE                     EQU $0259       ; fx201   &C9   Keyboard disable
025A                  sysvar_KEYB_STATUS                      EQU $025A       ; fx202   &CA   Keyboard status byte
                                                                              ;Bit 7  =1 shift enabled   
                                                                              ;Bit 6  =1 control pressed 
                                                                              ;bit 5  =0 shift lock      
                                                                              ;Bit 4  =0 Caps lock       
                                                                              ;Bit 3  =1 shift pressed   
                      
025B                  sysvar_RS423_BUF_EXT                    EQU $025B       ; fx203   &CB   BBC, Master: Serial input buffer extent
025C                  sysvar_RS423_SUPPRESS                   EQU $025C       ; fx204   &CC   BBC, Master: Serial input supression flag
025D                  sysvar_RS423CASS_SELECT                 EQU $025D       ; fx205   &CD   BBC, Master: Serial/cassette selection flag
025E                  sysvar_ECO_OSBW_INTERCEPT               EQU $025E       ; fx206   &CE   Econet OSBYTE/OSWORD intercept flag
025F                  sysvar_ECO_OSRDCH_INTERCEPT             EQU $025F       ; fx207   &CF   Econet OSRDCH intercept flag
0260                  sysvar_ECO_OSWRCH_INTERCEPT             EQU $0260       ; fx208   &D0   Econet OSWRCH intercept flag
0261                  sysvar_SPEECH_SUPPRESS                  EQU $0261       ; fx209   &D1   Speech suppression status
0262                  sysvar_SOUND_SUPPRESS                   EQU $0262       ; fx210   &D2   Sound suppression status
0263                  sysvar_BELL_CH                          EQU $0263       ; fx211   &D3   BELL channel number
0264                  sysvar_BELL_ENV                         EQU $0264       ; fx212   &D4   BELL envelope number/amplitude
0265                  sysvar_BELL_FREQ                        EQU $0265       ; fx213   &D5   BELL frequency
0266                  sysvar_BELL_DUR                         EQU $0266       ; fx214   &D6   BELL duration
0267                  sysvar_STARTUP_DISPOPT                  EQU $0267       ; fx215   &D7   Startup display and BOOT error options
0268                  sysvar_KEYB_SOFTKEY_LENGTH              EQU $0268       ; fx216   &D8   Soft key string length
0269                  sysvar_SCREENLINES_SINCE_PAGE           EQU $0269       ; fx217   &D9   Screen lines since last page
026A                  sysvar_VDU_Q_LEN                        EQU $026A       ; fx218   &DA   256-number of items in VDU queue
026B                  sysvar_KEYB_TAB_CHAR                    EQU $026B       ; fx219   &DB   BBC, Master: TAB key character
026C                  sysvar_KEYB_ESC_CHAR                    EQU $026C       ; fx220   &DC   ESCAPE character
026D                  sysvar_KEYB_C0CF_INSERT_INT             EQU $026D       ; fx221   &DD   Char &C0-&CF buffer insert interpretation
026E                  sysvar_KEYB_D0DF_INSERT_INT             EQU $026E       ; fx222   &DE   Char &D0-&DF buffer insert interpretation
026F                  sysvar_KEYB_E0EF_INSERT_INT             EQU $026F       ; fx223   &DF   Char &E0-&EF buffer insert interpretation
0270                  sysvar_KEYB_F0FF_INSERT_INT             EQU $0270       ; fx224   &E0   Char &F0-&FF buffer insert interpretation
0271                  sysvar_KEYB_808F_INSERT_INT             EQU $0271       ; fx225   &E1   Char &80-&8F buffer insert interpretation (FKey)
0272                  sysvar_KEYB_909F_INSERT_INT             EQU $0272       ; fx226   &E2   Char &90-&9F buffer insert interpretation (Sh+FKey)
0273                  sysvar_KEYB_A0AF_INSERT_INT             EQU $0273       ; fx227   &E3   Char &A0-&AF buffer insert interpretation (Ct+FKey)
0274                  sysvar_KEYB_B0BF_INSERT_INT             EQU $0274       ; fx228   &E4   Char &B0-&BF buffer insert interpretation (Ct+Sh+FKey)
0275                  sysvar_KEYB_ESC_ACTION                  EQU $0275       ; fx229   &E5   ESCAPE key action
0276                  sysvar_KEYB_ESC_EFFECT                  EQU $0276       ; fx230   &E6   ESCAPE effects
0277                  sysvar_USERVIA_IRQ_MASK_CPY             EQU $0277       ; fx231   &E7   User 6522 VIA IRQ mask
0278                  sysvar_ACIA_IRQ_MASK_CPY                EQU $0278       ; fx232   &E8   6850 ACIA IRQ bit mask
0279                  sysvar_SYSVIA_IRQ_MASK_CPY              EQU $0279       ; fx233   &E9   System 6522 VIA IRQ mask
027A                  sysvar_TUBE_PRESENT                     EQU $027A       ; fx234   &EA   Tube presence flag
027B                  sysvar_SPEECH_PRESENT                   EQU $027B       ; fx235   &EB   Speech processor presence flag
027C                  sysvar_OUTSTREAM_DEST                   EQU $027C       ; fx236   &EC   Output stream character destination, set with FX3
027D                  sysvar_KEY_CURSORSTAT                   EQU $027D       ; fx237   &ED   Cursor key status, set with FX4
027E                  sysvar_FX238                            EQU $027E       ; fx238   &EE   BBC, Electron: unused
027F                  sysvar_FX239                            EQU $027F       ; fx239   &EF   unused
0280                  sysvar_COUNTRY                          EQU $0280       ; fx240   &F0   Country code
0281                  sysvar_USERFLAG                         EQU $0281       ; fx241   &F1   User flag location, set with FX1
0282                  sysvar_SERPROC_CTL_CPY                  EQU $0282       ; fx242   &F2   BBC, Master: RAM copy of SERPROC control register
0283                  sysvar_TIMER_SWITCH                     EQU $0283       ; fx243   &F3   Timer switch state
0284                  sysvar_KEYB_SOFT_CONSISTANCY            EQU $0284       ; fx244   &F4   Soft key consistancy flag
0285                  sysvar_PRINT_DEST                       EQU $0285       ; fx245   &F5   Printer destination, set with FX5
0286                  sysvar_PRINT_IGNORE                     EQU $0286       ; fx246   &F6   Printer ignore character, set with FX6
0287                  sysvar_BREAK_VECTOR_JMP                 EQU $0287       ; fx247   &F7   Break Intercept Vector JMP
0288                  sysvar_BREAK_VECTOR_LOW                 EQU $0288       ; fx248   &F8   Break Intercept Vector address low byte
0289                  sysvar_BREAK_VECTOR_HIGH                EQU $0289       ; fx249   &F9   Break Intercept Vector address high byte
028A                  sysvar_SHADOW1                          EQU $028A       ; fx250   &FA   BBC, Electron: unused, unless shadow screen present
028B                  sysvar_SHADOW2                          EQU $028B       ; fx251   &FB   BBC, Electron: unused, unless shadow screen present
028C                  sysvar_CUR_LANG                         EQU $028C       ; fx252   &FC   Current language ROM
028D                  sysvar_BREAK_LAST_TYPE                  EQU $028D       ; fx253   &FD   Last BREAK type
028E                  sysvar_RAM_AVAIL                        EQU $028E       ; fx254   &FE   BBC: Available RAM
028F                  sysvar_STARTUP_OPT                      EQU $028F       ; fx255   &FF   Startup options
0290                  oswksp_VDU_VERTADJ                      EQU $0290       ; VDU vertical adjust, *TV first parameter
0291                  oswksp_VDU_INTERLACE                    EQU $0291       ; Interlace toggle flag, *TV second parameter
0292                  oswksp_TIME                             EQU $0292       ; TIME value 1, high byte...low byte
0297                  oswksp_TIME2                            EQU $0297       ; TIME value 2, high byte...low byte
029C                  oswksp_OSWORD3_CTDOWN                   EQU $029C       ; OSWORD 3/4 Countdown interval timer value
02A1                  oswksp_ROMTYPE_TAB                      EQU $02A1       ; Paged ROM type table
02B1                  oswksp_INKEY_CTDOWN                     EQU $02B1       ; INKEY countdown timer
02B3                  oswksp_OSWORD0_LINE_LEN                 EQU $02B3       ; OSWORD 0 maximum line length
02B4                  oswksp_OSWORD0_MIN_CH                   EQU $02B4       ; OSWORD 0 minimum character
02B5                  oswksp_OSWORD0_MAX_CH                   EQU $02B5       ; OSWORD 0 maximum character
02B6                  adc_CH1_LOW                             EQU $02B6       ; Channel 1 ADC value low
02B7                  adc_CH2_LOW                             EQU $02B7       ; Channel 2 ADC value low
02B8                  adc_CH3_LOW                             EQU $02B8       ; Channel 3 ADC value low
02B9                  adc_CH4_LOW                             EQU $02B9       ; Channel 4 ADC value low
02BA                  adc_CH1_HI                              EQU $02BA       ; Channel 1 ADC value high
02BB                  adc_CH2_HI                              EQU $02BB       ; Channel 2 ADC value high
02BC                  adc_CH3_HI                              EQU $02BC       ; Channel 3 ADC value high
02BD                  adc_CH4_HI                              EQU $02BD       ; Channel 4 ADC value high
02BE                  adc_CH_LAST                             EQU $02BE       ; Last ADC channel converted
02BF                  mosvar_EVENT_ENABLE                     EQU $02BF       ; MOS Event enable flags
02C9                  mosvar_SOFTKEY_PTR                      EQU $02C9       ; Soft key expansion pointer
02CA                  mosvar_KEYB_AUTOREPEAT_COUNT            EQU $02CA       ; First auto repeat count
02CB                  mosvar_KEYB_TWOKEY_ROLLOVER             EQU $02CB       ; Two key rollover workspace
02CE                  mosvar_SOUND_SEMAPHORE                  EQU $02CE       ; Sound semaphore
02CF                  mosbuf_buf_busy                         EQU $02CF       ; Buffer busy flags           
02D8                  mosbuf_buf_start                        EQU $02D8       ; Buffer start indexes        
02E1                  mosbuf_buf_end                          EQU $02E1       ; Buffer end indexes          
02EA                  cfsrfs_BLK_SIZE                         EQU $02EA       ; Block size
02EC                  cfsrfs_BLK_FLAG                         EQU $02EC       ; Block flag
02ED                  cfsrfs_LAST_CHA                         EQU $02ED       ; Last input character
02EE                  osfile_ctlblk                           EQU $02EE       ; OSFILE control blocks for *LOAD, *SAVE, *CREATE and *DELETE.
0300                  vduvars_start                           EQU $0300
0300                  vduvar_GRA_WINDOW                       EQU $0300                               
0300                  vduvar_GRA_WINDOW_LEFT                  EQU $0300       ; Current graphics window left column in pixels
0302                  vduvar_GRA_WINDOW_BOTTOM                EQU $0302       ; Current graphics window bottom row in pixels
0304                  vduvar_GRA_WINDOW_RIGHT                 EQU $0304       ; Current graphics window right column in pixels
0306                  vduvar_GRA_WINDOW_TOP                   EQU $0306       ; Current graphics window top row in pixels
0308                  vduvar_TXT_WINDOW_LEFT                  EQU $0308       ; Current text window left hand column
0309                  vduvar_TXT_WINDOW_BOTTOM                EQU $0309       ; Current text window bottom row
030A                  vduvar_TXT_WINDOW_RIGHT                 EQU $030A       ; Current text window right hand column
030B                  vduvar_TXT_WINDOW_TOP                   EQU $030B       ; Current text window top column
030C                  vduvar_GRA_ORG_EXT                      EQU $030C       ; Current graphics origin in external coordinates
0310                  vduvar_GRA_CUR_EXT                      EQU $0310       ; Current graphics cursor in external coordinates
0314                  vduvar_GRA_CUR_INT_OLD                  EQU $0314       ; Old graphics cursor in external coordinates
0318                  vduvar_TXT_CUR_X                        EQU $0318       ; Current text cursor X
0319                  vduvar_TXT_CUR_Y                        EQU $0319       ; Current text cursor Y
031A                  vduvar_GRA_CUR_CELL_LINE                EQU $031A       ; Line within current graphics cell of graphics cursor
031B                  vduvar_VDU_Q_START                      EQU $031B
0324                  vduvar_VDU_Q_END                        EQU $0324       ; end of VDU Q (well 1 after!)
0324                  vduvar_GRA_CUR_INT                      EQU $0324       ; Current graphics cursor in internal coordinates
0328                  vduvar_TEMP_8                           EQU $0328       ; Bitmap read from screen by OSBYTE 135, various coordinate routines
0330                  vduvar_GRA_WKSP                         EQU $0330       ; Graphics workspace
034A                  vduvar_6845_CURSOR_ADDR                 EQU $034A       ; Text cursor address for 6845
034C                  vduvar_TXT_WINDOW_WIDTH_BYTES           EQU $034C       ; Text window width in bytes
034E                  vduvar_SCREEN_BOTTOM_HIGH               EQU $034E       ; High byte of bottom of screen memory
034F                  vduvar_BYTES_PER_CHAR                   EQU $034F       ; Bytes per character for current mode
0350                  vduvar_6845_SCREEN_START                EQU $0350       ; Screen display start address for 6845
0352                  vduvar_BYTES_PER_ROW                    EQU $0352       ; Bytes per screen row
0354                  vduvar_SCREEN_SIZE_HIGH                 EQU $0354       ; Screen memory size high byte
0355                  vduvar_MODE                             EQU $0355       ; Current screen mode
0356                  vduvar_MODE_SIZE                        EQU $0356       ; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
0357                  vduvar_TXT_FORE                         EQU $0357       ; Foreground text colour
0358                  vduvar_TXT_BACK                         EQU $0358       ; Background text colour
0359                  vduvar_GRA_FORE                         EQU $0359       ; Foreground graphics colour
035A                  vduvar_GRA_BACK                         EQU $035A       ; Background graphics colour
035B                  vduvar_GRA_PLOT_FORE                    EQU $035B       ; Foreground plot mode
035C                  vduvar_GRA_PLOT_BACK                    EQU $035C       ; Background plot mode
035D                  vduvar_VDU_VEC_JMP                      EQU $035D       ; General VDU jump vector
035F                  vduvar_CUR_START_PREV                   EQU $035F       ; Cursor start register previous setting
0360                  vduvar_COL_COUNT_MINUS1                 EQU $0360       ; Number logical colours -1
0361                  vduvar_PIXELS_PER_BYTE_MINUS1           EQU $0361       ; Pixels per byte -1 (zero if text only mode)
0362                  vduvar_LEFTMOST_PIX_MASK                EQU $0362       ; Leftmost pixel colour mask
0363                  vduvar_RIGHTMOST_PIX_MASK               EQU $0363       ; Rightmost pixel colour mask
0364                  vduvar_TEXT_IN_CUR_X                    EQU $0364       ; Text input cursor X
0365                  vduvar_TEXT_IN_CUR_Y                    EQU $0365       ; Text input cursor Y
0366                  vduvar_MO7_CUR_CHAR                     EQU $0366       ; Teletext output cursor character
0367                  vduvar_EXPLODE_FLAGS                    EQU $0367       ; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
0368                  vduvar_FONT_LOC32_63                    EQU $0368       ; Font location, characters 32-63
0369                  vduvar_FONT_LOC64_95                    EQU $0369       ; Font location, characters 64-95 
036A                  vduvar_FONT_LOC96_127                   EQU $036A       ; Font location, characters 96-127
036B                  vduvar_FONT_LOC128_159                  EQU $036B       ; Font location, characters 128-159
036C                  vduvar_FONT_LOC160_191                  EQU $036C       ; Font location, characters 160-191
036D                  vduvar_FONT_LOC192_223                  EQU $036D       ; Font location, characters 192-223
036E                  vduvar_FONT_LOC224_255                  EQU $036E       ; Font location, characters 224-255
036F                  vduvar_PALLETTE                         EQU $036F       ; Palette for colours 0 to 15
                      
03D1                  fsvar_seq_block_gap                     EQU $03D1
                      
                      ********************************************************
                      *           B U F F E R   A D D R E S S E S            *
                      ********************************************************
                      
03E0                  BUFFER_KEYB_START                       EQU $03E0
03FF                  BUFFER_KEYB_END                         EQU $03FF
0A00                  BUFFER_SERI_START                       EQU $0A00
0AFF                  BUFFER_SERI_END                         EQU $0AFF
0900                  BUFFER_SERO_START                       EQU $0900
09BF                  BUFFER_SERO_END                         EQU $09BF
0880                  BUFFER_LPT_START                        EQU $0880
08BF                  BUFFER_LPT_END                          EQU $08BF
0840                  BUFFER_SND0_START                       EQU $0840
084F                  BUFFER_SND0_END                         EQU $084F
0850                  BUFFER_SND1_START                       EQU $0850
085F                  BUFFER_SND1_END                         EQU $085F
0860                  BUFFER_SND2_START                       EQU $0860
086F                  BUFFER_SND2_END                         EQU $086F
0870                  BUFFER_SND3_START                       EQU $0870
087F                  BUFFER_SND3_END                         EQU $087F
09C0                  BUFFER_SPCH_START                       EQU $09C0
09FF                  BUFFER_SPCH_END                         EQU $09FF
                      
                      
                      BUFFER_PTR_ADDR         MACRO ; 1=START, 2=END
                                              FDB (\2+1)-$100
                                              ENDM
                      
                      BUFFER_ACC_OFF          MACRO ; 1=START, 2=END
                                              FCB \1-(\2+1)-$100              ; i.e. $100 - len!
                                              ENDM
                      
                      
                      
                      
0800                  snd_unused1                             EQU $800        ; Unused
0804                  snd_q_occupied                          EQU $804        ; Sound queue occupancy flag
0808                  snd_amplitude                           EQU $808        ; Current amplitude
080C                  snd_amplitude_phase_count               EQU $80C        ; Number of amplitude phases processed
0810                  snd_abs_pitch                           EQU $810        ; Absolute pitch value
0814                  snd_pitch_phase_count                   EQU $814        ; Number of pitch phases processed
0818                  snd_steps_left                          EQU $818        ; Number of steps to process
081C                  snd_duration_ctr                        EQU $81C        ; Duration
0820                  snd_duration_mul                        EQU $820        ; Interval multiplier
0824                  snd_env_no                              EQU $824        ; Envelope number/auto repeat parameter
0828                  snd_length_left                         EQU $828        ; Length of remaining note interval
082C                  snd_sync_hold_parm                      EQU $82C        ; Sync hold parameter
0830                  snd_chip_pitch                          EQU $830        ; Sound chip current pitch setting
0834                  snd_pitch_deviation                     EQU $834        ; Pitch deviation
0838                  snd_num_chans_sync                      EQU $838        ; Number of channels required for sync
0839                  snd_cur_amp_step                        EQU $839        ; Current amplitude step
083A                  snd_cur_target_amplitude                EQU $83A        ; Current target amplitude
083B                  snd_num_chans_hold_sync                 EQU $83B        ; Number of channels on hold for sync
                      
083C                  snd_parm_wksp                           EQU $83C        ; Sound parameter calculation workspace
083D                  snd_low_parm                            EQU $83D        ; Low order frequency parameter as sent to the sound generator
083E                  snd_high_parm                           EQU $83E        ; High order frequency parameter as sent to the sound generator
083F                  snd_tempx                               EQU $83F
                      
08C0                  snd_envelope_defs                       EQU $8C0
                      
0B00                  soft_keys_start                         EQU $B00
0B00                  soft_keys_ptrs                          EQU soft_keys_start
0B10                  soft_keys_end_ptr                       EQU soft_keys_ptrs+$10
0B11                  soft_keys_defs                          EQU soft_keys_start+$11
                      
0D00                  vec_nmi                                 EQU $0D00
                      
0DF0                  swrom_wksp_tab                          EQU $0DF0
                      
                      ; REMAPPED HARDWARE VECTOS
                      
F7F0                  HWVEC_DIV0                              EQU     $F7F0
F7F2                  HWVEC_SWI3V                             EQU     $F7F2
F7F4                  HWVEC_SWI2V                             EQU     $F7F4
F7F6                  HWVEC_FIRQV                             EQU     $F7F6
F7F8                  HWVEC_IRQV                              EQU     $F7F8
F7FA                  HWVEC_SWIV                              EQU     $F7FA
F7FC                  HWVEC_NMIV                              EQU     $F7FC
F7FE                  HWVEC_RESETV                            EQU     $F7FE
                                              INCLUDE         "../../includes/oslib.inc"
                      ;       OS Entry points
                      
FFC2                  GSINIT                                  EQU     $FFC2
FFC5                  GSREAD                                  EQU     $FFC5
FFC8                  OSRDCH_NV                               EQU     $FFC8
FFCB                  OSWRCH_NV                               EQU     $FFCB
FFCE                  OSFIND                                  EQU     $FFCE
FFD1                  OSGBPB                                  EQU     $FFD1
FFD4                  OSBPUT                                  EQU     $FFD4
FFD7                  OSBGET                                  EQU     $FFD7
FFDA                  OSARGS                                  EQU     $FFDA
FFDD                  OSFILE                                  EQU     $FFDD
FFE0                  OSRDCH                                  EQU     $FFE0
FFE3                  OSASCI                                  EQU     $FFE3
FFE7                  OSNEWL                                  EQU     $FFE7
FFEC                  OSWRCR                                  EQU     $FFEC
FFEE                  OSWRCH                                  EQU     $FFEE
FFF1                  OSWORD                                  EQU     $FFF1
FFF4                  OSBYTE                                  EQU     $FFF4
FFF7                  OSCLI                                   EQU     $FFF7
                      
FF9B                  PRSTRING                                EQU     $FF9B
FFB9                  CLICOM                                  EQU     $FFB9
FFBC                  ERRJMP                                  EQU     $FFBC
FFBF                  OSINIT                                  EQU     $FFBF
FFA1                  SCANHEX                                 EQU     $FFA1
FFA7                  OSQUIT                                  EQU     $FFA7
FFAA                  PRHEX                                   EQU     $FFAA
FFAD                  PR2HEX                                  EQU     $FFAD
FFB0                  USERINT                                 EQU     $FFB0
FFB3                  PRTEXT                                  EQU     $FFB3
                      
FF98                  OSRDRM                                  EQU     $FF98   !!! Different to Beeb !!!
FF9E                  OSEVEN                                  EQU     $FF9E   !!! Different to Beeb !!!
FFA3                  RAWVDU                                  EQU     $FFA3   !!! Different to Beeb !!!
                      
FF8C                  DEBUGPRINTNEWL                          EQU     $FF8C
FF8F                  DEBUGPRINTHEX                           EQU     $FF8F
FF92                  DEBUGPRINTA                             EQU     $FF92
FF95                  DEBUGPRINTX                             EQU     $FF95
                      
                      ;       OS Constants
00FF                  OSFILE_LOAD                             EQU $FF
0000                  OSFILE_SAVE                             EQU $00
0005                  OSFILE_CAT                              EQU $05
0000                  OSFILE_OFS_FILENAME                     EQU $00
0002                  OSFILE_OFS_LOAD                         EQU $02
0006                  OSFILE_OFS_EXEC                         EQU $06
000A                  OSFILE_OFS_LEN                          EQU $0A
000A                  OSFILE_OFS_START                        EQU $0A
000E                  OSFILE_OFS_ATTR                         EQU $0E
000E                  OSFILE_OFS_END                          EQU $0E
                      
0000                  OSFIND_CLOSE                            EQU $00
0040                  OSFIND_OPENIN                           EQU $40
0080                  OSFIND_OPENOUT                          EQU $80
00C0                  OSFIND_OPENUP                           EQU $C0
                      
0007                  OSWORD_SOUND                            EQU $07
0008                  OSWORD_ENVELOPE                         EQU $08
                      
0001                  OSARGS_cmdtail                          EQU $01
0002                  OSARGS_EXT                              EQU $02
                      
                      
0000                  OSGBPB_WRITE_PTR                        EQU     $00
0002                  OSGBPB_WRITE_NOPTR                      EQU     $02
0003                  OSGBPB_READ_PTR                         EQU     $03
0004                  OSGBPB_READ_NOPTR                       EQU     $04
0005                  OSGBPB_READ_TITLE                       EQU     $05
0006                  OSGBPB_READ_DIR                         EQU     $06
0007                  OSGBPB_READ_LIB                         EQU     $07
0008                  OSGBPB_GET_DIRENT                       EQU     $08
                      
                      
0000                  SERVICE_0_NOP                           EQU     $0
0001                  SERVICE_1_ABSWKSP_REQ                   EQU     $1
0002                  SERVICE_2_RELWKSP_REQ                   EQU     $2
0003                  SERVICE_3_AUTOBOOT                      EQU     $3
0004                  SERVICE_4_UKCMD                         EQU     $4
0005                  SERVICE_5_UKINT                         EQU     $5
0006                  SERVICE_6_BRK                           EQU     $6
0007                  SERVICE_7_UKOSBYTE                      EQU     $7
0008                  SERVICE_7_UKOSWORD                      EQU     $8
0009                  SERVICE_9_HELP                          EQU     $9
000A                  SERVICE_A_ABSWKSP_CLAIM                 EQU     $A
000B                  SERVICE_B_NMI_RELEASE                   EQU     $B
000C                  SERVICE_C_NMI_CLAIM                     EQU     $C
000D                  SERVICE_D_ROMFS_INIT                    EQU     $D
000E                  SERVICE_E_ROMFS_GETB                    EQU     $E
000F                  SERVICE_F_FSVEC_CLAIMED                 EQU     $F
0010                  SERVICE_10_SPOOL_CLOSE                  EQU     $10
0011                  SERVICE_11_FONT_BANG                    EQU     $11
0012                  SERVICE_12_INITFS                       EQU     $12
0013                  SERVICE_13_SERIAL_CHAR                  EQU     $13
0014                  SERVICE_14_PRINT_CHAR                   EQU     $14
0015                  SERVICE_15_100Hz                        EQU     $15
0025                  SERVICE_25_FSINFO                       EQU     $25
                      
0006                  FSCV_6_NewFS                            EQU     $06
                      
                      ; OS Vectors
                      
0200                  USERV                                   EQU     $0200   ; User vector, called by *LINE, *CODE, OSWORD >=&E0
0202                  BRKV                                    EQU     $0202   ; The BRK vector
0204                  IRQ1V                                   EQU     $0204   ; Main interrupt vector
0206                  IRQ2V                                   EQU     $0206   ; Secondary interrupt vector
0208                  CLIV                                    EQU     $0208   ; Command Line Interpreter vector
020A                  BYTEV                                   EQU     $020A   ; OSBYTE (*FX) calls
020C                  WORDV                                   EQU     $020C   ; OSWORD calls
020E                  WRCHV                                   EQU     $020E   ; Send character to current output stream
0210                  RDCHV                                   EQU     $0210   ; Wait for a character from current input stream
0212                  FILEV                                   EQU     $0212   ; Operate on a whole file, eg loading/saving/delete/etc
0214                  ARGSV                                   EQU     $0214   ; Read/Write arguments on an open file
0216                  BGETV                                   EQU     $0216   ; Read a byte from an open file
0218                  BPUTV                                   EQU     $0218   ; Write a byte to an open file
021A                  GBPBV                                   EQU     $021A   ; Read/Write block of data from/to open file or device
021C                  FINDV                                   EQU     $021C   ; Open or close a file
021E                  FSCV                                    EQU     $021E   ; Various filing system control calls
0220                  EVNTV                                   EQU     $0220   ; Event handler
0222                  UPTV                                    EQU     $0222   ; User Print vector
0224                  NETV                                    EQU     $0224   ; Network Print vector
0226                  VDUV                                    EQU     $0226   ; Unrecognised VDU commands
0228                  KEYV                                    EQU     $0228   ; Read the keyboard
022A                  INSV                                    EQU     $022A   ; Insert characters into a buffer
022C                  REMV                                    EQU     $022C   ; Remove characters from a buffer
022E                  CNPV                                    EQU     $022E   ; Count or Purge a buffer
                      ;;IND1V                                 EQU     $0230   ; Spare 
0230                  SWI9V                                   EQU     $0230   ; SWI instruction vector - do not use except for debugging
0232                  ILOPV                                   EQU     $0232   ; Illegal operation vector
0234                  NMI9V                                   EQU     $0234   ; NMI vector - do not use except for debugging
                      
                      ; OS Extended Vectors Marker addresses
                      
FF00                  EXTVEC_ENTER_USERV                      EQU     $FF00   ; User vector, called by *LINE, *CODE, OSWORD >=&E0
FF03                  EXTVEC_ENTER_BRKV                       EQU     $FF03   ; The BRK vector
FF06                  EXTVEC_ENTER_IRQ1V                      EQU     $FF06   ; Main interrupt vector
FF09                  EXTVEC_ENTER_IRQ2V                      EQU     $FF09   ; Secondary interrupt vector
FF0C                  EXTVEC_ENTER_CLIV                       EQU     $FF0C   ; Command Line Interpreter vector
FF0F                  EXTVEC_ENTER_BYTEV                      EQU     $FF0F   ; OSBYTE (*FX) calls
FF12                  EXTVEC_ENTER_WORDV                      EQU     $FF12   ; OSWORD calls
FF15                  EXTVEC_ENTER_WRCHV                      EQU     $FF15   ; Send character to current output stream
FF18                  EXTVEC_ENTER_RDCHV                      EQU     $FF18   ; Wait for a character from current input stream
FF1B                  EXTVEC_ENTER_FILEV                      EQU     $FF1B   ; Operate on a whole file, eg loading/saving/delete/etc
FF1E                  EXTVEC_ENTER_ARGSV                      EQU     $FF1E   ; Read/Write arguments on an open file
FF21                  EXTVEC_ENTER_BGETV                      EQU     $FF21   ; Read a byte from an open file
FF24                  EXTVEC_ENTER_BPUTV                      EQU     $FF24   ; Write a byte to an open file
FF27                  EXTVEC_ENTER_GBPBV                      EQU     $FF27   ; Read/Write block of data from/to open file or device
FF2A                  EXTVEC_ENTER_FINDV                      EQU     $FF2A   ; Open or close a file
FF2D                  EXTVEC_ENTER_FSCV                       EQU     $FF2D   ; Various filing system control calls
FF30                  EXTVEC_ENTER_EVNTV                      EQU     $FF30   ; Event handler
FF33                  EXTVEC_ENTER_UPTV                       EQU     $FF33   ; User Print vector
FF36                  EXTVEC_ENTER_NETV                       EQU     $FF36   ; Network Print vector
FF39                  EXTVEC_ENTER_VDUV                       EQU     $FF39   ; Unrecognised VDU commands
FF3C                  EXTVEC_ENTER_KEYV                       EQU     $FF3C   ; Read the keyboard
FF3F                  EXTVEC_ENTER_INSV                       EQU     $FF3F   ; Insert characters into a buffer
FF42                  EXTVEC_ENTER_REMV                       EQU     $FF42   ; Remove characters from a buffer
FF45                  EXTVEC_ENTER_CNPV                       EQU     $FF45   ; Count or Purge a buffer
FF48                  EXTVEC_ENTER_SWI9V                      EQU     $FF48   ; Spare
FF4B                  EXTVEC_ENTER_ILOPV                      EQU     $FF4B   ; Spare
FF4E                  EXTVEC_ENTER_NMI9V                      EQU     $FF4E   ; Spare
                      
0D9F                  EXT_USERV                               EQU     $0D9F   ; User vector, called by *LINE, *CODE, OSWORD >=&E0
0DA2                  EXT_BRKV                                EQU     $0DA2   ; The BRK vector
0DA5                  EXT_IRQ1V                               EQU     $0DA5   ; Main interrupt vector
0DA8                  EXT_IRQ2V                               EQU     $0DA8   ; Secondary interrupt vector
0DAB                  EXT_CLIV                                EQU     $0DAB   ; Command Line Interpreter vector
0DAE                  EXT_BYTEV                               EQU     $0DAE   ; OSBYTE (*FX) calls
0DB1                  EXT_WORDV                               EQU     $0DB1   ; OSWORD calls
0DB4                  EXT_WRCHV                               EQU     $0DB4   ; Send character to current output stream
0DB7                  EXT_RDCHV                               EQU     $0DB7   ; Wait for a character from current input stream
0DBA                  EXT_FILEV                               EQU     $0DBA   ; Operate on a whole file, eg loading/saving/delete/etc
0DBD                  EXT_ARGSV                               EQU     $0DBD   ; Read/Write arguments on an open file
0DC0                  EXT_BGETV                               EQU     $0DC0   ; Read a byte from an open file
0DC3                  EXT_BPUTV                               EQU     $0DC3   ; Write a byte to an open file
0DC6                  EXT_GBPBV                               EQU     $0DC6   ; Read/Write block of data from/to open file or device
0DC9                  EXT_FINDV                               EQU     $0DC9   ; Open or close a file
0DCC                  EXT_FSCV                                EQU     $0DCC   ; Various filing system control calls
0DCF                  EXT_EVNTV                               EQU     $0DCF   ; Event handler
0DD2                  EXT_UPTV                                EQU     $0DD2   ; User Print vector
0DD5                  EXT_NETV                                EQU     $0DD5   ; Network Print vector
0DD8                  EXT_VDUV                                EQU     $0DD8   ; Unrecognised VDU commands
0DDB                  EXT_KEYV                                EQU     $0DDB   ; Read the keyboard
0DDE                  EXT_INSV                                EQU     $0DDE   ; Insert characters into a buffer
0DE1                  EXT_REMV                                EQU     $0DE1   ; Remove characters from a buffer
0DE4                  EXT_CNPV                                EQU     $0DE4   ; Count or Purge a buffer
0DE7                  EXT_SWI9V                               EQU     $0DE7   ; SWI instruction vector - do not use except for debugging
0DEA                  EXT_ILOPV                               EQU     $0DEA   ; Illegal operation vector
0DED                  EXT_NMI9V                               EQU     $0DED   ; NMI vector - do not use except for debugging
                      
000D                  OSBYTE_13_ENABLE_EVENT                  EQU     13
000E                  OSBYTE_14_ENABLE_EVENT                  EQU     14
006C                  OSBYTE_108_WRITE_SHADOW_STATE           EQU     108
0077                  OSBYTE_119_CLOSE_SPOOL_AND_EXEC         EQU     119
007E                  OSBYTE_126_ESCAPE_ACK                   EQU     126
0081                  OSBYTE_129_INKEY                        EQU     129
008F                  OSBYTE_142_SERVICE_CALL                 EQU     143
009C                  OSBYTE_156_SERIAL_STATE                 EQU     156
00A0                  OSBYTE_160_READ_VDU_VARIABLE            EQU     160
00A8                  OSBYTE_168_READ_ROM_POINTER_TABLE       EQU     168
00AA                  OSBYTE_171_ROMTAB                       EQU     170
00E8                  OSBYTE_232_VAR_IRQ_MASK_SERIAL          EQU     232
00EA                  OSBYTE_234_VAR_TUBE                     EQU     234
00FD                  OSBYTE_253_VAR_LAST_RESET               EQU     253
                      
0000                  vduvar_ix_GRA_WINDOW                    EQU $00                         
0000                  vduvar_ix_GRA_WINDOW_LEFT               EQU $00 ; Current graphics window left column in pixels
0002                  vduvar_ix_GRA_WINDOW_BOTTOM             EQU $02 ; Current graphics window bottom row in pixels
0004                  vduvar_ix_GRA_WINDOW_RIGHT              EQU $04 ; Current graphics window right column in pixels
0006                  vduvar_ix_GRA_WINDOW_TOP                EQU $06 ; Current graphics window top row in pixels
0008                  vduvar_ix_TXT_WINDOW_LEFT               EQU $08 ; Current text window left hand column
0009                  vduvar_ix_TXT_WINDOW_BOTTOM             EQU $09 ; Current text window bottom row
000A                  vduvar_ix_TXT_WINDOW_RIGHT              EQU $0A ; Current text window right hand column
000B                  vduvar_ix_TXT_WINDOW_TOP                EQU $0B ; Current text window top column
000C                  vduvar_ix_GRA_ORG_EXT                   EQU $0C ; Current graphics origin in external coordinates
0010                  vduvar_ix_GRA_CUR_EXT                   EQU $10 ; Current graphics cursor in external coordinates
0014                  vduvar_ix_GRA_CUR_INT_OLD               EQU $14 ; Old graphics cursor in external coordinates
0018                  vduvar_ix_TXT_CUR_X                     EQU $18 ; Current text cursor X
0019                  vduvar_ix_TXT_CUR_Y                     EQU $19 ; Current text cursor Y
001A                  vduvar_ix_GRA_CUR_CELL_LINE             EQU $1A ; Line within current graphics cell of graphics cursor
001B                  vduvar_ix_VDU_Q_START                   EQU $1B
0024                  vduvar_ix_VDU_Q_END                     EQU $24 ; end of VDU Q (well 1 after!)
0024                  vduvar_ix_GRA_CUR_INT                   EQU $24 ; Current graphics cursor in internal coordinates
0028                  vduvar_ix_TEMP_8                        EQU $28 ; Bitmap read from screen by OSBYTE 135, various coordinate routines
0030                  vduvar_ix_GRA_WKSP                      EQU $30 ; Graphics workspace
004A                  vduvar_ix_6845_CURSOR_ADDR              EQU $4A ; Text cursor address for 6845
004C                  vduvar_ix_TXT_WINDOW_WIDTH_BYTES        EQU $4C ; Text window width in bytes
004E                  vduvar_ix_SCREEN_BOTTOM_HIGH            EQU $4E ; High byte of bottom of screen memory
004F                  vduvar_ix_BYTES_PER_CHAR                EQU $4F ; Bytes per character for current mode
0050                  vduvar_ix_6845_SCREEN_START             EQU $50 ; Screen display start address for 6845
0052                  vduvar_ix_BYTES_PER_ROW                 EQU $52 ; Bytes per screen row
0054                  vduvar_ix_SCREEN_SIZE_HIGH              EQU $54 ; Screen memory size high byte
0055                  vduvar_ix_MODE                          EQU $55 ; Current screen mode
0056                  vduvar_ix_MODE_SIZE                     EQU $56 ; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
0057                  vduvar_ix_TXT_FORE                      EQU $57 ; Foreground text colour
0058                  vduvar_ix_TXT_BACK                      EQU $58 ; Background text colour
0059                  vduvar_ix_GRA_FORE                      EQU $59 ; Foreground graphics colour
005A                  vduvar_ix_GRA_BACK                      EQU $5A ; Background graphics colour
005B                  vduvar_ix_GRA_PLOT_FORE                 EQU $5B ; Foreground plot mode
005C                  vduvar_ix_GRA_PLOT_BACK                 EQU $5C ; Background plot mode
005D                  vduvar_ix_VDU_VEC_JMP                   EQU $5D ; General VDU jump vector
005F                  vduvar_ix_CUR_START_PREV                EQU $5F ; Cursor start register previous setting
0060                  vduvar_ix_COL_COUNT_MINUS1              EQU $60 ; Number logical colours -1
0061                  vduvar_ix_PIXELS_PER_BYTE_MINUS1        EQU $61 ; Pixels per byte -1 (zero if text only mode)
0062                  vduvar_ix_LEFTMOST_PIX_MASK             EQU $62 ; Leftmost pixel colour mask
0063                  vduvar_ix_RIGHTMOST_PIX_MASK            EQU $63 ; Rightmost pixel colour mask
0064                  vduvar_ix_TEXT_IN_CUR_X                 EQU $64 ; Text input cursor X
0065                  vduvar_ix_TEXT_IN_CUR_Y                 EQU $65 ; Text input cursor Y
0066                  vduvar_ix_MO7_CUR_CHAR                  EQU $66 ; Teletext output cursor character
0067                  vduvar_ix_EXPLODE_FLAGS                 EQU $67 ; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
0068                  vduvar_ix_FONT_LOC32_63                 EQU $68 ; Font location, characters 32-63
0069                  vduvar_ix_FONT_LOC64_95                 EQU $69 ; Font location, characters 64-95 
006A                  vduvar_ix_FONT_LOC96_127                EQU $6A ; Font location, characters 96-127
006B                  vduvar_ix_FONT_LOC128_159               EQU $6B ; Font location, characters 128-159
006C                  vduvar_ix_FONT_LOC160_191               EQU $6C ; Font location, characters 160-191
006D                  vduvar_ix_FONT_LOC192_223               EQU $6D ; Font location, characters 192-223
006E                  vduvar_ix_FONT_LOC224_255               EQU $6E ; Font location, characters 224-255
006F                  vduvar_ix_PALLETTE                      EQU $6F ; Palette for colours 0 to 15
                              ENDIF
                      
0001                  DEBUG                   EQU     1
8000                  LOADADDR                EQU $8000
8000                  COMPADDR                EQU $8000
                      
00FD                  ZP_MOS_ERROR_PTR_QRY    EQU     $FD             ; TODOFLEX - move this defn somewhere?
                      
                                              INCLUDE         "./macros.inc"
                      ABSR            MACRO
                      1
                      __ABSR          SET 1B+2
                              IF \1-__ABSR <=127 AND \1-__ABSR >=-128
                                      BSR     \1
                              ELSE
                                      LBSR    \1
                              ENDIF
                                      ENDM
                      
                      
                      
                      
                      TODODEADENDFLEX         MACRO
                                      DO_BRK_B
                                      FCB             $7E,"F:"
                                      FCB             \1
                                      FCB             0
                                              ENDM
                      
                      TODODEADEND             MACRO
                                      DO_BRK_B
                                      FCB             $7E,"D:"
                                      FCB             \1
                                      FCB             0
                                              ENDM
                      
                      TODO_CMD                MACRO
                                              TODODEADEND "\1"
                                              ENDM
                      
                      DO_BRK_B                MACRO                   ; code
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
                                              SWI
                                      ELSE
                                              SWI3
                                      ENDIF
                                              ENDM
                      
                      RESET_MACH_STACK        MACRO
                                              LDS     #MACH_STACK_TOP
                                              ENDM
                      
                      LDX_FPC                 MACRO                   ; this may be changed for position independent code
                                              LDX     #\1             ; leave as LDX for now for faster execution
                                              ENDM
                      
                      LDU_FPC                 MACRO                   ; this may be changed for position independent code
                                              LDY     #\1             ; leave as LDX for now for faster execution
                                              ENDM
                      
                      LDY_FPC                 MACRO                   ; this may be changed for position independent code
                                              LDY     #\1             ; leave as LDX for now for faster execution
                                              ENDM
                      
                      
                      CALL                    MACRO                   ; this may be changed for position independent code
                      9
                      __XBSR                  SET 9B+2
                      __XBSR2                 SET (\1-__XBSR) & $FF00
                      __XBSR3                 SET (\1-__XBSR) & $FF
                      
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                                              ENDM
                      
                      JUMP                    MACRO                   ; this may be changed for position independant code
                                              JMP     \1
                                              ENDM
                                              INCLUDE         "./zp.inc"
                                              ; Zero page
0000                  ZP_LOMEM                EQU $00
0002                  ZP_VARTOP               EQU $02
0004                  ZP_BAS_SP               EQU $04
0006                  ZP_HIMEM                EQU $06
0008                  ZP_ERL                  EQU $08
000A                  ZP_TXTOFF               EQU $0A
000B                  ZP_TXTPTR               EQU $0B
000D                  ZP_RND_WA               EQU $0D         ; this keeps same endianness as 6502
0012                  ZP_TOP                  EQU $12
0014                  ZP_PRINTBYTES           EQU $14         ; order of these is assumed in cmdPRINT
0015                  ZP_PRINTFLAG            EQU $15
0016                  ZP_ERR_VECT             EQU $16
0018                  ZP_PAGE_H               EQU $18
0019                  ZP_TXTPTR2              EQU $19
001B                  ZP_TXTOFF2              EQU $1B
001C                  ZP_READ_PTR             EQU $1C
001E                  ZP_PRLINCOUNT           EQU $1E
001F                  ZP_LISTO                EQU $1F
0020                  ZP_TRACE                EQU $20
0021                  ZP_MAXTRACLINE          EQU $21
0023                  ZP_WIDTH                EQU $23
0024                  ZP_REPEAT_LVL           EQU $24
0025                  ZP_GOSUB_LVL            EQU $25
0026                  ZP_FOR_LVL_X_15         EQU $26
0027                  ZP_VARTYPE              EQU $27
0028                  ZP_OPT                  EQU $28
0029                  ZP_ASS_OPBUF            EQU $29         ;; overlaps ZP_DUNNO, ZP_INT_WA stores opcode/postbytes being assembled
0029                  ZP_DUNNO                EQU $29
002A                  ZP_INT_WA               EQU $2A
002E                  ZP_FPA                  EQU $2E
0036                  ZP_STRBUFLEN            EQU $36
0037                  ZP_SAVE_BUF             EQU $37         ;; note this overlaps 
0037                  ZP_GEN_PTR              EQU $37
0038                  ZP_ASS_LIST_OPLEN       EQU $38
0039                  ZP_ASS_OPLEN            EQU $39         ;; length of opcode + postbytes
                      
0037                  ZP_NAMELENORVT          EQU $37         ;; NOTE this is different to 6502 where it is ZP_GEN_PTR+2
                      
003A                  ZP_ASS_OPSAVED          EQU $3A         ;; start of last saved instruction (used in print)
003B                  ZP_FPB                  EQU $3B
0039                  ZP_INT_WA_B             EQU $39         ;; note overlaps ZP_NAMELENORVT and ZP_FP_WA_B sign, exponent
003D                  ZP_INT_WA_C             EQU $3D         ;; note overlaps ZP_FP_WA_B mantissa
0044                  ZP_ASS_OP_IX            EQU ZP_FPB + 9
0043                  ZP_FP_TMP               EQU $43
004A                  ZP_FP_TMP_PTR1          EQU $4A
004C                  ZP_FP_TMP_PTR2          EQU $4C
                      
004E                  ZP_ASS_LBLEND           EQU $4E
004E                  ZP_TMP                  EQU $4E         ; new temporary save / loop counter area
0050                  ZP_DUNNO_WA             EQU $50 
                      
0050                  ZP_ESCPTR               EQU $50         ; new save pointer to escape flag
0052                  ZP_EXTRA_SAVE           EQU $52         ; get rid if possible? (used in cmdFOR)
0054                  ZP_BIGEND               EQU $54         ; =0 for bigendian OS NE for anything else
0056                  ZP_EXTRA_SAVE_PROC      EQU $56         ; get rid if possible? (used in doFNPROC)
006F                  ZP_DAFT                 EQU $6F
                      
                                              INCLUDE         "./tokens.inc"
                                              ;   Basic Tokens                
0080                  tknAND                  EQU $80
0081                  tknDIV                  EQU $81
0082                  tknEOR                  EQU $82
0083                  tknMOD                  EQU $83
0084                  tknOR                   EQU $84
0085                  tknERROR                EQU $85
0086                  tknLINE                 EQU $86
0087                  tknOFF                  EQU $87
0088                  tknSTEP                 EQU $88
0089                  tknSPC                  EQU $89
008A                  tknTAB                  EQU $8A
008B                  tknELSE                 EQU $8B
008D                  tknMissing              EQU $8D
008D                  tknLineNo               EQU $8D
008E                  tknOPENIN               EQU $8E
008C                  tknTHEN                 EQU $8C
008F                  tknPTR                  EQU $8F
0090                  tknPAGE                 EQU $90
0091                  tknTIME                 EQU $91
0092                  tknLOMEM                        EQU $92
0093                  tknHIMEM                        EQU $93
0094                  tknABS                  EQU $94
0095                  tknACS                  EQU $95
0096                  tknADVAL                        EQU $96
0097                  tknASC                  EQU $97
0098                  tknASN                  EQU $98
0099                  tknATN                  EQU $99
009A                  tknBGET                 EQU $9A
009B                  tknCOS                  EQU $9B
009C                  tknCOUNT                        EQU $9C
009D                  tknDEG                  EQU $9D
009E                  tknERL                  EQU $9E
009F                  tknERR                  EQU $9F
00A0                  tknEVAL                 EQU $A0
00A1                  tknEXP                  EQU $A1
00A2                  tknEXT                  EQU $A2
00A3                  tknFALSE                        EQU $A3
00A4                  tknFN                   EQU $A4
00A5                  tknGET                  EQU $A5
00A6                  tknINKEY                        EQU $A6
00A7                  tknINSTR                        EQU $A7
00A8                  tknINT                  EQU $A8
00A9                  tknLEN                  EQU $A9
00AA                  tknLN                   EQU $AA
00AB                  tknLOG                  EQU $AB
00AC                  tknNOT                  EQU $AC
00AD                  tknOPENUP                       EQU $AD
00AE                  tknOPENOUT                      EQU $AE
00AF                  tknPI                   EQU $AF
00B0                  tknPOINT                        EQU $B0
00B1                  tknPOS                  EQU $B1
00B2                  tknRAD                  EQU $B2
00B3                  tknRND                  EQU $B3
00B4                  tknSGN                  EQU $B4
00B5                  tknSIN                  EQU $B5
00B6                  tknSQR                  EQU $B6
00B7                  tknTAN                  EQU $B7
00B8                  tknTO                   EQU $B8
00B9                  tknTRUE                 EQU $B9
00BA                  tknUSR                  EQU $BA
00BB                  tknVAL                  EQU $BB
00BC                  tknVPOS                 EQU $BC
00BD                  tknCHR                  EQU $BD
00BE                  tknGETDollar            EQU $BE
00BF                  tknINKEYDollar          EQU $BF
00C0                  tknLEFT                 EQU $C0
00C1                  tknMID                  EQU $C1
00C2                  tknRIGHT                        EQU $C2
00C3                  tknSTR                  EQU $C3
00C4                  tknSTRING                       EQU $C4
00C5                  tknEOF                  EQU $C5
00C6                  tknAUTO                 EQU $C6
00C7                  tknDELETE                       EQU $C7
00C8                  tknLOAD                 EQU $C8
00C9                  tknLIST                 EQU $C9
00CA                  tknNEW                  EQU $CA
00CB                  tknOLD                  EQU $CB
00CC                  tknRENUMBER             EQU $CC
00CD                  tknSAVE                 EQU $CD
00CE                  tknEDIT                 EQU $CE
00CF                  tknPTRc                 EQU $CF
00D0                  tknPAGESet              EQU $D0
00D1                  tknTIMESet              EQU $D1
00D2                  tknLOMEMSet             EQU $D2
00D3                  tknHIMEMSet             EQU $D3
00D4                  tknSOUND                        EQU $D4
00D5                  tknBPUT                 EQU $D5
00D6                  tknCALL                 EQU $D6
00D7                  tknCHAIN                        EQU $D7
00D8                  tknCLEAR                        EQU $D8
00D9                  tknCLOSE                        EQU $D9
00DA                  tknCLG                  EQU $DA
00DB                  tknCLS                  EQU $DB
00DC                  tknDATA                 EQU $DC
00DD                  tknDEF                  EQU $DD
00DE                  tknDIM                  EQU $DE
00DF                  tknDRAW                 EQU $DF
00E0                  tknEND                  EQU $E0
00E1                  tknENDPROC                      EQU $E1
00E2                  tknENVELOPE                     EQU $E2
00E3                  tknFOR                  EQU $E3
00E4                  tknGOSUB                EQU $E4
00E5                  tknGOTO                 EQU $E5
00E6                  tknGCOL                 EQU $E6
00E7                  tknIF                   EQU $E7
00E8                  tknINPUT                        EQU $E8
00E9                  tknLET                  EQU $E9
00EA                  tknLOCAL                EQU $EA
00EB                  tknMODE                 EQU $EB
00EC                  tknMOVE                 EQU $EC
00ED                  tknNEXT                 EQU $ED
00EE                  tknON                   EQU $EE
00EF                  tknVDU                  EQU $EF
00F0                  tknPLOT                 EQU $F0
00F1                  tknPRINT                EQU $F1
00F2                  tknPROC                 EQU $F2
00F3                  tknREAD                 EQU $F3
00F4                  tknREM                  EQU $F4
00F5                  tknREPEAT               EQU $F5
00F6                  tknREPORT               EQU $F6
00F7                  tknRESTORE                      EQU $F7
00F8                  tknRETURN                       EQU $F8
00F9                  tknRUN                  EQU $F9
00FA                  tknSTOP                 EQU $FA
00FB                  tknCOLOR                        EQU $FB
00FC                  tknTRACE                        EQU $FC
00FD                  tknUNTIL                        EQU $FD
00FE                  tknWIDTH                EQU $FE
00FF                  tknOSCLI                        EQU $FF
                                              INCLUDE         "./layout.inc"
                      ***************************************************************************
                      * GENERAL MEMORY MAP AND CONSTANTS
                      ***************************************************************************
                      
                      
0400                  BASWKSP_INTVAR          EQU $400                                ; @%
0480                  BASWKSP_DYNVAR_HEADS    EQU $480
00F6                  BASWKSP_DYNVAR_off_PROC EQU $F6
00F8                  BASWKSP_DYNVAR_off_FN   EQU $F8
046C                  BASWKSP_FPTEMP1         EQU $46C
0471                  BASWKSP_FPTEMP2         EQU $471
0476                  BASWKSP_FPTEMP3         EQU $476
047B                  BASWKSP_FPTEMP4         EQU $47B
0500                  BASWKSP_REPEATSTACK     EQU $500
0528                  BASWKSP_FORSTACK        EQU $528
05CC                  BASWKSP_GOSUBSTACK      EQU $5CC
0600                  BASWKSP_STRING          EQU $600                                        ; note TIME$ trashes BASWKSP-1 if this is moved need to recode
                      
000F                  FORSTACK_ITEM_SIZE      EQU     15
000A                  FORSTACK_MAX_ITEMS      EQU     10
0000                  FORSTACK_OFFS_VARPTR    EQU     0
0002                  FORSTACK_OFFS_VARTYPE   EQU     2
0003                  FORSTACK_OFFS_STEP      EQU     3       ; 5 bytes for real, 4 for int
0008                  FORSTACK_OFFS_TO        EQU     8       ; 5 bytes for real, 4 for int
000D                  FORSTACK_OFFS_LOOP      EQU     13      ; pointer to start of loop instructions
                      
0011                  GOSUBSTACK_MAX          EQU     17
                      
0600                  BAS_StrA                EQU $600
0700                  BAS_InBuf               EQU $700
                      
0000                  VAR_TYPE_BYTE           EQU     $00
0002                  VAR_TYPE_INT_LE         EQU     $02     ; new type, int 32 in LE order for ! operator
0004                  VAR_TYPE_INT            EQU     $04
0005                  VAR_TYPE_REAL           EQU     $05
0080                  VAR_TYPE_STRING_STAT    EQU     $80
0081                  VAR_TYPE_STRING_DYN     EQU     $81
                      
0100                  MACH_STACK_BOT          EQU     $100
0200                  MACH_STACK_TOP          EQU     $200
                      
0440                  VAR_P_PERCENT           EQU     $440
043C                  VAR_O_PERCENT           EQU     $43C
                      
                      ************************** SETUP TABLES AND CODE AREAS ******************************
8000                                          ORG     COMPADDR
                                              SETDP   $00
                      
                      ************************** START MAIN ROM CODE ******************************
                              IF FLEX != 1
8000                  ROMSTART                
                                              INCLUDE         "./rom-header-tube.asm"
                      ; > HeaderROM
                      ; -----------
                      ; ROM header for non-6502 language ROMs to claim *BASIC command if CoPro matches
                      ; target CPU, disables self if CoPro doesn't match target CPU.
                      ;
                      ; TO DO: On 6809Beeb, service entry won't run as it is 6502 code. CHECK does 6809Beeb
                      ; check validity of service entry? If 6809MOS skips ROMs with entry<>6809 "JMP"
                      ; then service code will be ignored and ROM will work.
                      ;
                      ;
                      ; 18-Jan-2001 v0.01 Service code matches *help and *command with ROM title.
                      ;                   *Help prints ROM title and whole version string.
                      ; 15-Aug-2005 v0.02 *Help prints ROM title and version number only.
                      ; 28-Nov-2008 v0.03 *Help optimised slightly.
                      ; 15-Aug-2015 v0.04 Simple non-matched *Help, claims *BASIC command.
                      ; 03-Oct-2015 v0.05 Watches for Tube being set up to disable other ROMs if
                      ;                   not for this CPU and claim *BASIC, checks for Master
                      ;                   giving 'Not a language' on Reset.
                      ; 17-Oct-2015 v0.06 Checks the CPU on the other side of the Tube.
                      
                      
0003                  TUBECPU         EQU     $03     ; $03 = ROM type for CPU
007E                  TUBEMATCH       EQU     $7E     ; $7E = JMP opcode for CPU
                      
                      
8000                  HeaderStart
8000  7E80F7                  JMP     HeaderEnter             ; Allows entry at first byte
                              IF MACH_MATCHBOX
8003  4C                      FCB     $4C                     ; 6502 JMP for service entry
8004  2B                      FCB     HeaderService % 256     ; 6502 service address - little endian
8005  80                      FCB     HeaderService / 256     ; 6502 service address
8006  E3                      FCB     $E0+TUBECPU             ; Service+Language+Tube+CPU
                              ELSE
                              FCB     0,0,0
                              FCB     $60+TUBECPU             ; Lang+6809 BASIC               ; TODO: check beeb6809 service call handler, make it check for valid 6x09 JMP instruction?
                              ENDIF
8007  18                      FCB     HeaderCopyright-HeaderStart
8008  04                      FCB     4                       ; For BASIC, must match which 6502 equivalant to
                                                              ; 0: no offset assembly, no OSCLI
                                                              ; 2: offset assembly, OSCLI, OPENIN/OUT/UP
                                                              ; 4: TIME$
                              IF CPU_6309
                              FCB     "6309"
                              ELSE
8009  36383039                FCB     "6809"
                              ENDIF
800D  20424153494300          FCB     " BASIC",0                      ; ROM title, for BASIC must be <CPU><SPC>"BASIC"
8014  34                      FCB     ((VERSION / 256) & 15)+'0'      ; Version string
8015  2E                      FCB     "."
8016  33                      FCB     ((VERSION / 16) & 15)+'0'
8017  33                      FCB     (VERSION & 15)+'0'
8018                  HeaderCopyright
8018  002843293230323220446F73737900         FCB     0,"(C)2022 Dossy",0             ; Copyright message
8027  00                      FCB     LOADADDR % 256                  ; Second processor transfer address
8028  80                      FCB     LOADADDR / 256                  ; Note stored in little-endian byte order!
8029  00                      FCB     0                               ; 32-bit address
802A  00                      FCB     0
                      
                              ;
802B                  HeaderService
802B  48C901F031C911F05EC927F05AC906F0         FCB     $48,$C9,$01,$F0,$31,$C9,$11,$F0,$5E,$C9,$27,$F0,$5A,$C9,$06,$F0
803B  36C909D030B1F2C90DD02A20E7FFA200         FCB     $36,$C9,$09,$D0,$30,$B1,$F2,$C9,$0D,$D0,$2A,$20,$E7,$FF,$A2,$00
804B  BD0980D002A920C928F00620EEFFE8D0         FCB     $BD,$09,$80,$D0,$02,$A9,$20,$C9,$28,$F0,$06,$20,$EE,$FF,$E8,$D0
805B  EF20E7FF6860AD7A02300AA6F4BDA102         FCB     $EF,$20,$E7,$FF,$68,$60,$AD,$7A,$02,$30,$0A,$A6,$F4,$BD,$A1,$02
806B  29BF9DA1026860A6F0BD02014AB0F6A0         FCB     $29,$BF,$9D,$A1,$02,$68,$60,$A6,$F0,$BD,$02,$01,$4A,$B0,$F6,$A0
807B  00B1FDD0F071FDC8C017D0F9C9EAD0E5         FCB     $00,$B1,$FD,$D0,$F0,$71,$FD,$C8,$C0,$17,$D0,$F9,$C9,$EA,$D0,$E5
808B  A6F4A98E4CF4FFAD0302D0D99848A9FF         FCB     $A6,$F4,$A9,$8E,$4C,$F4,$FF,$AD,$03,$02,$D0,$D9,$98,$48,$A9,$FF
809B  20060490F9A9004848A9F848BAA001A9         FCB     $20,$06,$04,$90,$F9,$A9,$00,$48,$48,$A9,$F8,$48,$BA,$A0,$01,$A9
80AB  004820060468686868A207CAD0FDAEE5         FCB     $00,$48,$20,$06,$04,$68,$68,$68,$68,$A2,$07,$CA,$D0,$FD,$AE,$E5
80BB  FEA9BF20060468A8E07ED09FA20F         FCB     $FE,$A9,$BF,$20,$06,$04,$68,$A8,$E0,TUBEMATCH,$D0,$9F,$A2,$0F
80C9  BDA102294FC943F008BDA10229BF         FCB     $BD,$A1,$02,$29,$4F,$C9,$40+TUBECPU,$F0,$08,$BD,$A1,$02,$29,$BF
80D7  9DA102CA10ECAE8C023009BDA102294F         FCB     $9D,$A1,$02,$CA,$10,$EC,$AE,$8C,$02,$30,$09,$BD,$A1,$02,$29,$4F
80E7  C947F005A6F48E8C02A6F48E4B026860         FCB     $C9,$47,$F0,$05,$A6,$F4,$8E,$8C,$02,$A6,$F4,$8E,$4B,$02,$68,$60
                              ;
80F7                  HeaderEnter
                              ; Language code starts here
                      
80F7  8101                                    CMPA    #1
80F9  270B                                    BEQ     ROM_LANGST
80FB  39                                      RTS
                              ELSE
                                              BRA     FLEX_LANGST
                              ENDIF
80FC  0001            tblTENS_BE              FDB     $0001
80FE  000A                                    FDB     $000A
8100  0064                                    FDB     $0064
8102  03E8                                    FDB     $03E8
8104  2710                                    FDB     $2710
                      
                      ;               ;  LANGUAGE STARTUP
                      ;               ;  ================
                      ;;JGH 15-Jun-2017
                      ;; Startup procedure should be:
                      ;;  Reset stack - we can now do CALLs
                      ;;  Set up direct page in case OSINIT doesn't change it
                      ;;  Initialise error handler - we can now claim BRKV, ask for memory limits and access Direct Page
                      ;;  Doing in this order allows OSINIT to set DP to a per-task area
                      ;;  Claim BRKV as pointed to by OSINIT
                      ;;  Request memory limits
                      ;;  Start initialising memory
                      ;;  DB - 
                      
                      
                              IF FLEX != 1
                      ;
                      ;               ;  LANGUAGE STARTUP
                      ;               ;  ================
8106                  ROM_LANGST      RESET_MACH_STACK
8106  10CE0200                                LDS     #MACH_STACK_TOP
810A  3402                            PSHS    A                                       ; store A
                      
810C  4F                              CLRA
                      ;;              TFR     A, DP                                   ; Default direct page
                      
810D  BDFFBF                          JSR     OSINIT                                  ; A=0, Set up default environment
8110  9754                            STA     ZP_BIGEND
8112  109F50                          STY     ZP_ESCPTR
8115  338D316C                        LEAU    HandleBRK, PCR
8119  EF84                            STU     ,X                                      ; Claim BRKV
                      
811B  338DFEF9                        LEAU    HeaderCopyright, PCR
811F  DFFD                            STU     ZP_MOS_ERROR_PTR_QRY
                      
8121  8684                            LDA     #$84
8123  BDFFF4                          JSR     OSBYTE                                  ; Read top of memory, set HIMEM
8126  9F06                            STX     ZP_HIMEM
8128  308DFED4                        LEAX    ROMSTART,PCR
812C  9C06                            CMPX    ZP_HIMEM                                ; check to see if the returned HIMEM is > than start of ROM
812E  2402                            BHS     1F                                      ; if it is ignore it and set to start of ROM - this for
8130  9F06                            STX     ZP_HIMEM                                ; old matchbox copros with unfixed tube client code
8132  8683            1               LDA     #$83                                    ; DB: must reload value here as A might be set above
8134  BDFFF4                          JSR     OSBYTE
8137  1F10                            TFR     X,D                                     ; A=high byte of returned bottom of memory
8139  8108                            CMPA    #8
813B  2304                            BLS     2F                                      ; Too low, reserve space for workspace
813D  9106                            CMPA    ZP_HIMEM                                ; check to see that returned page isn't too high (matchbox client code fix)
813F  2502                            BLO     1F
8141  8608            2               LDA     #8                                      ; make PAGE at least 800 to leave room for ZP, stack, variable pointers etc
8143  9718            1               STA     ZP_PAGE_H                               ; Read bottom of memory, set PAGE
                                                                                      ; Will need more work to do "per task" memory relocations
                              ELSE
                      FLEX_LANGST
                                      CLRA
                                      TFR     A, DP                                   ; Default direct page
                                      RESET_MACH_STACK
                      
                                      LDA     #$80
                                      LDY     #$00FF
                                      CLR     $FF                                     ; TODOFLEX - how to detect ESCAPE?
                                      STA     ZP_BIGEND
                                      STY     ZP_ESCPTR
                                      LDA     #$8
                                      STA     ZP_PAGE_H
                                      LDX     #$8000
                                      STX     ZP_HIMEM                                ; TODOFLEX this assumes program loaded at $8000 and full 56k memory
                      
                                      ;;CLR   ECHOFLAG                                ; TODOFLEX - is this the right way to turn off local echo?
                              ENDIF
                      
                      ;       IF DEBUG != 0
                      ;               TST     ZP_BIGEND
                      ;               BPL     1F
                      ;               PRINT_STR       "(LE"
                      ;               BRA     2F
                      ;1              PRINT_STR       "(BE"
                      ;2              PRINT_STR       ", page="
                      ;               LDA     ZP_PAGE_H
                      ;               CALL    PRHEX
                      ;               PRINT_STR "00, himem="
                      ;               LDX     ZP_HIMEM
                      ;               CALL    PR2HEX
                      ;
                      ;               PRINT_STR ", swr#="
                      ;
                      ;               LDA     <$F4    ; get current rom number
                      ;               CALL    PRHEX
                      ;
                      ;       IF IF FLEX = 1
                      ;               PRINT_STR ", FLEX)\r"
                      ;       ELSE
                      ;               PRINT_STR ", BBC/CHIP/MB)\r"
                      ;       ENDIF
                      ;       ENDIF
                      
8145  8601                            LDA     #$01
8147  9411                            ANDA    ZP_RND_WA + 4                           ; just bottom bit of +4?
8149  9A10                            ORA     ZP_RND_WA + 3
814B  9A0F                            ORA     ZP_RND_WA + 2
814D  9A0E                            ORA     ZP_RND_WA + 1
814F  9A0D                            ORA     ZP_RND_WA + 0                           ;  Check RND seed
8151  260A                            BNE     1F                                      ;  If nonzero, skip past
8153  CC5241                          LDD     #$5241
8156  DD0F                            STD     ZP_RND_WA + 2                           ;  Set RND seed to "ARW" - Acorn/Roger/Wilson
8158  CC0057                          LDD     #$57
815B  DD0D                            STD     ZP_RND_WA + 0
815D                  1               
                      
815D  0F1F                            CLR     ZP_LISTO                                ;  Set LISTO to 0
815F  7F0400                          CLR     BASWKSP_INTVAR + 0
8162  7F0401                          CLR     BASWKSP_INTVAR + 1                      ;  Set @% to $0000xxxx
8165  86FF                            LDA     #$FF
8167  9723                            STA     ZP_WIDTH                                ;  Set WIDTH to $ff
8169  CC090A                          LDD     #$090A                                  ;  Set up @% (thanks JGH)
816C  FD0402                          STD     BASWKSP_INTVAR + 2
                      
816F                                  CLI                                             ; enable IRQ
816F  1CEF                    ANDCC   #~(CC_I)
8171                                  JUMP    reset_prog_enter_immedprompt            ;  Enable IRQs, jump to immediate loop - DB - I've kept this similar as I may want to add command line params later...
8171  7E92D7                                  JMP     \1
                      
                                      ******************************************
                                      * FLEX - Replacement routines
                                      ******************************************
                      
                              IF FLEX =1
                      PRSTRING        LDA     ,X+
                                      BEQ     1F
                                      JSR     OSASCI                                  ; TODOFLEX: need to check for special chars?
                                      BRA     PRSTRING
                      1               RTS
                      
                      PRHEX           PSHS    A,X
                                      LEAX    1,S
                                      JSR     OUTHEX
                                      PULS    A,X,PC
                      PR2HEX          PSHS    X
                                      LEAX    0,S
                                      JSR     OUTHEX
                                      LEAX    1,S
                                      JSR     OUTHEX
                                      PULS    X,PC
                      OSASCI          cmpa    #$0D            
                                      bne     OSWRCH          
                      OSNEWL          lda     #$0A            
                                      JSR     OSWRCH  
                                      lda     #$0D            
                      OSWRCH          PSHS    A
                                      JSR     PUTCHR
                                      PULS    A,PC
                      
                      OSCLI           PSHS    D,X,U,U,CC
                                      CLRB
                                      LDU     #LINBUF
                                      STU     CBUFPT
                      1               LDA     B,X
                                      STA     B,U
                                      CMPA    #$D
                                      BEQ     1F
                                      INCB
                                      BPL     1B
                      
                      1               JSR     DOCMD
                                      TSTB
                                      BEQ     OSCLI_OK
                                      ORB     #$80                            ; make a BASIC error number from a Flex error number
                      FLEXERROR
                                      LDU     #MACH_STACK_BOT
                                      PSHS    U                               ; "return address" for HandleBRK
                                      STB     ,U+                             ; error number
                                      LEAX    strFLEXERROR,PCR
                      1               LDA     ,X+
                                      STA     ,U+
                                      BNE     1B
                                      JMP     HandleBRK                       ; jump to dynamic error
                      
                      
                      OSCLI_OK                PULS    D,X,U,U,CC,PC
                      
                      OSRDCH          JMP     GETCHR
                                      
                      
                      FLEX_READLINE   CLRB                                    ; TODOFLEX - this is very simplistic
                                      TFR     D,X
                      FLEX_RL_LP      JSR     OSRDCH                          ; get char
                                      CMPA    #$D
                                      BEQ     FLEX_RL_CR
                                      CMPA    #8
                                      BEQ     FLEX_RL_BS
                                      CMPA    #$1B
                                      BEQ     FLEX_RL_ESC
                                      INCB
                                      BEQ     FLEX_RL_FULL
                                      STA     ,X+
                                      ;;JSR   OSWRCH
                                      BRA     FLEX_RL_LP
                      FLEX_RL_FULL
                                      DECB
                      FLEX_RL_BEEP
                                      LDA     #7
                                      JSR     OSWRCH
                                      BRA     FLEX_RL_LP
                      FLEX_RL_CR
                                      INCB
                                      BEQ     FLEX_RL_RTS
                                      STA     ,X+
                                      JSR     OSNEWL
                                      BRA     FLEX_RL_RTS
                      FLEX_RL_BS      TSTB
                                      BEQ     FLEX_RL_BEEP
                                      DECB
                                      LEAX    -1,X
                                      LDA     #' '
                                      JSR     OSWRCH                          ; TODOFLEX - assumes char 8 is backspace
                                      LDA     #8
                                      JSR     OSWRCH
                                      BRA     FLEX_RL_LP
                      
                      FLEX_RL_ESC     SEC
                      FLEX_RL_RTS     RTS
                      
                                      SECTION "tables_and_strings"
                      strFLEXERROR    FCB     "Flex Error",0
                                      CODE
                      
                              ENDIF
                      
                      
                              include         "./tokenstable.asm"
                      ;                       ;  Meaning of ZP_FP_WA_B and ZP_FP_WA_B + 1 in tokenizer loop
                                              ;  ZP_FP_WA_B   +0      +1      State is
                                              ;               FF      0       Middle of statement mode
                                              ;               0       0       Start of statement mode
                                              ;               -       FF      Expect line number next
                      
                      ;                       ;  TOKEN TABLE
                      ;                       ;  ===========
                      ;                       ;  string, token (b7=1), flag
                      ;                       ;
                      ;                       ;  Token flag
                      ;                       ;  Bit 0 - Conditional tokenisation (don't tokenise if followed by an alphabetic character).
                      ;                       ;  Bit 1 - Go into "Middle of Statement" mode.
                      ;                       ;  Bit 2 - Go into "Start of Statement" mode.
                      ;                       ;  Bit 3 - FN/PROC keyword - don't tokenise the name of the subroutine.
                      ;                       ;  Bit 4 - Start tokenising a line number now (after a GOTO, etc...).
                      ;                       ;  Bit 5 - Don't tokenise rest of line (REM , DATA, etc...) ; DB: JGH had this as bit 6
                      ;                       ;  Bit 6 - Pseudo variable flag - add $40 to token if at the start of a 
                                              ;          statement/hex number i.e. PAGE
                      ;                       ;  Bit 7 - Unused - externally used for quote toggle.
                      
0001                  TOK_FLAG_CONDITIONAL    EQU     $01
0000                  BIT_FLAG_CONDITIONAL    EQU     0
                      
0002                  TOK_FLAG_NEXT_MID       EQU     $02
0001                  BIT_FLAG_NEXT_MOD       EQU     1
                      
0004                  TOK_FLAG_NEXT_START     EQU     $04
0002                  BIT_FLAG_NEXT_START     EQU     2
                      
0008                  TOK_FLAG_FNPROC         EQU     $08
0003                  BIT_FLAG_FNPROC         EQU     3
                      
0010                  TOK_FLAG_NEXTLINENO     EQU     $10
0004                  BIT_FLAG_NEXTLINENO     EQU     4
                      
                      
0020                  TOK_FLAG_SKIP_EOL       EQU     $20
0005                  BIT_FLAG_SKIP_EOL       EQU     5
                      
0040                  TOK_FLAG_PSEUDO_VAR     EQU     $40
0006                  BIT_FLAG_PSEUDO_VAR     EQU     6
                      
8174                  tblTOKENS
8174  414E448000                       FCB      "AND",        $80,    $00             ;  00000000
8179  4142539400                       FCB      "ABS",        $94,    $00             ;  00000000
817E  4143539500                       FCB      "ACS",        $95,    $00             ;  00000000
8183  414456414C9600                   FCB      "ADVAL",      $96,    $00             ;  00000000
818A  4153439700                       FCB      "ASC",        $97,    $00             ;  00000000
818F  41534E9800                       FCB      "ASN",        $98,    $00             ;  00000000
8194  41544E9900                       FCB      "ATN",        $99,    $00             ;  00000000
8199  4155544FC610                     FCB      "AUTO",       $C6,    $10             ;  00010000
819F  424745549A01                     FCB      "BGET",       $9A,    $01             ;  00000001
81A5  42505554D503                     FCB      "BPUT",       $D5,    $03             ;  00000011
81AB  434F4C4F5552FB02                  FCB      "COLOUR",     $FB,    $02             ;  00000010
81B3  43414C4CD602                     FCB      "CALL",       $D6,    $02             ;  00000010
81B9  434841494ED702                   FCB      "CHAIN",      $D7,    $02             ;  00000010
81C0  43485224BD00                     FCB      "CHR$",       $BD,    $00             ;  00000000
81C6  434C454152D801                   FCB      "CLEAR",      $D8,    $01             ;  00000001
81CD  434C4F5345D903                   FCB      "CLOSE",      $D9,    $03             ;  00000011
81D4  434C47DA01                       FCB      "CLG",        $DA,    $01             ;  00000001
81D9  434C53DB01                       FCB      "CLS",        $DB,    $01             ;  00000001
81DE  434F539B00                       FCB      "COS",        $9B,    $00             ;  00000000
81E3  434F554E549C01                   FCB      "COUNT",      $9C,    $01             ;  00000001
81EA  434F4C4F52FB02                   FCB      "COLOR",      $FB,    $02             ;  00000010
81F1  44415441DC20                     FCB      "DATA",       $DC,    $20             ;  00100000
81F7  4445479D00                       FCB      "DEG",        $9D,    $00             ;  00000000
81FC  444546DD00                       FCB      "DEF",        $DD,    $00             ;  00000000
8201  44454C455445C710                  FCB      "DELETE",     $C7,    $10             ;  00010000
8209  4449568100                       FCB      "DIV",        $81,    $00             ;  00000000
820E  44494DDE02                       FCB      "DIM",        $DE,    $02             ;  00000010
8213  44524157DF02                     FCB      "DRAW",       $DF,    $02             ;  00000010
8219  454E4450524F43E101                  FCB      "ENDPROC",    $E1,    $01             ;  00000001
8222  454E44E001                       FCB      "END",        $E0,    $01             ;  00000001
8227  454E56454C4F5045E202                  FCB      "ENVELOPE",   $E2,    $02             ;  00000010
8231  454C53458B14                     FCB      "ELSE",       $8B,    $14             ;  00010100
8237  4556414CA000                     FCB      "EVAL",       $A0,    $00             ;  00000000
823D  45524C9E01                       FCB      "ERL",        $9E,    $01             ;  00000001
8242  4552524F528504                   FCB      "ERROR",      $85,    $04             ;  00000100
8249  454F46C501                       FCB      "EOF",        $C5,    $01             ;  00000001
824E  454F528200                       FCB      "EOR",        $82,    $00             ;  00000000
8253  4552529F01                       FCB      "ERR",        $9F,    $01             ;  00000001
8258  455850A100                       FCB      "EXP",        $A1,    $00             ;  00000000
825D  455854A201                       FCB      "EXT",        $A2,    $01             ;  00000001
8262  45444954CE10                     FCB      "EDIT",       $CE,    $10             ;  00010000
8268  464F52E302                       FCB      "FOR",        $E3,    $02             ;  00000010
826D  46414C5345A301                   FCB      "FALSE",      $A3,    $01             ;  00000001
8274  464EA408                         FCB      "FN",         $A4,    $08             ;  00001000
8278  474F544FE512                     FCB      "GOTO",       $E5,    $12             ;  00010010
827E  47455424BE00                     FCB      "GET$",       $BE,    $00             ;  00000000
8284  474554A500                       FCB      "GET",        $A5,    $00             ;  00000000
8289  474F535542E412                   FCB      "GOSUB",      $E4,    $12             ;  00010010
8290  47434F4CE602                     FCB      "GCOL",       $E6,    $02             ;  00000010
8296  48494D454D9343                   FCB      "HIMEM",      $93,    $43             ;  00100011
829D  494E505554E802                   FCB      "INPUT",      $E8,    $02             ;  00000010
82A4  4946E702                         FCB      "IF",         $E7,    $02             ;  00000010
82A8  494E4B455924BF00                  FCB      "INKEY$",     $BF,    $00             ;  00000000
82B0  494E4B4559A600                   FCB      "INKEY",      $A6,    $00             ;  00000000
82B7  494E54A800                       FCB      "INT",        $A8,    $00             ;  00000000
82BC  494E53545228A700                  FCB      "INSTR(",     $A7,    $00             ;  00000000
82C4  4C495354C910                     FCB      "LIST",       $C9,    $10             ;  00010000
82CA  4C494E458600                     FCB      "LINE",       $86,    $00             ;  00000000
82D0  4C4F4144C802                     FCB      "LOAD",       $C8,    $02             ;  00000010
82D6  4C4F4D454D9243                   FCB      "LOMEM",      $92,    $43             ;  00100011
82DD  4C4F43414CEA02                   FCB      "LOCAL",      $EA,    $02             ;  00000010
82E4  4C4546542428C000                  FCB      "LEFT$(",     $C0,    $00             ;  00000000
82EC  4C454EA900                       FCB      "LEN",        $A9,    $00             ;  00000000
82F1  4C4554E904                       FCB      "LET",        $E9,    $04             ;  00000100
82F6  4C4F47AB00                       FCB      "LOG",        $AB,    $00             ;  00000000
82FB  4C4EAA00                         FCB      "LN",         $AA,    $00             ;  00000000
82FF  4D49442428C100                   FCB      "MID$(",      $C1,    $00             ;  00000000
8306  4D4F4445EB02                     FCB      "MODE",       $EB,    $02             ;  00000010
830C  4D4F448300                       FCB      "MOD",        $83,    $00             ;  00000000
8311  4D4F5645EC02                     FCB      "MOVE",       $EC,    $02             ;  00000010
8317  4E455854ED02                     FCB      "NEXT",       $ED,    $02             ;  00000010
831D  4E4557CA01                       FCB      "NEW",        $CA,    $01             ;  00000001
8322  4E4F54AC00                       FCB      "NOT",        $AC,    $00             ;  00000000
8327  4F4C44CB01                       FCB      "OLD",        $CB,    $01             ;  00000001
832C  4F4EEE02                         FCB      "ON",         $EE,    $02             ;  00000010
8330  4F46468700                       FCB      "OFF",        $87,    $00             ;  00000000
8335  4F528400                         FCB      "OR",         $84,    $00             ;  00000000
8339  4F50454E494E8E00                  FCB      "OPENIN",     $8E,    $00             ;  00000000
8341  4F50454E4F5554AE00                  FCB      "OPENOUT",    $AE,    $00             ;  00000000
834A  4F50454E5550AD00                  FCB      "OPENUP",     $AD,    $00             ;  00000000
8352  4F53434C49FF02                   FCB      "OSCLI",      $FF,    $02             ;  00000010
8359  5052494E54F102                   FCB      "PRINT",      $F1,    $02             ;  00000010
8360  504147459043                     FCB      "PAGE",       $90,    $43             ;  01000011
8366  5054528F43                       FCB      "PTR",        $8F,    $43             ;  01000011
836B  5049AF01                         FCB      "PI",         $AF,    $01             ;  00000001
836F  504C4F54F002                     FCB      "PLOT",       $F0,    $02             ;  00000010
8375  504F494E5428B000                  FCB      "POINT(",     $B0,    $00             ;  00000000
837D  50524F43F20A                     FCB      "PROC",       $F2,    $0A             ;  00001010
8383  504F53B101                       FCB      "POS",        $B1,    $01             ;  00000001
8388  52455455524EF801                  FCB      "RETURN",     $F8,    $01             ;  00000001
8390  524550454154F500                  FCB      "REPEAT",     $F5,    $00             ;  00000000
8398  5245504F5254F601                  FCB      "REPORT",     $F6,    $01             ;  00000001
83A0  52454144F302                     FCB      "READ",       $F3,    $02             ;  00000010
83A6  52454DF420                       FCB      "REM",        $F4,    $20             ;  00100000
83AB  52554EF901                       FCB      "RUN",        $F9,    $01             ;  00000001
83B0  524144B200                       FCB      "RAD",        $B2,    $00             ;  00000000
83B5  524553544F5245F712                  FCB      "RESTORE",    $F7,    $12             ;  00010010
83BE  52494748542428C200                  FCB      "RIGHT$(",    $C2,    $00             ;  00000000
83C7  524E44B301                       FCB      "RND",        $B3,    $01             ;  00000001
83CC  52454E554D424552CC10                  FCB      "RENUMBER",   $CC,    $10             ;  00010000
83D6  535445508800                     FCB      "STEP",       $88,    $00             ;  00000000
83DC  53415645CD02                     FCB      "SAVE",       $CD,    $02             ;  00000010
83E2  53474EB400                       FCB      "SGN",        $B4,    $00             ;  00000000
83E7  53494EB500                       FCB      "SIN",        $B5,    $00             ;  00000000
83EC  535152B600                       FCB      "SQR",        $B6,    $00             ;  00000000
83F1  5350438900                       FCB      "SPC",        $89,    $00             ;  00000000
83F6  53545224C300                     FCB      "STR$",       $C3,    $00             ;  00000000
83FC  535452494E472428C400                  FCB      "STRING$(",   $C4,    $00             ;  00000000
8406  534F554E44D402                   FCB      "SOUND",      $D4,    $02             ;  00000010
840D  53544F50FA01                     FCB      "STOP",       $FA,    $01             ;  00000001
8413  54414EB700                       FCB      "TAN",        $B7,    $00             ;  00000000
8418  5448454E8C14                     FCB      "THEN",       $8C,    $14             ;  00010100
841E  544FB800                         FCB      "TO",         $B8,    $00             ;  00000000
8422  544142288A00                     FCB      "TAB(",       $8A,    $00             ;  00000000
8428  5452414345FC12                   FCB      "TRACE",      $FC,    $12             ;  00010010
842F  54494D459143                     FCB      "TIME",       $91,    $43             ;  01000011
8435  54525545B901                     FCB      "TRUE",       $B9,    $01             ;  00000001
843B  554E54494CFD02                   FCB      "UNTIL",      $FD,    $02             ;  00000010
8442  555352BA00                       FCB      "USR",        $BA,    $00             ;  00000000
8447  564455EF02                       FCB      "VDU",        $EF,    $02             ;  00000010
844C  56414CBB00                       FCB      "VAL",        $BB,    $00             ;  00000000
8451  56504F53BC01                     FCB      "VPOS",       $BC,    $01             ;  00000001
8457  5749445448FE02                   FCB      "WIDTH",      $FE,    $02             ;  00000010
845E  50414745D000                     FCB      "PAGE",       $D0,    $00             ;  00000000
8464  505452CF00                       FCB      "PTR",        $CF,    $00             ;  00000000
8469  54494D45D100                     FCB      "TIME",       $D1,    $00             ;  00000000
846F  4C4F4D454DD200                   FCB      "LOMEM",      $D2,    $00             ;  00000000
8476  48494D454DD300                   FCB      "HIMEM",      $D3,    $00             ;  00000000
847D  4D697373696E67208D00                  FCB      "Missing ",   $8D,    $00
                      ; END
                      
                      
                      
                      
                      ;               
                      ;               
                      ;               ;  Look up FN/PROC address
                      ;               ;  =======================
                      ;               ;  On entry, B=length of name
                      ;               ;            [ZP_GEN_PTR+2]+1=>FN/PROC token (ie, first character of name)
8487  3440            findFNPROC      PSHS    U
8489  D737                            STB     ZP_NAMELENORVT                  ;  Store length of name
848B  DE39                            LDU     ZP_GEN_PTR+2
848D  A641                            LDA     1,U                             ;  Get FN/PROC character
848F  C6F6                            LDB     #BASWKSP_DYNVAR_off_PROC        ;  Preload with offset to PROC list
8491  81F2                            CMPA    #tknPROC
8493  270D                            BEQ     findLinkedListNewAPI            ;  If PROC, follow PROC list
8495  C6F8                            LDB     #BASWKSP_DYNVAR_off_FN
8497  2009                            BRA     findLinkedListNewAPI            ;  Otherwise, follow FN list
                      ;               
                      ;               
                      ;                       ;  Look up variable address
                      ;                       ;  ========================
                      ;                       ;  On entry, B=1 + length of name
                      ;                       ;            [ZP_GEN_PTR+2]+1=>first character of name
                                              ;  On exit
                                              ;       Z = 1 for not found
                                              ;       else X and ZP_INT_WA + 2 points at variable data
8499                  findVarDynLL_NewAPI
8499  3440                            PSHS    U
849B  D737                            STB     ZP_NAMELENORVT                  ;  Store length of name
849D  DE39                            LDU     ZP_GEN_PTR+2
849F  E641                            LDB     1,U                             ;  Get initial letter
84A1  58                              ASLB
                      ;                       ;  Follow linked variable list to find named item
                      ;                       ;  ----------------------------------------------
                      ;                       ;  B = offset in Page 4 link start table
84A2                  findLinkedListNewAPI
84A2  8604                            LDA     #BASWKSP_INTVAR / 256
84A4  1F01                            TFR     D,X
                      ;               LDX     ,X                              ; X contains pointer to first var block (or zero)
                      ;               BRA     fll_skitem                                                              
84A6                  fll_nextItem    
84A6  C602                            LDB     #2
84A8  AE84                            LDX     ,X
84AA  271B            fll_skitem      BEQ     fll_sk_nomatch                          
                                      *STX    ZP_INT_WA + 2                   ; store pointer
84AC  A685            fll_chlp        LDA     B,X
84AE  270F                            BEQ     fll_sk_nameEnd
84B0  A1C5                            CMPA    B,U
84B2  26F2                            BNE     fll_nextItem
84B4  5C                              INCB
84B5  D137                            CMPB    ZP_NAMELENORVT                  ; at end of name?
84B7  26F3                            BNE     fll_chlp
84B9  A685                            LDA     B,X                             ; at end of name - check 0 term in dynvar
84BB  26E9                            BNE     fll_nextItem
84BD  2004                            BRA     fll_match
                      ;
84BF                  fll_sk_nameEnd
84BF  D137                            CMPB    ZP_NAMELENORVT
84C1  26E3                            BNE     fll_nextItem
84C3  5C              fll_match       INCB
84C4  3A                              ABX
84C5  9F2C                            STX     ZP_INT_WA + 2                   ; ZP_INT_WA points at the start of the variable data
84C7                  fll_sk_nomatch
84C7  35C0                            PULS    U,PC                            ;  not matched Z = 1
                      
                      
                                      ;  Search for program line
                                      ;  =======================
                                      ; NEW API
                                      ;  On entry,    ZP_INT_WA + 2 => line number
                                      ;  On Exit,     X,Y and ZP_FPB + 2 => program line start or next line (points at the 0D at start of this line)
                                      ;               Cy=1 indicates line found
                                      ;               Cy=0 not found
                              ;  TODO: check all occurrences and remove store to ZP_FPB if not ever used
                                      ; OLD API
                                      ;  On entry,    ZP_INT_WA = line number
                                      ;  On exit,  ZP_FPB + 2 =>program line, or next line
                                      ;            CS = line found
                                      ;            CC = line not found
                                      ;           NOTE: Y = 2 always - TODO: Remove ?
                                      
84C9                  findProgLineNewAPI      
84C9  9618                            LDA     ZP_PAGE_H               ; X points at start of Program
84CB  5F                              CLRB
84CC  1F01                            TFR     D,X
84CE  EC01            fpl_lp1         LDD     1,X                     ; get 16 bit line number at +1
84D0  10932C                          CMPD    ZP_INT_WA + 2
84D3  2405                            BHS     fpl_ge
84D5  E603                            LDB     3,X
84D7  3A                              ABX
84D8  20F4                            BRA     fpl_lp1
84DA  2602            fpl_ge          BNE     flp_sk1
84DC                                  SEC
84DC  1A01                    ORCC    #CC_C
84DE  9F3D            flp_sk1         STX     ZP_FPB + 2
84E0  3384                            LEAU    ,X
84E2  39                              RTS
                      ;               
                      ;               
                      ;;findProgLineNewAPI: 
                      ;;              STZ ZP_FPB + 2
                      ;;              LDA ZP_PAGE_H
                      ;;              STA ZP_FPB + 3                  ;  Start at PAGE
                      ;;@lp1:         LDU #$01
                      ;;              LDA (ZP_FPB + 2),Y                      ;  Check line number high byte
                      ;;              CMP ZP_INT_WA + 1
                      ;;              BCS @sk1                                ;  Partial match, jump to check low byte
                      ;;@lp2:         LDU #$03
                      ;;              LDA (ZP_FPB + 2),Y                      ;  Get line length
                      ;;              ADC ZP_FPB + 2
                      ;;              STA ZP_FPB + 2                  ;  Step to next line
                      ;;              BCC @lp1
                      ;;              INC ZP_FPB + 3
                      ;;              BRA @lp1                                ;  Loop back to check next line
                      ;;@sk1:         BNE @sk2                                ;  Gone past target, jump to return CC and Y=2
                      ;;              INY
                      ;;              LDA (ZP_FPB + 2),Y                      ;  Check line number low byte
                      ;;              CMP ZP_INT_WA
                      ;;              BCC @lp2                                ;  line < target, step to next line
                      ;;              BNE @sk2                                ;  Line not equal, jump to return CC
                      ;;              RTS                                     ;  Line found, return CS and Y=2
                      ;;@sk2:         LDU #$02
                      ;;              CLC
                      ;;              RTS                                     ;  Line not found, return CC and Y=2
                      ;
                      ;                       
                      ;                       
                      ;                       
                      ;                       
                      ;               ;  Integer division
                      ;               ;  ================
                      ;               ;  On entry, $2A-$2D (IntA)  =  integer LHS of A DIV B or A MOD B
                      ;               ;            $30-$34 (RealA) =  real LHS of A DIV B or A MOD B
                      ;               ;            Program pointer => RHS of expression
                      ;               ;  On exit,  $39-$3C = result, $37=sign of result
                      ;               ;            $3D-$40 = remainder, $38=sign of remainder
                      ;               ;
84E3                  evalDoIntDivide                                         ; L80F9
84E3                                  CALL    checkTypeInAConvert2INT         ;  Convert Real to Integer
84E3                  9
84E5                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84E3  BD986F                                  JSR     \1
                              ENDIF
84E6  962A                            LDA     ZP_INT_WA + 0
84E8  A7E2                            STA     ,-S                             ; save sign of LHS as sign of remainder
84EA                                  CALL    intWA_ABS                       ; Ensure LHS is positive
84EA                  9
84EC                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
000E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84EA  BDACFA                                  JSR     \1
                              ENDIF
84ED                                  CALL    stackINTEvalLevel2              ; Stack LHS, evaluate RHS
84ED                  9
84EF                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84ED  BDA0AC                                  JSR     \1
                              ENDIF
84F0  D727                            STB     ZP_VARTYPE                      ; Save current token
84F2                                  CALL    checkTypeInAConvert2INT         ; Save next character, convert Real to Int
84F2                  9
84F4                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84F2  BD986F                                  JSR     \1
                              ENDIF
84F5  A6E0                            LDA     ,S+                             ; get back sign of remainder
84F7  982A                            EORA    ZP_INT_WA + 0                   
84F9  9737                            STA     ZP_GEN_PTR                      ; EOR with sign of RHS to get sign of result
84FB                                  CALL    intWA_ABS                       ; Ensure RHS is positive
84FB                  9
84FD                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
84FB  BDACFA                                  JSR     \1
                              ENDIF
84FE  8E0039                          LDX     #ZP_INT_WA_B                    
8501                                  CALL    popIntAtXNew                    ; Pop LHS from stack to IntB at $39-$3C
8501                  9
8503                  __XBSR                  SET 9B+2
3600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8501  BDBBFF                                  JSR     \1
                              ENDIF
8504  4F                              CLRA
8505  973D                            STA     ZP_INT_WA_C
8507  973E                            STA     ZP_INT_WA_C + 1
8509  973F                            STA     ZP_INT_WA_C + 2
850B  9740                            STA     ZP_INT_WA_C + 3                 ; Clear remainder in IntC
850D                                  CALL    IntWAZero                       ; Check if IntA is zero
850D                  9
850F                  __XBSR                  SET 9B+2
3400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
850D  BDB9D6                                  JSR     \1
                              ENDIF
8510  2745                            BEQ     brkDivideByZero                 ; Error if divide by zero
8512  C620                            LDB     #$20                            ; 32-bit division
8514  D743                            STB     ZP_FP_TMP
                      
                                      ; TODO - bytewise shift here should speed things up
                      
8516                  1                                                       ; L812D
8516  0A43                            DEC     ZP_FP_TMP
8518  273C                            BEQ     2F                              ; All bits done
851A  083C                            ASL     ZP_INT_WA_B + 3
851C  093B                            ROL     ZP_INT_WA_B + 2
851E  093A                            ROL     ZP_INT_WA_B + 1
8520  0939                            ROL     ZP_INT_WA_B + 0                 ; Result=Result*2
8522  2AF2                            BPL     1B                              ; Loop if no zero bit
8524                  3                                                       ; L813A:
8524  093C                            ROL     ZP_INT_WA_B + 3                 ; Result=Result*2
8526  093B                            ROL     ZP_INT_WA_B + 2
8528  093A                            ROL     ZP_INT_WA_B + 1
852A  0939                            ROL     ZP_INT_WA_B + 0
852C  0940                            ROL     ZP_INT_WA_C + 3                 ; Remainder=Remainder*2+1 
852E  093F                            ROL     ZP_INT_WA_C + 2                 ; (there is always a carry from WA_B 
8530  093E                            ROL     ZP_INT_WA_C + 1                 ; as it was PL at end of loop above)
8532  093D                            ROL     ZP_INT_WA_C + 0                         
                      
8534  DC3F                            LDD     ZP_INT_WA_C + 2
8536  932C                            SUBD    ZP_INT_WA + 2
8538  3406                            PSHS    D
853A  DC3D                            LDD     ZP_INT_WA_C + 0
853C  D22B                            SBCB    ZP_INT_WA + 1
853E  922A                            SBCA    ZP_INT_WA + 0
8540  2508                            BCS     4F                              ; Couldn't subtract, do next bit
8542  DD3D                            STD     ZP_INT_WA_C + 0
8544  3506                            PULS    D
8546  DD3F                            STD     ZP_INT_WA_C + 2                 ; Remainder=Remainder-Divisor
8548  2006                            BRA     5F                              ; Loop to do next bit
854A                  4                                                       ; L816C:
854A                                  CLC                             ; swap carry
854A  1CFE                    ANDCC   #~CC_C
854C  3262                            LEAS    2,S                             ; Couldn't subtract, drop stacked value
854E  2002                            BRA     6F
8550                  5                                                       ; L816E:
8550                                  SEC                             ; swap carry
8550  1A01                    ORCC    #CC_C
8552  0A43            6               DEC     ZP_FP_TMP
8554  26CE                            BNE     3B                              ; Loop for another bit
8556                  2                                                       ; L8171
8556  39                              RTS                                     ; All done, return
                      
8557                  brkDivideByZero
8557                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8557  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8558  124469766973696F6E206279207A65726F00                 FCB     $12,"Division by zero",0
                      
                      
                      ;               ;  Convert Integer to Real
                      ;               ;  =======================
                      ;               ;  On entry, $2A-$2D (IntA) = Integer
                      ;               ;  On exit,  $2E=sign of real
                      ;               ; TODO - this first bit of shuffling could be done better with D/16
856A                  IntToReal
856A  4F                              CLRA
856B  9735                            STA     ZP_FPA + 7
856D  972F                            STA     ZP_FPA + 1                              ; Clear rounding byte and exponent high byte
856F                  IntToReal2                                                      ; L8189
856F  962A                            LDA     ZP_INT_WA + 0
8571  972E                            STA     ZP_FPA                          ; set sign from integer sign
8573  2A05                            BPL     Int2R_skPos                             ; Copy IntA sign to RealA sign, jump if positive
8575                                  CALL    negateIntA                              ; Convert negative IntA to positive
8575                  9
8577                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8575  BDAD1B                                  JSR     \1
                              ENDIF
                      
                                      ; left justify the integer in the FPA register mantissa
                      
8578  962A                            LDA     ZP_INT_WA + 0                           
857A                  Int2R_skPos                                                     ; L8194:
857A  2622                            BNE     IntToReal_left32                                        ; Top byte nonzero, so jump to convert
857C  0F34                            CLR     ZP_FPA + 6
857E  962B                            LDA     ZP_INT_WA + 1
8580  2614                            BNE     IntToReal_left24                                        ; Clear RealA, if next byte nonzero jump to convert
8582  0F33                            CLR     ZP_FPA + 5
8584  962C                            LDA     ZP_INT_WA + 2
8586  2606                            BNE     IntToReal_left16                                        ; Clear RealA, if next byte nonzero jump to convert
8588  0F32                            CLR     ZP_FPA + 4
858A  962D                            LDA     ZP_INT_WA + 3
858C  202D                            BRA     IntToReal_skSetB88cont                  ;  Clear RealA, if next byte nonzero jump to convert
                      
                      ;               ;  INT=$0000xxyy where xx<>00
                      ;               ;  ----------------------
                      
858E                  IntToReal_left16                                                        ; L81A8
858E  D62D                            LDB     ZP_INT_WA + 3
8590  D732                            STB     ZP_FPA + 4                              ;  Copy $yy000000 to mantissa
8592  C690                            LDB     #$90
8594  2027                            BRA     IntToReal_Normalize                                     ;  Normalise 16 bits
                      
                      ;               ;  INT=$00xxyyyy where xx<>00, A = $xx
                      ;               ;  -----------------------------
8596                  IntToReal_left24                                                ; L81B0
8596  9E2C                            LDX     ZP_INT_WA + 2
8598  9F32                            STX     ZP_FPA + 4                              ;  Copy $yyyy0000 to mantissa
859A  C698                            LDB     #$98
859C  201F                            BRA     IntToReal_Normalize                                     ;  Normalise 24 bits
                      
                      ;               ;  $xxyyyyyy when xx<>00, A = $xx
                      ;               ;  ----------------------------
859E                  IntToReal_left32                                                ; L81BC
859E  9E2B                            LDX     ZP_INT_WA + 1
85A0  9F32                            STX     ZP_FPA + 4                              ;  Copy $yyyyyy00 to mantissa
85A2  D62D                            LDB     ZP_INT_WA + 3
85A4  D734                            STB     ZP_FPA + 6
85A6  C6A0                            LDB     #$A0
85A8  2013                            BRA     IntToReal_Normalize                                     ;  Normalise 32 bits
                      
                      ;               ;  Return Real zero
                      ;               ;  ----------------
                                              ; expects A=0 on entry, trashes B
85AA                  IntToReal_retReal0
85AA  5F                              CLRB
85AB  DD2E                            STD     ZP_FPA
85AD  DD30                            STD     ZP_FPA + 2
                      
85AF  39              anRTS8          RTS
                      
85B0                  IntToReal_8signedA2real_check                           ; L81D5
85B0                                  CALL    zero_FPA
85B0                  9
85B2                  __XBSR                  SET 9B+2
2100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
85B0  BDA6ED                                  JSR     \1
                              ENDIF
85B3  4D                              TSTA
85B4  2A05                            BPL     IntToReal_skSetB88cont
85B6  972E                            STA     ZP_FPA
85B8  88FF                            EORA    #$FF
85BA  4C                              INCA
85BB                  IntToReal_skSetB88cont                                  ; L81E0
85BB  C688                            LDB     #$88                            ;  Normalise 8 bits
                      
                      ;                       ;  Normalise RealA
                      ;                       ;  ---------------
                      ;                       ;  On entry, A=high byte of mantissa, B=exponent
                      ;                       ;  On exit,  exponent and mantissa in RealA normalised
85BD                  IntToReal_Normalize                                     ; L81E2
85BD  4D                              TSTA
85BE  2B0C                            BMI     IntToReal_Normalize_sk0         ; Top bit set, it is normalized
85C0  27E8                            BEQ     IntToReal_retReal0              ; Zero, jump to return Real zero
85C2                  IntToReal_Normalize_lp                                  ; L81E8
85C2  5A                              DECB                                    ; Decrease exponent, dividing number by 2
85C3  0834                            ASL     ZP_FPA + 6
85C5  0933                            ROL     ZP_FPA + 5
85C7  0932                            ROL     ZP_FPA + 4                      ; Multiply mantissa by 2, keeping number the same
85C9  49                              ROLA
85CA  2AF6                            BPL     IntToReal_Normalize_lp          ; Loop while exponent still >= $80+0
85CC                  IntToReal_Normalize_sk0                                 ; L81F2
85CC  9731                            STA     ZP_FPA + 3                      ; store MSB
85CE  D730                            STB     ZP_FPA + 2                      ; store exponent
85D0  39                              RTS                                     ; Store mantissa and exponent, return
                      ;               
                      ;                       ;  Normalise RealA
                      ;                       ;  ---------------
85D1                  NormaliseRealA
85D1  9631                            LDA     ZP_FPA + 3                      ; Get mantissa top byte
85D3                  NormaliseRealA_2
85D3  2BDA                            BMI     anRTS8                          ; top bit set, return
85D5                  NormaliseRealA_3
85D5  2620                            BNE     __NormaliseRealA_sk2            ; Nonzero, skip zero test
85D7  9A32                            ORA     ZP_FPA + 4
85D9  9A33                            ORA     ZP_FPA + 5                      ; Check if mantissa is zero
85DB  9A34                            ORA     ZP_FPA + 6
85DD  9A35                            ORA     ZP_FPA + 7
85DF  27C9                            BEQ     IntToReal_retReal0              ; Jump to return Real zero
85E1  9E2F                            LDX     ZP_FPA + 1                      ; Not zero, get exponent
85E3                  NormaliseRealA_lp1                                      ; If we got here top byte of mantissa is empty, shift mant up 8 and dec the exp
85E3  DC32                            LDD     ZP_FPA + 4
85E5  DD31                            STD     ZP_FPA + 3
85E7  DC34                            LDD     ZP_FPA + 6
85E9  DD33                            STD     ZP_FPA + 5
85EB  0F35                            CLR     ZP_FPA + 7
85ED  3018                            LEAX    -8,X                            ; Decrease exponent by 8
85EF                  NormaliseRealA_sk1
85EF  0D31                            TST     ZP_FPA + 3
85F1  27F0                            BEQ     NormaliseRealA_lp1              ; Mantissa top byte still zero, need to normalise more
85F3  2B14                            BMI     __NormaliseRealA_sk5            ; Fully normalised, store and return
85F5  2002                            BRA     __NormaliseRealA_sk3            ; Less than 8 bits left to normalise
85F7                  __NormaliseRealA_sk2
85F7  9E2F                            LDX     ZP_FPA + 1                      ;  Get exponent
85F9                  __NormaliseRealA_sk3
85F9  DC31                            LDD     ZP_FPA + 3
85FB                  NormaliseRealA_lp2
85FB  301F                            LEAX    -1,X                            ;  Decrease exponent by 1
85FD                  NormaliseRealA_sk4
85FD  0835                            ASL     ZP_FPA + 7
85FF  0934                            ROL     ZP_FPA + 6                      ;  Multiply mantissa by 2
8601  0933                            ROL     ZP_FPA + 5
8603  59                              ROLB
8604  49                              ROLA
8605  2AF4                            BPL     NormaliseRealA_lp2              ;  Still not normalise, loop for another bit
8607  DD31                            STD     ZP_FPA + 3
8609                  __NormaliseRealA_sk5
8609  9F2F                            STX     ZP_FPA + 1
860B  39                              RTS                             ;  Store exponent and return
                      ;               
                      ;                       ;  Convert float to integer
                      ;                       ;  ========================
                      ;                       ;  On entry, FloatA (ZP_FPA + 0..7) holds a float (extended exponent ignored but sign byte at ZP_FPA is used)
                      ;                       ;  On exit,  FloatA (ZP_FPA + 2..7) holds integer part
                      ;                       ;  ---------------------------------------------
                      ;                       ;  The real value is partially denormalised by repeatedly dividing the mantissa
                      ;                       ;  by 2 and incrementing the exponent to multiply the number by 2, until the
                      ;                       ;  exponent is $80, indicating that we have got to mantissa * 2^0.
                      ;                       ;
860C                  fpAMant2Int
860C  9630                            LDA     ZP_FPA + 2
860E  2A28                            BPL     fpAMant2Int_sk1                 ; Exponent<$80, number<1, jump to return 0
8610  0D31                            TST     ZP_FPA + 3
8612  2776                            BEQ     fpMant2Int_CheckSignAndNegate   ; Mantissa = $00xxxxxx, real holds an int, jump to check for negative
8614                  fpAMant2Int_lp1
8614  0431                            LSR     ZP_FPA + 3
8616  0632                            ROR     ZP_FPA + 4                      ; Divide the mantissa by 2 to denormalise by one power
8618  0633                            ROR     ZP_FPA + 5
861A  0634                            ROR     ZP_FPA + 6
861C  4C                              INCA
861D  2764                            BEQ     fpMant2Int_brkTooBig            ; Inc. exponent, if run out of exponent, jump to 'Too big'
861F  81A0            fpAMant2Int_lp2 CMPA    #$A0
8621  2463                            BHS     fpMant2Int_brkTooBigIfNE        ; Exponent is +32, float has been denormalised to an integer
8623  8199                            CMPA    #$99
8625  24ED                            BHS     fpAMant2Int_lp1                 ; Loop to keep dividing
8627  8B08                            ADDA    #$08                            ; Increment exponent by 8
8629  9E32                            LDX     ZP_FPA + 4
862B  9F33                            STX     ZP_FPA + 5                      ; Divide mantissa by 2^8
862D  D631                            LDB     ZP_FPA + 3
862F  D732                            STB     ZP_FPA + 4
8631  0F31                            CLR     ZP_FPA + 3
8633  20EA                            BRA     fpAMant2Int_lp2                 ; Loop to keep dividing
                      
                      
8635                  fpFPAtoFPBzeroFPA
8635                                  CALL fpCopyFPAtoFPB
8635                  9
8637                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8635  BDA498                                  JSR     \1
                              ENDIF
8638                  fpAMant2Int_sk1 JUMP    zero_FPA
8638  7EA6ED                                  JMP     \1
                      
863B                  fpFPAMant2Int_remainder_inFPB                           ; L8275
863B  9630                            LDA     ZP_FPA + 2
863D  2AF6                            BPL     fpFPAtoFPBzeroFPA               ; if exponent < $80 then zero FPA and copy FPA to FPB
863F                                  CALL    fpSetRealBto0
863F                  9
8641                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
863F  BDA5B9                                  JSR     \1
                              ENDIF
8642  D631                            LDB     ZP_FPA + 3                      ; get mantissa MSB return 0 or -1 depending on sign
8644  2744                            BEQ     fpMant2Int_CheckSignAndNegate   ; L827E
8646                  L8280
8646  0431                            LSR     ZP_FPA + 3                      ; roll A mantissa into B mantissa
8648  0632                            ROR     ZP_FPA + 4
864A  0633                            ROR     ZP_FPA + 5
864C  0634                            ROR     ZP_FPA + 6
864E  063D                            ROR     ZP_FPB + 2
8650  063E                            ROR     ZP_FPB + 3
8652  063F                            ROR     ZP_FPB + 4
8654  0640                            ROR     ZP_FPB + 5
8656  4C                              INCA
8657  272A                            BEQ     fpMant2Int_brkTooBig
8659                  L8293
8659  81A0                            CMPA    #$A0                            ; compare to A0, i.e. $80 + 32
865B  2429                            BHS     fpMant2Int_brkTooBigIfNE        ; if so then if equal return else too big
865D  8199                            CMPA    #$99
865F  24E5                            BHS     L8280                           ; keep rolling bitwise
8661  8B08                            ADDA    #$08                            ; else roll bytewise
8663  D63F                            LDB     ZP_FPB + 4
8665  D740                            STB     ZP_FPB + 5
8667  D63E                            LDB     ZP_FPB + 3
8669  D73F                            STB     ZP_FPB + 4
866B  D63D                            LDB     ZP_FPB + 2
866D  D73E                            STB     ZP_FPB + 3
                                      
866F  D634                            LDB     ZP_FPA + 6
8671  D73D                            STB     ZP_FPB + 2
                                      
8673  D633                            LDB     ZP_FPA + 5
8675  D734                            STB     ZP_FPA + 6              
8677  D632                            LDB     ZP_FPA + 4
8679  D733                            STB     ZP_FPA + 5              
867B  D631                            LDB     ZP_FPA + 3
867D  D732                            STB     ZP_FPA + 4
                                      
867F  0F31                            CLR     ZP_FPA + 3
8681  20D6                            BRA L8293
8683                  fpMant2Int_brkTooBig
8683                                  JUMP    brkTooBig
8683  7EA6FE                                  JMP     \1
8686                  fpMant2Int_brkTooBigIfNE                                ; L82C0
8686  26FB                            BNE     fpMant2Int_brkTooBig            ; Exponent>32, jump to 'Too big' error
8688  9730                            STA     ZP_FPA + 2                      ; Store +32 exponent
868A                  fpMant2Int_CheckSignAndNegate                           ; L82C4
868A  962E                            LDA     ZP_FPA                  ; sign byte
868C  2A10                            BPL     fpMant2Int_RTS                  ; If positive, jump to return
868E                  fpReal2Int_NegateMantissa                               ; L82C8
                                      ;  Negate the mantissa to get integer
868E  CC0000                          LDD     #0
8691  9333                            SUBD    ZP_FPA + 5
8693  DD33                            STD     ZP_FPA + 5
8695  CC0000                          LDD     #0
8698  D232                            SBCB    ZP_FPA + 4
869A  9231                            SBCA    ZP_FPA + 3
869C  DD31                            STD     ZP_FPA + 3
869E                  fpMant2Int_RTS                                          ; L82DF
869E  39                              RTS
869F                  L82E0
869F  9630                            LDA     ZP_FPA + 2
86A1  2B05                            BMI     L82E9
86A3  0F49                            CLR     ZP_FP_TMP + 6
86A5                                  JUMP    fpCheckMant0SetSignExp0
86A5  7EA47F                                  JMP     \1
86A8                  L82E9           CALL    fpFPAMant2Int_remainder_inFPB
86A8                  9
86AA                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
86A8  8D91                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
86AA  9634                            LDA     ZP_FPA + 6
86AC  9749                            STA     ZP_FP_TMP + 6
86AE                                  CALL    fpCopyBManttoA_NewAPI
86AE                  9
86B0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
86AE  8D61                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
86B0  8680                            LDA     #$80
86B2  9730                            STA     ZP_FPA + 2
86B4  D631                            LDB     ZP_FPA + 3
86B6  2A0E                            BPL     L830A
86B8  982E                            EORA    ZP_FPA
86BA  972E                            STA     ZP_FPA
86BC  2A04                            BPL     L8305
86BE  0C49                            INC     ZP_FP_TMP + 6
86C0  2002                            BRA     L8307
86C2  0A49            L8305           DEC     ZP_FP_TMP + 6
86C4                  L8307           CALL    fpReal2Int_NegateMantissa
86C4                  9
86C6                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
86C4  8DC8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
86C6                  L830A           JUMP    NormaliseRealA
86C6  7E85D1                                  JMP     \1
                      
86C9                  fpIncrementFPAMantissa                                  ; L830D
86C9  0C34                            INC     ZP_FPA + 6
86CB  260C                            BNE     L831D
86CD  0C33                            INC     ZP_FPA + 5
86CF  2608                            BNE     L831D
86D1  0C32                            INC     ZP_FPA + 4
86D3  2604                            BNE     L831D
86D5  0C31                            INC     ZP_FPA + 3
86D7  27AA                            BEQ     fpMant2Int_brkTooBig
86D9                  L831D
86D9  39                              RTS
                                      ; make next random
                                      ; not order of storage is different to 6502
                                      ; 0 -> 3
                                      ; 1 -> 2
                                      ; 2 -> 1
                                      ; 3 -> 0
                                      ; 4 -> 4
86DA                  rndNext                                         ; L831E
86DA  C604                            LDB     #4
86DC  D743                            STB     ZP_FP_TMP
86DE  0611            1               ROR     ZP_RND_WA + 4
86E0  960D                            LDA     ZP_RND_WA + 0
86E2  1F89                            TFR     A,B
86E4  46                              RORA
86E5  9711                            STA     ZP_RND_WA + 4
86E7  960E                            LDA     ZP_RND_WA + 1
86E9  970D                            STA     ZP_RND_WA + 0
86EB  44                              LSRA
86EC  980F                            EORA    ZP_RND_WA + 2
86EE  840F                            ANDA    #$0F
86F0  980F                            EORA    ZP_RND_WA + 2
86F2  46                              RORA
86F3  46                              RORA
86F4  46                              RORA
86F5  46                              RORA
86F6  9811                            EORA    ZP_RND_WA + 4
86F8  D711                            STB     ZP_RND_WA + 4
86FA  D60F                            LDB     ZP_RND_WA + 2
86FC  D70E                            STB     ZP_RND_WA + 1
86FE  D610                            LDB     ZP_RND_WA + 3
8700  D70F                            STB     ZP_RND_WA + 2
8702  9710                            STA     ZP_RND_WA + 3
8704  0A43                            DEC     ZP_FP_TMP
8706  26D6                            BNE     1B
8708  39                              RTS
                      
8709                  fpCopyBtoA_NewAPI                                       ; L8349         - note TRASHES B
8709  DC3B                            LDD     ZP_FPB
870B  972E                            STA     ZP_FPA
870D  0F2F                            CLR     ZP_FPA + 1
870F  D730                            STB     ZP_FPA + 2
8711                  fpCopyBManttoA_NewAPI                                   ; L8353         - note TRASHES B
8711  DC3D                            LDD     ZP_FPB + 2
8713  DD31                            STD     ZP_FPA + 3
                      
8715  DC3F                            LDD     ZP_FPB + 4
8717  DD33                            STD     ZP_FPA + 5
                      
8719  9641                            LDA     ZP_FPB + 6
871B  9735                            STA     ZP_FPA + 7
871D                  rtsL8367
871D  39                              RTS
871E                  fpAddAtoBStoreA                                         ; L8368
871E  9631                            LDA     ZP_FPA + 3                      ; quick check if A = 0 then just move B to A
8720  27E7                            BEQ     fpCopyBtoA_NewAPI
8722  9630                            LDA     ZP_FPA + 2
8724  903C                            SUBA    ZP_FPB + 1
8726  2761                            BEQ     fpAddAtoBStoreA_sk_sameExp
8728  252D                            BCS     fpAddAtoBStoreA_skAtooSmall
872A  8125                            CMPA    #$25
872C  24EF                            BCC     rtsL8367
872E  1F89                            TFR     A,B
8730  8438                            ANDA    #$38
8732  270E                            BEQ     fpAddAtoBStoreA_shr8_B_sk
8734                  fpAddAtoBStoreA_shr8_B_lp                               ; L837F
8734  9E3F                            LDX     ZP_FPB + 4                      ; shift B right in 8's
8736  9F40                            STX     ZP_FPB + 5
8738  9E3D                            LDX     ZP_FPB + 2
873A  9F3E                            STX     ZP_FPB + 3
873C  0F3D                            CLR     ZP_FPB + 2
873E  8008                            SUBA    #$08
8740  26F2                            BNE     fpAddAtoBStoreA_shr8_B_lp
8742                  fpAddAtoBStoreA_shr8_B_sk                               ; L8395:
8742  1F98                            TFR     B,A
8744  8407                            ANDA    #$07
8746  2741                            BEQ     fpAddAtoBStoreA_sk_sameExp
8748                  fpAddAtoBStoreA_shr1_B_lp                                       ; L839A:
8748  043D                            LSR     ZP_FPB + 2
874A  063E                            ROR     ZP_FPB + 3
874C  063F                            ROR     ZP_FPB + 4
874E  0640                            ROR     ZP_FPB + 5
8750  0641                            ROR     ZP_FPB + 6
8752  4A                              DECA
8753  26F3                            BNE     fpAddAtoBStoreA_shr1_B_lp
8755  2032                            BRA     fpAddAtoBStoreA_sk_sameExp
                      
8757                  fpAddAtoBStoreA_skAtooSmall                             ; L83A9
                                      ; shift A  right until it is of same order as B
8757  88FF                            EORA    #$FF
8759  4C                              INCA
875A  8125                            CMPA    #$25
875C  24AB                            BCC     fpCopyBtoA_NewAPI
875E  D63C                            LDB     ZP_FPB + 1
8760  D730                            STB     ZP_FPA + 2
8762  1F89                            TFR     A,B
8764  8438                            ANDA    #$38
8766  270E                            BEQ     fpAddAtoBStoreA_shr8_A_sk
8768                  fpAddAtoBStoreA_shr8_A_lp                               ; L83BA:
8768  9E33                            LDX     ZP_FPA + 5
876A  9F34                            STX     ZP_FPA + 6
876C  9E31                            LDX     ZP_FPA + 3
876E  9F32                            STX     ZP_FPA + 4
8770  0F31                            CLR     ZP_FPA + 3
8772  8008                            SUBA    #$08
8774  26F2                            BNE     fpAddAtoBStoreA_shr8_A_lp
8776                  fpAddAtoBStoreA_shr8_A_sk                               ; L83D0:
8776  1F98                            TFR     B,A
8778  8407                            ANDA    #$07
877A  270D                            BEQ     fpAddAtoBStoreA_sk_sameExp
877C                  fpAddAtoBStoreA_shr1_A_lp                               ; L83D5:
877C  0431                            LSR     ZP_FPA + 3
877E  0632                            ROR     ZP_FPA + 4
8780  0633                            ROR     ZP_FPA + 5
8782  0634                            ROR     ZP_FPA + 6
8784  0635                            ROR     ZP_FPA + 7
8786  4A                              DECA
8787  26F3                            BNE     fpAddAtoBStoreA_shr1_A_lp
8789                  fpAddAtoBStoreA_sk_sameExp                              ; L83E2
8789  962E                            LDA     ZP_FPA
878B  983B                            EORA    ZP_FPB
878D  2B03                            BMI     fpAddAtoBstoreA_oppsigns        ; signs are different
878F                                  JUMP    fpAddAtoBstoreinA_sameExp
878F  7EA4C1                                  JMP     \1
8792                  fpAddAtoBstoreA_oppsigns                                ; L83EC
8792  DC31                            LDD     ZP_FPA + 3                      ; compare mants
8794  10933D                          CMPD    ZP_FPB + 2
8797  2610                            BNE     fpAddAtoBstoreA_oppsigns_sk
8799  DC33                            LDD     ZP_FPA + 5
879B  10933F                          CMPD    ZP_FPB + 4
879E  2609                            BNE     fpAddAtoBstoreA_oppsigns_sk
87A0  9635                            LDA     ZP_FPA + 7
87A2  9141                            CMPA    ZP_FPB + 6
87A4  2603                            BNE     fpAddAtoBstoreA_oppsigns_sk
87A6                                  JUMP    zero_FPA                        ; they're the same return 0
87A6  7EA6ED                                  JMP     \1
87A9                  fpAddAtoBstoreA_oppsigns_sk                             ; L840D
87A9  241B                            BHS     fpAddAtoBstoreA_oppsigns_sk2    ; gt
87AB  963B                            LDA     ZP_FPB
87AD  972E                            STA     ZP_FPA                  ; keep B' sign
                      
87AF  DC40                            LDD     ZP_FPB + 5
87B1  9334                            SUBD    ZP_FPA + 6
87B3  9734                            STA     ZP_FPA + 6
                      
87B5  DC3E                            LDD     ZP_FPB + 3
87B7  D233                            SBCB    ZP_FPA + 5
87B9  9232                            SBCA    ZP_FPA + 4
87BB  DD32                            STD     ZP_FPA + 4
                      
87BD  963D                            LDA     ZP_FPB + 2
87BF  9231                            SBCA    ZP_FPA + 3
87C1  9731                            STA     ZP_FPA + 3
87C3                                  JUMP    NormaliseRealA_2
87C3  7E85D3                                  JMP     \1
                      
87C6                  fpAddAtoBstoreA_oppsigns_sk2                            ; L8435
87C6  DC34                            LDD     ZP_FPA + 6
87C8  9340                            SUBD    ZP_FPB + 5
87CA  DD34                            STD     ZP_FPA + 6
                      
87CC  DC32                            LDD     ZP_FPA + 4
87CE  D23F                            SBCB    ZP_FPB + 4
87D0  923E                            SBCA    ZP_FPB + 3
87D2  DD32                            STD     ZP_FPA + 4
                      
87D4  9631                            LDA     ZP_FPA + 3
87D6  923D                            SBCA    ZP_FPB + 2
87D8  9731                            STA     ZP_FPA + 3
87DA                                  JUMP    NormaliseRealA_2
87DA  7E85D3                                  JMP     \1
                      ;               
                      ;                       ;  00000000
                      ;                       ;  FUNCTION/COMMAND DISPATCH TABLE
                      ;                       ;  ===============================
87DD                  tblCmdDispatch
87DD  AB56                             FDB fnOPENIN                   ;  $8E - OPENIN
87DF  AB34                             FDB varGetPTR                  ;  $8F - =PTR
87E1  AE3B                             FDB varGetPAGE                 ;  $90 - =PAGE
87E3  AE7F                             FDB varGetTIME                 ;  $91 - =TIME
87E5  AE68                             FDB varGetLOMEM                ;  $92 - =LOMEM
87E7  AE6C                             FDB varGetHIMEM                ;  $93 - =HIMEM
87E9  ACF2                             FDB fnABS                      ;  $94 - ABS
87EB  A8F5                             FDB fnACS                      ;  $95 - ACS
87ED  AE1F                             FDB fnADVAL                    ;  $96 - ADVAL
87EF  ABE7                             FDB fnASC                      ;  $97 - ASC
87F1  A8FD                             FDB fnASN                      ;  $98 - ASN
87F3  A90B                             FDB fnATN                      ;  $99 - ATN
87F5  AB4B                             FDB fnBGET                     ;  $9A - BGET
87F7  A95F                             FDB fnCOS                      ;  $9B - COS
87F9  AE64                             FDB fnCOUNT                    ;  $9C - COUNT
87FB  AA3C                             FDB fnDEG                      ;  $9D - DEG
87FD  AE70                             FDB varERL                     ;  $9E - ERL
87FF  AE74                             FDB varERR                     ;  $9F - ERR
8801  AB7A                             FDB fnEVAL                     ;  $A0 - EVAL
8803  AA44                             FDB fnEXP                      ;  $A1 - EXP
8805  AB30                             FDB fnEXT                      ;  $A2 - EXT
8807  AC1D                             FDB varFALSE                   ;  $A3 - FALSE
8809  B074                             FDB fnFN                       ;  $A4 - FN
880B  AE7A                             FDB fnGET                      ;  $A5 - GET
880D  ABF8                             FDB fnINKEY                    ;  $A6 - INKEY
880F  AC6F                             FDB fnINSTR                    ;  $A7 - INSTR(
8811  ABBA                             FDB fnINT                      ;  $A8 - INT
8813  AE40                             FDB fnLEN                      ;  $A9 - LEN
8815  A77F                             FDB fnLN                       ;  $AA - LN
8817  AA34                             FDB fnLOG                      ;  $AB - LOG
8819  AAFA                             FDB fnNOT                      ;  $AC - NOT
881B  AB5E                             FDB fnOPENUP                   ;  $AD - OPENUP
881D  AB5A                             FDB fnOPENOUT                  ;  $AE - OPENOUT
881F  AB74                             FDB fnPI                       ;  $AF - PI
8821  AC42                             FDB fnPOINT                    ;  $B0 - POINT(
8823  AB09                             FDB fnPOS                      ;  $B1 - POS
8825  AA2C                             FDB fnRAD                      ;  $B2 - RAD
8827  AAE3                             FDB fnRND                      ;  $B3 - RND
8829  AC29                             FDB fnSGN                      ;  $B4 - SGN
882B  A95B                             FDB fnSIN                      ;  $B5 - SIN
882D  A7FF                             FDB fnSQR                      ;  $B6 - SQR
882F  A5D1                             FDB fnTAN                      ;  $B7 - TAN
8831  AE2F                             FDB fnTO                       ;  $B8 - TO
8833  AC11                             FDB returnINTminus1            ;  $B9 - TRUE
8835  AB0E                             FDB fnUSR                      ;  $BA - USR
8837  AB86                             FDB fnVAL                      ;  $BB - VAL
8839  AB26                             FDB fnVPOS                     ;  $BC - VPOS
883B  B250                             FDB fnCHR                      ;  $BD - CHR$
883D  AEB9                             FDB fnGETDOLLAR                ;  $BE - GET$
883F  AF16                             FDB fnINKEYDOLLAR              ;  $BF - INKEY$
8841  AEC8                             FDB fnLEFT                     ;  $C0 - LEFT$(
8843  AF20                             FDB fnMIDstr                   ;  $C1 - MID$(
8845  AECC                             FDB fnRIGHT                    ;  $C2 - RIGHT$(
8847  AF94                             FDB fnSTR                      ;  $C3 - STR$(
8849  AFC3                             FDB fnSTRING                   ;  $C4 - STRING$(
884B  AC03                             FDB fnEOF                      ;  $C5 - EOF
884D  9679                             FDB cmdAUTO                    ;  $C6 - AUTO
884F  9633                             FDB cmdDELETE                  ;  $C7 - DELETE
8851  92CA                             FDB cmdLOAD                    ;  $C8 - LOAD
8853  B3EB                             FDB cmdLIST                    ;  $C9 - LIST
8855  92E6                             FDB cmdNEW                     ;  $CA - NEW
8857  92AD                             FDB cmdOLD                     ;  $CB - OLD
8859  9664                             FDB cmdRENUMBER                ;  $CC - RENUMBER
885B  BD3D                             FDB cmdSAVE                    ;  $CD - SAVE
885D  B3A7                             FDB cmdEDIT                    ;  $CE - EDIT
885F  BD78                             FDB varSetPTR                  ;  $CF - PTR=
8861  97E7                             FDB varSetPAGE                 ;  $D0 - PAGE=
8863  982A                             FDB varSetTIME                 ;  $D1 - TIME=
8865  97D9                             FDB varSetLOMEM                ;  $D2 - LOMEM=
8867  97CE                             FDB varSetHIMEM                ;  $D3 - HIMEM=
8869  B2D4                             FDB cmdSOUND                   ;  $D4 - SOUND
886B  BDA5                             FDB cmdBPUT                    ;  $D5 - BPUT
886D  95E0                             FDB cmdCALL                    ;  $D6 - CALL
886F  92A8                             FDB cmdCHAIN                   ;  $D7 - CHAIN
8871  97F1                             FDB cmdCLEAR                   ;  $D8 - CLEAR
8873  BD9B                             FDB cmdCLOSE                   ;  $D9 - CLOSE
8875  996E                             FDB cmdCLG                     ;  $DA - CLG
8877  9975                             FDB cmdCLS                     ;  $DB - CLS
8879  9317                             FDB cmdREM                     ;  $DC - DATA
887B  9317                             FDB cmdREM                     ;  $DD - DEF
887D  971F                             FDB cmdDIM                     ;  $DE - DIM
887F  9932                             FDB cmdDRAW                    ;  $DF - DRAW
8881  92CF                             FDB cmdEND                     ;  $E0 - END
8883  9C67                             FDB cmdENDPROC                 ;  $E1 - ENDPROC
8885  B2F4                             FDB cmdENVELOPE                ;  $E2 - ENVELOPE
8887  B633                             FDB cmdFOR                     ;  $E3 - FOR
8889  B6CD                             FDB cmdGOSUB                   ;  $E4 - GOSUB
888B  B70C                             FDB cmdGOTO                    ;  $E5 - GOTO
888D  98D9                             FDB cmdGCOL                    ;  $E6 - GCOL
888F  9CAD                             FDB cmdIF                      ;  $E7 - IF
8891  B88F                             FDB cmdINPUT                   ;  $E8 - INPUT
8893  93A4                             FDB cmdLET                     ;  $E9 - LET
8895  98A2                             FDB cmdLOCAL                   ;  $EA - LOCAL
8897  98F9                             FDB cmdMode                    ;  $EB - MODE
8899  992E                             FDB cmdMOVE                    ;  $EC - MOVE
889B  B4F8                             FDB cmdNEXT                    ;  $ED - NEXT
889D  B739                             FDB cmdON                      ;  $EE - ON
889F  999C                             FDB cmdVDU                     ;  $EF - VDU
88A1  993E                             FDB cmdPLOT                    ;  $F0 - PLOT
88A3  94C6                             FDB cmdPRINT                   ;  $F1 - PRINT
88A5  988F                             FDB cmdPROC                    ;  $F2 - PROC
88A7  B957                             FDB cmdREAD                    ;  $F3 - READ
88A9  9317                             FDB cmdREM                     ;  $F4 - REM
88AB  BA10                             FDB cmdREPEAT                  ;  $F5 - REPEAT
88AD  9982                             FDB cmdREPORT                  ;  $F6 - REPORT
88AF  B92E                             FDB cmdRESTORE                 ;  $F7 - RESTORE
88B1  B6F9                             FDB cmdRETURN                  ;  $F8 - RETURN
88B3  92BD                             FDB cmdRUN                     ;  $F9 - RUN
88B5  93DD                             FDB cmdSTOP                    ;  $FA - STOP
88B7  98EF                             FDB cmdCOLOUR                  ;  $FB - COLOUR
88B9  97F9                             FDB cmdTRACE                   ;  $FC - TRACE
88BB  B9E2                             FDB cmdUNTIL                   ;  $FD - UNTIL
88BD  B327                             FDB cmdWIDTH                   ;  $FE - WIDTH
88BF  BD65                             FDB cmdOSCLI                   ;  $FF - OSCLI
                      
                                       include "./assembler_share.asm"
88C1                  assScanExit                                                     ; L891A
88C1  4A                              DECA
88C2  9728                            STA     ZP_OPT
88C4                                  JUMP    skipSpacesAtYexecImmed
88C4  7E936A                                  JMP     \1
88C7                  assScanEnter                                            ; L8920
88C7                                  CALL    skipSpacesY
88C7                  9
88C9                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88C7  BD928C                                  JSR     \1
                              ENDIF
88CA  885D                            EORA    #']'
88CC  27F3                            BEQ     assScanExit                             ;  End of assembler
88CE  335F                            LEAU    -1,U
88D0                                  CALL    storeYasTXTPTR
88D0                  9
88D2                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88D0  BD9C83                                  JSR     \1
                              ENDIF
88D3  3440                            PSHS    U
88D5                                  CALL    assScanNextOp
88D5                  9
88D7                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
007F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88D5  BD8B56                                  JSR     \1
                              ENDIF
88D8  3510                            PULS    X
88DA  9F19                            STX     ZP_TXTPTR2                      ; points at start of instruction
88DC  DF2E                            STU     ZP_FPA
                      ;;              LEAU    -1,U
88DE  9628                            LDA     ZP_OPT
88E0  44                              LSRA
88E1  247D                            BCC     assSkipList
88E3  961E                            LDA     ZP_PRLINCOUNT
88E5  8B05                            ADDA    #$05
88E7  973F                            STA     ZP_FPB + 4
88E9  9637                            LDA     ZP_GEN_PTR                      ; print opcode address
88EB                                  CALL    list_printHexByte
88EB                  9
88ED                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0058                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88EB  BDBC45                                  JSR     \1
                              ENDIF
88EE  9638                            LDA     ZP_GEN_PTR + 1
88F0                                  CALL    list_printHexByteAndSpace
88F0                  9
88F2                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0079                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
88F0  BDBC6B                                  JSR     \1
                              ENDIF
88F3  C6FC                            LDB     #$FC
88F5  9639                            LDA     ZP_ASS_OPLEN                    ; get back op len
88F7  2A02                            BPL     assPrintString                  ; if negative its a string
88F9  9636                            LDA     ZP_STRBUFLEN                    ; get string len
88FB                  assPrintString                                          ; L894E
88FB  9738                            STA     ZP_ASS_LIST_OPLEN
88FD  2718                            BEQ     assPrintSk0LenOp
88FF  9E3A                            LDX     ZP_ASS_OPSAVED
8901                  assPrintOpCodeLp                
8901  5C                              INCB
8902  260A                            BNE     L8961
8904                                  CALL    PrintCRclearPRLINCOUNT
8904                  9
8906                  __XBSR                  SET 9B+2
3100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0038                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8904  BDBA3E                                  JSR     \1
                              ENDIF
8907  D63F                            LDB     ZP_FPB + 4
8909                                  CALL    list_printBSpaces
8909                  9
890B                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8909  BDBC9D                                  JSR     \1
                              ENDIF
890C  C6FD                            LDB     #$FD
890E                  L8961
890E  A680                            LDA     ,X+
8910                                  CALL    list_printHexByteAndSpace
8910                  9
8912                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0059                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8910  BDBC6B                                  JSR     \1
                              ENDIF
8913  0A38                            DEC     ZP_ASS_LIST_OPLEN
8915  26EA                            BNE     assPrintOpCodeLp
8917                  assPrintSk0LenOp
                      ;;              TXA
                      ;;              TAY
8917                  assPrintAlignOpTxtLp                                    ;L896D
8917  5C                              INCB
8918  270B                            BEQ     assPrintAlignOpTxtSk
891A  3404                            PSHS    B
891C  C603                            LDB     #$03
891E                                  CALL    list_printBSpaces
891E                  9
8920                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
891E  BDBC9D                                  JSR     \1
                              ENDIF
8921  3504                            PULS    B
8923  20F2                            BRA     assPrintAlignOpTxtLp
8925                  assPrintAlignOpTxtSk                                    ; L8977
8925  C60A                            LDB     #$0A
8927  9E19                            LDX     ZP_TXTPTR2                      ; back to start of stmt in program
8929  A680                            LDA     ,X+
892B  812E                            CMPA    #'.'                            ; if original stmt started with '.' print label
892D  260E                            BNE     assPrintLabelSk                         
892F                  assPrintLabelLp                                         ; L897F
892F                                  CALL    doListPrintTokenA
892F                  9
8931                  __XBSR                  SET 9B+2
3200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
892F  BDBC21                                  JSR     \1
                              ENDIF
8932  5A                              DECB
8933  2602                            BNE     1F
8935  C601                            LDB     #$01
8937  A680            1               LDA     ,X+
8939  9C4E                            CMPX    ZP_ASS_LBLEND
893B  23F2                            BLS     assPrintLabelLp
893D                  assPrintLabelSk                                         ; L898E
893D                                  CALL    list_printBSpaces
893D                  9
893F                  __XBSR                  SET 9B+2
3300                  __XBSR2                 SET (\1-__XBSR) & $FF00
005E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
893D  BDBC9D                                  JSR     \1
                              ENDIF
8940  301F                            LEAX    -1,X
8942                  L8992
8942  A180                            CMPA    ,X+                             ; skip spaces at start?
8944  27FC                            BEQ     L8992
8946  301F                            LEAX    -1,X
8948                  L8997
8948  A684                            LDA     ,X
894A  813A                            CMPA    #$3A
894C  270B                            BEQ     L89A7
894E  810D                            CMPA    #$0D
8950  270B                            BEQ     L89AB
8952                  L89A1
8952                                  CALL doListPrintTokenA
8952                  9
8954                  __XBSR                  SET 9B+2
3200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8952  BDBC21                                  JSR     \1
                              ENDIF
8955  3001                            LEAX    1,X
8957  20EF                            BRA     L8997
8959  9C2E            L89A7           CMPX    ZP_FPA
895B  25F5                            BLO     L89A1
895D                  L89AB           CALL    PrintCRclearPRLINCOUNT
895D                  9
895F                  __XBSR                  SET 9B+2
3000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
895D  BDBA3E                                  JSR     \1
                              ENDIF
8960                  assSkipList     
                      ;;              LEAU    -1,U
8960  A6C0            L89B1           LDA     ,U+
8962  813A                            CMPA    #':'
8964  2704                            BEQ     L89BC
8966  810D                            CMPA    #$0D
8968  26F6                            BNE     L89B1
896A  335F            L89BC           LEAU    -1,U
896C                                  CALL    scanNextStmtFromY
896C                  9
896E                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
896C  BD9C74                                  JSR     \1
                              ENDIF
896F  A6C0                            LDA     ,U+
8971  813A                            CMPA    #':'
8973  270C                            BEQ     L89D1
8975  1F30                            TFR     U,D
                      ;;;             LDA     ZP_TXTPTR + 1
8977  8107                            CMPA    #$07
8979  2603                            BNE     L89CE
897B                                  JUMP    immedPrompt
897B  7E92EF                                  JMP     \1
897E                  L89CE           CALL    doTraceOrEndAtELSE
897E                  9
8980                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
001C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
897E  BD9C9C                                  JSR     \1
                              ENDIF
8981                  L89D1           JUMP    assScanEnter
8981  7E88C7                                  JMP     \1
                      
8984                  assDecYEvalForceINT_LE
8984  335F                            LEAU    -1,U
8986                  assEvalForceINT_LE
8986                                  CALL    evalForceINT
8986                  9
8988                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8986  BD95A1                                  JSR     \1
                              ENDIF
8989  3406                            PSHS    D
898B  DC2A                            LDD     ZP_INT_WA
898D  3406                            PSHS    D
898F  DC2C                            LDD     ZP_INT_WA+2
8991  1E89                            EXG     A,B
8993  DD2A                            STD     ZP_INT_WA
8995  3506                            PULS    D
8997  1E89                            EXG     A,B
8999  DD2C                            STD     ZP_INT_WA+2
899B  3586                            PULS    D,PC
                      
                              IF ASSEMBLER_6502
                                      include "./assembler6502.asm"
                              ELSE
                                      include "./assembler6x09.asm"
                      
                      
                              ; vars used in opcode parse phase
0000                  ASS_VAR_OPACC   EQU     0                               ; 2 byte "op-acc" accumulator 25 bits + flags
0004                  ASS_VAR_FLAGS   EQU     4                               ; flags from parse table
                              ; vars used in class lookup phase and beyond (note flags carry through and are OR'ed with the flags from parse table)
0000                  ASS_VAR_IX      EQU     0                               ; opcode index
0000                  ASS_VAR_MODEP   EQU     0                               ; scratch during mode decoding 
0001                  ASS_VAR_SUFFIX  EQU     1                               ; suffix item index
0002                  ASS_VAR_MODESET EQU     2                               ; mode set for this op class
0003                  ASS_VAR_OPLEN   EQU     3                               ; opcode len (minus prefix byte)
                      
0005                  ASS_VAR_PTR_SAV EQU     5                               ; store Y temporarily
0007                  ASS_VAR_OP      EQU     7                               ; "base" opcode number from parse table, followed by upto 4 more post bytes
                      
000C                  ASS_VAR_SPACE   EQU     12
                      
                      
                              IF ASSEMBLER_6309
                                      include "6309-assembler.gen.asm"
                              ELSE
                                      include "6809-assembler.gen.asm"
                      
                      
                      *********************************************************
                      * P A R S E   T A B L E
                      *********************************************************
                      
899D                  assParseTbl
                      
                              ********** A **********
899D                  assParseTbl_A
899D                  assParseTbl_ABX
0000                  assParseTbl_ABX_IX      EQU     $00
899D  0458                            FDB     $0458           ; [00] - ABX
899F  3A                              FCB     $3A             ; base op
89A0                  assParseTbl_DAA
0001                  assParseTbl_DAA_IX      EQU     $01
89A0  1021                            FDB     $1021           ; [01] - DAA
89A2  19                              FCB     $19             ; base op
89A3                  assParseTbl_NOP
0002                  assParseTbl_NOP_IX      EQU     $02
89A3  39F0                            FDB     $39F0           ; [02] - NOP
89A5  12                              FCB     $12             ; base op
89A6                  assParseTbl_RTI
0003                  assParseTbl_RTI_IX      EQU     $03
89A6  4A89                            FDB     $4A89           ; [03] - RTI
89A8  3B                              FCB     $3B             ; base op
89A9                  assParseTbl_RTS
0004                  assParseTbl_RTS_IX      EQU     $04
89A9  4A93                            FDB     $4A93           ; [04] - RTS
89AB  39                              FCB     $39             ; base op
                      
                              ********** A1 **********
89AC                  assParseTbl_A1
89AC                  assParseTbl_SYN
0005                  assParseTbl_SYN_IX      EQU     $05
89AC  4F2E                            FDB     $4F2E           ; [05] - SYN
89AE  13                              FCB     $13             ; base op
                      
                              ********** A2 **********
89AF                  assParseTbl_A2
89AF                  assParseTbl_SEX
0006                  assParseTbl_SEX_IX      EQU     $06
89AF  4CB8                            FDB     $4CB8           ; [06] - SEX
89B1  1D                              FCB     $1D             ; base op
                      
                              ********** B **********
89B2                  assParseTbl_B
89B2                  assParseTbl_ADC
0007                  assParseTbl_ADC_IX      EQU     $07
89B2  0483                            FDB     $0483           ; [07] - ADC
89B4  89                              FCB     $89             ; base op
89B5                  assParseTbl_EOR
0008                  assParseTbl_EOR_IX      EQU     $08
89B5  15F2                            FDB     $15F2           ; [08] - EOR
89B7  88                              FCB     $88             ; base op
89B8                  assParseTbl_SBC
0009                  assParseTbl_SBC_IX      EQU     $09
89B8  4C43                            FDB     $4C43           ; [09] - SBC
89BA  82                              FCB     $82             ; base op
                      
                              ********** B2 **********
89BB                  assParseTbl_B2
89BB                  assParseTbl_AND
000A                  assParseTbl_AND_IX      EQU     $0A
89BB  05C4                            FDB     $05C4           ; [0A] - AND
89BD  84                              FCB     $84             ; base op
89BE                  assParseTbl_OR
000B                  assParseTbl_OR_IX       EQU     $0B
89BE  01F2                            FDB     $01F2           ; [0B] - OR
89C0  8A                              FCB     $8A             ; base op
                      
                              ********** C **********
89C1                  assParseTbl_C
89C1                  assParseTbl_ADD
000C                  assParseTbl_ADD_IX      EQU     $0C
89C1  0484                            FDB     $0484           ; [0C] - ADD
89C3  8B                              FCB     $8B             ; base op
                      
                              ********** DIR **********
89C4                  assParseTbl_DIR
89C4                  assParseTbl_OPT
000D                  assParseTbl_OPT_IX      EQU     $0D
89C4  3E14                            FDB     $3E14           ; [0D] - OPT
89C6  00                              FCB     $00             ; base op
89C7                  assParseTbl_EQU
000E                  assParseTbl_EQU_IX      EQU     $0E
89C7  1635                            FDB     $1635           ; [0E] - EQU
89C9  01                              FCB     $01             ; base op
89CA                  assParseTbl_DCB
000F                  assParseTbl_DCB_IX      EQU     $0F
89CA  1062                            FDB     $1062           ; [0F] - DCB
89CC  02                              FCB     $02             ; base op
89CD                  assParseTbl_DCW
0010                  assParseTbl_DCW_IX      EQU     $10
89CD  1077                            FDB     $1077           ; [10] - DCW
89CF  03                              FCB     $03             ; base op
89D0                  assParseTbl_DCD
0011                  assParseTbl_DCD_IX      EQU     $11
89D0  1064                            FDB     $1064           ; [11] - DCD
89D2  04                              FCB     $04             ; base op
89D3                  assParseTbl_SET
0012                  assParseTbl_SET_IX      EQU     $12
89D3  4CB4                            FDB     $4CB4           ; [12] - SET
89D5  05                              FCB     $05             ; base op
                      
                              ********** E **********
89D6                  assParseTbl_E
89D6                  assParseTbl_CWA
0013                  assParseTbl_CWA_IX      EQU     $13
89D6  0EE1                            FDB     $0EE1           ; [13] - CWA
89D8  3C                              FCB     $3C             ; base op
                      
                              ********** F **********
89D9                  assParseTbl_F
89D9                  assParseTbl_NEG
0014                  assParseTbl_NEG_IX      EQU     $14
89D9  38A7                            FDB     $38A7           ; [14] - NEG
89DB  00                              FCB     $00             ; base op
89DC                  assParseTbl_ASL
0015                  assParseTbl_ASL_IX      EQU     $15
89DC  066C                            FDB     $066C           ; [15] - ASL
89DE  08                              FCB     $08             ; base op
89DF                  assParseTbl_ASR
0016                  assParseTbl_ASR_IX      EQU     $16
89DF  0672                            FDB     $0672           ; [16] - ASR
89E1  07                              FCB     $07             ; base op
89E2                  assParseTbl_LSL
0017                  assParseTbl_LSL_IX      EQU     $17
89E2  326C                            FDB     $326C           ; [17] - LSL
89E4  08                              FCB     $08             ; base op
                      
                              ********** G **********
89E5                  assParseTbl_G
89E5                  assParseTbl_BIT
0018                  assParseTbl_BIT_IX      EQU     $18
89E5  0934                            FDB     $0934           ; [18] - BIT
89E7  85                              FCB     $85             ; base op
                      
                              ********** H **********
89E8                  assParseTbl_H
89E8                  assParseTbl_CLR
0019                  assParseTbl_CLR_IX      EQU     $19
89E8  0D92                            FDB     $0D92           ; [19] - CLR
89EA  0F                              FCB     $0F             ; base op
89EB                  assParseTbl_COM
001A                  assParseTbl_COM_IX      EQU     $1A
89EB  0DED                            FDB     $0DED           ; [1A] - COM
89ED  03                              FCB     $03             ; base op
89EE                  assParseTbl_DEC
001B                  assParseTbl_DEC_IX      EQU     $1B
89EE  10A3                            FDB     $10A3           ; [1B] - DEC
89F0  0A                              FCB     $0A             ; base op
89F1                  assParseTbl_INC
001C                  assParseTbl_INC_IX      EQU     $1C
89F1  25C3                            FDB     $25C3           ; [1C] - INC
89F3  0C                              FCB     $0C             ; base op
89F4                  assParseTbl_TST
001D                  assParseTbl_TST_IX      EQU     $1D
89F4  5274                            FDB     $5274           ; [1D] - TST
89F6  0D                              FCB     $0D             ; base op
                      
                              ********** I **********
89F7                  assParseTbl_I
89F7                  assParseTbl_CMP
001E                  assParseTbl_CMP_IX      EQU     $1E
89F7  0DB0                            FDB     $0DB0           ; [1E] - CMP
89F9  81                              FCB     $81             ; base op
                      
                              ********** K **********
89FA                  assParseTbl_K
89FA                  assParseTbl_EXG
001F                  assParseTbl_EXG_IX      EQU     $1F
89FA  1707                            FDB     $1707           ; [1F] - EXG
89FC  1E                              FCB     $1E             ; base op
89FD                  assParseTbl_TFR
0020                  assParseTbl_TFR_IX      EQU     $20
89FD  50D2                            FDB     $50D2           ; [20] - TFR
89FF  1F                              FCB     $1F             ; base op
                      
                              ********** L **********
8A00                  assParseTbl_L
8A00                  assParseTbl_JMP
0021                  assParseTbl_JMP_IX      EQU     $21
8A00  29B0                            FDB     $29B0           ; [21] - JMP
8A02  0E                              FCB     $0E             ; base op
                      
                              ********** M **********
8A03                  assParseTbl_M
8A03                  assParseTbl_JSR
0022                  assParseTbl_JSR_IX      EQU     $22
8A03  2A72                            FDB     $2A72           ; [22] - JSR
8A05  9D                              FCB     $9D             ; base op
                      
                              ********** N **********
8A06                  assParseTbl_N
8A06                  assParseTbl_LD
0023                  assParseTbl_LD_IX       EQU     $23
8A06  0184                            FDB     $0184           ; [23] - LD
8A08  86                              FCB     $86             ; base op
                      
                              ********** P **********
8A09                  assParseTbl_P
8A09                  assParseTbl_LEA
0024                  assParseTbl_LEA_IX      EQU     $24
8A09  30A1                            FDB     $30A1           ; [24] - LEA
8A0B  30                              FCB     $30             ; base op
                      
                              ********** Q **********
8A0C                  assParseTbl_Q
8A0C                  assParseTbl_LSR
0025                  assParseTbl_LSR_IX      EQU     $25
8A0C  3272                            FDB     $3272           ; [25] - LSR
8A0E  04                              FCB     $04             ; base op
8A0F                  assParseTbl_ROL
0026                  assParseTbl_ROL_IX      EQU     $26
8A0F  49EC                            FDB     $49EC           ; [26] - ROL
8A11  09                              FCB     $09             ; base op
8A12                  assParseTbl_ROR
0027                  assParseTbl_ROR_IX      EQU     $27
8A12  49F2                            FDB     $49F2           ; [27] - ROR
8A14  06                              FCB     $06             ; base op
                      
                              ********** R **********
8A15                  assParseTbl_R
8A15                  assParseTbl_MUL
0028                  assParseTbl_MUL_IX      EQU     $28
8A15  36AC                            FDB     $36AC           ; [28] - MUL
8A17  3D                              FCB     $3D             ; base op
                      
                              ********** S **********
8A18                  assParseTbl_S
8A18                  assParseTbl_PSH
0029                  assParseTbl_PSH_IX      EQU     $29
8A18  4268                            FDB     $4268           ; [29] - PSH
8A1A  34                              FCB     $34             ; base op
8A1B                  assParseTbl_PUL
002A                  assParseTbl_PUL_IX      EQU     $2A
8A1B  42AC                            FDB     $42AC           ; [2A] - PUL
8A1D  35                              FCB     $35             ; base op
                      
                              ********** T **********
8A1E                  assParseTbl_T
8A1E                  assParseTbl_ST
002B                  assParseTbl_ST_IX       EQU     $2B
8A1E  0274                            FDB     $0274           ; [2B] - ST
8A20  97                              FCB     $97             ; base op
                      
                              ********** U **********
8A21                  assParseTbl_U
8A21                  assParseTbl_BCC
002C                  assParseTbl_BCC_IX      EQU     $2C
8A21  0863                            FDB     $0863           ; [2C] - BCC
8A23  24                              FCB     $24             ; base op
8A24                  assParseTbl_BCS
002D                  assParseTbl_BCS_IX      EQU     $2D
8A24  0873                            FDB     $0873           ; [2D] - BCS
8A26  25                              FCB     $25             ; base op
8A27                  assParseTbl_BEQ
002E                  assParseTbl_BEQ_IX      EQU     $2E
8A27  08B1                            FDB     $08B1           ; [2E] - BEQ
8A29  27                              FCB     $27             ; base op
8A2A                  assParseTbl_BGE
002F                  assParseTbl_BGE_IX      EQU     $2F
8A2A  08E5                            FDB     $08E5           ; [2F] - BGE
8A2C  2C                              FCB     $2C             ; base op
8A2D                  assParseTbl_BGT
0030                  assParseTbl_BGT_IX      EQU     $30
8A2D  08F4                            FDB     $08F4           ; [30] - BGT
8A2F  2E                              FCB     $2E             ; base op
8A30                  assParseTbl_BHI
0031                  assParseTbl_BHI_IX      EQU     $31
8A30  0909                            FDB     $0909           ; [31] - BHI
8A32  22                              FCB     $22             ; base op
8A33                  assParseTbl_BHS
0032                  assParseTbl_BHS_IX      EQU     $32
8A33  0913                            FDB     $0913           ; [32] - BHS
8A35  24                              FCB     $24             ; base op
8A36                  assParseTbl_BLE
0033                  assParseTbl_BLE_IX      EQU     $33
8A36  0985                            FDB     $0985           ; [33] - BLE
8A38  2F                              FCB     $2F             ; base op
8A39                  assParseTbl_BLO
0034                  assParseTbl_BLO_IX      EQU     $34
8A39  098F                            FDB     $098F           ; [34] - BLO
8A3B  25                              FCB     $25             ; base op
8A3C                  assParseTbl_BLS
0035                  assParseTbl_BLS_IX      EQU     $35
8A3C  0993                            FDB     $0993           ; [35] - BLS
8A3E  23                              FCB     $23             ; base op
8A3F                  assParseTbl_BLT
0036                  assParseTbl_BLT_IX      EQU     $36
8A3F  0994                            FDB     $0994           ; [36] - BLT
8A41  2D                              FCB     $2D             ; base op
8A42                  assParseTbl_BMI
0037                  assParseTbl_BMI_IX      EQU     $37
8A42  09A9                            FDB     $09A9           ; [37] - BMI
8A44  2B                              FCB     $2B             ; base op
8A45                  assParseTbl_BNE
0038                  assParseTbl_BNE_IX      EQU     $38
8A45  09C5                            FDB     $09C5           ; [38] - BNE
8A47  26                              FCB     $26             ; base op
8A48                  assParseTbl_BPL
0039                  assParseTbl_BPL_IX      EQU     $39
8A48  0A0C                            FDB     $0A0C           ; [39] - BPL
8A4A  2A                              FCB     $2A             ; base op
8A4B                  assParseTbl_BRA
003A                  assParseTbl_BRA_IX      EQU     $3A
8A4B  0A41                            FDB     $0A41           ; [3A] - BRA
8A4D  20                              FCB     $20             ; base op
8A4E                  assParseTbl_BRN
003B                  assParseTbl_BRN_IX      EQU     $3B
8A4E  0A4E                            FDB     $0A4E           ; [3B] - BRN
8A50  21                              FCB     $21             ; base op
8A51                  assParseTbl_BSR
003C                  assParseTbl_BSR_IX      EQU     $3C
8A51  0A72                            FDB     $0A72           ; [3C] - BSR
8A53  8D                              FCB     $8D             ; base op
8A54                  assParseTbl_BVC
003D                  assParseTbl_BVC_IX      EQU     $3D
8A54  0AC3                            FDB     $0AC3           ; [3D] - BVC
8A56  28                              FCB     $28             ; base op
8A57                  assParseTbl_BVS
003E                  assParseTbl_BVS_IX      EQU     $3E
8A57  0AD3                            FDB     $0AD3           ; [3E] - BVS
8A59  29                              FCB     $29             ; base op
                      
                              ********** Y **********
8A5A                  assParseTbl_Y
8A5A                  assParseTbl_SWI
003F                  assParseTbl_SWI_IX      EQU     $3F
8A5A  4EE9                            FDB     $4EE9           ; [3F] - SWI
8A5C  3F                              FCB     $3F             ; base op
                      
                              ********** Z **********
8A5D                  assParseTbl_Z
8A5D                  assParseTbl_SUB
0040                  assParseTbl_SUB_IX      EQU     $40
8A5D  4EA2                            FDB     $4EA2           ; [40] - SUB
8A5F  80                              FCB     $80             ; base op
                      
8A60  FF              assParseTbl_END FCB     $FF     ; end of table marker
                      
                      
                      
                      
                      *********************************************************
                      * S U F F I X    S E T S   T A B L E
                      *********************************************************
                      
8A61                  assSuffSetsTbl
                                      * SUFLIST [01] - LD ABDSUXY*EFWQ BT MD
8A61  05070F11181A9C                  FCB     $05,$07,$0F,$11,$18,$1A,$9C
                                      * SUFLIST [08] - ADC AB*D R CC
8A68  090587                          FCB     $09,$05,$87
                                      * SUFLIST [0B] - ABD MD
8A6B  05078E                          FCB     $05,$07,$8E
                                      * SUFLIST [0E] - SUXY
8A6E  14161B9E                        FCB     $14,$16,$1B,$9E
                                      * SUFLIST [12] - AB*DW
8A72  0486                            FCB     $04,$86
                                      * SUFLIST [14] - 23
8A74  020381                          FCB     $02,$03,$81
                                      * SUFLIST [17] - ADD ABD*EFW R
8A77  0D49                            FCB     $0D,$49
                                      * SUFLIST [19] - ABD*EFW
8A79  04068A                          FCB     $04,$06,$8A
                                      * SUFLIST [1C] - CMP ABDSUXY*EFW R
8A7C  1315191D0C49                    FCB     $13,$15,$19,$1D,$0C,$49
                                      * SUFLIST [22] - SUB ABD*EFW R
8A82  0B49                            FCB     $0B,$49
                                      * SUFLIST [24] - SU
8A84  1297                            FCB     $12,$97
                      
                      
                      
                      *********************************************************
                      * S U F F I X    I T E M   T A B L E
                      *********************************************************
                      
8A86                  assSuffItemTbl
                                      * SUFITEM [01] - 
                                                      ; no suff
8A86  80                              FCB     $80     ; FLAGS - 
                                      * SUFITEM [02] - 2
8A87  12                              FCB     $12     ; "2"
8A88  90                              FCB     $90     ; FLAGS - 10
                                      * SUFITEM [03] - 3
8A89  13                              FCB     $13     ; "3"
8A8A  91                              FCB     $91     ; FLAGS - 11
                                      * SUFITEM [04] - A
8A8B  41                              FCB     $41     ; "A"
8A8C  84                              FCB     $84     ; FLAGS - SUF-OP
8A8D  40                              FCB     $40     ; OP
                                      * SUFITEM [05] - A
8A8E  41                              FCB     $41     ; "A"
8A8F  80                              FCB     $80     ; FLAGS - 
                                      * SUFITEM [06] - B
8A90  42                              FCB     $42     ; "B"
8A91  84                              FCB     $84     ; FLAGS - SUF-OP
8A92  50                              FCB     $50     ; OP
                                      * SUFITEM [07] - B
8A93  42                              FCB     $42     ; "B"
8A94  84                              FCB     $84     ; FLAGS - SUF-OP
8A95  40                              FCB     $40     ; OP
                                      * SUFITEM [08] - C
8A96  43                              FCB     $43     ; "C"
8A97  80                              FCB     $80     ; FLAGS - 
                                      * SUFITEM [09] - CC
8A98  4343                            FCB     $43,$43 ; "CC"
0009                  ASS_REGS_CC_IX  EQU     $09
8A9A  C8                              FCB     $C8     ; FLAGS - SUF-MODE EXTRA0-OPMAP
8A9B  81                              FCB     $81     ; MODE #
                                      * SUFITEM [0A] - D
8A9C  44                              FCB     $44     ; "D"
8A9D  96                              FCB     $96     ; FLAGS - 10 #16 SUF-OP
8A9E  40                              FCB     $40     ; OP
                                      * SUFITEM [0B] - D
8A9F  44                              FCB     $44     ; "D"
8AA0  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AA1  03                              FCB     $03     ; OP
                                      * SUFITEM [0C] - D
8AA2  44                              FCB     $44     ; "D"
8AA3  96                              FCB     $96     ; FLAGS - 10 #16 SUF-OP
8AA4  02                              FCB     $02     ; OP
                                      * SUFITEM [0D] - D
8AA5  44                              FCB     $44     ; "D"
8AA6  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AA7  38                              FCB     $38     ; OP
                                      * SUFITEM [0E] - D
8AA8  44                              FCB     $44     ; "D"
8AA9  92                              FCB     $92     ; FLAGS - 10 #16
                                      * SUFITEM [0F] - D
8AAA  44                              FCB     $44     ; "D"
8AAB  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AAC  46                              FCB     $46     ; OP
                                      * SUFITEM [10] - I
8AAD  49                              FCB     $49     ; "I"
8AAE  80                              FCB     $80     ; FLAGS - 
                                      * SUFITEM [11] - S
8AAF  53                              FCB     $53     ; "S"
8AB0  96                              FCB     $96     ; FLAGS - 10 #16 SUF-OP
8AB1  48                              FCB     $48     ; OP
                                      * SUFITEM [12] - S
8AB2  53                              FCB     $53     ; "S"
8AB3  82                              FCB     $82     ; FLAGS - #16
                                      * SUFITEM [13] - S
8AB4  53                              FCB     $53     ; "S"
8AB5  97                              FCB     $97     ; FLAGS - 11 #16 SUF-OP
8AB6  0B                              FCB     $0B     ; OP
                                      * SUFITEM [14] - S
8AB7  53                              FCB     $53     ; "S"
8AB8  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AB9  02                              FCB     $02     ; OP
                                      * SUFITEM [15] - U
8ABA  55                              FCB     $55     ; "U"
8ABB  97                              FCB     $97     ; FLAGS - 11 #16 SUF-OP
8ABC  02                              FCB     $02     ; OP
                                      * SUFITEM [16] - U
8ABD  55                              FCB     $55     ; "U"
8ABE  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8ABF  03                              FCB     $03     ; OP
                                      * SUFITEM [17] - U
8AC0  55                              FCB     $55     ; "U"
8AC1  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AC2  02                              FCB     $02     ; OP
                                      * SUFITEM [18] - U
8AC3  55                              FCB     $55     ; "U"
8AC4  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AC5  48                              FCB     $48     ; OP
                                      * SUFITEM [19] - X
8AC6  58                              FCB     $58     ; "X"
8AC7  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AC8  0B                              FCB     $0B     ; OP
                                      * SUFITEM [1A] - X
8AC9  58                              FCB     $58     ; "X"
8ACA  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8ACB  08                              FCB     $08     ; OP
                                      * SUFITEM [1B] - X
8ACC  58                              FCB     $58     ; "X"
8ACD  82                              FCB     $82     ; FLAGS - #16
                                      * SUFITEM [1C] - Y
8ACE  59                              FCB     $59     ; "Y"
8ACF  96                              FCB     $96     ; FLAGS - 10 #16 SUF-OP
8AD0  08                              FCB     $08     ; OP
                                      * SUFITEM [1D] - Y
8AD1  59                              FCB     $59     ; "Y"
8AD2  96                              FCB     $96     ; FLAGS - 10 #16 SUF-OP
8AD3  0B                              FCB     $0B     ; OP
                                      * SUFITEM [1E] - Y
8AD4  59                              FCB     $59     ; "Y"
8AD5  86                              FCB     $86     ; FLAGS - #16 SUF-OP
8AD6  01                              FCB     $01     ; OP
                      
                      
                      *********************************************************
                      * C L A S S   T A B L E
                      *********************************************************
                      
8AD7                  assClassTbl
0000                  assClass_A_ix   equ     $00     ; class #assClassTbl_A
8AD7  05                              FCB     $05     ; max index
8AD8  80                              FCB     $80     ; flags
8AD9  00                              FCB     $00     ; suffix set
8ADA  00                              FCB     $00     ; mode set
0001                  assClass_A1_ix  equ     $01     ; class #assClassTbl_A1
8ADB  06                              FCB     $06     ; max index
8ADC  88                              FCB     $88     ; flags
8ADD  88                              FCB     $88     ; suffix set
8ADE  00                              FCB     $00     ; mode set
0002                  assClass_A2_ix  equ     $02     ; class #assClassTbl_A2
8ADF  07                              FCB     $07     ; max index
8AE0  88                              FCB     $88     ; flags
8AE1  81                              FCB     $81     ; suffix set
8AE2  00                              FCB     $00     ; mode set
0003                  assClass_B_ix   equ     $03     ; class #assClassTbl_B
8AE3  0A                              FCB     $0A     ; max index
8AE4  88                              FCB     $88     ; flags
8AE5  09                              FCB     $09     ; suffix set
8AE6  1F                              FCB     $1F     ; mode set
0004                  assClass_B2_ix  equ     $04     ; class #assClassTbl_B2
8AE7  0C                              FCB     $0C     ; max index
8AE8  88                              FCB     $88     ; flags
8AE9  08                              FCB     $08     ; suffix set
8AEA  1F                              FCB     $1F     ; mode set
0005                  assClass_C_ix   equ     $05     ; class #assClassTbl_C
8AEB  0D                              FCB     $0D     ; max index
8AEC  88                              FCB     $88     ; flags
8AED  17                              FCB     $17     ; suffix set
8AEE  1F                              FCB     $1F     ; mode set
0006                  assClass_DIR_ix equ     $06     ; class #assClassTbl_DIR
8AEF  13                              FCB     $13     ; max index
8AF0  80                              FCB     $80     ; flags
8AF1  00                              FCB     $00     ; suffix set
8AF2  00                              FCB     $00     ; mode set
0007                  assClass_E_ix   equ     $07     ; class #assClassTbl_E
8AF3  14                              FCB     $14     ; max index
8AF4  88                              FCB     $88     ; flags
8AF5  90                              FCB     $90     ; suffix set
8AF6  81                              FCB     $81     ; mode set
0008                  assClass_F_ix   equ     $08     ; class #assClassTbl_F
8AF7  18                              FCB     $18     ; max index
8AF8  80                              FCB     $80     ; flags
8AF9  12                              FCB     $12     ; suffix set
8AFA  3E                              FCB     $3E     ; mode set
0009                  assClass_G_ix   equ     $09     ; class #assClassTbl_G
8AFB  19                              FCB     $19     ; max index
8AFC  88                              FCB     $88     ; flags
8AFD  0B                              FCB     $0B     ; suffix set
8AFE  1F                              FCB     $1F     ; mode set
000A                  assClass_H_ix   equ     $0A     ; class #assClassTbl_H
8AFF  1E                              FCB     $1E     ; max index
8B00  80                              FCB     $80     ; flags
8B01  19                              FCB     $19     ; suffix set
8B02  3E                              FCB     $3E     ; mode set
000B                  assClass_I_ix   equ     $0B     ; class #assClassTbl_I
8B03  1F                              FCB     $1F     ; max index
8B04  88                              FCB     $88     ; flags
8B05  1C                              FCB     $1C     ; suffix set
8B06  1F                              FCB     $1F     ; mode set
000C                  assClass_K_ix   equ     $0C     ; class #assClassTbl_K
8B07  21                              FCB     $21     ; max index
8B08  80                              FCB     $80     ; flags
8B09  00                              FCB     $00     ; suffix set
8B0A  82                              FCB     $82     ; mode set
000D                  assClass_L_ix   equ     $0D     ; class #assClassTbl_L
8B0B  22                              FCB     $22     ; max index
8B0C  80                              FCB     $80     ; flags
8B0D  00                              FCB     $00     ; suffix set
8B0E  3E                              FCB     $3E     ; mode set
000E                  assClass_M_ix   equ     $0E     ; class #assClassTbl_M
8B0F  23                              FCB     $23     ; max index
8B10  80                              FCB     $80     ; flags
8B11  00                              FCB     $00     ; suffix set
8B12  4E                              FCB     $4E     ; mode set
000F                  assClass_N_ix   equ     $0F     ; class #assClassTbl_N
8B13  24                              FCB     $24     ; max index
8B14  88                              FCB     $88     ; flags
8B15  01                              FCB     $01     ; suffix set
8B16  1F                              FCB     $1F     ; mode set
0010                  assClass_P_ix   equ     $10     ; class #assClassTbl_P
8B17  25                              FCB     $25     ; max index
8B18  88                              FCB     $88     ; flags
8B19  0E                              FCB     $0E     ; suffix set
8B1A  04                              FCB     $04     ; mode set
0011                  assClass_Q_ix   equ     $11     ; class #assClassTbl_Q
8B1B  28                              FCB     $28     ; max index
8B1C  80                              FCB     $80     ; flags
8B1D  12                              FCB     $12     ; suffix set
8B1E  3E                              FCB     $3E     ; mode set
0012                  assClass_R_ix   equ     $12     ; class #assClassTbl_R
8B1F  29                              FCB     $29     ; max index
8B20  88                              FCB     $88     ; flags
8B21  81                              FCB     $81     ; suffix set
8B22  00                              FCB     $00     ; mode set
0013                  assClass_S_ix   equ     $13     ; class #assClassTbl_S
8B23  2B                              FCB     $2B     ; max index
8B24  88                              FCB     $88     ; flags
8B25  24                              FCB     $24     ; suffix set
8B26  83                              FCB     $83     ; mode set
0014                  assClass_T_ix   equ     $14     ; class #assClassTbl_T
8B27  2C                              FCB     $2C     ; max index
8B28  88                              FCB     $88     ; flags
8B29  01                              FCB     $01     ; suffix set
8B2A  4E                              FCB     $4E     ; mode set
0015                  assClass_U_ix   equ     $15     ; class #assClassTbl_U
8B2B  3F                              FCB     $3F     ; max index
8B2C  80                              FCB     $80     ; flags
8B2D  00                              FCB     $00     ; suffix set
8B2E  80                              FCB     $80     ; mode set
0016                  assClass_Y_ix   equ     $16     ; class #assClassTbl_Y
8B2F  40                              FCB     $40     ; max index
8B30  88                              FCB     $88     ; flags
8B31  14                              FCB     $14     ; suffix set
8B32  00                              FCB     $00     ; mode set
0017                  assClass_Z_ix   equ     $17     ; class #assClassTbl_Z
8B33  41                              FCB     $41     ; max index
8B34  88                              FCB     $88     ; flags
8B35  22                              FCB     $22     ; suffix set
8B36  1F                              FCB     $1F     ; mode set
8B37                  assClassTbl_END
                      
                      
                      
                      
                      *********************************************************
                      * M O D E    T A B L E 
                      *********************************************************
                      
8B37                  assModeTbl
8B37  12                              fcb     $12     ; # dp ix ex dp
8B38  10                              fcb     $10     ; OP
8B39  00                              fcb     $00     ; FLAGS
8B3A  14                              fcb     $14     ; # dp ix ex ix
8B3B  20                              fcb     $20     ; OP
8B3C  00                              fcb     $00     ; FLAGS
8B3D  18                              fcb     $18     ; # dp ix ex ex
8B3E  30                              fcb     $30     ; OP
8B3F  00                              fcb     $00     ; FLAGS
8B40  44                              fcb     $44     ; ST dp ix ex ix
8B41  10                              fcb     $10     ; OP
8B42  00                              fcb     $00     ; FLAGS
8B43  48                              fcb     $48     ; ST dp ix ex ex
8B44  20                              fcb     $20     ; OP
8B45  00                              fcb     $00     ; FLAGS
8B46  34                              fcb     $34     ; dp ix ex ix
8B47  60                              fcb     $60     ; OP
8B48  00                              fcb     $00     ; FLAGS
8B49  38                              fcb     $38     ; dp ix ex ex
8B4A  70                              fcb     $70     ; OP
8B4B  00                              fcb     $00     ; FLAGS
8B4C  00                              FCB 0; EOT
                      
                      
0081                  ASS_MODESET_IMMEDONLY   equ     $81
001F                  ASS_MODESET_ANY1        equ     $1F
002F                  ASS_MODESET_ANY_LDQ     equ     $2F
004E                  ASS_MODESET_MEM2        equ     $4E
0083                  ASS_MODESET_W   equ     $83
003E                  ASS_MODESET_MEM1        equ     $3E
0004                  ASS_MODESET_INDEXONLY   equ     $04
0082                  ASS_MODESET_REGREG      equ     $82
0080                  ASS_MODESET_REL equ     $80
0084                  ASS_MODESET_BITBIT      equ     $84
0085                  ASS_MODESET_TFM equ     $85
0000                  ASS_MODESET_IMPLIED     equ     $00
                      
                      
                      *********************************************************
                      * C C    O P S
                      *********************************************************
                      
8B4D                  assXlateCC
8B4D  02                              fcb     $02     ; size
8B4E  8A                              fcb     $8A     ; op org
8B4F  1A                              fcb     $1A     ; op new
8B50  84                              fcb     $84     ; op org
8B51  1C                              fcb     $1C     ; op new
7FFF                  ASS_MNE_BITS    equ     $00007FFF       ; bits used in mnemonics
0011                  ASS_BITS_PRE    equ     $11     ; bits set indicate prefix
0010                  ASS_BITS_PRE_10 equ     $10     ; prefix = $10
0011                  ASS_BITS_PRE_11 equ     $11     ; prefix = $10
0040                  ASS_BITS_EXTRA0 equ     $40     ; EXTRA0 only
0008                  ASS_BITS_BOTH   equ     $08     ; BOTH suffix and mode required
0002                  ASS_BITS_16B    equ     $02     ; immediate values 16 bits
                      
000C                  FLAGS_SUF_ANY   equ     $0C     ; suffix specific bits
0004                  FLAGS_SUF_OP    equ     $04     ; suffix followed by OP code delta
0008                  FLAGS_SUF_MODE  equ     $08     ; suffix followed by mode override
                      
0004                  ASS_CLSTBL_SIZE equ     $04     ; class table entry size
0000                  ASS_CLSTBL_OF_IXMAX     equ     $00     ; offset ixmax
0001                  ASS_CLSTBL_OF_FLAGS     equ     $01     ; offset flags
0002                  ASS_CLSTBL_OF_SUFS      equ     $02     ; offset suffix set
0003                  ASS_CLSTBL_OF_MODES     equ     $03     ; offset suffix set
                      
0003                  ASS_OPTBL_SIZE  equ     $03     ; opcode/mne table entry size
0000                  ASS_OPTBL_OF_MNE        equ     $00     ; offset mne hash (2)
0002                  ASS_OPTBL_OF_OP equ     $02     ; offset base opcode
                      
0010                  ASS_MEMPB_IND   equ     $10     ;IX,INDIRECT FLAG
0020                  ASS_MEMPB_SZ8   equ     $20     ;IX,FORCE 8
0040                  ASS_MEMPB_SZ16  equ     $40     ;IX,FORCE 16
0001                  ASS_MEMPB_IMM   equ     $01     ;IMMEDIATE
0002                  ASS_MEMPB_DP    equ     $02     ;DIRECT PAGE
0004                  ASS_MEMPB_IX    equ     $04     ;INDEX/INDIRECT
0008                  ASS_MEMPB_EXT   equ     $08     ;EXTENDED
                              ENDIF
                      
                      
0004                  assEndStmtChCt  EQU     4
8B52  3A0D5C3B        assEndStmtCh    FCB     ":",$0D,"\\;"
                      
8B56  C60C            assScanNextOp   LDB     #ASS_VAR_SPACE
8B58  6FE2            1               CLR     ,-S                             ; make room on stack
8B5A  5A                              DECB
8B5B  26FB                            BNE     1B
                                      
8B5D                  assScanContinue
8B5D                                  CALL    skipSpacesYStepBack             ; L89EB
8B5D                  9
8B5F                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0036                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8B5D  BD9295                                  JSR     \1
                              ENDIF
                      
8B60  C604                            LDB     #assEndStmtChCt
8B62  8E8B52                          LDX     #assEndStmtCh
8B65  A180            1               CMPA    ,X+
8B67  10270460                        LBEQ    assScanEndOfStmt
8B6B  5A                              DECB
8B6C  26F7                            BNE     1B
                      
8B6E  812E                            CMPA    #'.'
8B70  272D                            BEQ     assScanLabel                    ;  Label
8B72  C603                            LDB     #$03                            ;  Prepare to fetch up to three characters
8B74  D738                            STB     ZP_ASS_LIST_OPLEN               ;  counter of # of chars in accumulator
                      
                                      ; special check for op code starting "LB"
8B76  ECC4                            LDD     ,U
                              IF CPU_6309
                                      ANDD    #$DFDF                          ; to uppercase
                              ELSE
8B78  84DF                            ANDA    #$DF
8B7A  C4DF                            ANDB    #$DF
                              ENDIF
8B7C  10834C42                        CMPD    #('L'<<8) + 'B'
8B80  2606                            BNE     assScanOpLoop
8B82  8640                            LDA     #ASS_BITS_EXTRA0
8B84  A764                            STA     ASS_VAR_FLAGS,S                 ; set flag
8B86  3341                            LEAU    1,U
8B88                  assScanOpLoop
                                      ; parse loop, keep adding chars until there's a match or 3 chars added (|P_ASS_LIST_OPLEN)
8B88  A6C0                            LDA     ,U+
8B8A  2B2B                            BMI     assScanTokFound                 ; special handling for tokens OR,EOR,AND
8B8C  8120                            CMPA    #' '
8B8E  2746                            BEQ     assScanOpSkSpace
                      
                                      ; rol into accumulator
8B90  C605                            LDB     #$05
8B92  48                              ASLA
8B93  48                              ASLA
8B94  48                              ASLA
8B95  48              assScanOpLoop2  ASLA                                    ; L8A17
8B96  6961                            ROL     ASS_VAR_OPACC+1,S               ; roll 5 LSB's of opcode char into accum
8B98  69E4                            ROL     ASS_VAR_OPACC+0,S
8B9A  5A                              DECB
8B9B  26F8                            BNE     assScanOpLoop2
8B9D  2039                            BRA     assScanParseTbl
                      
8B9F  3341            assScanLabel    LEAU    1,U                             ; L89D4
8BA1                                  CALL    findVarOrAllocEmpty
8BA1                  9
8BA3                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BA1  BD9A31                                  JSR     \1
                              ENDIF
8BA4  274A                            BEQ     assJmpBrkSyntax2
8BA6  2548                            BCS     assJmpBrkSyntax2
8BA8                                  CALL    pushVarPtrAndType
8BA8                  9
8BAA                  __XBSR                  SET 9B+2
2F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BA8  BDBB68                                  JSR     \1
                              ENDIF
8BAB                                  CALL    GetP_percent                    ;  Get P%
8BAB                  9
8BAD                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BAB  BDADB6                                  JSR     \1
                              ENDIF
8BAE  9727                            STA     ZP_VARTYPE
8BB0                                  CALL    storeEvaledExpressioninStackedVarPTr
8BB0                  9
8BB2                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8BB0  BDB33B                                  JSR     \1
                              ENDIF
                      ;;              CALL    copyTXTOFF2toTXTOFF
8BB3  DF4E                            STU     ZP_ASS_LBLEND           
                      
8BB5  20A6                            BRA     assScanContinue
                      
                      
8BB7                  assScanTokFound
                                      ; this assumes that the token is at the start of the scan and just sets up the
                                      ; accumulator as such
                              IF CPU_6309
                                      LDB     #4
                              ELSE
8BB7  C603                            LDB     #3
                              ENDIF
8BB9  308C37                          LEAX    assTok2Acc_tbl,PCR
8BBC  A184            1               CMPA    ,X
8BBE  2707                            BEQ     1F
8BC0  3002                            LEAX    2,X
8BC2  5A                              DECB
8BC3  26F7                            BNE     1B
8BC5  2029                            BRA     assJmpBrkSyntax2                ; not found syntax error
8BC7  E601            1               LDB     1,X
8BC9  D744                            STB     ZP_ASS_OP_IX                    ; setup index
8BCB  8603                            LDA     #ASS_OPTBL_SIZE
8BCD  3D                              MUL
8BCE  308DFDCB                        LEAX    assParseTbl,PCR
8BD2  308B                            LEAX    D,X                             ; X now points at parse table entry
8BD4  2023                            BRA     assScanParseTbl_match
                      
                      
8BD6                  assScanOpSkSpace
8BD6  0F38                            CLR     ZP_ASS_LIST_OPLEN               ; clear char counter, scan no more chars
8BD8                  assScanParseTbl
                                      ; now try matching against the parse table
8BD8  8E899D                          LDX     #assParseTbl                    ; get start of parse table
8BDB  0F44                            CLR     ZP_ASS_OP_IX                    ; index
8BDD                  assScanParseTbl_lp
8BDD  EC84                            LDD     ASS_OPTBL_OF_MNE,X              ; get hashed opcode from table
8BDF  2B0B                            BMI     assScanParse_nomatch
8BE1  10A3E4                          CMPD    ASS_VAR_OPACC,S                 ; compare with hashed opcode built from source
8BE4  2713                            BEQ     assScanParseTbl_match
8BE6                  assScanParseTbl_next            
8BE6  0C44                            INC     ZP_ASS_OP_IX
8BE8  3003                            LEAX    ASS_OPTBL_SIZE,X                ; no match
8BEA  20F1                            BRA     assScanParseTbl_lp
                                      
8BEC                  assScanParse_nomatch
8BEC  0A38                            DEC     ZP_ASS_LIST_OPLEN
8BEE  2698                            BNE     assScanOpLoop
                      
8BF0                  assJmpBrkSyntax2
8BF0                                  JUMP    brkSyntax
8BF0  7E9C37                                  JMP     \1
                      
8BF3                  assTok2Acc_tbl
8BF3  80                              FCB     tknAND
8BF4  0A                              FCB     assParseTbl_AND_IX
8BF5  82                              FCB     tknEOR
8BF6  08                              FCB     assParseTbl_EOR_IX
8BF7  84                              FCB     tknOR
8BF8  0B                              FCB     assParseTbl_OR_IX
                              IF ASSEMBLER_6309
                                      FCB     tknDIV
                                      FCB     assParseTbl_DIV_IX
                              ENDIF
                      
                              IF      assParseTbl_AND-assParseTbl > 255 || assParseTbl_EOR-assParseTbl > 255 || assParseTbl_OR-assParseTbl > 255 || assParseTbl_DIV-assParseTbl > 255
                                      error   "assTok2Acc_tbl overflow"
                              ENDIF
                      
                      
8BF9                  assScanParseTbl_match
                      
8BF9                  assScanProcessTblEnt                                    
                                      ; X now points at matching parse table entry and we've tried all possible 5 char opcodes
                                      ; we now have X pointing at parser table entry
                                      ; ZP_ASS_OP_IX is the op index which we'll used to access the classes table
                                      ; save the stuff in our stack workspace
8BF9  A602                            LDA     ASS_OPTBL_OF_OP,X
8BFB  A767                            STA     ASS_VAR_OP,S                    ; base opcode
8BFD  9644                            LDA     ZP_ASS_OP_IX
8BFF  A7E4                            STA     ASS_VAR_IX,S                    ; op index
                                      ; find which class from the class table
8C01  308DFED2                        LEAX    assClassTbl,PCR                 ; get base of class table
8C05  5F                              CLRB
8C06  A184            1               CMPA    ASS_CLSTBL_OF_IXMAX,X           ; see if the opcode index is < ixmax
8C08  2505                            BLO     assClassFound
8C0A  3004                            LEAX    ASS_CLSTBL_SIZE,X
8C0C  5C                              INCB
8C0D  20F7                            BRA     1B
                      
8C0F                  assClassFound
8C0F  A601                            LDA     ASS_CLSTBL_OF_FLAGS,X
8C11  AA64                            ORA     ASS_VAR_FLAGS,S                 ; possibly already set flags in parse for "LB"
8C13  A764                            STA     ASS_VAR_FLAGS,S                 ; parse flags
                      
8C15  C106                            CMPB    #assClass_DIR_ix
8C17  10270409                        LBEQ    assClass_DIR_parse
                      
8C1B  6C63                            INC     ASS_VAR_OPLEN,S                 ; got at least 1 byte to store
                              IF ASSEMBLER_6309
                                      CMPB    #assClass_D_ix                  ; class D is AIM etc require an immediate before looking for modes
                                      LBEQ    assClass_D_parse
                              ENDIF
                                      ; Get modeset and store it
8C1D  E603                            LDB     ASS_CLSTBL_OF_MODES,X
8C1F  E762                            STB     ASS_VAR_MODESET,S
                      
                                      ; check to see if there's a suffix set and process it
8C21  E602                            LDB     ASS_CLSTBL_OF_SUFS,X
8C23  1027001E                        LBEQ    assModesParse
8C27  102B000D                        LBMI    assClass_SuffSetSingle          ; skip straight to singleton
8C2B                  assClassSuff_FollowTail
8C2B  8E8A61                          LDX     #assSuffSetsTbl                 ; get base of suffix sets table
                                      ; loop through table to find start of our set, skipping unwanted sets
8C2E  C43F                            ANDB    #$3F
8C30  5A              1               DECB
8C31  3A                              ABX
8C32                  assClass_SuffSetLp
                                      ; suffix set found, now need to try out each suffix set item
8C32  E680                            LDB     ,X+
8C34  C540                            BITB    #$40                            ; check for a tail bit - if set restart scan at spec'd index in lower bits
8C36  26F3                            BNE     assClassSuff_FollowTail
8C38                  assClass_SuffSetSingle
8C38                                  CALL    assParseTrySuffix
8C38                  9
8C3A                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0025                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8C38  8D25                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8C3A  251A                            BCS     assClass_suffixMatched          ; we found one
8C3C  5D                              TSTB    
8C3D  2AF3                            BPL     assClass_SuffSetLp              ; not at end of suffix set yet try again
                                      ; no suffix matched - if "both" flag is set then error out
8C3F  8608                            LDA     #ASS_BITS_BOTH
8C41  A564                            BITA    ASS_VAR_FLAGS,S
8C43  26AB                            BNE     assJmpBrkSyntax2
                      
8C45                  assModesParse
8C45  E662                            LDB     ASS_VAR_MODESET,S               ; get modes set
8C47  2713                            BEQ     jmpAssScanEndOfStmt             ; node modes set, implicit, we're done
8C49  102A009F                        LBPL    assModesParseMem
                      
8C4D  C407                            ANDB    #$07
8C4F  58                              ASLB
8C50  8E8CE4                          LDX     #assModesTbl
8C53  3A                              ABX
8C54  6E94                            JMP     [,X]
                      
8C56                  assClass_suffixMatched
                                      
                                      ; check to see if this is a "both" type opcode
8C56  8608                            LDA     #ASS_BITS_BOTH
8C58  A564                            BITA    ASS_VAR_FLAGS,S
8C5A  26E9                            BNE     assModesParse           
8C5C                  jmpAssScanEndOfStmt
8C5C                                  JUMP    assScanEndOfStmt
8C5C  7E8FCB                                  JMP     \1
                      
8C5F                  assParseTrySuffix
                                      ; try and match suffix against source text
                                      ; if a match return CY=1, A=flags, B=opcode delta, else X,B preserved
                      
8C5F  3454                            PSHS    B,X,U
8C61  C43F                            ANDB    #$3F                            ; ignore tail / end bits
8C63  E768                            STB     7+ASS_VAR_SUFFIX,S
                      
                      
8C65  308DFE1D                        LEAX    assSuffItemTbl,PCR              ; point to suffix items table
8C69  5A              1               DECB
8C6A  2712                            BEQ     assSuffItemFound
                      
                                      ; skip suffix string, skip chars until -ve
8C6C  A680            2               LDA     ,X+
8C6E  2AFC                            BPL     2B
                      
8C70  8504                            BITA    #FLAGS_SUF_OP
8C72  2702                            BEQ     3F
8C74  3001                            LEAX    1,X                             ; skip op
                      
8C76  8508            3               BITA    #FLAGS_SUF_MODE
8C78  2702                            BEQ     3F
8C7A  3001                            LEAX    1,X                             ; skip mode
                      
8C7C  20EB            3               BRA     1B
                      
8C7E                  assSuffItemFound
                                      ; we are now pointing at suffix def
8C7E                                  CALL    assMatchXY
8C7E                  9
8C80                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8C7E  8D04                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8C80  2521                            BCS     assSuffItemMatch
                                      ; reset U
8C82  35D4                            PULS    B,X,U,PC
                      
8C84                  assMatchXY      ; match strings at X, U (X is >$80 terminated) return Cy=1 for match or Cy=0 and >$80 in A
                                      ; match to source, note needs to match partial strings i.e. S or SP
8C84  A680            1               LDA     ,X+
8C86  2B0D                            BMI     2F      
8C88  A8C0                            EORA    ,U+                             ; get source char
8C8A  84DF                            ANDA    #$DF                            ; ifgnore case
8C8C  27F6                            BEQ     1B
8C8E  A680            3               LDA     ,X+                             ; skip rest of string up to terminator
8C90  2AFC                            BPL     3B
8C92                  4               CLC     
8C92  1CFE                    ANDCC   #~CC_C
8C94  39                              RTS
8C95                  2               ; check to see if at end of register i.e. <A >Z
8C95  3402                            PSHS    A
8C97  A6C4                            LDA     ,U
8C99                                  CALL    checkIsValidVariableNameChar
8C99                  9
8C9B                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8C99  BD915D                                  JSR     \1
                              ENDIF
8C9C  3502                            PULS    A
8C9E  25F2                            BCS     4B                              ; return no match
8CA0                                  SEC
8CA0  1A01                    ORCC    #CC_C
8CA2  39                              RTS
                      
                      
8CA3                  assSuffItemMatch                
8CA3  3265                            LEAS    5,S                             ; discard saved U,B,X
                      
8CA5  8504                            BITA    #FLAGS_SUF_OP
8CA7  2706                            BEQ     3F
8CA9  E680                            LDB     ,X+                             ; get op code delta in B
8CAB  EB69                            ADDB    2+ASS_VAR_OP,S
8CAD  E769                            STB     2+ASS_VAR_OP,S                  ; update opcode
8CAF  8508            3               BITA    #FLAGS_SUF_MODE
8CB1  2704                            BEQ     3F
8CB3  E680                            LDB     ,X+                             ; get mode override
8CB5  E764                            STB     2+ASS_VAR_MODESET,S
                      
8CB7  8540            3               BITA    #ASS_BITS_EXTRA0
8CB9  2720                            BEQ     3F
                      
                                      ;lookup extra opcode mappings based on suffset/orginal op
8CBB  3406                            PSHS    D
8CBD  A66B                            LDA     4+ASS_VAR_OP,S                  ; original opcode
8CBF  E665                            LDB     4+ASS_VAR_SUFFIX,S              ; suffix set
                              IF ASSEMBLER_6309
                                      CMPB    #ASS_REGS_REGREG_IX
                                      BNE     1F
                                      LDX     #assXlateRegReg
                                      BRA     2F
                      1
                              ENDIF
8CC1  C109                            CMPB    #ASS_REGS_CC_IX
8CC3  2614                            BNE     1F
8CC5  8E8B4D                          LDX     #assXlateCC
8CC8                  2               ; scan table, look for op map
8CC8  E680                            LDB     ,X+                             ; size of table
8CCA  A180            4               CMPA    ,X+                             ; compare opcode to xlate table entry
8CCC  2707                            BEQ     5F
8CCE  3001                            LEAX    1,X
8CD0  5A                              DECB    
8CD1  26F7                            BNE     4B
8CD3  2004                            BRA     1F
8CD5  A680            5               LDA     ,X+
8CD7  A76B                            STA     4+ASS_VAR_OP,S
8CD9  3506            1               PULS    D
                      
8CDB  84F3            3               ANDA    #~FLAGS_SUF_ANY                 ; clear suffix specific bits
8CDD  AA66                            ORA     2+ASS_VAR_FLAGS,S               ; update flags
8CDF  A766                            STA     2+ASS_VAR_FLAGS,S
8CE1                                  SEC                                     ; indicate successful match
8CE1  1A01                    ORCC    #CC_C
8CE3  39                              RTS
                      
                      
                      
                      
8CE4                  assModesTbl
8CE4  8F62                            FDB     assModesRel
8CE6  8FAC                            FDB     assModesImmed
8CE8  8EF6                            FDB     assModesRegReg
8CEA  8F26                            FDB     assModesPxxxW
                              IF ASSEMBLER_6309
                                      FDB     assModesBitBit
                                      FDB     assModesTFM
                              ENDIF
8CEC                  assModesParseMem
8CEC                                  CALL    skipSpacesY
8CEC                  9
8CEE                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CEC  BD928C                                  JSR     \1
                              ENDIF
                                      ; a "standard memory type"
                                      ; immed?
8CEF  C501                            BITB    #1
8CF1  276D                            BEQ     assModesParseMem_NotImmed       ; if bit 0 set try immed
8CF3  8123                            CMPA    #'#'
8CF5  2669                            BNE     assModesParseMem_NotImmed
8CF7                  assModeImmed
8CF7                                  CALL    evalForceINT
8CF7                  9
8CF9                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8CF7  BD95A1                                  JSR     \1
                              ENDIF
8CFA  C6FF                            LDB     #-1             
8CFC  A662                            LDA     ASS_VAR_MODESET,S
8CFE  812F                            CMPA    #ASS_MODESET_ANY_LDQ            ; if LDQ then 32 bit immeds
8D00  2604                            BNE     2F
8D02  C6FC                            LDB     #-4
8D04  2007                            BRA     1F
8D06  A664            2               LDA     ASS_VAR_FLAGS,S
8D08  8502                            BITA    #ASS_BITS_16B                   ; if 16 bit immeds
8D0A  2701                            BEQ     1F                                      
8D0C  5A                              DECB
8D0D  8E002E          1               LDX     #ZP_INT_WA+4
8D10  3085                            LEAX    B,X
8D12  50                              NEGB
8D13                                  CALL    assCopyBBytesToOpBuf
8D13                  9
8D15                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
004B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D13  BD9060                                  JSR     \1
                              ENDIF
8D16  C601                            LDB     #ASS_MEMPB_IMM
8D18                  assMemModeCheckValid
8D18  3404                            PSHS    B
8D1A  A6E4                            LDA     ASS_VAR_MODEP,S
8D1C  AAE0                            ORA     ,S+
8D1E  E462                            ANDB    ASS_VAR_MODESET,S
8D20  C40F                            ANDB    #$0F
8D22  272D                            BEQ     brkIllMode
                      
                                      ; calculate mem/op combination based on address type and modeset
                                                                              ; get lower 4 bits of MODEP
8D24  840F                            ANDA    #$0F
8D26  972A                            STA     ZP_INT_WA
8D28  A662                            LDA     ASS_VAR_MODESET,S
8D2A  8470                            ANDA    #$70                            ; get modeset index
8D2C  9A2A                            ORA     ZP_INT_WA
8D2E  972A                            STA     ZP_INT_WA
                                      ; search assModeTbl for matching entry
8D30  8E8B37                          LDX     #assModeTbl
8D33  A680            1               LDA     ,X+
8D35  2714                            BEQ     2F                              ; end of table
8D37  912A                            CMPA    ZP_INT_WA
8D39  2704                            BEQ     3F
8D3B  3002                            LEAX    2,X
8D3D  20F4                            BRA     1B
8D3F                  3               ; got a match update flags and opcode
8D3F  A680                            LDA     ,X+
8D41  AB67                            ADDA    ASS_VAR_OP,S
8D43  A767                            STA     ASS_VAR_OP,S
8D45  A680                            LDA     ,X+
8D47  AA64                            ORA     ASS_VAR_FLAGS,S
8D49  A764                            STA     ASS_VAR_FLAGS,S
                      
8D4B                  2               
                                      ; final mode check
                      
8D4B                                  JUMP    assScanEndOfStmt
8D4B  7E8FCB                                  JMP     \1
                      
                      
8D4E                  assJmpBrkSyntax                                         ; L8A35
8D4E                                  JUMP     brkSyntax
8D4E  7E9C37                                  JMP     \1
                      
8D51                  brkIllMode
8D51                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8D51  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8D52  03496C6C6567616C204D6F646500                 FCB     $3, "Illegal Mode", 0
                      
8D60                  assModesParseMem_NotImmed
                                      ; now look for any of the memory addressing modes
8D60  6FE4                            CLR     ASS_VAR_MODEP,S                 ; clear flags
                      
                                      ; check for any <,>,[
8D62  813C            4               CMPA    #'<'
8D64  2604                            BNE     1F
                                      ; got an DP indicator
8D66  8620                            LDA     #ASS_MEMPB_SZ8
8D68  200E                            BRA     2F
8D6A  815B            1               CMPA    #'['
8D6C  2604                            BNE     1F
                                      ; got an DP indicator
8D6E  8610                            LDA     #ASS_MEMPB_IND
8D70  2006                            BRA     2F
8D72  813E            1               CMPA    #'>'
8D74  260B                            BNE     4F
8D76  8640                            LDA     #ASS_MEMPB_SZ16
                                      ; got an DP indicator
8D78  AAE4            2               ORA     ASS_VAR_MODEP,S
8D7A  A7E4                            STA     ASS_VAR_MODEP,S
8D7C                  3               CALL    skipSpacesY
8D7C                  9
8D7E                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
000E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D7C  BD928C                                  JSR     \1
                              ENDIF
8D7F  20E1                            BRA     4B
                      
8D81  812C            4               CMPA    #','
8D83  102700DA                        LBEQ    assModeZeroIX
                      
                                      ; now check for R,IX form
8D87  DF19                            STU     ZP_TXTPTR2                      ; save U incase we back out
8D89  8E8EEF                          LDX     #assModesTblAccIX
8D8C  84DF                            ANDA    #$DF                            ; to upper
8D8E  972A                            STA     ZP_INT_WA
8D90  EC81            1               LDD     ,X++
8D92  4D                              TSTA    
8D93  10270087                        LBEQ    assModexParseNotRegIX
8D97  912A            2               CMPA    ZP_INT_WA                       ; compare to original char
8D99  26F5                            BNE     1B
                              IF ASSEMBLER_6309
                                      ; check for 6309 mode
                                      TSTB    
                                      BPL     1F
                                      LDA     #$10
                                      BITA    ZP_OPT
                                      LBEQ    assModexParseNotRegIX           ; skip it, we're not in 6309 mode!
                      1               
                              ENDIF
8D9B                                  CALL    skipSpacesCheckCommaAtY
8D9B                  9
8D9D                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
002B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8D9B  BD90C8                                  JSR     \1
                              ENDIF
8D9E  1026007C                        LBNE    assModexParseNotRegIX
8DA2  C40F                            ANDB    #$0F
                                      ; we now have an index type # in B
                      
8DA4                                  CALL    assModeParseIXRegAfterComma
8DA4                  9
8DA6                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8DA4  8D1E                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8DA6                  assPostByteIXCheckIndThenValidate
8DA6                                  CALL    assModeParseIXIndCheckAndMerge2A
8DA6                  9
8DA8                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0007                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8DA6  8D07                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8DA8                  assPostByteIXCheckValidModeIX
8DA8  C604                            LDB     #ASS_MEMPB_IX
8DAA                  assPostByteIXCheckValid
8DAA                                  CALL    assPostByte             
8DAA                  9
8DAC                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8DAA  8D0C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8DAC                                  JUMP    assMemModeCheckValid    
8DAC  7E8D18                                  JMP     \1
                      
8DAF                  assModeParseIXIndCheckAndMerge2A
                                      ; merge in the indirect flag if present
8DAF  A662                            LDA     2+ASS_VAR_MODEP,S
8DB1  3404                            PSHS    B
8DB3  8410                            ANDA    #ASS_MEMPB_IND
8DB5  AAE0                            ORA     ,S+
8DB7  39                              RTS
                      
                      
8DB8  3404            assPostByte     PSHS    B
                                      ; add this byte to instruction
8DBA  E666                            LDB     3+ASS_VAR_OPLEN,S
8DBC  CB0A                            ADDB    #3+ASS_VAR_OP
8DBE  A7E5                            STA     B,S
8DC0  6C66                            INC     3+ASS_VAR_OPLEN,S
8DC2  3584                            PULS    B,PC
                      
8DC4                  assModeParseIXRegAfterComma
                      ; enter with index type (i.e. low 4 bits of post byte) in B
                      
8DC4                                  CALL    skipSpacesY                     ; this should be one of SUXY
8DC4                  9
8DC6                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8DC4  BD928C                                  JSR     \1
                              ENDIF
8DC7  84DF                            ANDA    #$DF                            ; to upper
8DC9  5D                              TSTB
8DCA  263B                            BNE     assDontCheckPC
                                      ; if B is 0 on entry also test for PC/PCR
8DCC  8150                            CMPA    #'P'
8DCE  2637                            BNE     assDontCheckPC
8DD0  A6C0                            LDA     ,U+
8DD2  8143                            CMPA    #'C'
8DD4  263E                            BNE     brkIndex
8DD6  A6C4                            LDA     ,U
8DD8  8152                            CMPA    #'R'
8DDA  2628                            BNE     assNotPCR
8DDC  3341                            LEAU    1,U
                                      ; PCR, subtract P% from INT_WA          
                                      ; calculate length of instruction in ZP_INT_WA+0,1
8DDE  0F2A                            CLR     ZP_INT_WA
8DE0  8603                            LDA     #3                              ; room for op, post byte, 8 bit offset 
8DE2  C611                            LDB     #ASS_BITS_PRE
8DE4  E566                            BITB    2+ASS_VAR_FLAGS,S
8DE6  2603                            BNE     1F
8DE8  7C8DE8                          INC     A                               ; add one for prefix
8DEB  972B            1               STA     ZP_INT_WA + 1
8DED  DC2C                            LDD     ZP_INT_WA + 2
8DEF  B30442                          SUBD    VAR_P_PERCENT + 2
8DF2  932A                            SUBD    ZP_INT_WA + 0                   ; subtract length of op (8 bit form)
8DF4  DD2C                            STD     ZP_INT_WA + 2
8DF6  1D                              SEX
8DF7  912C                            CMPA    ZP_INT_WA + 2                   ; check if fits in 8 bits
8DF9  2709                            BEQ     assNotPCR                       ; it does
                                      ; it doesn't fit
8DFB  8640                            LDA     #ASS_MEMPB_SZ16
8DFD  AA66                            ORA     2+ASS_VAR_FLAGS,S
8DFF  A766                            STA     2+ASS_VAR_FLAGS,S
8E01                                  CALL    assDecIntWa2
8E01                  9
8E03                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0057                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E01  BD8F5A                                  JSR     \1
                              ENDIF
                      
8E04  C60C            assNotPCR       LDB     #$0C                            ; +ve C indicates PC/PCR
8E06  39                              RTS
8E07  8E8EEB          assDontCheckPC  LDX     #assModesTblRegIX
8E0A  CAE0                            ORB     #$80+(3<<5)                     ; index reg bits and 1 in top bit
8E0C  A180            1               CMPA    ,X+
8E0E  270C                            BEQ     assModeParseIXRegFound
8E10  C020                            SUBB    #1<<5
8E12  2BF8                            BMI     1B                              ; if it goes +ve again we've tried everything
8E14                  brkIndex        DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8E14  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8E15  03496E64657800                  FCB     $3, "Index", 0
8E1C                  assModeParseIXRegFound
8E1C  5D                              TSTB
8E1D  39                              RTS
                      
8E1E                  assModexParseNotRegIX
8E1E  DE19                            LDU     ZP_TXTPTR2
8E20  335F                            LEAU    -1,U
                      
8E22                                  CALL    evalForceINT
8E22                  9
8E24                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E22  BD95A1                                  JSR     \1
                              ENDIF
8E25                                  CALL    skipSpacesCheckCommaAtYStepBack
8E25                  9
8E27                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E25  BD90CE                                  JSR     \1
                              ENDIF
8E28  273A                            BEQ     assModeParseOffsIX
                                      ; not , so either a DP or EXT or [indir]
                                      ; first check for indir
8E2A  8610                            LDA     #ASS_MEMPB_IND
8E2C  A5E4                            BITA    ASS_VAR_MODEP,S
8E2E  270F                            BEQ     assModexDpOrExt
                                      ; it is indir
8E30  CC9F04                          LDD     #$9F00 + ASS_MEMPB_IX           ; special number for indirect
8E33                  assModePostByteThen16fromWA
8E33                                  CALL    assPostByte
8E33                  9
8E35                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8E33  8D83                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8E35                  assMode16fromWA
8E35  962C                            LDA     ZP_INT_WA+2
8E37                                  CALL    assPostByte
8E37                  9
8E39                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E37  BD8DB8                                  JSR     \1
                              ENDIF
8E3A                  assMode8fromWA
8E3A  962D                            LDA     ZP_INT_WA+3
8E3C                                  JUMP    assPostByteIXCheckValid
8E3C  7E8DAA                                  JMP     \1
8E3F                  assModexDpOrExt
                                      ; TODO - this assumes 16 if not <
8E3F  8620                            LDA     #ASS_MEMPB_SZ8
8E41  A5E4                            BITA    ASS_VAR_MODEP,S
8E43  2605                            BNE     assModexDp
                                      ; mode is EXT
8E45  C608                            LDB     #ASS_MEMPB_EXT
8E47                                  JUMP    assMode16fromWA
8E47  7E8E35                                  JMP     \1
8E4A  C602            assModexDp      LDB     #ASS_MEMPB_DP
8E4C                                  JUMP    assMode8fromWA
8E4C  7E8E3A                                  JMP     \1
                      
8E4F  5C              assIXAutoDec    INCB
8E50  5C                              INCB
8E51  A6C0                            LDA     ,U+
8E53  812D                            CMPA    #'-'
8E55  2603                            BNE     2F
8E57  5C                              INCB
8E58  2002                            BRA     1F
8E5A  335F            2               LEAU    -1,U
8E5C                  1               CALL    assModeParseIXRegAfterComma
8E5C                  9
8E5E                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0066                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E5C  BD8DC4                                  JSR     \1
                              ENDIF
8E5F  2022                            BRA     assModeParseAutoIncDecDone
                      
8E61                  assModeZeroIX
8E61                                  CALL    varFALSE                        ; put 0 in ZP_INT_WA
8E61                  9
8E63                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E61  BDAC1D                                  JSR     \1
                              ENDIF
8E64                  assModeParseOffsIX
                                      ; ZP_INT_WA now contains the offset
                                      ; FLAGS may indicate to force 8 or 16 bits
                                      ; first parse which register
8E64  5F                              CLRB
8E65                                  CALL    skipSpacesY
8E65                  9
8E67                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0025                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E65  BD928C                                  JSR     \1
                              ENDIF
8E68  812D                            CMPA    #'-'
8E6A  27E3                            BEQ     assIXAutoDec
8E6C  335F                            LEAU    -1,U
8E6E                                  CALL    assModeParseIXRegAfterComma
8E6E                  9
8E70                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E6E  BD8DC4                                  JSR     \1
                              ENDIF
8E71  2A22                            BPL     assModeParseOffsIX_NotAutoInc   ; if +ve B then is PC/PCR
                                      ; check for -,--,+,++
8E73                                  CALL    skipSpacesY
8E73                  9
8E75                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E73  BD928C                                  JSR     \1
                              ENDIF
8E76  812B                            CMPA    #'+'
8E78  261B                            BNE     assModeParseOffsIX_NotAutoInc
8E7A  A6C4                            LDA     ,U
8E7C  812B                            CMPA    #'+'
8E7E  2603                            BNE     assModeParseAutoIncDecDone
8E80  3341                            LEAU    1,U
8E82  5C                              INCB
8E83                  assModeParseAutoIncDecDone
8E83                  2               CALL    IntWAZero
8E83                  9
8E85                  __XBSR                  SET 9B+2
2B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E83  BDB9D6                                  JSR     \1
                              ENDIF
8E86  268C                            BNE     brkIndex                        ; must be 0 offset
                                                                              ; should be one of 0 for +, 1 for ++, 2 for -, 3 for --
8E88  C501                            BITB    #1                              ; if not odd then can't be indirect
8E8A  2606                            BNE     1F
8E8C  8610                            LDA     #ASS_MEMPB_IND
8E8E  A5E4                            BITA    ASS_VAR_MODEP,S
8E90  2682                            BNE     brkIndex
8E92                  1               JUMP    assPostByteIXCheckIndThenValidate
8E92  7E8DA6                                  JMP     \1
                      
8E95                  assModeParseOffsIX_NotAutoInc
8E95  335F                            LEAU    -1,U
                                      ; check for force 16 bit offset
8E97  8640                            LDA     #ASS_MEMPB_SZ16
8E99  A5E4                            BITA    ASS_VAR_MODEP,S
8E9B  2637                            BNE     assModeParseOffsIX_16B
                                      ; check for zero offset
8E9D                                  CALL    IntWAZero
8E9D                  9
8E9F                  __XBSR                  SET 9B+2
2B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8E9D  BDB9D6                                  JSR     \1
                              ENDIF
8EA0  2605                            BNE     assModeParseOffsIX_NotZeroOffs
8EA2  CA04                            ORB     #$04                            ; zero offset
8EA4                                  JUMP    assPostByteIXCheckIndThenValidate
8EA4  7E8DA6                                  JMP     \1
                      
8EA7                  assModeParseOffsIX_NotZeroOffs
                      
                                      ; TODO we should check here for SZ8!
                      
8EA7  3404                            PSHS    B                               ; save postbyte
8EA9  DC2C                            LDD     ZP_INT_WA + 2                   ; get offset
8EAB  2A02                            BPL     1F
8EAD  53                              COMB
8EAE  43                              COMA
8EAF  4D              1               TSTA
8EB0  2622                            BNE     assModeParseOffsIX_16B          ; doesn't fit in a byte
8EB2  6DE4                            TST     ,S                              ; check for -ve
8EB4  2A15                            BPL     assModeParseOffsIX_8B           ; if so then PC/PCR form
8EB6  C4F0                            ANDB    #$F0
8EB8  2611                            BNE     assModeParseOffsIX_8B           ; doesn't fit in 5 bits
8EBA  8610                            LDA     #ASS_MEMPB_IND
8EBC  A561                            BITA    1+ASS_VAR_MODEP,S               ; indirect use 1 byte form
8EBE  260B                            BNE     assModeParseOffsIX_8B
8EC0  D62D                            LDB     ZP_INT_WA + 3
8EC2  C41F                            ANDB    #$1F
8EC4  EAE0                            ORB     ,S+
8EC6  C47F                            ANDB    #$7F
8EC8                                  JUMP    assPostByteIXCheckIndThenValidate
8EC8  7E8DA6                                  JMP     \1
                      
8ECB                  assModeParseOffsIX_8B
8ECB  3504                            PULS    B
8ECD  CA88                            ORB     #$88
8ECF                                  CALL    assModeParseIXIndCheckAndMerge2A
8ECF                  9
8ED1                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8ECF  BD8DAF                                  JSR     \1
                              ENDIF
8ED2  200C                            BRA     1F
8ED4                  assModeParseOffsIX_16B
8ED4  3504                            PULS    B
8ED6  CA89                            ORB     #$89                            ; 16 bit postbyte
8ED8                                  CALL    assModeParseIXIndCheckAndMerge2A
8ED8                  9
8EDA                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8ED8  BD8DAF                                  JSR     \1
                              ENDIF
8EDB                                  CALL    assPostByte
8EDB                  9
8EDD                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8EDB  BD8DB8                                  JSR     \1
                              ENDIF
8EDE  962C                            LDA     ZP_INT_WA + 2
8EE0                  1               CALL    assPostByte
8EE0                  9
8EE2                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8EE0  BD8DB8                                  JSR     \1
                              ENDIF
8EE3  962D                            LDA     ZP_INT_WA + 3
8EE5                                  JUMP    assPostByteIXCheckValidModeIX
8EE5  7E8DA8                                  JMP     \1
                      
                      
8EE8                  assJmpBrkSyntax3
8EE8                                  JUMP    assJmpBrkSyntax
8EE8  7E8D4E                                  JMP     \1
                      
                      
8EEB                  assModesTblRegIX
8EEB  53555958                        FCB     "SUYX"
                      
8EEF                  assModesTblAccIX
8EEF  4106                            FCB     'A', $06
8EF1  4205                            FCB     'B', $05
8EF3  440B                            FCB     'D', $0B
                              IF ASSEMBLER_6309
                                      FCB     'E', $87                ; 6309 -ve
                                      FCB     'F', $8A
                                      FCB     'W', $8E
                              ENDIF
8EF5  00                              FCB     0
                      
                      
8EF6                  assModesRegReg  CALL    skipSpacesYStepBack
8EF6                  9
8EF8                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8EF6  BD9295                                  JSR     \1
                              ENDIF
8EF9                                  CALL    assModesRegRegScan
8EF9                  9
8EFB                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8EF9  8D14                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8EFB  48                              ASLA
8EFC  48                              ASLA
8EFD  48                              ASLA
8EFE  48                              ASLA
8EFF  3402                            PSHS    A
8F01                                  CALL    skipSpacesCheckCommaAtY
8F01                  9
8F03                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F01  BD90C8                                  JSR     \1
                              ENDIF
8F04  26E2                            BNE     assJmpBrkSyntax3
8F06                                  CALL    assModesRegRegScan
8F06                  9
8F08                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0007                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8F06  8D07                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8F08  840F                            ANDA    #$0F
8F0A  AAE0                            ORA     ,S+
8F0C                                  JUMP    assPostByteThenScanEndOfStmt
8F0C  7E8FA6                                  JMP     \1
                                      
                      
8F0F                  assModesRegRegScan
8F0F  5F                              CLRB
8F10  3440                            PSHS    U
8F12  8E90AA                          LDX     #tblRegRegCodes
8F15                  1               CALL    assMatchXY
8F15                  9
8F17                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F15  BD8C84                                  JSR     \1
                              ENDIF
8F18  2505                            BCS     1F
8F1A  EEE4                            LDU     ,S
8F1C  5C                              INCB
8F1D  20F6                            BRA     1B
8F1F  81FF            1               CMPA    #$FF
8F21  27C5                            BEQ     assJmpBrkSyntax3
8F23  3262                            LEAS    2,S                             ; discard stacked U
8F25  39                              RTS
                      
                      
                      
                      
                              IF ASSEMBLER_6309
                      assClass_D_parse
                                      SWI
                              ENDIF
                      
                              IF ASSEMBLER_6309
                      assModesBitBit
                                      SWI
                              ENDIF
                      
                              IF ASSEMBLER_6309
                      assModesTFM
                                      SWI
                              ENDIF
                      
8F26                  assModesPxxxW
                              IF ASSEMBLER_6309
                                      LDA     ,U
                                      ANDA    #$DF
                                      CMPA    #'W'
                                      BNE     1F
                                      OIM     #ASS_BITS_PRE_10,ASS_VAR_FLAGS,S; set 10 prefix
                                      EIM     #$0C,ASS_VAR_OP,S               ; change opcode
                                      JUMP    assScanEndOfStmt
                      1
                              ENDIF
8F26                                  CALL    skipSpacesCheckHashAtYStepBack
8F26                  9
8F28                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F26  BD90D5                                  JSR     \1
                              ENDIF
8F29  2608                            BNE     1F
                                      ; got an immediate
8F2B                                  CALL    evalForceINT
8F2B                  9
8F2D                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F2B  BD95A1                                  JSR     \1
                              ENDIF
8F2E  962D                            LDA     ZP_INT_WA+3
8F30                                  JUMP    assPostByteThenScanEndOfStmt
8F30  7E8FA6                                  JMP     \1
8F33                  1               
                      
8F33  6FE2                            CLR     ,-S                             ; build post byte here
                      
8F35                  assPushPullRegsLoop
8F35                                  CALL    assModesRegRegScan
8F35                  9
8F37                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8F35  8DD8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8F37  C106                            CMPB    #6
8F39  2305                            BLS     1F
8F3B  5A                              DECB
8F3C  C108                            CMPB    #8
8F3E  24A8                            BHS     assJmpBrkSyntax3
8F40  8601            1               LDA     #1
8F42  5A              assBitLp        DECB
8F43  2B03                            BMI     1F
8F45  48                              ASLA
8F46  20FA                            BRA     assBitLp
8F48  AAE4            1               ORA     ,S
8F4A  A7E4                            STA     ,S                              ; update postbyte
8F4C                                  CALL    skipSpacesCheckCommaAtYStepBack
8F4C                  9
8F4E                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F4C  BD90CE                                  JSR     \1
                              ENDIF
8F4F  27E4                            BEQ     assPushPullRegsLoop
8F51  A6E0                            LDA     ,S+                             ; get postbyte
8F53  1027FF91                        LBEQ    assJmpBrkSyntax3
8F57                                  JUMP    assPostByteThenScanEndOfStmt
8F57  7E8FA6                                  JMP     \1
                      
                      
8F5A                  assDecIntWa2
8F5A  DC2C                            LDD     ZP_INT_WA+2
8F5C  830001                          SUBD    #1
8F5F  DD2C                            STD     ZP_INT_WA+2
8F61  39                              RTS
                      
8F62                  assModesRel
8F62                                  CALL    evalForceINT                    ; get "other" address
8F62                  9
8F64                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
003D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8F62  BD95A1                                  JSR     \1
                              ENDIF
8F65  DC2C                            LDD     ZP_INT_WA+2
8F67  B30442                          SUBD    VAR_P_PERCENT+2                 ; get rel addr
8F6A  830002                          SUBD    #2
8F6D  DD2C                            STD     ZP_INT_WA+2
                                      ; check for "LBxx"
8F6F  8640                            LDA     #ASS_BITS_EXTRA0
8F71  A564                            BITA    ASS_VAR_FLAGS,S
8F73  2728                            BEQ     assModesRelShort
                                      ; it's a long branch
8F75                                  CALL    assDecIntWa2
8F75                  9
8F77                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8F75  8DE3                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                                      ; sort out op codes
8F77  A667                            LDA     ASS_VAR_OP,S
8F79  8120                            CMPA    #$20                            ; BRA
8F7B  260C                            BNE     1F
8F7D  8616                            LDA     #$16
8F7F                  assModesRelLong_UpdateOp
8F7F  A767                            STA     ASS_VAR_OP,S
8F81                  assModesRelLong_End
8F81  C602                            LDB     #2
8F83  8E002C                          LDX     #ZP_INT_WA+2
8F86                                  JUMP    assCopyBBytesToOpBufAndEnd
8F86  7E905B                                  JMP     \1
8F89  818D            1               CMPA    #$8D                            ; BSR
8F8B  2605                            BNE     1F
8F8D  8617                            LDA     #$17
8F8F                                  JUMP    assModesRelLong_UpdateOp
8F8F  7E8F7F                                  JMP     \1
8F92  8610            1               LDA     #ASS_BITS_PRE_10
8F94  AA64                            ORA     ASS_VAR_FLAGS,S
8F96  A764                            STA     ASS_VAR_FLAGS,S
8F98                                  CALL    assDecIntWa2
8F98                  9
8F9A                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
8F98  8DC0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
8F9A                                  JUMP    assModesRelLong_End
8F9A  7E8F81                                  JMP     \1
8F9D                  assModesRelShort        
8F9D  D62D                            LDB     ZP_INT_WA+3                     ; get low byte
8F9F  1D                              SEX
8FA0  912C                            CMPA    ZP_INT_WA+2                     ; if <> high byte then out of range
8FA2  2612                            BNE     assOutOfRange
8FA4  1F98                            TFR     B,A
8FA6                  assPostByteThenScanEndOfStmt
8FA6                                  CALL    assPostByte
8FA6                  9
8FA8                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8FA6  BD8DB8                                  JSR     \1
                              ENDIF
8FA9                                  JUMP    assScanEndOfStmt
8FA9  7E8FCB                                  JMP     \1
                      
8FAC                  assModesImmed   CALL    skipSpacesCheckHashAtY
8FAC                  9
8FAE                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
8FAC  BD90C2                                  JSR     \1
                              ENDIF
8FAF  1026006E                        LBNE    assJmpBrkSyntax5
8FB3                                  JUMP    assModeImmed
8FB3  7E8CF7                                  JMP     \1
8FB6                  assOutOfRange
8FB6  D628                            LDB     ZP_OPT
8FB8  C402                            ANDB    #$02                            ; check to see if errors suppressed - if so store 0 in offset!
8FBA  27EA                            BEQ     assPostByteThenScanEndOfStmt    ; store anything
8FBC                  brkOutOfRange
8FBC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
8FBC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
8FBD  014F7574206F662072616E676500                 FCB     $01, "Out of range", 0
                              IF ASSEMBLER_6309
                      brk6309
                                      DO_BRK_B
                                      FCB     $3, "6309", 0
                              ENDIF
                      
                      
                      
8FCB                  assScanEndOfStmt
8FCB  A664                            LDA     ASS_VAR_FLAGS,S
                              IF ASSEMBLER_6309
                                      ; ignore if this is a 6309 instruction but not OPT $10
                                      BITA    #ASS_BITS_6309
                                      BEQ     1F                              ; not 6309 instr
                                      LDA     ZP_OPT
                                      BITA    #$10
                                      LBEQ    brk6309                         ; not 6309 mode
                      1
                              ENDIF
                      
                      
8FCD  10AF65                          STY     ASS_VAR_PTR_SAV,S               ; L8A5E
8FD0  10BE0442                        LDY     VAR_P_PERCENT + 2
8FD4  109F37                          STY     ZP_GEN_PTR
8FD7  8604                            LDA     #4
8FD9  9528                            BITA    ZP_OPT
8FDB  2704                            BEQ     assSkNotOpt4                    ; check for OPT 4+
8FDD  10BE043E                        LDY     VAR_O_PERCENT + 2               ; opt 4+ get O% into storage pointer
8FE1  109F3A          assSkNotOpt4    STY     ZP_ASS_OPSAVED
8FE4  3067                            LEAX    ASS_VAR_OP,S                    ; source for the copy
8FE6  E663                            LDB     ASS_VAR_OPLEN,S                 ; get opcode length (without any prefix)
8FE8  2A05                            BPL     1F
8FEA  D636                            LDB     ZP_STRBUFLEN                    ; if -ve then store a string set up by EQUS
8FEC  8E0600                          LDX     #BASWKSP_STRING                 ; string buffer
8FEF  D739            1               STB     ZP_ASS_OPLEN
8FF1  2728                            BEQ     assSkNowtToStore
8FF3  A664                            LDA     ASS_VAR_FLAGS,S
8FF5  8411                            ANDA    #ASS_BITS_PRE                   ; check for a prefix
8FF7  2705                            BEQ     assStoreLoop
8FF9  0C39                            INC     ZP_ASS_OPLEN
8FFB  5C                              INCB
8FFC  2002                            BRA     1F
8FFE                  assStoreLoop                                            ; L8A83
8FFE  A680                            LDA     ,X+
9000                  1
9000  A7A0                            STA     ,Y+
                      
9002  7C0443                          INC     VAR_P_PERCENT + 3
9005  2603                            BNE     1F
9007  7C0442                          INC     VAR_P_PERCENT + 2
900A  8604            1               LDA     #4
900C  9528                            BITA    ZP_OPT
900E  2708                            BEQ     assSkNotOpt4_2
9010  7C043F                          INC     VAR_O_PERCENT + 3
9013  2603                            BNE     assSkNotOpt4_2
9015  7C043E                          INC     VAR_O_PERCENT + 2
9018  5A              assSkNotOpt4_2  DECB
9019  26E3                            BNE     assStoreLoop
                      
901B                  assSkNowtToStore                                        ; L8AA5
901B  10AE65                          LDY     ASS_VAR_PTR_SAV,S
901E  326C                            LEAS    ASS_VAR_SPACE,S
9020  39                              RTS
                      
9021                  assJmpBrkSyntax5
9021                                  CALL    assJmpBrkSyntax4
9021                  9
9023                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0084                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9021  BD90A7                                  JSR     \1
                              ENDIF
                      
                      
9024                  assClass_DIR_parse
9024  0F39                            CLR     ZP_ASS_OPLEN                    ; all directives are 0 length
                      
9026  A667                            LDA     ASS_VAR_OP,S                    ; get "opcode" - for directives
9028  260A                            BNE     assDirNotOPT
                                      ; OPT
902A                                  CALL    evalForceINT
902A                  9
902C                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
902A  BD95A1                                  JSR     \1
                              ENDIF
902D  962D                            LDA     ZP_INT_WA+3
902F  9728                            STA     ZP_OPT
9031                                  JUMP    assScanEndOfStmt
9031  7E8FCB                                  JMP     \1
9034                  assDirNotOPT
9034  8101                            CMPA    #1
9036  2650                            BNE     assDirNotEQU
                                      ; we have EQUx
9038  A6C0                            LDA     ,U+
903A  84DF                            ANDA    #$DF                            ; uppercase
903C  8153                            CMPA    #'S'
903E  2733                            BEQ     assDirEQUS
9040  C601                            LDB     #1
9042  8142                            CMPA    #'B'
9044  270B                            BEQ     1F
9046  5C                              INCB
9047  8157                            CMPA    #'W'
9049  2706                            BEQ     1F
904B  C604                            LDB     #4
904D  8144                            CMPA    #'D'
904F  2656                            BNE     assJmpBrkSyntax4
9051  3404            1               PSHS    B
                                      ; get an integer (little endian)
9053                                  CALL    assEvalForceINT_LE
9053                  9
9055                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0031                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9053  BD8986                                  JSR     \1
                              ENDIF
9056  8E002A                          LDX     #ZP_INT_WA
9059  3504                            PULS    B
905B                  assCopyBBytesToOpBufAndEnd
905B                                  CALL    assCopyBBytesToOpBuf
905B                  9
905D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
905B  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
905D                                  JUMP    assScanEndOfStmt
905D  7E8FCB                                  JMP     \1
                      
                                      ; copies B bytes from X to end of OpBuf
9060                  assCopyBBytesToOpBuf
9060  3420                            PSHS    Y
9062  316B                            LEAY    4+ASS_VAR_OP,S                  ; point Y at op buffer
9064  A667                            LDA     4+ASS_VAR_OPLEN,S
9066  31A6                            LEAY    A,Y                             ; add length of existing op bytes
9068  A680            1               LDA     ,X+
906A  A7A0                            STA     ,Y+
906C  6C67                            INC     4+ASS_VAR_OPLEN,S
906E  5A                              DECB
906F  26F7                            BNE     1B
9071  35A0                            PULS    Y,PC
                      
9073                  assDirEQUS      
9073  9628                            LDA     ZP_OPT
9075  3402                            PSHS    A                               ; this cribbed from 6502 basic not sure it's needed!
9077                                  CALL    evalAtY
9077                  9
9079                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9077  BD9DC1                                  JSR     \1
                              ENDIF
907A  4D                              TSTA
907B  1026036C                        LBNE    brkTypeMismatch                 ; must be a string!
907F  3502                            PULS    A       
9081  9728                            STA     ZP_OPT
9083  6363                            COM     ASS_VAR_OPLEN,S                 ; indicate a string
9085                                  JUMP    assScanEndOfStmt
9085  7E8FCB                                  JMP     \1
9088  8105            assDirNotEQU    CMPA    #5
908A  241B                            BHS     assDirSET
908C  1F89                            TFR     A,B
908E  C104                            CMPB    #4
9090  2701                            BEQ     1F
9092  5A                              DECB
9093  3404            1               PSHS    B
9095                                  CALL    evalForceINT
9095                  9
9097                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9095  BD95A1                                  JSR     \1
                              ENDIF
9098  C604                            LDB     #4
909A  E0E4                            SUBB    ,S
909C  8E002A                          LDX     #ZP_INT_WA
909F  3A                              ABX
90A0  3504                            PULS    B
90A2                                  CALL    assCopyBBytesToOpBuf
90A2                  9
90A4                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
90A2  8DBC                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
90A4                                  JUMP    assScanEndOfStmt
90A4  7E8FCB                                  JMP     \1
                      
                      
90A7                  assDirSET
90A7                  assJmpBrkSyntax4                                        ; L8A35
90A7                                  JUMP     brkSyntax
90A7  7E9C37                                  JMP     \1
                      
                      
90AA                  tblRegRegCodes                                          ; index is push/pull bit, terminator is reg,reg code
90AA  43438A                          FCB     "CC",   $80 + $0A
90AD  4188                            FCB     "A",    $80 + $08
90AF  4289                            FCB     "B",    $80 + $09
90B1  44508B                          FCB     "DP",   $80 + $0B
90B4  5881                            FCB     "X",    $80 + $01
90B6  5982                            FCB     "Y",    $80 + $02
90B8  5384                            FCB     "S",    $80 + $04
90BA  5583                            FCB     "U",    $80 + $03
90BC  504385                          FCB     "PC",   $80 + $05
                      
90BF  4480                            FCB     "D",    $80 + $00
                      
                      
                              IF ASSEMBLER_6309
                                      FCB     "W",    $80 + $06 + ASS_BITS_6309
                                      FCB     "V",    $80 + $07 + ASS_BITS_6309
                                      FCB     "E",    $80 + $0E + ASS_BITS_6309
                                      FCB     "F",    $80 + $0F + ASS_BITS_6309
                              ENDIF
90C1  FF                              FCB     $FF
                              ENDIF
                      
90C2                  skipSpacesCheckHashAtY
90C2                                  CALL    skipSpacesY
90C2                  9
90C4                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
90C2  BD928C                                  JSR     \1
                              ENDIF
90C5  8123                            CMPA    #'#'
90C7  39                              RTS             
90C8                  skipSpacesCheckCommaAtY
90C8                                  CALL    skipSpacesY
90C8                  9
90CA                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
90C8  BD928C                                  JSR     \1
                              ENDIF
90CB  812C                            CMPA    #','
90CD  39                              RTS
                      
90CE                  skipSpacesCheckCommaAtYStepBack
90CE                                  CALL    skipSpacesCheckCommaAtY
90CE                  9
90D0                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
90CE  8DF8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
90D0  2702            2               BEQ     1F
90D2  335F                            LEAU    -1,U
90D4  39              1               RTS             
90D5                  skipSpacesCheckHashAtYStepBack
90D5                                  CALL    skipSpacesCheckHashAtY
90D5                  9
90D7                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
90D5  8DEB                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
90D7  20F7                            BRA     2B
                      
                                      ; [ZP_GEN_PTR+2] <= A
                                      ; ZP_NAMELENORVT <= Y (last character CONSUMED i.e. before what is to be kept)
                                      ; Copy rest of line to ZP_GEN_PTR
                                      ; return with count of chars after token including $0d in B
                                      ; trashes A, X, Y
90D9                  storeTokenAndCloseUpLine
90D9  9E39                            LDX     ZP_GEN_PTR+2
90DB  A780                            STA     ,X+
90DD  5F                              CLRB
90DE  5C              1               INCB
90DF  A6C0                            LDA     ,U+
90E1  A780                            STA     ,X+             
90E3  810D                            CMPA    #$0D
90E5  26F7                            BNE     1B
90E7  DE39                            LDU     ZP_GEN_PTR+2
90E9  3341                            LEAU    1,U
90EB  39                              RTS
                      
                      ;               CLC
                      ;               TYA
                      ;               ADC ZP_GEN_PTR
                      ;               STA ZP_NAMELENORVT
                      ;               LDU #$00
                      ;               TYA
                      ;               ADC ZP_GEN_PTR + 1
                      ;               STA ZP_NAMELENORVT + 1
                      
                      ;L8CFA:
                      ;               INY
                      ;               LDA (ZP_NAMELENORVT),Y
                      ;               STA (ZP_GEN_PTR),Y
                      ;               CMP #$0D
                      ;               BNE L8CFA
                      ;               RTS
                      
                                      ; on entry A contains a numeric digit
                                      ; parse number and store in ?????
                                      ; TODO, there may be a quicker / smaller way of doing this
                                      ; use shift and add instead of mul and add?
90EC                  tokenizeLineNo  
90EC  840F                            ANDA    #$0F
90EE  973E                            STA     ZP_FPB + 3              ; low byte
90F0  0F3D                            CLR     ZP_FPB + 2              ; convert '0'-'9' to 0-9 and store as 16bit at ZP_FPB + 2       
                      
90F2  A6C0            tokLinLp        LDA     ,U+
90F4                                  CALL    checkIsNumeric
90F4                  9
90F6                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0077                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
90F4  8D77                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
90F6  2426                            BCC     tokLineNoSk1
90F8  840F                            ANDA    #$F
90FA  9738                            STA     ZP_GEN_PTR+1
90FC  0F37                            CLR     ZP_GEN_PTR+0            ; store as 16 bit no
                      
90FE  963E                            LDA     ZP_FPB + 3              ; low byte * 10
9100  C60A                            LDB     #10
9102  3D                              MUL                             ; this cannot overflow or go minus so don't panic!
9103  D337                            ADDD    ZP_GEN_PTR              ; add to current digit
9105  2B14                            BMI     tokLinOv                ; overflowed
9107  DD37                            STD     ZP_GEN_PTR              ; store 
                                      
9109  963D            1               LDA     ZP_FPB + 2              ; mul old number hi byte by 10
910B  C60A                            LDB     #10
910D  3D                              MUL
910E  250B                            BCS     tokLinOv                ; top bit of B
9110  4D                              TSTA                            ; or top byte of result
9111  2608                            BNE     tokLinOv                ; causes overflow
9113  1E89                            EXG     A,B                     ; now D = 256 * B 
9115  D337            2               ADDD    ZP_GEN_PTR
9117  DD3D                            STD     ZP_FPB + 2              ; store result
9119  2AD7                            BPL     tokLinLp
911B                  tokLinOv
911B                                  SEC
911B  1A01                    ORCC    #CC_C
911D  39                              RTS                             ; unstack result
911E                  tokLineNoSk1                                    ; found end of number
911E  335F                            LEAU    -1,U                    ; point at char after last read digit
9120  868D                            LDA     #tknLineNo
9122                                  CALL    storeTokenAndCloseUpLine        ; B + ZP_GEN_PTR is end of line
9122                  9
9124                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9122  8DB5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9124  DE39                            LDU     ZP_GEN_PTR+2
9126  3043                            LEAX    3,U                             ; make space for line number and length (3)
9128  9F39                            STX     ZP_GEN_PTR+2
912A  5C                              INCB
912B  3A                              ABX
912C  4F                              CLRA                                    
912D  33CB                            LEAU    D,U                             ; point at end of strings + 1
                      ;L8D59:
912F                  1
912F  A6C2                            LDA     ,-U                     ; move end of line on 3 bytes and leave gap for rest of tokenized number
9131  A782                            STA     ,-X
9133  5A                              DECB
9134  26F9                            BNE     1B
                      ;L8D62: - when moving stuff to point here beware line number must be in ZP_FPB + 2,3 in bigendian, Y must point at byte before first of the three bytes
9136                  int16atZP_FPB2toBUFasTOKENIZED
9136  963D                            LDA     ZP_FPB + 2              ; see p.40 of ROM UG (note diagram is wrong see text)
9138  8A40                            ORA     #$40
913A  A743                            STA     3,U                     ; byte 3 = "01" & MSB[5 downto 0] 
913C  963E                            LDA     ZP_FPB + 3              ; lsb
913E  843F                            ANDA    #$3F
9140  8A40                            ORA     #$40
9142  A742                            STA     2,U                     ; byte 2 = "01" & MSB[5 downto 0] 
                      
9144  963E                            LDA     ZP_FPB + 3
9146  84C0                            ANDA    #$C0            
9148  973E                            STA     ZP_FPB + 3              ; mask off all but top two bits of LSB
                      
914A  963D                            LDA     ZP_FPB + 2
914C  84C0                            ANDA    #$C0
914E  44                              LSRA
914F  44                              LSRA
9150  9A3E                            ORA     ZP_FPB + 3
9152  44                              LSRA
9153  44                              LSRA
9154  8854                            EORA    #$54
9156  A741                            STA     1,U                     ; byte 1 = "01" & MSB[7 downto 6] & LSB[7 downto 6] & "00"
9158  3344                            LEAU    4,U                     ; pointer after tokenized number
915A                                  CLC
915A  1CFE                    ANDCC   #~CC_C
915C  39                              RTS
                      
                                      ; returns CY=1 if [_£a-zA-Z0-9]
915D                  checkIsValidVariableNameChar
915D  817B                            CMPA    #'z' + 1
915F  2416                            BCC     rtsL8D9A ; > z
9161  815F                            CMPA    #'_'
9163  2417                            BCC     setcarryRTS ; > ='_'
9165  815B                            CMPA    #'Z' + 1 
9167  240E                            BCC     rtsL8D9A ; > 'Z'
9169  8141                            CMPA    #'A'
916B  240F                            BCC     setcarryRTS
                      
                                      ; returns CY=1 if [0-9]
916D  813A            checkIsNumeric  CMPA    #'9' + 1                        ; not difference to 6502 compares! TODO - change api for fewer jumps?
916F  2406                            BCC     rtsL8D9A                        ; >'9'  
9171  8130                            CMPA    #'0'
9173  2407                            BCC     setcarryRTS
9175                                  CLC
9175  1CFE                    ANDCC   #~CC_C
9177  39              rtsL8D9A        RTS
                      
9178                  checkIsDotOrNumeric
9178  812E                            CMPA    #'.'
917A  26F1                            BNE     checkIsNumeric
917C                  setcarryRTS     SEC
917C  1A01                    ORCC    #CC_C
917E  39                              RTS
                      
                      ;ZPPTR_GetCharIncPtr
                      ;               LDA     [ZP_GEN_PTR]
                      ;ZPPTR_Inc16                                            ; incremenet ptr and save
                      ;               LDX     ZP_GEN_PTR
                      ;               LEAX    1,X
                      ;               STX     ZP_GEN_PTR
                      ;1              RTS                     
                      ;
                      ;ZPPTR_IncThenGetNextChar
                      ;               CALL    ZPPTR_Inc16
                      ;               LDA     [ZP_GEN_PTR]
                      ;               RTS
                      
                      
                      ;                       ;  Tokenise line at $37/8
                      
917F                  toklp0          ;;LEAU  1,Y                             ;  Step past charac     ter
                      
917F                  tokenizeATY
917F  DF39                            STU     ZP_GEN_PTR+2                    ; where token will be stored
9181                  toklp2
9181  A6C0                            LDA     ,U+                             ;  Get current character
9183  810D                            CMPA    #$0D
9185  2724                            BEQ     rtsL8DDF                        ;  Exit with <cr>
9187  8120                            CMPA    #' '
9189  27F4                            BEQ     toklp0                          ;  Skip <spc>
918B  8126                            CMPA    #'&'
918D  260E                            BNE     tokNotAmper                     ;  Jump if not '&'
918F  A6C0            toklp1          LDA     ,U+                             ;  Get next character, check if it looks like HEX
9191                                  CALL    checkIsNumeric                  ;  Is it a digit?
9191                  9
9193                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9191  8DDA                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9193  25FA                            BCS     toklp1                          ;  Loop back if a digit
9195  8141                            CMPA    #'A'
9197  24E8                            BCC     toklp2                          ;  Loop back if <'A'
9199  8147                            CMPA    #'F' + 1
919B  24F2                            BCC     toklp1                          ;  Step to next if 'A'..'F'
919D  8122            tokNotAmper     CMPA    #'"'
919F  260B                            BNE     tokNotQuot                      ;  Not quote,
91A1  A6C0            tokQuotLp       LDA     ,U+                             ;  Get next character
91A3  8122                            CMPA    #'"'
91A5  27D8                            BEQ     toklp0                          ;  Jump back if closing quote
91A7  810D                            CMPA    #$0D
91A9  26F6                            BNE     tokQuotLp                       ;  Loop until <cr> or quote
91AB  39              rtsL8DDF        RTS
                      
91AC  813A            tokNotQuot      CMPA    #':'
91AE  2606                            BNE     tokNotColon
                                      
91B0  0F3B            L8DE7           CLR     ZP_FPB                          ; start of statement - don't expect line num
91B2  0F3C            L8DE9           CLR     ZP_FPB + 1                      
91B4  20CB                            BRA     toklp2
                      
                      
91B6                  tokNotColon
91B6  812C                            CMPA    #','
91B8  27C5                            BEQ     toklp0                          ; if comma carry on
91BA  812A                            CMPA    #'*'
91BC  260C                            BNE     tokNotStar
91BE  0D3B                            TST     ZP_FPB
91C0  27E9                            BEQ     rtsL8DDF                        ; if a * and ZP_FPB==0 return (OSCLI at start of stmt?)
                      
91C2  C6FF            tokNotKeyword   LDB     #$FF
91C4  D73B                            STB     ZP_FPB
91C6  0F3C                            CLR     ZP_FPB + 1
91C8  20B5                            BRA     toklp0
                      
91CA  812E            tokNotStar      CMPA    #'.'
91CC  270D                            BEQ     tokDot
91CE                                  CALL    checkIsNumeric
91CE                  9
91D0                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
91CE  8D9D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
91D0  2425                            BCC     tokNotNum
91D2  0D3C                            TST     ZP_FPB + 1
91D4  2705                            BEQ     tokDot
91D6                                  CALL    tokenizeLineNo
91D6                  9
91D8                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91D6  BD90EC                                  JSR     \1
                              ENDIF
91D9  24A4                            BCC     toklp0
                      
91DB  A6C0            tokDot          LDA     ,U+
91DD                                  CALL    checkIsDotOrNumeric
91DD                  9
91DF                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
91DD  8D99                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
91DF  25FA                            BCS     tokDot
91E1                  tokNextSetFlag0_FF
                      ;L8E1F
91E1  335F                            LEAU    -1,U
91E3  86FF            1               LDA     #$FF
91E5  973B                            STA     ZP_FPB
91E7  20C9                            BRA     L8DE9
                      
91E9                  tokNotKey2                                       ; is it a variable? if so skip over it...
91E9                                  CALL    checkIsValidVariableNameChar
91E9                  9
91EB                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0072                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91E9  BD915D                                  JSR     \1
                              ENDIF
91EC  24D4                            BCC     tokNotKeyword
                      ;L8E2A
91EE                  tokNotKey_SkipVarName
91EE  A6C0                            LDA     ,U+
91F0                                  CALL    checkIsValidVariableNameChar
91F0                  9
91F2                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
91F0  BD915D                                  JSR     \1
                              ENDIF
91F3  24EC                            BCC     tokNextSetFlag0_FF
91F5  20F7                            BRA     tokNotKey_SkipVarName
91F7                  tokNotNum
91F7  8141                            CMPA    #'A'
91F9  25C7                            BLO     tokNotKeyword           ; if <'A'
91FB  8157                            CMPA    #'W'                    
91FD  22EA                            BHI     tokNotKey2              ; of >='X'
91FF  8E8174                          LDX     #tblTOKENS
9202  335F                            LEAU    -1,U
9204  DF39                            STU     ZP_GEN_PTR+2
9206                  tokKeyCmp
9206  DE39                            LDU     ZP_GEN_PTR+2                    ; reset buffer pointer
                      ;L8E46:
9208  A6C0                            LDA     ,U+                             ; start again with first char in A
920A  A180                            CMPA    ,X+                             
920C  25E0                            BLO     tokNotKey_SkipVarName           ; < tok char lt treat as variable name TODO: we already skipped a lot of the variable but that get wasted here
920E  260E                            BNE     tokSkipEndTryNext
                      ;L8E4E:
9210                  tokKeyCmpLp
9210  A680                            LDA     ,X+
9212  2B1E                            BMI     tokKeyFound
9214  A1C0                            CMPA    ,U+
9216  27F8                            BEQ     tokKeyCmpLp
9218  A65F                            LDA     -1,U
921A  812E                            CMPA    #'.'
921C  270A                            BEQ     tokKeyAbbrev
                      
921E                  tokSkipEndTryNext                                       ;L8E5D:
921E  A680                            LDA     ,X+
9220  2AFC                            BPL     tokSkipEndTryNext
9222  81FE                            CMPA    #tknWIDTH
9224  2608                            BNE     tokMoveNextTkn                  ; not the last one, increment pointer and carry on
9226  20C6                            BRA     tokNotKey_SkipVarName           
                      
9228                  tokKeyAbbrev                                            ;L8E68:
9228                  tokKeyAbbrevLp1                                         ;L8E69:
9228  A680                            LDA     ,X+                             ; skip to end of keyword, increasing X
922A  2B06                            BMI     tokKeyFound
922C  20FA                            BRA     tokKeyAbbrevLp1
922E                  tokMoveNextTkn                                          ;L8E75:
922E  3001                            LEAX    1,X                             ; move X past token and flags
                                                                              ;L8E80: (not used was a skip for add hi byte)
9230  20D4                            BRA     tokKeyCmp
9232                  tokKeyFound                                             ;L8E84:
9232  1F89                            TFR     A,B                             ; store token in B (TODO - use A and save a couple of swaps)
9234  A684                            LDA     ,X                              ; get flags in A
9236  973D                            STA     ZP_FPB + 2                      ; store flags
9238  8501                            BITA    #TOK_FLAG_CONDITIONAL                                   
923A  2707                            BEQ     tokKeyFound2                    ; if flags[0]='0' we've got a full keyword
923C  A6C4                            LDA     ,U                              ; if not check if next is a valid variable char
923E                                  CALL    checkIsValidVariableNameChar    
923E                  9
9240                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
923E  BD915D                                  JSR     \1
                              ENDIF
9241  25AB                            BCS     tokNotKey_SkipVarName           ; and we have a variable name char treat it as such and skip to
                                                                              ; end of variable
9243                  tokKeyFound2                                            ;L8E95
9243  963D                            LDA     ZP_FPB + 2
9245  8540                            BITA    #TOK_FLAG_PSEUDO_VAR
9247  2706                            BEQ     tokNOTPSEUDO
9249  0D3B                            TST     ZP_FPB
924B  2602                            BNE     tokNOTPSEUDO
924D  CB40                            ADDB    #$40                            ; at start of line and a PSEUDO var then add $40 to token?!
924F                  tokNOTPSEUDO    ;L8EA0
924F  1F98                            TFR     B, A
9251                                  CALL    storeTokenAndCloseUpLine        ; attention check regs trashed
9251                  9
9253                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9251  BD90D9                                  JSR     \1
                              ENDIF
9254  963D                            LDA     ZP_FPB + 2
9256  8502                            BITA    #TOK_FLAG_NEXT_MID
9258  2706                            BEQ     tokNOTNEXTMID
925A  C6FF                            LDB     #$FF
925C  D73B                            STB     ZP_FPB
925E  0F3C                            CLR     ZP_FPB + 1
9260                  tokNOTNEXTMID                                           ;L8EB0:
9260  8504                            BITA    #TOK_FLAG_NEXT_START
9262  2704                            BEQ     tokNOTNEXTSTART
9264  0F3B                            CLR     ZP_FPB
9266  0F3C                            CLR     ZP_FPB + 1
9268                  tokNOTNEXTSTART                                         ;L8EB7:
9268  8508                            BITA    #TOK_FLAG_FNPROC
926A  270F                            BEQ     tokSkipNotFNPROC
926C  DE39                            LDU     ZP_GEN_PTR+2            
926E  3341                            LEAU    1,U
9270                  tokSkipPROCNAMElp                                       ;L8EBD:                                 
9270  A6C0                            LDA     ,U+
9272                                  CALL    checkIsValidVariableNameChar
9272                  9
9274                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9272  BD915D                                  JSR     \1
                              ENDIF
9275  25F9                            BCS     tokSkipPROCNAMElp
                                                                              ;L8EC9:
9277  335E                            LEAU    -2,U
9279  DF39                            STU     ZP_GEN_PTR+2                    ; now pointing at last char of name
                                      
927B                  tokSkipNotFNPROC                        ;L8ECA:
927B  963D                            LDA     ZP_FPB + 2
927D  8510                            BITA    #TOK_FLAG_NEXTLINENO
927F  2702                            BEQ     tokNotNEXTLINENO
9281  D73C                            STB     ZP_FPB + 1                      ; FF
9283                  tokNotNEXTLINENO        ;L8ECF:
9283  8520                            BITA    #TOK_FLAG_SKIP_EOL
9285  260B                            BNE     anRTS7
9287                                  JUMP    toklp0
9287  7E917F                                  JMP     \1
                      
                      ;               
                      ;               ;  Skip spaces at PTRB
                      ;               ;  ===================
                                      ;  leaves PTR unchanged returns next non white pointer + 1 in Y, char in A
928A                  skipSpacesPTRB
928A  DE19                            LDU     ZP_TXTPTR2
928C                  skipSpacesY                
928C  A6C0                            LDA     ,U+
928E  8120                            CMPA    #' '
9290  27FA                            BEQ     skipSpacesY
9292  39              anRTS7          RTS
                      
9293                  inySkipSpacesYStepBack
9293  3341                            LEAU    1,U
9295                  skipSpacesYStepBack
9295                                  CALL    skipSpacesY
9295                  9
9297                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9295  8DF5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9297  335F                            LEAU    -1,U
9299  39                              RTS
                      
                      ;               
                      ;               ;  Skip spaces at PTRA
                      ;               ;  ===================
                                      ;  leaves PTR unchanged returns next non white pointer + 1 in Y, char in A
929A                  skipSpacesPTRA
929A  DE0B                            LDU     ZP_TXTPTR
929C  20EE                            BRA     skipSpacesY
                      
                      ;               
                      ;                       ;  Expect comma
                      ;                       ;  ============
929E                  skipSpacesCheckCommaAtYOrBRK
929E                                  CALL    skipSpacesCheckCommaAtY
929E                  9
92A0                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0028                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
929E  BD90C8                                  JSR     \1
                              ENDIF
92A1  27EF                            BEQ     anRTS7                  ;  Comma found, return
92A3                  brkMissingComma
92A3                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
92A3  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
92A4  058D2C00                        FCB     $05, tknMissing, ',', 0
92A8                  cmdCHAIN                ; L8EFB
                      
92A8                                  CALL    loadProg2Page
92A8                  9
92AA                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92A8  BDBCB0                                  JSR     \1
                              ENDIF
92AB  2013                            BRA     L8F15
92AD                  cmdOLD                  ; L8F00
                                              ;  OLD
92AD                                  CALL    scanNextStmtFromY
92AD                  9
92AF                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92AD  BD9C74                                  JSR     \1
                              ENDIF
92B0  9618                            LDA     ZP_PAGE_H
92B2  C601                            LDB     #1
92B4  1F01                            TFR     D,X
92B6  6F84                            CLR     ,X
92B8                                  CALL    findTOP
92B8                  9
92BA                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0005                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92B8  BDBCBF                                  JSR     \1
                              ENDIF
92BB  202F                            BRA     resetVarsImmedPrompt
92BD                  cmdRUN
                                              
                      ;                       ;  RUN
92BD                                  CALL    scanNextStmtFromY
92BD                  9
92BF                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92BD  BD9C74                                  JSR     \1
                              ENDIF
92C0                  L8F15
92C0                                  CALL    ResetVars
92C0                  9
92C2                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92C0  BDBAF0                                  JSR     \1
                              ENDIF
92C3  9618                            LDA     ZP_PAGE_H
92C5  5F                              CLRB
92C6  DD0B                            STD     ZP_TXTPTR
92C8  2035                            BRA     runFromZP_TXTPTR
92CA                  cmdLOAD
92CA                                  CALL    loadProg2Page
92CA                  9
92CC                  __XBSR                  SET 9B+2
2900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92CA  BDBCB0                                  JSR     \1
                              ENDIF
92CD  201D                            BRA     resetVarsImmedPrompt
92CF                  cmdEND                  ; L8F25!
92CF                                  CALL    scanNextStmtFromY
92CF                  9
92D1                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92CF  BD9C74                                  JSR     \1
                              ENDIF
92D2                                  CALL    findTOP
92D2                  9
92D4                  __XBSR                  SET 9B+2
2900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92D2  BDBCBF                                  JSR     \1
                              ENDIF
92D5  2018                            BRA     immedPrompt
                      
                      
                      
92D7                  reset_prog_enter_immedprompt
                                      ;TODO !!!!!!!!!!!!!!!!!!!!!!! FOR TESTING ONLY
                      *               LDD     #$00F2          ; get bytes $f2,f3 from host proc (command pointer)
                      *               LBSR    retD16asUINT_LE
                      *               LBSR    callOSWORD5INT_WA
                      *               TFR     A,B
                      *               LBSR    callOSWORD5INT_WA
                      *               EXG     B,A             ; little endian!
                      *               STD     ZP_INT_WA       ; zp_int_wa points at end of command tail in host proc
                      *               LDB     #$14
                      *1              DECB
                      *               LBEQ    cmdNEW2
                      *               LBSR    callOSWORD5INT_WA
                      *               CMPA    #$0D
                      *               BEQ     cmdNEW2
                      *               CMPA    #'@'
                      *               BNE     1B
                      *               LBSR    callOSWORD5INT_WA
                      *               CMPA    #$0D            
                      *               BNE     cmdNEW2
92D7                                  CALL    deleteProgSetTOP
92D7                  9
92D9                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92D7  BDBDC4                                  JSR     \1
                              ENDIF
                      
                                      ; dom bodge
92DA  0F20                            CLR     ZP_TRACE
                      
92DC                                  CALL    findTOP
92DC                  9
92DE                  __XBSR                  SET 9B+2
2900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92DC  BDBCBF                                  JSR     \1
                              ENDIF
                      
92DF  CE0700          1               LDU #BAS_InBuf
92E2  DF0B                            STU ZP_TXTPTR
92E4  2006                            BRA resetVarsImmedPrompt
                      ;;2             LDA [ZP_LOMEM]
                      ;;              BEQ resetVarsImmedPrompt
                      ;;              STA ,Y+
                      ;;              BEQ cmdNEW2
                      ;;              INC ZP_LOMEM + 1
                      ;;              BNE 1F
                      ;;              INC ZP_LOMEM
                      ;;1             CMPA #$0D
                      ;;              BNE 2B
                      ;;              LDA ZP_LOMEM
                      ;;              CMPA ZP_HIMEM
                      ;;              BCS resetVarsImmedPrompt
                      ;;              CALL tokenizeAndStore
                      ;;              BRA 1B
92E6                  cmdNEW                                                                  ;  NEW
92E6                                  CALL    scanNextStmtFromY
92E6                  9
92E8                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
008C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92E6  BD9C74                                  JSR     \1
                              ENDIF
92E9                  cmdNEW2
92E9                                  CALL    deleteProgSetTOP
92E9                  9
92EB                  __XBSR                  SET 9B+2
2A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92E9  BDBDC4                                  JSR     \1
                              ENDIF
92EC                  resetVarsImmedPrompt
92EC                                  CALL    ResetVars
92EC                  9
92EE                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92EC  BDBAF0                                  JSR     \1
                              ENDIF
                      
                      
92EF  CE0700          immedPrompt     LDU     #BAS_InBuf
92F2  DF0B                            STU     ZP_TXTPTR                       ;  PtrA = BAS_InBuf - input buffer
92F4                                  CALL    ONERROROFF;                     ;  ON ERROR OFF
92F4                  9
92F6                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92F4  BDB2B5                                  JSR     \1
                              ENDIF
92F7  863E                            LDA     #'>'
92F9  BDFFEE                          JSR     OSWRCH                  ;  Print '>' prompt
                      
92FC                                  CALL    ReadKeysTo_InBuf                        ;  Read input to buffer at BAS_InBuf
92FC                  9
92FE                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0026                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
92FC  BDBA24                                  JSR     \1
                              ENDIF
                                      
92FF                  runFromZP_TXTPTR                                                ; L8F97
92FF                                  RESET_MACH_STACK                
92FF  10CE0200                                LDS     #MACH_STACK_TOP
9303                                  CALL    ONERROROFF                              ;  Clear machine stack, ON ERROR OFF
9303                  9
9305                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9303  BDB2B5                                  JSR     \1
                              ENDIF
9306                                  CALL    tokenizeAndStore
9306                  9
9308                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9306  BDBA6A                                  JSR     \1
                              ENDIF
9309  25E1                            BCS     resetVarsImmedPrompt                    ;  Tokenise, enter into program, loop back if program line
930B                                  JUMP    execImmediateLine                       ;  Jump to execute immediate line
930B  7E9380                                  JMP     \1
                      
930E                  doOSCLIAtY                                                    ; L8FA4
930E  30C4                            LEAX    ,U
9310  3440                            PSHS    U
9312  BDFFF7                          JSR     OSCLI
9315  3540                            PULS    U
                      ;                       ;  DATA, DEF,   ;
                      ;                       ;  ==============
9317                  cmdREM
9317  860D                            LDA     #$0D
9319                  1                                                       ; L8FB3:
9319  A1C0                            CMPA    ,U+
931B  26FC                            BNE     1B                              ;  Loop until found <cr>
                                                                              ;L8FB8:
931D  335F                            LEAU    -1,U
931F  DF0B                            STU     ZP_TXTPTR
9321  2004                            BRA     stepNextLineOrImmedPrompt       ;  Update line pointer, step to next line
9323                  skipToNextLineOrImmedPrompt                             ; L8FBD
9323  810D                            CMPA    #$0D
9325  26F0                            BNE     cmdREM                          ;  Step to end of line
9327                  stepNextLineOrImmedPrompt
9327  960B                            LDA     ZP_TXTPTR
9329  8107                            CMPA    #BAS_InBuf / 256
932B  27C2                            BEQ     immedPrompt
932D  A641                            LDA     1,U                             ; if next line number top but end of prog
932F  2BBE                            BMI     immedPrompt
9331  9620                            LDA     ZP_TRACE
9333  2707                            BEQ     skNoTRACE
9335  EC41                            LDD     1,U
9337  DD2C                            STD     ZP_INT_WA + 2
9339                                  CALL    doTRACE
9339                  9
933B                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9339  BD9CE5                                  JSR     \1
                              ENDIF
933C                  skNoTRACE                                               ;L8FDB:
933C  3344                            LEAU    4,U                             ; skip over $d,line num,len to first token
933E  DF0B                            STU     ZP_TXTPTR
9340  2028                            BRA     skipSpacesAtYexecImmed
9342                  enterAssembler                                          ;L8FE1:
9342  8603                            LDA     #$03
9344  9728                            STA     ZP_OPT
9346                                  JUMP    assScanEnter                    ; enter assembler scanner, default OPT=3
9346  7E88C7                                  JMP     \1
9349                  scanTryStarAssEXTEq                                     ; L8FEB
9349  A65F                            LDA     -1,U
934B  812A                            CMPA    #'*'
934D  27BF                            BEQ     doOSCLIAtY
934F  815B                            CMPA    #'['
9351  27EF                            BEQ     enterAssembler
9353  81A2                            CMPA    #tknEXT
9355  10272A1B                        LBEQ    cmdEXTEq
9359  813D                            CMPA    #'='
935B  275E                            BEQ     cmdEquals
935D                  decYGoScanNextContinue                                  ; L9000
935D  335F                            LEAU  -1,U
935F                  scanNextContinue                                        ; L9002
935F                                  CALL    scanNextStmtFromY               ;  Return to execution loop
935F                  9
9361                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
935F  BD9C74                                  JSR     \1
                              ENDIF
9362                  continue                                                ; L9005
9362  A6C4                            LDA     ,U
9364  813A                            CMPA    #':'
9366  26BB                            BNE     skipToNextLineOrImmedPrompt
9368                  incYskipSpacesAtYexecImmed                              ; L900B         
9368  3341                            LEAU    1,U
936A                  skipSpacesAtYexecImmed                                  ; L900D
936A                                  CALL    skipSpacesY
936A                  9
936C                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
936A  BD928C                                  JSR     \1
                              ENDIF
936D  813A                            CMPA    #':'            
936F  27F9                            BEQ     skipSpacesAtYexecImmed          ;  Skip spaces and ':'
9371  81CF                            CMPA    #tknPTRc
9373  2512                            BLO     execTryVarAssign                ;  Not command token, try variable assignment
                      ;               
                      ;                       ;  Dispatch function/command
                      ;                       ;  -------------------------
9375                  exeTokenInA                                             ;L9019:         TODO: move command table and make relative jump
9375  808E                            SUBA    #tknOPENIN                      ; first token
9377  1F89                            TFR     A,B
9379  58                              ASLB                                    ; mul by two
937A  8E87DD                          LDX     #tblCmdDispatch
937D  3A                              ABX
937E                                  JUMP    [,X]            ;  Index into dispatch table and jump to routine
937E  6E94                                    JMP     \1
                      ;               
                      ;                       ;  Command entered at immediate prompt
                      ;                       ;  -----------------------------------
9380                  execImmediateLine                       ;L901E:
9380                                  CALL    skipSpacesPTRA                  ;  Skip spaces at PtrA
9380                  9
9382                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0018                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9380  BD929A                                  JSR     \1
                              ENDIF
9383  81C6                            CMPA    #tknAUTO
9385  24EE                            BHS     exeTokenInA                     ;  If command token, jump to execute command
                                              
                      ;                       ;  Not command token, try variable assignment
9387                  execTryVarAssign                                        ; L9025
9387  305F                            LEAX    -1,U
9389  9F19                            STX     ZP_TXTPTR2
938B                                  CALL    findVarAtYMinus1
938B                  9
938D                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
938B  BD9A83                                  JSR     \1
                              ENDIF
938E  261B                            BNE     assignVarAtZP_INT_WA            ;  Look up variable, jump if exists to assign new value
9390  25B7                            BCS     scanTryStarAssEXTEq                             ;  Invalid variable name, try =, [, *, EXT commands
                      
                      ;                       ;  Variable doesn't exist, create it
                      ;                       ;  ---------------------------------
9392                                  CALL    skipToEqualsOrBRKY              ; Check for and step past '='
9392                  9
9394                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9392  BD9C56                                  JSR     \1
                              ENDIF
9395                                  CALL    allocVAR                        ; Create new variable
9395                  9
9397                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
004C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9395  BD99E3                                  JSR     \1
                              ENDIF
9398  8605                            LDA     #$05                            ; Prepare B=5
939A  912A                            CMPA    ZP_INT_WA + 0                   
939C  2601                            BNE     varAss_sk1
939E  4C                              INCA            ;                       ;  Use X=6
939F                  varAss_sk1                                              ;L9045
939F                                  CALL    AllocVarSpaceOnHeap             ;  Allocate space for variable
939F                  9
93A1                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
939F  BD9A15                                  JSR     \1
                              ENDIF
93A2  DE19                            LDU     ZP_TXTPTR2
                      ;                       ;  LET <var> = <expression>
                      ;                       ;  ========================
93A4                  cmdLET
                      
93A4                                  CALL    findVarOrAllocEmpty
93A4                  9
93A6                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
008B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93A4  BD9A31                                  JSR     \1
                              ENDIF
93A7  1027088C                        LBEQ    brkSyntax                       ; Find and create variable, error if invalid name
93AB                  assignVarAtZP_INT_WA                                    ; L904F         
93AB  2421                            BCC     cmdSetVarNumeric                ;  CC - jump to assign numeric value
93AD                                  CALL    stackINT_WAasINT
93AD                  9
93AF                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93AD  BDBB5A                                  JSR     \1
                              ENDIF
93B0                                  CALL    skipSpacesExpectEqEvalExp       ;  Stack IntA, step past '=' and evaluate expression
93B0                  9
93B2                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93B0  BD9C26                                  JSR     \1
                              ENDIF
93B3  9627                            LDA     ZP_VARTYPE
93B5  2634                            BNE     brkTypeMismatch                 ;  If not string, Type mismatch
93B7                                  CALL    copyStringToVar
93B7                  9
93B9                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
93B7  8D4C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
93B9  20A7                            BRA     continue                        ;  Copy string result to string variable, return to execution loop
                      ;               
                      ;               ;  =<expression> - return from function
                      ;               ;  ====================================
93BB                  cmdEquals
93BB  118C01FB                        CMPS    #MACH_STACK_TOP - 5
93BF  2423                            BHS     brkNoFN                 ;  Stack empty, not in a function
93C1  B601FD                          LDA     MACH_STACK_TOP - 3
93C4  81A4                            CMPA    #tknFN
93C6  261C                            BNE     brkNoFN                 ;  No FN token, not in a function
93C8                                  CALL    evalExpressionMAIN
93C8                  9
93CA                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93C8  BD9DC1                                  JSR     \1
                              ENDIF
93CB                                  JUMP    scanNextStmtFromY                       ;  Evaluate expression, pop program pointer and continue execution
93CB  7E9C74                                  JMP     \1
                      
                      
                      ;                       ;  <numvar>=<numeric>
                      ;                       ;  ------------------
93CE                  cmdSetVarNumeric
93CE  9E2C                            LDX     ZP_INT_WA + 2
93D0  962A                            LDA     ZP_INT_WA + 0
93D2  3412                            PSHS    A,X
93D4                                  CALL    skipSpacesExpectEqEvalExp       ;  Step past '=' and evalute expression
93D4                  9
93D6                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93D4  BD9C26                                  JSR     \1
                              ENDIF
93D7                                  CALL    storeEvaledExpressioninStackedVarPTr
93D7                  9
93D9                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93D7  BDB33B                                  JSR     \1
                              ENDIF
93DA                                  JUMP    continue                        ;  Copy numeric value to variable, return to execution loop
93DA  7E9362                                  JMP     \1
                      
                      
93DD                  cmdSTOP
                      
93DD                                  CALL    scanNextStmtFromY               ;  Check end of statement
93DD                  9
93DF                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0095                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
93DD  BD9C74                                  JSR     \1
                              ENDIF
93E0                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
93E0  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
93E1  00FA00                          FCB     $00, tknSTOP, 0
93E4                  brkNoFN
93E4                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
93E4  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
93E5  074E6F20A400                    FCB  $07, "No ", tknFN, 0
93EB                  brkTypeMismatch
93EB                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
93EB  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
93EC  0654797065206D69736D6174636800                 FCB  $06, "Type mismatch", 0
93FB                  brkNoRoom
93FB                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
93FB  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
93FC  004E6F20726F6F6D00                 FCB  $00, "No room", 0
                      ;               
                      ;               ;  Copy string value to string variable
                      ;               ;  ------------------------------------
9405                  copyStringToVar CALL    popIntANew                      ;  Pop IntA which points to String Parameter Block
9405                  9
9407                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9405  BDBBEC                                  JSR     \1
                              ENDIF
9408                  copyStringToVar2                                        ; L90AE
9408  3440                            PSHS    U
940A  962A                            LDA     ZP_INT_WA + 0
940C  8180                            CMPA    #$80
940E  2754                            BEQ     indStringStore                  ;  Type = $80, $<addr>=<string>, jump to store directly
9410  DE2C                            LDU     ZP_INT_WA + 2
9412  A642                            LDA     2,U                             ;  Get maximum string size
9414  9136                            CMPA    ZP_STRBUFLEN
9416  2436                            BHS     L910E                   ;  Longer than string to store, so store it
9418  DC02                            LDD     ZP_VARTOP
941A  DD2C                            STD     ZP_INT_WA + 2           ;  Copy VARTOP to $2C/D as addr of new string block
941C  9636                            LDA     ZP_STRBUFLEN
941E  8108                            CMPA    #$08
9420  2506                            BLO     L90D0                   ; If new length<8, jump to use it
9422  8B08                            ADDA    #$08                    ; else ADD 8 for luck!
9424  2402                            BCC     L90D0                   ; If new length<256, use it
9426  86FF                            LDA     #$FF                    ; Otherwise, use 255 bytes
9428  3402            L90D0           PSHS    A                       ; Save string length to use
942A  AEC4                            LDX     ,U                      ; get current string pointer
942C  E642                            LDB     2,U                     ; get current string space
942E  3A                              ABX
942F  9C02                            CMPX    ZP_VARTOP
9431  2604                            BNE     L90EA                   ; if this isn't at the top of the heap then we need to make a new buffer
                                      
                                      ;  The string's current string block is the last thing in the heap, so it can just be extended
                                      ;  -------------------------------------------------------------------------------------------
9433  0F2C                            CLR     ZP_INT_WA + 2           ; Set ZP_INT_WA + 2 to zero to not change string address later
9435  A042                            SUBA    2,U                     ; X=newstrlen - currstrlen = extra memory needed
9437  1F89            L90EA           TFR     A,B                     ; B & A contain the ammount that VARTOP needs to be shifted by
9439  9E02                            LDX     ZP_VARTOP
943B  3A                              ABX
943C  9C04                            CMPX    ZP_BAS_SP
943E  24BB                            BHS     brkNoRoom               ;  Compare to STACKBOT, no room if new VARTOP>=STACKBOT
9440  9F02                            STX     ZP_VARTOP               ;  Store new VARTOP
9442  3504                            PULS    B
9444  E742                            STB     2,U                     ;  Get string length back and store it
9446  0D2C                            TST     ZP_INT_WA + 2
9448  2704                            BEQ     L910E                   ;  Get string address, jump if not moved
944A  9E2C                            LDX     ZP_INT_WA + 2
944C  AFC4                            STX     ,U
944E  D636            L910E           LDB     ZP_STRBUFLEN            ;  Get string length
9450  E743                            STB     3,U
9452  270E                            BEQ     L912B                   ;  Store string length, exit if zero length
9454  EEC4                            LDU     0,U
9456  DF2C                            STU     ZP_INT_WA + 2           ; store new pointer
9458  8E0600                          LDX     #BAS_StrA
945B                  copystr600
945B  A680            1               LDA     ,X+
945D  A7C0                            STA     ,U+
945F  5A                              DECB
9460  26F9                            BNE     1B
9462  35C0            L912B           PULS    U,PC
                      ;
                      ;                       ;  Store fixed string at $<addr>
                      ;                       ;  -----------------------------
9464                  indStringStore  CALL    str600CRterm                    ;  Store <cr> at end of string buffer
9464                  9
9466                  __XBSR                  SET 9B+2
2800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9464  BDBCF9                                  JSR     \1
                              ENDIF
9467  DE2C                            LDU     ZP_INT_WA + 2
9469  5C                              INCB                                    ; include terminating CR
946A  20EF                            BRA     copystr600
                      
                      
946C                  cmdPRINT_HASH                                           ; L9141
946C                                  CALL    decYSaveAndEvalHashChannelAPI
946C                  9
946E                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0094                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
946C  BDBA02                                  JSR     \1
                              ENDIF
946F  3420                            PSHS    Y                               ; save Channel #
9471                  cmdPRINTHAS_lp          
9471  DE0B                            LDU     ZP_TXTPTR
9473                                  CALL    skipSpacesCheckCommaAtY
9473                  9
9475                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0053                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9473  BD90C8                                  JSR     \1
                              ENDIF
9476  2647                            BNE     cmdPRINTHASH_exit
9478                                  CALL    evalAtY
9478                  9
947A                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9478  BD9DC1                                  JSR     \1
                              ENDIF
947B  DF0B                            STU     ZP_TXTPTR                       ; save BASIC test pointer
947D  10AEE4                          LDY     ,S                              ; channel
9480  9627                            LDA     ZP_VARTYPE                      ; var type, output to file
9482  BDFFD4                          JSR     OSBPUT
9485  4D                              TSTA
9486  2723                            BEQ     cmdPRINTHASH_STR
9488  2B0F                            BMI     cmdPRINTHASH_FP
948A  C603                            LDB     #$03
948C  8E002A                          LDX     #ZP_INT_WA
948F  A680            1               LDA     ,X+                             ; not it's big endian in the file!
9491  BDFFD4                          JSR     OSBPUT
9494  5A                              DECB
9495  2AF8                            BPL     1B
9497  20D8                            BRA     cmdPRINTHAS_lp
9499                  cmdPRINTHASH_FP
9499                                  CALL    fpCopyFPA_FPTEMP1               ; put eval'd FP at FPTEMP1 in 5 byte form 
9499                  9
949B                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9499  BDA56C                                  JSR     \1
                              ENDIF
949C  C604                            LDB     #$04
949E  8E0471                          LDX     #BASWKSP_FPTEMP1+5
94A1  A682            1               LDA     ,-X
94A3  BDFFD4                          JSR     OSBPUT
94A6  5A                              DECB
94A7  2AF8                            BPL     1B
94A9  20C6                            BRA     cmdPRINTHAS_lp
94AB                  cmdPRINTHASH_STR
94AB  9636                            LDA     ZP_STRBUFLEN
94AD  BDFFD4                          JSR     OSBPUT
94B0  D636                            LDB     ZP_STRBUFLEN
94B2  8E0600                          LDX     #BAS_StrA
94B5  27BA            1               BEQ     cmdPRINTHAS_lp
94B7  A680                            LDA     ,X+
94B9  BDFFD4                          JSR     OSBPUT
94BC  5A                              DECB
94BD  20F6                            BRA     1B
94BF                  cmdPRINTHASH_exit
94BF  3262                            LEAS    2,S                             ; discard stacked channel
94C1  335F                            LEAU    -1,U
94C3                                  JUMP    scanNextContinue
94C3  7E935F                                  JMP     \1
                      
                      
                      ;                       ;  PRINT (<print items>)
                      ;                       ;  =====================
94C6                  cmdPRINT
94C6                                  CALL    skipSpacesCheckHashAtYStepBack
94C6                  9
94C8                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
000D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94C6  BD90D5                                  JSR     \1
                              ENDIF
94C9  27A1                            BEQ     cmdPRINT_HASH                   ; Get next non-space char, if '#' jump to do PRINT#
94CB  201A                            BRA     cmdPRINT_skStart                ;  Jump into PRINT loop
                      
94CD                  cmdPRINT_setHexFlagFromCarry2
94CD                                  SEC
94CD  1A01                    ORCC    #CC_C
94CF  201D                            BRA     cmdPRINT_setHexFlagFromCarry
                      
                      ;                       ;  Print a comma
                      ;                       ;  -------------
94D1                  cmdPRINT_padToNextField                                 ; L9196
94D1  B60403                          LDA     BASWKSP_INTVAR + 3              ; get low byte of @%
94D4  2711                            BEQ     cmdPRINT_skStart                ;  If field width zero, no padding needed, jump back into main loop
94D6  961E                            LDA     ZP_PRLINCOUNT                   ;  Get COUNT
94D8                  cmdPRINT_padToNextField_lp                              ; L919D
94D8  270D                            BEQ     cmdPRINT_skStart                ;  Zero, just started a new line, no padding, jump back into main loop
94DA  B00403                          SUBA    BASWKSP_INTVAR + 3              ;  Get COUNT-field width
94DD  24F9                            BCC     cmdPRINT_padToNextField_lp      ;  Loop to reduce until (COUNT MOD fieldwidth)<0
94DF  1F89                            TFR     A,B                             ;  B=-number of spaces to get back to (COUNT MOD width)=zero
94E1                  cmdPRINT_padToNextField_lp2                             ; L91A5
94E1                                  CALL    list_print1Space
94E1                  9
94E3                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94E1  BDBC6D                                  JSR     \1
                              ENDIF
94E4  5C                              INCB
94E5  26FA                            BNE     cmdPRINT_padToNextField_lp2     ; Loop to print required spaces
94E7                  cmdPRINT_skStart                                        ; L91AB
                                      
94E7  B60403                          LDA     BASWKSP_INTVAR + 3              ; Get @%
94EA  9714                            STA     ZP_PRINTBYTES                   ; Set current field width from @%
94EC                                  CLC                                     ; Prepare to print decimal
94EC  1CFE                    ANDCC   #~CC_C
94EE                  cmdPRINT_setHexFlagFromCarry                            ; L91B1
94EE  0615                            ROR     ZP_PRINTFLAG                    ; Set hex/dec flag from Carry
94F0                  cmdPRINT_lp1                                            ; L91B1
94F0                                  CALL    skipSpacesY                     ; Get next non-space character
94F0                  9
94F2                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94F0  BD928C                                  JSR     \1
                              ENDIF
94F3  813A                            CMPA    #':'
94F5  2708                            BEQ     cmdPRINT_endcmd                 ; End of statement if <colon> found
94F7  810D                            CMPA    #$0D
94F9  2704                            BEQ     cmdPRINT_endcmd                 ; End if statement if <cr> found
94FB  818B                            CMPA    #tknELSE
94FD  2619                            BNE     cmdPRINT_sk0                    ; Not 'ELSE', jump to check this item
                      
                      ;                       ;  End of PRINT statement
                      ;                       ;  ----------------------
94FF                  cmdPRINT_endcmd                                         ; L91C2
94FF                                  CALL    PrintCRclearPRLINCOUNT          ; Output new line and set COUNT to zero
94FF                  9
9501                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
003D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
94FF  BDBA3E                                  JSR     \1
                              ENDIF
9502                  cmdPRINT_endcmd_noCR                                    ; L91C5
9502                                  JUMP    decYGoScanNextContinue          ; Check end of statement, return to execution loop
9502  7E935D                                  JMP     \1
9505                  cmdPRINT_lp2_checkendcmd                                ; L91C8
9505  0F14                            CLR     ZP_PRINTBYTES                   ;TODO: work out if BEQ->LBRA's below are better / shorter/faster than straight LBEQ's
9507  0F15                            CLR     ZP_PRINTFLAG                    ;  Set current field to zero, hex/dec flag to decimal
9509                                  CALL    skipSpacesY                     ;  Get next non-space character
9509                  9
950B                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9509  BD928C                                  JSR     \1
                              ENDIF
950C  813A                            CMPA    #':'
950E  27F2                            BEQ     cmdPRINT_endcmd_noCR            ;  <colon> found, finish printing
9510  810D                            CMPA    #$0D
9512  27EE                            BEQ     cmdPRINT_endcmd_noCR            ;  <cr> found, finish printing
9514  818B                            CMPA    #tknELSE
9516  27EA                            BEQ     cmdPRINT_endcmd_noCR            ;  'ELSE' found, finish printing
                      
                      ;                       ;  Otherwise, continue into main loop
9518                  cmdPRINT_sk0                                            ; L91DB
9518  817E                            CMPA    #'~'
951A  27B1                            BEQ     cmdPRINT_setHexFlagFromCarry2   ; Jump back to set hex/dec flag from Carry
951C  812C                            CMPA    #','
951E  27B1                            BEQ     cmdPRINT_padToNextField         ; Jump to pad to next print field
9520  813B                            CMPA    #';'
9522  27E1                            BEQ     cmdPRINT_lp2_checkendcmd        ; Jump to check for end of print statement
9524                                  CALL    cmdPRINT_checkaposTABSPC
9524                  9
9526                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9524  BD95AC                                  JSR     \1
                              ENDIF
9527  24C7                            BCC     cmdPRINT_lp1                    ; Check for ' TAB SPC, if print token found return to outer main loop
                      
                      ;                       ;  All print formatting have been checked, so it now must be an expression
                      ;                       ;  -----------------------------------------------------------------------
9529  DC14                            LDD     ZP_PRINTBYTES                   ; TODO: assumes order ZP_PRINTBYTES precedes ZP_PRINTFLAG
                      ;; removed;             LDB     ZP_PRINTFLAG
952B  3406                            PSHS    D
                      ;                       ;  Save field width and flags, as evaluator
                      ;                       ;   may call PRINT (eg FN, STR$, etc.)
952D  335F                            LEAU    -1,U
952F                                  CALL    evalAtY                         ; Evaluate expression
952F                  9
9531                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0090                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
952F  BD9DC1                                  JSR     \1
                              ENDIF
9532  3506                            PULS    D                               ; Restore field width and flags
9534  DD14                            STD     ZP_PRINTBYTES
                      ;; removed;             STB     ZP_PRINTFLAG
9536  0D27                            TST     ZP_VARTYPE                      ; DB - was from Y
9538  2711                            BEQ     cmdPRINT_printString            ; If type=0, jump to print string
953A                                  CALL    cmdPRINT_num2str                ; Convert Numeric value to string
953A                  9
953C                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
953A  BDA19C                                  JSR     \1
                              ENDIF
953D  9614                            LDA     ZP_PRINTBYTES                   ; Get current field width
953F  9036                            SUBA    ZP_STRBUFLEN                    ; A=width-stringlength
9541  2308                            BLS     cmdPRINT_printString            ; length>=width - print it
9543  1F89                            TFR     A,B                             ; B=number of spaces needed
9545                  cmdPRINT_padlp1                                         ; L9211
9545                                  CALL    list_print1Space
9545                  9
9547                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0026                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9545  BDBC6D                                  JSR     \1
                              ENDIF
9548  5A                              DECB
9549  26FA                            BNE     cmdPRINT_padlp1                 ;  Loop to print required spaces
                      
                      ;                       ;  Print string in string buffer
                      ;                       ;  -----------------------------
954B                  cmdPRINT_printString
954B  D636                            LDB     ZP_STRBUFLEN
954D  27A1                            BEQ     cmdPRINT_lp1                    ; Null string, jump back to main loop
954F  8E0600                          LDX     #BAS_StrA
9552                  cmdPRINT_printString_lp                                 ; L921D
9552  A680                            LDA     ,X+
9554                                  CALL    list_printANoEDIT               ; Print the character from string buffer
9554                  9
9556                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9554  BDBC73                                  JSR     \1
                              ENDIF
9557  5A                              DECB
9558  26F8                            BNE     cmdPRINT_printString_lp         ;  Increment pointer, loop for full string
955A  2094                            BRA     cmdPRINT_lp1                    ;  Jump back to main loop
                      
                      
955C                  cmdPRINT_TAB_comma                                      ; L922D
955C  962D                            LDA     ZP_INT_WA + 3                   ;  Save current value
955E  3402                            PSHS    A
9560                                  CALL    evalL1BracketAlreadyOpenConvert2INT     ;  Evaluate next integer, check for closing bracket
9560                  9
9562                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9560  BD9858                                  JSR     \1
                              ENDIF
9563  861F                            LDA     #$1F
9565  BDFFEE                          JSR     OSWRCH                          ;  VDU 31 - Set cursor position
9568  3502                            PULS    A                               ;  Get first parameter back
956A  BDFFEE                          JSR     OSWRCH                          ;  Send X parameter
956D                                  CALL    doVDUChar_fromWA3               ;  Send Y parameter from integer accumulator
956D                  9
956F                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
956D  BD99CE                                  JSR     \1
                              ENDIF
9570  202C                            BRA     rtsCLC_L926A
                      
                                              ;  Clear carry flag, Set PTR A offset = PTR B offset and exit
                                              ;  PRINT TAB()
                                              ;  -----------
9572                  cmdPRINT_TAB                                            ; L9241
9572                                  CALL    evalAtYcheckTypeInAConvert2INT  ; Get Integer result of expression
9572                  9
9574                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9572  BD9860                                  JSR     \1
                              ENDIF
9575                                  CALL    skipSpacesCheckCommaAtY         ; Get next non-space character, compare with ','
9575                  9
9577                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9575  BD90C8                                  JSR     \1
                              ENDIF
9578  27E2                            BEQ     cmdPRINT_TAB_comma              ; Comma, jump to TAB(x,y)
957A  8129                            CMPA    #')'                            ; Check for closing bracket
957C  1026FD23                        LBNE    brkMissingComma                 ; Jump to give "Missing )" error
9580  962D                            LDA     ZP_INT_WA + 3                   ; Get value
9582  901E                            SUBA    ZP_PRLINCOUNT                   ; A=tab-COUNT
9584  2718                            BEQ     rtsCLC_L926A                    ; No spaces needed, jump to clear carry, update and return
9586  1F89                            TFR     A,B                             ; B=number of spaces needed
9588  250C                            BCS     cmdPRINT_B_SPACESCLCRTS         ; Output X number of spaces, clear carry, update and return
958A                                  CALL    PrintCRclearPRLINCOUNT          ; Start new output line
958A                  9
958C                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
958A  BDBA3E                                  JSR     \1
                              ENDIF
958D  2003                            BRA     cmdPRINT_SPACESatZP_INT_WA_3    ; Output ?2A number of spaces, clear carry, update and return
                      
                      ;                       ;  PRINT SPC()
                      ;                       ;  -----------
958F                  cmdPRINT_SPC                                            ; L925B
958F                                  CALL    evalLevel1checkTypeStoreAsINT   ; Evaluate integer
958F                  9
9591                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
958F  BD9865                                  JSR     \1
                              ENDIF
9592                  cmdPRINT_SPACESatZP_INT_WA_3                            ; L925E
9592  D62D                            LDB     ZP_INT_WA + 3                   ; Get returned value
9594  2708                            BEQ     rtsCLC_L926A                    ; If zero, clear carry, update and return
9596                  cmdPRINT_B_SPACESCLCRTS                                 ; L9262
9596                                  CALL    list_printBSpaces               ; Output X number of Spaces
9596                  9
9598                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0005                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9596  BDBC9D                                  JSR     \1
                              ENDIF
9599  2003                            BRA     rtsCLC_L926A                    ; Clear carry, update and return
                      
                      ;                       ;  PRINT '
                      ;                       ;  -------
959B                  cmdPRINT_CR                                     ; L9267
959B                                          CALL PrintCRclearPRLINCOUNT                     ;  Output a new line
959B                  9
959D                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
959B  BDBA3E                                  JSR     \1
                              ENDIF
                      ;                       ;  Clear carry, update and return
                      ;                       ;  ------------------------------
959E                  rtsCLC_L926A            
959E                                  CLC
959E  1CFE                    ANDCC   #~CC_C
                      ;               ;;;; REMOVED    BRA copyTXTOFF2toTXTOFF                 ;  Update PTR A offset = PTR B offset and return
95A0  39                              RTS
                      ;               
                      ;       
                      
                      ;decYEvalForceINT
                      ;               LEAU    -1,Y
95A1                  evalForceINT
95A1                                  CALL    evalExpressionMAIN
95A1                  9
95A3                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95A1  BD9DC1                                  JSR     \1
                              ENDIF
95A4                                  CALL    checkTypeInAConvert2INT
95A4                  9
95A6                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95A4  BD986F                                  JSR     \1
                              ENDIF
95A7                  copyTXTOFF2toTXTOFF
95A7  DF0B                            STU     ZP_TXTPTR
95A9  DF19                            STU     ZP_TXTPTR2
95AB  39                              RTS
                      
                      ;                       ;  Check special print formatting ' TAB( SPC
                      ;                       ;  -----------------------------------------
95AC                  cmdPRINT_checkaposTABSPC                                ; L927A
                      ;; REMOVED      ;               LDX ZP_TXTPTR
                      ;; REMOVED      ;               STX ZP_TXTPTR2
                      ;; REMOVED      ;               LDX ZP_TXTPTR + 1
                      ;; REMOVED      ;               STX ZP_TXTPTR2 + 1
                      ;; REMOVED      ;               LDX ZP_TXTOFF
                      ;; REMOVED      ;               STX ZP_TXTOFF2
95AC  8127                            CMPA    #'''
95AE  27EB                            BEQ     cmdPRINT_CR                     ;  Current char is "'", jump to print newline
95B0  818A                            CMPA    #tknTAB
95B2  27BE                            BEQ     cmdPRINT_TAB                    ;  Current char 'TAB(', jump to do TAB()
95B4  8189                            CMPA    #tknSPC
95B6  27D7                            BEQ     cmdPRINT_SPC                    ;  Current char 'SPC', jump to do SPC()
95B8                  rtsSEC_L9292
95B8                                  SEC                                     ;  Flag 'not formatting token'
95B8  1A01                    ORCC    #CC_C
95BA                  rtsL9293
95BA  39                              RTS
95BB                  brkMissingQuote                                         ; L9294
95BB                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
95BB  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
95BC  098D2200                        FCB     $09, tknMissing, $22,
95C0                  cmdINPUT_PRINT_prompt
95C0                                  CALL    skipSpacesY
95C0                  9
95C2                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95C0  BD928C                                  JSR     \1
                              ENDIF
95C3                                  CALL    cmdPRINT_checkaposTABSPC                
95C3                  9
95C5                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
95C3  8DE7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
95C5  24F3                            BCC     rtsL9293                        ; 
95C7  8122                            CMPA    #'"'
95C9  26ED                            BNE     rtsSEC_L9292
95CB  A6C0            2               LDA     ,U+
95CD  810D                            CMPA    #$0D
95CF  27EA                            BEQ     brkMissingQuote
95D1  8122                            CMPA    #'"'
95D3  2606                            BNE     1F
95D5  A1C4                            CMPA    ,U                              ; double " 
95D7  26C5                            BNE     rtsCLC_L926A
95D9  3341                            LEAU    1,U
95DB                  1               CALL    list_printANoEDIT
95DB                  9
95DD                  __XBSR                  SET 9B+2
2600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0096                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95DB  BDBC73                                  JSR     \1
                              ENDIF
95DE  20EB                            BRA     2B
95E0                  cmdCALL                 ; L92BE!
95E0                                  CALL    evalExpressionMAIN
95E0                  9
95E2                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95E0  BD9DC1                                  JSR     \1
                              ENDIF
95E3                                  CALL    checkTypeInZP_VARTYPEConvert2INT
95E3                  9
95E5                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0088                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95E3  BD986D                                  JSR     \1
                              ENDIF
95E6                                  CALL    stackINT_WAasINT
95E6                  9
95E8                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0072                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95E6  BDBB5A                                  JSR     \1
                              ENDIF
95E9  7F0600                          CLR     BAS_StrA                        ; number of parameters
95EC  8E0601                          LDX     #BAS_StrA+1
95EF                  L92CC
95EF                                  CALL    skipSpacesCheckCommaAtYStepBack
95EF                  9
95F1                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95EF  BD90CE                                  JSR     \1
                              ENDIF
95F2  2612                            BNE     L92F1
95F4                                  CALL    findVarAtYSkipSpaces
95F4                  9
95F6                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
95F4  BD9A7D                                  JSR     \1
                              ENDIF
95F7  271C                            BEQ     L9301
95F9  962A                            LDA     ZP_INT_WA + 0
95FB  A780                            STA     ,X+                             ; var type
95FD  DC2C                            LDD     ZP_INT_WA + 2           
95FF  ED81                            STD     ,X++                            ; var ptr
9601  7C0600                          INC     BAS_StrA
9604  20E9                            BRA     L92CC
9606                  L92F1           CALL    scanNextStmtFromY
9606                  9
9608                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
006C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9606  BD9C74                                  JSR     \1
                              ENDIF
9609                                  CALL    popIntANew
9609                  9
960B                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9609  BDBBEC                                  JSR     \1
                              ENDIF
960C  3440                            PSHS    U
960E                                  CALL    callusrSetRegsEnterCode
960E                  9
9610                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
960E  8D08                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9610  3540                            PULS    U
9612                                  JUMP    continue
9612  7E9362                                  JMP     \1
9615                  L9301
9615                                  JUMP    brkNoSuchVar
9615  7EADBC                                  JMP     \1
9618                  callusrSetRegsEnterCode                         ; L9304
9618  3440                            PSHS    U
961A  B6040F                          LDA     $040C+3                         ; C% into carry
961D  44                              LSRA
961E  B60407                          LDA     $0404+3
9621  F6040B                          LDB     $0408+3
9624  BE0462                          LDX     $0460+2
9627  FE0466                          LDU     $0464+2
962A  AD9F002C                        JSR     [ZP_INT_WA + 2]
962E  35C0                            PULS    U,PC
9630                  L9314JUMPbrkSyntax
9630                                  JUMP    brkSyntax
9630  7E9C37                                  JMP     \1
9633                  cmdDELETE
                      
9633                                          TODO_CMD "DELETE"
9633                                          TODODEADEND "\1"
9633                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9633  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9634  7E443A                          FCB             $7E,"D:"
9637  44454C455445                    FCB             \1
963D  00                              FCB             0
                                              
                      ;                       ;  DELETE
                      ;               CALL skipSpacesDecodeLineNumber
                      ;               BCC L9314JUMPbrkSyntax
                      ;               CALL stackINT_WAasINT
                      ;               CALL SkipSpaceCheckComma
                      ;               BNE L9314JUMPbrkSyntax
                      ;               CALL skipSpacesDecodeLineNumber
                      ;               BCC L9314JUMPbrkSyntax
                      ;               CALL scanNextStmt
                      ;               LDA ZP_INT_WA
                      ;               STA ZP_NAMELENORVT
                      ;               LDA ZP_INT_WA + 1
                      ;               STA ZP_NAMELENORVT + 1
                      ;               CALL popIntA
                      ;L9337:
                      ;               CALL findLineAndDelete  
                      ;               CALL checkForESC
                      ;               CALL inc_INT_WA
                      ;               LDA ZP_NAMELENORVT
                      ;               CMP ZP_INT_WA
                      ;               LDA ZP_NAMELENORVT + 1
                      ;               SBC ZP_INT_WA + 1
                      ;               BCS L9337
                      ;               JUMP resetVarsImmedPrompt
963E                  AUTO_RENUM_STARTSTEP_DEF1010                            ; L934D
963E  C60A                            LDB     #$0A
9640                                  CALL    retB8asUINT                     ; default first param 10
9640                  9
9642                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9640  BDAE56                                  JSR     \1
                              ENDIF
9643                                  CALL    skipSpacesDecodeLineNumberNewAPI
9643                  9
9645                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9643  BD9BFB                                  JSR     \1
                              ENDIF
9646                                  CALL    stackINT_WAasINT
9646                  9
9648                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0012                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9646  BDBB5A                                  JSR     \1
                              ENDIF
9649  C60A                            LDB     #$0A                            ; default second param 10
964B                                  CALL    retB8asUINT
964B                  9
964D                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
964B  BDAE56                                  JSR     \1
                              ENDIF
964E                                  CALL    skipSpacesCheckCommaAtY
964E                  9
9650                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
964E  BD90C8                                  JSR     \1
                              ENDIF
9651  260E                            BNE     L9370
9653                                  CALL    skipSpacesDecodeLineNumberNewAPI
9653                  9
9655                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9653  BD9BFB                                  JSR     \1
                              ENDIF
9656  962C                            LDA     ZP_INT_WA + 2
9658  2617                            BNE     brkSilly
965A  962D                            LDA     ZP_INT_WA + 3
965C  2713                            BEQ     brkSilly
965E                                  JUMP    scanNextStmtFromY
965E  7E9C74                                  JMP     \1
9661                  L9370
9661                                  JUMP    scanNextExpectColonElseCR
9661  7E9C77                                  JMP     \1
                      ;L9373:
                      ;               LDA ZP_TOP
                      ;               STA ZP_FPB
                      ;               LDA ZP_TOP + 1
                      ;               STA ZP_FPB + 1
                      ;L937B:
                      ;               LDA ZP_PAGE_H
                      ;               STA ZP_GEN_PTR + 1
                      ;               LDU #$01
                      ;               STU ZP_GEN_PTR
                      ;               RTS
9664                  cmdRENUMBER             ; L9384!
                      
9664                                          TODO_CMD "RENUMBER"
9664                                          TODODEADEND "\1"
9664                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9664  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9665  7E443A                          FCB             $7E,"D:"
9668  52454E554D424552                 FCB             \1
9670  00                              FCB             0
                                              
                      ;                       ;  RENUMBER
                      ;               CALL AUTO_RENUM_STARTSTEP_DEF1010
                      ;               LDX #ZP_NAMELENORVT
                      ;               CALL popIntAtX
                      ;               CALL findTOP
                      ;               CALL L9373
                      ;L9392:
                      ;               LDA (ZP_GEN_PTR)
                      ;               BMI L93C4
                      ;               STA (ZP_FPB)
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               STA (ZP_FPB),Y
                      ;               SEC
                      ;               TYA
                      ;               ADC ZP_FPB
                      ;               STA ZP_FPB
                      ;               BCC L93A6
                      ;               INC ZP_FPB + 1
                      ;L93A6:
                      ;               CMP ZP_HIMEM
                      ;               LDA ZP_FPB + 1
                      ;               SBC ZP_HIMEM + 1
                      ;               BCS brkRENUMBERspace
                      ;               CALL L947A
                      ;               BRA L9392
                      ;brkRENUMBERspace:
                      ;               BRK
                      ;               .byte  $00
                      ;               .byte  tknRENUMBER, " space"
9671                  brkSilly
9671                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9671  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9672  0053696C6C7900                  FCB     $00, "Silly", 0
                      ;
                      ;L93C4:         CALL L937B
                      ;L93C7:         LDA (ZP_GEN_PTR)
                      ;               BMI L93E7
                      ;               LDA ZP_NAMELENORVT + 1
                      ;               STA (ZP_GEN_PTR)
                      ;               LDA ZP_NAMELENORVT
                      ;               STA (ZP_GEN_PTR),Y
                      ;               CLC
                      ;               LDA ZP_NAMELENORVT
                      ;               ADC ZP_INT_WA
                      ;               STA ZP_NAMELENORVT
                      ;               LDA #$00
                      ;               ADC ZP_NAMELENORVT + 1
                      ;               AND #$7F
                      ;               STA ZP_NAMELENORVT + 1
                      ;               CALL L947A
                      ;               BRA L93C7
                      ;L93E7:
                      ;               LDA ZP_PAGE_H
                      ;               STA ZP_TXTPTR + 1
                      ;               STZ ZP_TXTPTR
                      ;L93ED:
                      ;               LDU #$01
                      ;               LDA (ZP_TXTPTR),Y
                      ;               BMI L945A
                      ;               LDU #$04
                      ;               STZ ZP_INT_WA + 2
                      ;L93F7:
                      ;               LDA (ZP_TXTPTR),Y
                      ;               LDX ZP_INT_WA + 2
                      ;               BNE L9405
                      ;               CMP #$8D
                      ;               BEQ L941B
                      ;               CMP #$F4
                      ;               BEQ L9412
                      ;L9405:
                      ;               INY
                      ;               CMP #$22
                      ;               BNE L940E
                      ;               EOR ZP_INT_WA + 2
                      ;               STA ZP_INT_WA + 2
                      ;L940E:
                      ;               CMP #$0D
                      ;               BNE L93F7
                      ;L9412:
                      ;               LDU #$03
                      ;               LDA (ZP_TXTPTR),Y
                      ;               CALL L9BF4
                      ;               BRA L93ED
                      ;L941B:
                      ;               CALL decodeLineNumber
                      ;               CALL L9373
                      ;L9421:
                      ;               LDA (ZP_GEN_PTR)
                      ;               BMI L945C
                      ;               LDA (ZP_FPB)
                      ;               CMP ZP_INT_WA + 1
                      ;               BNE L944A
                      ;               LDA (ZP_FPB),Y
                      ;               CMP ZP_INT_WA
                      ;               BNE L944A
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               STA ZP_FPB + 2
                      ;               LDA (ZP_GEN_PTR)
                      ;               TAX
                      ;               LDU ZP_TXTOFF
                      ;               DEY
                      ;               LDA ZP_TXTPTR
                      ;               STA ZP_NAMELENORVT
                      ;               LDA ZP_TXTPTR + 1
                      ;               STA ZP_NAMELENORVT + 1
                      ;               CALL L8D62
                      ;L9446:
                      ;               LDU ZP_TXTOFF
                      ;               BRA L93F7
                      ;L944A:
                      ;               CLC
                      ;               CALL L947A
                      ;               LDA ZP_FPB
                      ;               ADC #$02
                      ;               STA ZP_FPB
                      ;               BCC L9421
                      ;               INC ZP_FPB + 1
                      ;               BRA L9421
                      ;L945A:
                      ;               BRA L94B6
                      ;L945C:
                      ;               PRINT_STR "Failed at "
                      ;               LDA (ZP_TXTPTR),Y
                      ;               STA ZP_INT_WA + 1
                      ;               INY
                      ;               LDA (ZP_TXTPTR),Y
                      ;               STA ZP_INT_WA
                      ;               CALL int16print_AnyLen -- API CHANGE -- API CHANGE
                      ;               CALL PrintCRclearPRLINCOUNT
                      ;               BRA L9446
                      ;L947A:
                      ;               INY
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               LDU #$01
                      ;               ADC ZP_GEN_PTR
                      ;               STA ZP_GEN_PTR
                      ;               BCC L9488
                      ;               INC ZP_GEN_PTR + 1
                      ;               CLC
                      ;L9488:
                      ;               RTS
                      ;                       ;  AUTO [num[,num]]
                      ;                       ;  ================
9679                  cmdAUTO                 
9679                                  CALL    AUTO_RENUM_STARTSTEP_DEF1010
9679                  9
967B                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9679  8DC3                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
967B  962D                            LDA     ZP_INT_WA + 3
967D  3402                            PSHS    A                               ; stack the step
967F                                  CALL    popIntANew
967F                  9
9681                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
967F  BDBBEC                                  JSR     \1
                              ENDIF
9682                  L9492           CALL    stackINT_WAasINT
9682                  9
9684                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9682  BDBB5A                                  JSR     \1
                              ENDIF
9685                                  CALL    int16print_fmt5
9685                  9
9687                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0049                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9685  BDA0D0                                  JSR     \1
                              ENDIF
9688                                  CALL    ReadKeysTo_InBuf
9688                  9
968A                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9688  BDBA24                                  JSR     \1
                              ENDIF
968B                                  CALL    popIntANew
968B                  9
968D                  __XBSR                  SET 9B+2
2500                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
968B  BDBBEC                                  JSR     \1
                              ENDIF
968E                                  CALL    L8DE7
968E                  9
9690                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
968E  BD91B0                                  JSR     \1
                              ENDIF
9691  CE0700                          LDU     #BAS_InBuf
9694                                  CALL    tokenizeAndStoreAlreadyLineNoDecoded 
9694                  9
9696                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9694  BDBA81                                  JSR     \1
                              ENDIF
9697                                  CALL    ResetVars
9697                  9
9699                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0057                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9697  BDBAF0                                  JSR     \1
                              ENDIF
969A  E6E4                            LDB     ,S
969C  4F                              CLRA
969D  D32C                            ADDD    ZP_INT_WA + 2
969F  DD2C                            STD     ZP_INT_WA + 2
96A1  2ADF                            BPL     L9492
96A3                  L94B6           JUMP    resetVarsImmedPrompt
96A3  7E92EC                                  JMP     \1
                      
                      
                      ;                       ;  DIM name - Reserve memory
                      ;                       ;  -------------------------
96A6                  cmdDIM_reserve_mem                                      ; L94BC
96A6                                  CALL    findVarOrAllocEmpty             ;  Step back, find/create variable
96A6                  9
96A8                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96A6  BD9A31                                  JSR     \1
                              ENDIF
96A9  276C                            BEQ brkBadDIM
96AB  256A                            BCS brkBadDIM                           ;  Error if string variable or bad variable name
96AD                                  CALL pushVarPtrAndType                  ;  Push IntA - address of info block
96AD                  9
96AF                  __XBSR                  SET 9B+2
2400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96AD  BDBB68                                  JSR     \1
                              ENDIF
96B0                                  CALL evalAtYcheckTypeInAConvert2INT
96B0                  9
96B2                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96B0  BD9860                                  JSR     \1
                              ENDIF
96B3                                  CALL inc_INT_WA                         ;  Evaluate integer, IntA=IntA+1 to count zeroth byte
96B3                  9
96B5                  __XBSR                  SET 9B+2
2700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96B3  BDBDB5                                  JSR     \1
                              ENDIF
96B6  962A                            LDA ZP_INT_WA + 0
96B8  9A2B                            ORA ZP_INT_WA + 1
96BA  265B                            BNE brkBadDIM                           ;  Size>$FFFF or <0, error
                      ;               CLC
                      ;               LDA ZP_INT_WA
                      ;               ADC ZP_VARTOP
                      ;               TAY                                     ;  XY=VARTOP+size
                      ;               LDA ZP_INT_WA + 1
                      ;               ADC ZP_VARTOP + 1
                      ;               TAX
96BC  DC2C                            LDD     ZP_INT_WA + 2
96BE  D302                            ADDD    ZP_VARTOP
96C0  109304                          CMPD    ZP_BAS_SP                       ; new vartop
96C3  102400FD                        LBHS    brkDIMspace                     ; check room
96C7  9E02                            LDX     ZP_VARTOP
96C9  9F2C                            STX     ZP_INT_WA + 2                   ; store org vartop as return value (top bytes already 0)
96CB  DD02                            STD     ZP_VARTOP
96CD  8640                            LDA     #$40
96CF  9727                            STA     ZP_VARTYPE                      ;  Type=Integer
96D1                                  CALL storeEvaledExpressioninStackedVarPTr
96D1                  9
96D3                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0068                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96D1  BDB33B                                  JSR     \1
                              ENDIF
96D4                                  CALL copyTXTOFF2toTXTOFF                        ;  Set the variable, update PTRA
96D4                  9
96D6                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96D4  BD95A7                                  JSR     \1
                              ENDIF
96D7                  cmdDIM_more_dims_q                                      ; L94FB
96D7                                  CALL    skipSpacesCheckCommaAtYStepBack
96D7                  9
96D9                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
96D7  BD90CE                                  JSR     \1
                              ENDIF
96DA  2743                            BEQ     cmdDIM                          ;  Next character is comma, do another DIM
96DC                                  JUMP    scanNextContinue
96DC  7E935F                                  JMP     \1
                      ;                       ;  Return to execution loop
                                      ; multiply 15 bit contents of 2,S by 15 bits in D, return in D
                                      ; uses ZP_INT_WA_C as scratch space
                                      ;         a b === D
                                      ;       x c d === [,S]
                                      ;       =====
                                      ;         bxd
                                      ;  +    axd
                                      ;  +    bxc
                                      ;  +  axc
                                      ;  ==========
                                      ;     F F C   = bad DIM !
96DF                  cmdDIM_mul_D_by_S                                       ; L9503
96DF  DD3D                            STD     ZP_INT_WA_C
96E1  4D                              TSTA
96E2  2704                            BEQ     1F
96E4  6D62                            TST     2,S
96E6  262F                            BNE     brkBadDIM                       ; > &10000
                                      
96E8  A663            1               LDA     3,S             ; A = d
96EA  3D                              MUL                     ; res = b * d
96EB  4D                              TSTA
96EC  2B29                            BMI     brkBadDIM
96EE  DD3F                            STD     ZP_INT_WA_C + 2
                      
96F0  963D                            LDA     ZP_INT_WA_C + 0 ; B = a
96F2  E663                            LDB     3,S             ; A = d
96F4  3D                              MUL                     
96F5  4D                              TSTA
96F6  261F                            BNE     brkBadDIM       ; overflow
96F8                                  CLC
96F8  1CFE                    ANDCC   #~CC_C
96FA  D93F                            ADCB    ZP_INT_WA_C + 2
96FC  2B19                            BMI     brkBadDIM       ; overflow
96FE  2517                            BCS     brkBadDIM       ; overflow
9700  D73F                            STB     ZP_INT_WA_C + 2
                      
9702  963E                            LDA     ZP_INT_WA_C + 1 ; B = b
9704  E662                            LDB     2,S             ; A = c
9706  3D                              MUL                     
9707  4D                              TSTA
9708  260D                            BNE     brkBadDIM       ; overflow
970A                                  CLC
970A  1CFE                    ANDCC   #~CC_C
970C  D93F                            ADCB    ZP_INT_WA_C + 2
970E  2B07                            BMI     brkBadDIM       ; overflow
9710  2505                            BCS     brkBadDIM       ; overflow
9712  1F98                            TFR     B,A
9714  D640                            LDB     ZP_INT_WA_C + 3
9716  39                              RTS
                                      
                      
9717                  brkBadDIM                                               ; L952C
9717                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9717  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9718  0A42616420DE00                  fcb  $0A, "Bad ", tknDIM, 0
                      
                      ;                       ;  DIM
                      ;                       ;  ===
971F                  cmdDIM
971F                                  CALL skipSpacesY
971F                  9
9721                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
971F  BD928C                                  JSR     \1
                              ENDIF
9722                  L9541
9722  335E                            LEAU    -2,U                            ; point 1 before variable name
9724  DF39                            STU     ZP_GEN_PTR+2
9726  C605                            LDB     #$05
9728  D73F                            STB     ZP_FPB + 4                      ; Real, 5 bytes needed
972A                                  CALL    fnProcScanYplus1varname; Check variable name
972A                  9
972C                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
972A  BD9BD3                                  JSR     \1
                              ENDIF
972D  C101                            CMPB    #1
972F  27E6                            BEQ     brkBadDIM                       ; Bad name, jump to error
9731  8128                            CMPA    #'('
9733  2715                            BEQ     cmdDIM_realArray                                ; Real array
9735  8124                            CMPA    #'$'
9737  2706                            BEQ     cmdDIM_strArray                 ; String array
9739  8125                            CMPA    #'%'
973B  1026FF67                        LBNE    cmdDIM_reserve_mem              ; Not (, $, %, reserve memory
973F                  cmdDIM_strArray                                         ; L9563
973F  0A3F                            DEC     ZP_FPB + 4                      ; String or Integer, 4 bytes needed
9741  5C                              INCB                                    ; length += 1
9742  A680                            LDA     ,X+                             ; Get ext character
9744  8128                            CMPA    #'('
9746  1026FF5C                        LBNE    cmdDIM_reserve_mem              ; No '(', jump to reserve memory
                      
                      
                      ;                       ;  Dimension an array
                      ;                       ;  ------------------
974A                  cmdDIM_realArray                                        ; L9570
974A  9F0B                            STX     ZP_TXTPTR
974C  5C                              INCB
974D  D737                            STB     ZP_NAMELENORVT
974F                                  CALL    findVarDynLL_NewAPI             ;  Get variable address
974F                  9
9751                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
974F  BD8499                                  JSR     \1
                              ENDIF
9752  26C3                            BNE     brkBadDIM
9754                                  CALL    allocVAR                        ;  Create new variable
9754                  9
9756                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9754  BD99E3                                  JSR     \1
                              ENDIF
9757  8601                            LDA     #1
9759                                  CALL    AllocVarSpaceOnHeap             ;  Allocate space
9759                  9
975B                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9759  BD9A15                                  JSR     \1
                              ENDIF
975C  963F                            LDA     ZP_FPB + 4
975E  3402                            PSHS    A
9760  9E02                            LDX     ZP_VARTOP
9762  3001                            LEAX    1,X                             ; leave room for 1 byte offset to first cell
9764  3410                            PSHS    X
9766  CC0001                          LDD     #1
9769  3406                            PSHS    D                               ; total cells accumulator on U stack
                      
976B  DE0B                            LDU     ZP_TXTPTR
                      
976D                  L9589           CALL    evalForceINT                    ;  Evaluate integer
976D                  9
976F                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
976D  BD95A1                                  JSR     \1
                              ENDIF
9770  962C                            LDA     ZP_INT_WA + 2
9772  84C0                            ANDA    #$C0
9774  9A2A                            ORA     ZP_INT_WA + 0
9776  9A2B                            ORA     ZP_INT_WA + 1
9778  269D                            BNE     brkBadDIM                       ;  Bad DIM
                      
977A  DC2C                            LDD     ZP_INT_WA + 2                   ; current dimension
977C                                  CLC
977C  1CFE                    ANDCC   #~CC_C
977E  C30001                          ADDD    #1                              ; increment
9781  AE62                            LDX     2,S
9783  ED81                            STD     ,X++                            ; store at VARTOP...
9785  AF62                            STX     2,S
9787                  1               CALL    cmdDIM_mul_D_by_S                               ;  Multiply [,S] by D return in D
9787                  9
9789                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0056                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9787  BD96DF                                  JSR     \1
                              ENDIF
978A  EDE4                            STD     ,S
978C                                  CALL    skipSpacesCheckCommaAtY         ;
978C                  9
978E                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
978C  BD90C8                                  JSR     \1
                              ENDIF
978F  27DC                            BEQ     L9589                           ;  Comma, another dimension
9791  8129                            CMPA    #')'
9793  1026FF80                        LBNE    brkBadDIM                       ;  Not ')', error
                      
                      ;                       ;  Closing ')' found
                      ;                       ;  -----------------
                                      ; calculate 1 byte pointer to 1st cell
9797  1F10                            TFR     X,D                             ; transfer X to D
9799  9302                            SUBD    ZP_VARTOP
979B  E79F0002                        STB     [ZP_VARTOP]                     ; store before the indices
                      
                                      ; calculate the array size in bytes
979F  E664                            LDB     4,S                             ; get cell size back from stack
97A1  4F                              CLRA
97A2                                  CALL    cmdDIM_mul_D_by_S
97A2                  9
97A4                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97A2  BD96DF                                  JSR     \1
                              ENDIF
97A5  3406                            PSHS    D
97A7  3410                            PSHS    X
97A9  E3E1                            ADDD    ,S++                            ; add cells byte count to X
97AB  2517                            BCS     brkDIMspace                     ; > 64K
97AD  109304                          CMPD    ZP_BAS_SP
97B0  2412                            BHS     brkDIMspace                     ; new VARTOP >= U
97B2  DD02                            STD     ZP_VARTOP
97B4  3506                            PULS    D                               ; get back byte count
97B6  4C                              INCA                                    ; increment hi byte of count so we can do BNE
97B7  6F80            1               CLR     ,X+
97B9  5A                              DECB
97BA  26FB                            BNE     1B
97BC  4A                              DECA
97BD  26F8                            BNE     1B
97BF  3265                            LEAS    5,S                             ; discard cell count and cell size from stack
97C1                                  JUMP    cmdDIM_more_dims_q
97C1  7E96D7                                  JMP     \1
                      ;                       ;  Check if another dimension
97C4                  brkDIMspace                                             ; L9605
97C4                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
97C4  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
97C5  0BDE20737061636500                 FCB     $0B, tknDIM, " space", 0
                      
                      ;                       ;  Program environment commands
                      ;                       ;  ============================
                      ;                       ;  HIMEM=address - Set top of BASIC memory, clearing stack
                      ;                       ;  -------------------------------------------------------
97CE                  varSetHIMEM                     ; L960F!
                      
                                              
                                              
97CE                                  CALL    evalAssignEqInteger             ;  Check for '=', evaluate integer
97CE                  9
97D0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97CE  BD986A                                  JSR     \1
                              ENDIF
97D1  9E2C                            LDX     ZP_INT_WA + 2
97D3  9F06                            STX     ZP_HIMEM
97D5  9F04                            STX     ZP_BAS_SP
97D7  2015                            BRA     L963B_continue                  ;  Return to execution loop
                      ;                       ;  LOMEM=address
                      ;                       ;  -------------
97D9                  varSetLOMEM                     ; L9620!
97D9                                  CALL    evalAssignEqInteger             ;  Check for '=', evaluate integer
97D9                  9
97DB                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97D9  BD986A                                  JSR     \1
                              ENDIF
97DC  9E2C                            LDX     ZP_INT_WA + 2
97DE  9F00                            STX     ZP_LOMEM
97E0  9F02                            STX     ZP_VARTOP
97E2                                  CALL    InittblFPRtnAddr                ;  Clear dynamic variables
97E2                  9
97E4                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97E2  BDBAF8                                  JSR     \1
                              ENDIF
97E5  2007                            BRA     L963B_continue;                 ;  Return to execution loop
                      ;                       ;  PAGE=address - Set program start
                      ;                       ;  --------------------------------
97E7                  varSetPAGE                      ; L9634!
97E7                                  CALL    evalAssignEqInteger             ;  Check for '=', evaluate integer
97E7                  9
97E9                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97E7  BD986A                                  JSR     \1
                              ENDIF
97EA  962C                            LDA     ZP_INT_WA + 2
97EC  9718                            STA     ZP_PAGE_H                       ;  Set PAGE
97EE                  L963B_continue
97EE                                  JUMP    continue                        ;  Return to execution loop
97EE  7E9362                                  JMP     \1
                      
                      ;                       ;  CLEAR
                      ;                       ;  -----
97F1                  cmdCLEAR                                                ; L963E
                      
97F1                                  CALL    scanNextStmtFromY       
97F1                  9
97F3                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97F1  BD9C74                                  JSR     \1
                              ENDIF
97F4                                  CALL    ResetVars                       ;  Check end of statement, clear variables
97F4                  9
97F6                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97F4  BDBAF0                                  JSR     \1
                              ENDIF
97F7  20F5                            BRA     L963B_continue;                 ;  Return to execution loop
                      
                      ;                       ;  TRACE [ON|OFFOFF|<linenum>]
                      ;                       ;  ---------------------------
97F9                  cmdTRACE
                      
97F9                                  CALL    skipSpacesDecodeLineNumberNewAPI
97F9                  9
97FB                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
97F9  BD9BFB                                  JSR     \1
                              ENDIF
97FC  250B                            BCS     L9656                           ;  TRACE linenum
97FE  81EE                            CMPA    #tknON
9800  2715                            BEQ     L9667                           ;  TRACE ON
9802  8187                            CMPA    #tknOFF
9804  271B                            BEQ     L9670                           ;  TRACE OFF
9806                                  CALL    evalForceINT                    ;  Evaluate integer
9806                  9
9808                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9806  BD95A1                                  JSR     \1
                              ENDIF
9809                  L9656           CALL    scanNextStmtFromY               ;  Check end of statement
9809                  9
980B                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9809  BD9C74                                  JSR     \1
                              ENDIF
980C  DC2C                            LDD     ZP_INT_WA + 2
980E  DD21            L965F           STD     ZP_MAXTRACLINE                  ;  Set TRACE <linenum>
9810  86FF                            LDA     #$FF                            ;  Set TRACE ON
9812  9720            L9663           STA     ZP_TRACE
9814                                  JUMP    continue                        ;  Return to execution loop
9814  7E9362                                  JMP     \1
9817  3341            L9667           LEAU    1,U
9819                                  CALL    scanNextStmtFromY               ;  Check end of statement
9819                  9
981B                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0059                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9819  BD9C74                                  JSR     \1
                              ENDIF
981C  CCFFFF                          LDD     #$FFFF
981F  20ED                            BRA     L965F                           ;  Jump to set TRACE $FFxx and TRACE ON
9821  3341            L9670           LEAU    1,U
9823                                  CALL    scanNextStmtFromY               ;  Check end of statement
9823                  9
9825                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
004F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9823  BD9C74                                  JSR     \1
                              ENDIF
9826  4F                              CLRA
9827  5F                              CLRB
9828  20E8                            BRA     L9663
                      
                              IF FLEX = 1
                      brkFlexNotImpl  DO_BRK_B
                                      FCB     $FE, "Not implemented in FLEX OS", 0
                              ENDIF
                      
                                              ;  Jump to set TRACE OFF
                                              ;  TIME=val, TIME$=s$ - set TIME or TIME$
                                              ;  ======================================
982A                  varSetTIME                      ; L9679!
                      
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE                    
982A  A6C4                            LDA     ,U                              ;  Get next character
982C  8124                            CMPA    #'$'
982E  270F                            BEQ     varSetTime_Dollar               ;  Jump for TIME$=
9830                                  CALL    evalAssignEqInteger
9830                  9
9832                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0038                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9830  8D38                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9832                                  CALL    SwapEndian
9832                  9
9834                  __XBSR                  SET 9B+2
1600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9832  BDAE94                                  JSR     \1
                              ENDIF
9835  0F2F                            CLR     ZP_INT_WA+5                     ;  Check for '=', evaluate integer, set byte 5 to zero
9837  8E002A                          LDX     #ZP_INT_WA
983A  8602                            LDA     #$02                            ;  A=2 for Write TIME
983C                  L968B
983C                                  JUMP    OSWORD_continue                 ;  Call OSWORD, return to execution loop
983C  7EB31E                                  JMP     \1
                              ENDIF
                      ;                       ;  TIME$=string
                      ;                       ;  ------------
983F                  varSetTime_Dollar                                       ; L968E
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
983F  3341                            LEAU    1,U                             ; skip '$'
9841                                  CALL    styZP_TXTPTR2_skipSpacesExectEqEvalExp
9841                  9
9843                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9841  BD9C24                                  JSR     \1
                              ENDIF
9844  9627                            LDA     ZP_VARTYPE
9846  1026FBA1                        LBNE    brkTypeMismatch                 ;  If not string, jump to Type mismatch
984A  860F                            LDA     #$0F                            ;  A = $0F for Write RTC
984C  D636                            LDB     ZP_STRBUFLEN
984E  8E05FF                          LDX     #BASWKSP_STRING-1               ;  Store string length as subfunction
9851  E784                            STB     ,X                              ;  Point to StringBuf-1                         ; TODO: CHECK this overwrites &05FF!
9853  20E7                            BRA     L968B                           ;  Call OSWORD, return to execution loop
                              ENDIF
9855                  evalstackStringExpectINTCloseBracket                    ; L96A4
9855                                  CALL    StackString
9855                  9
9857                  __XBSR                  SET 9B+2
2300                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9855  BDBB74                                  JSR     \1
                              ENDIF
9858                  evalL1BracketAlreadyOpenConvert2INT                             ; L96A7
9858                                  CALL    evalL1BracketAlreadyOpen
9858                  9
985A                  __XBSR                  SET 9B+2
1500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0084                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9858  BDADDE                                  JSR     \1
                              ENDIF
985B  2012                            BRA     checkTypeInAConvert2INT
985D                  checkCommaThenEvalAtYcheckTypeInAConvert2INT            ; L96AC
985D                                  CALL    skipSpacesCheckCommaAtYOrBRK
985D                  9
985F                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
985D  BD929E                                  JSR     \1
                              ENDIF
                      
9860                  evalAtYcheckTypeInAConvert2INT                          ; L96AF
9860                                  CALL    evalAtY
9860                  9
9862                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9860  BD9DC1                                  JSR     \1
                              ENDIF
9863  200A                            BRA     checkTypeInAConvert2INT
                      
9865                  evalLevel1checkTypeStoreAsINT
9865                                  CALL    evalLevel1
9865                  9
9867                  __XBSR                  SET 9B+2
1500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9865  BDAD70                                  JSR     \1
                              ENDIF
9868  2005                            BRA     checkTypeInAConvert2INT
                      ;                       ;  Evaluate =<integer>
                      ;                       ;  ===================
986A                  evalAssignEqInteger                                     ; L96B9
986A                                  CALL styZP_TXTPTR2_skipSpacesExectEqEvalExp                     ;  Check for '=', evaluate expression
986A                  9
986C                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
986A  BD9C24                                  JSR     \1
                              ENDIF
986D                  checkTypeInZP_VARTYPEConvert2INT                ; L96BC
986D  9627                            LDA ZP_VARTYPE                  ;  Get type and ensure is an integer
                      ;               
                      ;                       ;  Convert real to integer
                      ;                       ;  -----------------------
                                              ;  new API:
                                              ;  expect type in A
                                              ;  convert item to ZP_INT_WA
                      ;; - REMOVE THIS fpTAYcheckTypeInAConvert2INT (expected type in A)
                      ;; - REMOVE THIS fpcheckTypeInAConvert2INT (expected type in Y)
                      ;;;             TAY                                     ;  Copy type to Y to set flags
986F                  checkTypeInAConvert2INT
986F  4D                              TSTA
9870  1027FB77                        LBEQ    brkTypeMismatch
9874  2A0B                            BPL     anRTS                           ;  If string, error; if already integer, return
                                      
9876                  fpReal2Int      
9876                                  CALL    fpAMant2Int                     ;  Convert real to integer
9876                  9
9878                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0094                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9876  BD860C                                  JSR     \1
                              ENDIF
9879                  fpCopyAmant2intWA
9879  DC31                            LDD     ZP_FPA + 3
987B  DD2A                            STD     ZP_INT_WA
987D  DC33                            LDD     ZP_FPA + 5
987F  DD2C                            STD     ZP_INT_WA + 2
9881  39              anRTS           RTS
                      ;JUMPBrkTypeMismatch2:
                      ;               JUMP brkTypeMismatch
                      ;
9882                  evalLevel1ConvertReal
9882                                  CALL     evalLevel1
9882                  9
9884                  __XBSR                  SET 9B+2
1400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9882  BDAD70                                  JSR     \1
                              ENDIF
9885                  checkTypeIntToReal
9885  4D                              TSTA
9886  1027FB61                        LBEQ     brkTypeMismatch
988A  2BF5                            BMI     anRTS
988C                                  JUMP     IntToReal
988C  7E856A                                  JMP     \1
                      ;               
                      ;               
988F                  cmdPROC
                      
                      ;;;                     ;  PROC
988F  DF19                            STU     ZP_TXTPTR2
9891  86F2                            LDA     #tknPROC
9893                                  CALL    doFNPROCcall
9893                  9
9895                  __XBSR                  SET 9B+2
1700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9893  BDB076                                  JSR     \1
                              ENDIF
                      
9896                                  CALL    scanNextStmtFromY
9896                  9
9898                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9896  BD9C74                                  JSR     \1
                              ENDIF
9899                                  JUMP    continue
9899  7E9362                                  JMP     \1
989C                  L96FB
                      ;;              LDU #$03
                      ;;              LDA #$00
                      ;;              STA (ZP_INT_WA),Y
989C  9E2C                            LDX     ZP_INT_WA + 2           ; get var pointer
989E  6F02                            CLR     2,X                     ; store 0 in top byte of next var pointer
98A0  201D                            BRA     L971F
98A2                  cmdLOCAL
98A2  118C01FB                        CMPS    #MACH_STACK_TOP - 5             ; Check if stack is "empty"
98A6  2421                            BHS     brkNotLOCAL
98A8                                  CALL    findVarOrAllocEmpty
98A8                  9
98AA                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98A8  BD9A31                                  JSR     \1
                              ENDIF
98AB  2719                            BEQ     L972F
98AD                                  CALL    localVarAtIntA
98AD                  9
98AF                  __XBSR                  SET 9B+2
1800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98AD  BDB19F                                  JSR     \1
                              ENDIF
98B0  0D2A                            TST     ZP_INT_WA
98B2  2BE8                            BMI     L96FB
98B4                                  CALL    pushVarPtrAndType
98B4                  9
98B6                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98B4  BDBB68                                  JSR     \1
                              ENDIF
98B7                                  CALL    varFALSE
98B7                  9
98B9                  __XBSR                  SET 9B+2
1300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98B7  BDAC1D                                  JSR     \1
                              ENDIF
98BA  9727                            STA     ZP_VARTYPE
98BC                                  CALL    storeEvaledExpressioninStackedVarPTr
98BC                  9
98BE                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98BC  BDB33B                                  JSR     \1
                              ENDIF
98BF  6C64            L971F           INC     4, S                    ; DB inc SP + 6
                      ;;              LDU     ZP_TXTOFF2
                      ;;              STU     ZP_TXTOFF
98C1                                  CALL    skipSpacesCheckCommaAtYStepBack
98C1                  9
98C3                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98C1  BD90CE                                  JSR     \1
                              ENDIF
98C4  27DC                            BEQ     cmdLOCAL                
98C6                  L972F           JUMP    scanNextContinue
98C6  7E935F                                  JMP     \1
98C9                  brkNotLOCAL                                             ; L9732
98C9                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
98C9  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
98CA  0C4E6F7420EA00                  FCB     $0C, "Not ", tknLOCAL, 0
98D1                  brkBadMode                                              ; L9739
98D1                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
98D1  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
98D2  19                              FCB     $19
98D3  42616420EB00                    FCB     "Bad ", tknMODE, 0
                      
                      
98D9                  cmdGCOL                                                 ; L9741
98D9                                  CALL    evalForceINT
98D9                  9
98DB                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98D9  BD95A1                                  JSR     \1
                              ENDIF
98DC  962D                            LDA     ZP_INT_WA + 3
98DE  3402                            PSHS    A
98E0                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
98E0                  9
98E2                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98E0  BD985D                                  JSR     \1
                              ENDIF
98E3                                  CALL    scanNextStmtFromY
98E3                  9
98E5                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98E3  BD9C74                                  JSR     \1
                              ENDIF
98E6  8612                            LDA     #$12
98E8  BDFFEE                          JSR     OSWRCH
98EB  3502                            PULS    A
98ED  2038                            BRA     L979B
98EF                  cmdCOLOUR
                      ;                       ;  COLOUR
98EF                                  CALL    evalForceINT
98EF                  9
98F1                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98EF  BD95A1                                  JSR     \1
                              ENDIF
98F2                                  CALL    scanNextStmtFromY
98F2                  9
98F4                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98F2  BD9C74                                  JSR     \1
                              ENDIF
98F5  8611                            LDA     #$11
98F7  202E                            BRA     L979B
98F9                  cmdMode                 ; L975F!
                      
98F9                                  CALL    evalForceINT
98F9                  9
98FB                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98F9  BD95A1                                  JSR     \1
                              ENDIF
98FC                                  CALL    scanNextStmtFromY
98FC                  9
98FE                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
98FC  BD9C74                                  JSR     \1
                              ENDIF
                              IF FLEX != 1                                            ; TODOFLEX - assuming that this either has no effect or we're on the TUBE?
98FF  BDBD18                          JSR     OSByte82
9902  3001                            LEAX    1,X
9904  261D                            BNE     L9797                                   ; machine high order address != $FFFF, skip memory clash check
9906  9E04                            LDX     ZP_BAS_SP
9908  9C06                            CMPX    ZP_HIMEM                                ; check if basic stack is at HIMEM
990A  26C5                            BNE     brkBadMode                              ; else "BAD MODE"
990C                                  LDX_B   ZP_INT_WA + 3                           ; mode # low byte as got by eval
990C  3406                    PSHS    D
990E  D62D                    LDB     \1
9910  8600                    LDA     #0      ;DB: changed as CLRA resets carry!
9912  1F01                    TFR     D,X
9914  3506                    PULS    D
9916  8685                            LDA     #$85
9918  BDFFF4                          JSR     OSBYTE                                  ; get mode HIMEM address in X
991B  9C02                            CMPX    ZP_VARTOP                               ; if below VARTOP
991D  25B2                            BLO     brkBadMode                              ; "BAD MODE"
991F  9F06                            STX     ZP_HIMEM
9921  9F04                            STX     ZP_BAS_SP
9923                  L9797
                              ENDIF
9923  0F1E                            CLR     ZP_PRLINCOUNT
9925  8616                            LDA     #$16
9927                  L979B
9927  BDFFEE                          JSR     OSWRCH
992A  962D                            LDA     ZP_INT_WA + 3           ; not - got least sig byte
992C  204E                            BRA     OSWRCH_then_continue
                      
992E                  cmdMOVE                 ; L97A2!
992E  8604                            LDA     #$04
9930  2002                            BRA     doMOVE_DRAW
                      
9932                  cmdDRAW                 ; L97A6!
9932  8605                            LDA     #$05
9934                  doMOVE_DRAW                                             ; fpFPAeq_sqr_FPA
9934  3402                            PSHS    A
9936                                  CALL    evalExpressionMAIN
9936                  9
9938                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9936  BD9DC1                                  JSR     \1
                              ENDIF
9939                                  CALL    checkTypeInZP_VARTYPEConvert2INT
9939                  9
993B                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9939  BD986D                                  JSR     \1
                              ENDIF
993C  200A                            BRA     doPLOT2
                      
993E                  cmdPLOT
993E                                  CALL    evalForceINT
993E                  9
9940                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
993E  BD95A1                                  JSR     \1
                              ENDIF
9941  962D                            LDA     ZP_INT_WA + 3
9943  3402                            PSHS    A                               ; push plot code
9945                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
9945                  9
9947                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0016                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9945  BD985D                                  JSR     \1
                              ENDIF
9948                  doPLOT2                                                 ; L97BA
9948                                  CALL    stackINT_WAasINT
9948                  9
994A                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9948  BDBB5A                                  JSR     \1
                              ENDIF
994B                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
994B                  9
994D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
994B  BD985D                                  JSR     \1
                              ENDIF
994E                                  CALL    scanNextStmtFromY
994E                  9
9950                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0024                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
994E  BD9C74                                  JSR     \1
                              ENDIF
9951  8619                            LDA     #$19
9953  BDFFEE                          JSR     OSWRCH
9956  3502                            PULS    A
9958  BDFFEE                          JSR     OSWRCH
995B                                  CALL    popIntAtZP_GEN_PTRNew
995B                  9
995D                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
009F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
995B  BDBBFC                                  JSR     \1
                              ENDIF
995E  963A                            LDA     ZP_GEN_PTR + 3
9960  BDFFEE                          JSR     OSWRCH
9963  9639                            LDA     ZP_GEN_PTR + 2
9965  BDFFEE                          JSR     OSWRCH
9968                                  CALL    doVDUChar_fromWA3
9968                  9
996A                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9968  8D64                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
996A  962C                            LDA     ZP_INT_WA + 2
996C  200E                            BRA     OSWRCH_then_continue
                      
                      ;                       ;  CLG - Clear graphics window
                      ;                       ;  ---------------------------
996E                  cmdCLG                                                  ; L97E0!
996E                                  CALL    scanNextStmtFromY               ;  Check end of statement
996E                  9
9970                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
996E  BD9C74                                  JSR     \1
                              ENDIF
9971  8610                            LDA     #$10
9973  2007                            BRA     OSWRCH_then_continue            ;  Jump to do VDU 16
                      
                      ;                       ;  CLS - Clear text window
                      ;                       ;  -----------------------
9975                  cmdCLS                  ; L97E7!
9975                                  CALL    scanNextStmtFromY               ;  Check end of statement
9975                  9
9977                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9975  BD9C74                                  JSR     \1
                              ENDIF
9978  0F1E                            CLR     ZP_PRLINCOUNT
997A  860C                            LDA     #$0C                            ;  Clear COUNT, do VDU 12
997C                  OSWRCH_then_continue                                    ; L97EE
997C  BDFFEE                          JSR OSWRCH                              ;Send to VDU
997F                  L97F1           JUMP continue                           ;Return to execution loop
997F  7E9362                                  JMP     \1
9982                  cmdREPORT
9982                                  CALL    scanNextStmtFromY
9982                  9
9984                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9982  BD9C74                                  JSR     \1
                              ENDIF
9985                                  CALL    PrintCRclearPRLINCOUNT
9985                  9
9987                  __XBSR                  SET 9B+2
2000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9985  BDBA3E                                  JSR     \1
                              ENDIF
9988  9EFD                            LDX     ZP_MOS_ERROR_PTR_QRY
998A  3001                            LEAX    1,X                             ; skip error number
                      
998C                  cmdREPORTlp                                             ;L97FC:
998C  A680                            LDA     ,X+
998E  1027F9D0                        LBEQ    continue
9992                                  CALL    doListPrintTokenA
9992                  9
9994                  __XBSR                  SET 9B+2
2200                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9992  BDBC21                                  JSR     \1
                              ENDIF
9995  20F5                            BRA     cmdREPORTlp
9997                  doVDUChar_fromWA32                              ;L9808:
9997  962C                            LDA ZP_INT_WA + 2
9999  BDFFEE                          JSR OSWRCH
999C                  cmdVDU                                         ; L980D!       ;  VDU
999C                                  CALL    skipSpacesY
999C                  9
999E                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
999C  BD928C                                  JSR     \1
                              ENDIF
999F                  1                                               ;L9810:
999F  813A                            CMPA    #':'
99A1  2728                            BEQ     skVDUend
99A3  810D                            CMPA    #$0D
99A5  2724                            BEQ     skVDUend
99A7  818B                            CMPA    #tknELSE
99A9  2720                            BEQ     skVDUend
99AB  335F                            LEAU    -1,U
99AD                                  CALL    evalForceINT
99AD                  9
99AF                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
99AD  BD95A1                                  JSR     \1
                              ENDIF
99B0                                  CALL    doVDUChar_fromWA3
99B0                  9
99B2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
99B0  8D1C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
99B2                                  CALL    skipSpacesCheckCommaAtY
99B2                  9
99B4                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0014                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
99B2  BD90C8                                  JSR     \1
                              ENDIF
99B5  27E5                            BEQ     cmdVDU
99B7  813B                            CMPA    #';'
99B9  27DC                            BEQ     doVDUChar_fromWA32
99BB  817C                            CMPA    #'|'
99BD  26E0                            BNE     1B
99BF  8600                            LDA     #$00
99C1  C609                            LDB     #$09
99C3                  2                                       ;L9835:
99C3  BDFFEE                          JSR     OSWRCH
99C6  5A                              DECB
99C7  26FA                            BNE     2B
99C9  20D1                            BRA     cmdVDU
99CB                  skVDUend                                                ;L983D
99CB                                  JUMP    decYGoScanNextContinue
99CB  7E935D                                  JMP     \1
99CE                  doVDUChar_fromWA3                                       ;L9840:
99CE  962D                            LDA     ZP_INT_WA + 3
99D0  7EFFEE                          JMP     OSWRCH
                      
                      
99D3  3440            allocFNPROC     PSHS    U
99D5  DE39                            LDU     ZP_GEN_PTR+2
99D7  A641                            LDA     1,U                             ; get token
                      
99D9  C6F6                            LDB     #BASWKSP_DYNVAR_off_PROC        ; set A to offset of var list in page 4
99DB  81F2                            CMPA    #tknPROC
99DD  270B                            BEQ     __allocVARint
99DF  C6F8                            LDB     #BASWKSP_DYNVAR_off_FN
99E1  2007                            BRA     __allocVARint
                      
                                      ; Allocate a dynamic variable 
                                      ; on entry ZP_GEN_PTR => variable name -1
                                      ; ZP_NAMELENORVT contains the length of the variable name
                      
99E3  3440            allocVAR        PSHS    U
99E5  DE39                            LDU     ZP_GEN_PTR+2
99E7  E641                            LDB     1,U
99E9  58                              ASLB                            ; get variable offset in page 4
99EA                  __allocVARint
99EA  8604                            LDA     #BASWKSP_INTVAR / 256
99EC  1F03                            TFR     D,U                             ; Y points at DYN var head
99EE                  __allocVARint_lp1
99EE  DF3D                            STU     ZP_INT_WA_C                     ; look for tail of the current list
99F0  6DC4                            TST     0,U                             ; if high byte of next addr = 0 then at end of list
99F2  2704                            BEQ     _allocVARint_sk1
99F4  EEC4                            LDU     ,U                              ; jump to next pointer
99F6  20F6                            BRA     __allocVARint_lp1@lp1
99F8                  _allocVARint_sk1
99F8  9E02                            LDX     ZP_VARTOP
99FA  AFC4                            STX     ,U                              ; store pointer to next var block in old tail ptr
99FC  6F80                            CLR     ,X+
99FE  6F80                            CLR     ,X+
9A00  C602                            LDB     #2                              
9A02  D137                            CMPB    ZP_NAMELENORVT                  ; equal to 2, don't store name
9A04  270D                            BEQ     _allocVARint_sk2
9A06  DE39                            LDU     ZP_GEN_PTR+2
9A08  3342                            LEAU    2,U
9A0A                  _allocVARint_lp2
9A0A  A6C0                            LDA     ,U+
9A0C  A780                            STA     ,X+
9A0E  5C                              INCB
9A0F  D137                            CMPB    ZP_NAMELENORVT
9A11  26F7                            BNE     _allocVARint_lp2
9A13                  _allocVARint_sk2
9A13  35C0                            PULS    U,PC
                      ;               
                      ;               
                      ;                       ;  Allocate space for variable at top of heap
                      ;                       ;  ------------------------------------------
                                              ; On entry B points after end of name (at 0 marker to be stored)
                                              ;          A contains the number of bytes to store for end of name byte and variable
                                              ; Trashes X  
9A15                  AllocVarSpaceOnHeap                                     ; L9883
9A15  9E02                            LDX     ZP_VARTOP
9A17  3A                              ABX
9A18  6F80            allheap_lp1     CLR     ,X+                             ;  (ZP_VARTOP)=>top of heap
9A1A  4A                              DECA
9A1B  26FB                            BNE     allheap_lp1                     ;  Put terminating zero and empty parameter block
9A1D                  CheckVarFitsX                                           ;L988B API change (Expected to add Y to ZP_VARTOP)
9A1D  9C04                            CMPX    ZP_BAS_SP
9A1F  2509                            BLO     allheap_sk_ok
                                                                              ;L989F:
9A21  9E3D                            LDX     ZP_INT_WA_C                     ; Remove this variable from heap
9A23  6F84                            CLR     0,X
9A25  6F01                            CLR     1,X                             ; by removing link from previous variable
9A27                                  JUMP    brkNoRoom                       ; Jump to No room error
9A27  7E93FB                                  JMP     \1
9A2A                  allheap_sk_ok                                           ;L98A8:
9A2A  9F02                            STX     ZP_VARTOP                       ; Update VARTOP
9A2C                  anRTS10
9A2C  39                              RTS
                      ;
                      ;
                      
9A2D                  L98AB           CALL    AllocVarSpaceOnHeap             
9A2D                  9
9A2F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A2D  8DE6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A2F  DE19                            LDU     ZP_TXTPTR2
9A31                  findVarOrAllocEmpty
9A31  DF19                            STU     ZP_TXTPTR2
9A33                                  CALL    findVarAtYSkipSpaces
9A33                  9
9A35                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A33  8D48                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A35  261F                            BNE     anRTS6
9A37  251D                            BCS     anRTS6
9A39  DE19                            LDU     ZP_TXTPTR2
9A3B                                  CALL    allocVAR
9A3B                  9
9A3D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9A3B  8DA6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9A3D  8605                            LDA     #$05
9A3F  912A                            CMPA    ZP_INT_WA + 0
9A41  26EA                            BNE     L98AB
9A43  4C                              INCA
9A44  20E7                            BRA     L98AB
                      
9A46                  findVARTreatAsMemoryAccess                                      ;L98C1
9A46  8121                            CMPA  #'!'
9A48  270D                            BEQ   memacc32                          ; Jump to do !<addr>
9A4A  8124                            CMPA  #'$'
9A4C  2715                            BEQ   memaccStr                         ; Jump to do $<addr>
9A4E  883F                            EORA  #'?'
9A50  2707                            BEQ   memacc8                           ; Jump to do ?<addr>
9A52  8600                            LDA   #$00
9A54                                  SEC                             ; Return EQ/CS for invalid name
9A54  1A01                    ORCC    #CC_C
9A56  39              anRTS6          RTS
                      
9A57                  memacc32                                                ;L98D1:
9A57  8602                            LDA     #VAR_TYPE_INT_LE                ; Little-endian integer
9A59                  memacc8                                                 ;L98D3:
9A59  3402                            PSHS    A                               ; 0 for byte on entry unless fallen through from memacc32
9A5B                                  CALL    evalLevel1checkTypeStoreAsINT
9A5B                  9
9A5D                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A5B  BD9865                                  JSR     \1
                              ENDIF
9A5E  DF19                            STU     ZP_TXTPTR2
9A60                                  JUMP    popAasVarType
9A60  7E9B24                                  JMP     \1
9A63                  memaccStr                                               ; L98DC
9A63                                  CALL    evalLevel1checkTypeStoreAsINT
9A63                  9
9A65                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9A63  BD9865                                  JSR     \1
                              ENDIF
9A66  962C                            LDA     ZP_INT_WA + 2                   ; if pointer at zero page fail with RANGE TODO: Is this valid on 6809?
9A68  2709                            BEQ     brkRange
9A6A  DF19                            STU     ZP_TXTPTR2
9A6C  8680                            LDA     #VAR_TYPE_STRING_STAT
9A6E  972A                            STA     ZP_INT_WA + 0
9A70                                  SEC
9A70  1A01                    ORCC    #CC_C
9A72  39                              RTS
9A73                  brkRange                                                ;L98EB:
9A73                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9A73  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9A74  08242072616E676500                 FCB  $08, "$ range", 0
                      
                      ;                       ;  Find Variable
                      ;                       ;  =============
                      ;                       ;  On entry, PTRA (ZP_TXTPTR),ZP_TXTOFF=>variable name
                      ;                       ;            'variable name' can be:
                      ;                       ;            '?value' '!value' '$value' 'variable' 'variable?value' 'variable!value'
                      ;                       ;  On exit,  ZP_INT_WA=>data
                      ;                       ;            ZP_INT_WA + 2  = type
                      ;                       ;  EQ   CC      not found
                                              ;  EQ   CS      invalid name
                                              ;  NE   CS      found, dynamic string
                                              ;  NE   CC      found other
                      ;findVarAtPTRA
                      ;               LDU     ZP_TXTPTR
                      ;               STU     ZP_TXTPTR2
9A7D                  findVarLp1
9A7D                  findVarAtYSkipSpaces                                    ; L9901;
9A7D  A6C0                            LDA     ,U+
9A7F  8120                            CMPA    #' '
9A81  27FA                            BEQ     findVarLp1                      ; Skip spaces
9A83                  findVarAtYMinus1                                                ; L9909
                      ;               LEAX    -1,Y                            ; TODO - tidy this up!
                      ;               STX     ZP_TXTPTR2                      ; save pointer needed to try again in skfindVarDynamic
9A83  8140                            CMPA    #'@'
9A85  25BF                            BLO     findVARTreatAsMemoryAccess      ; <'@', not a variable, check for indirection
9A87  815B                            CMPA    #'['
9A89  241A                            BHS     skfindVarDynamic                ; >'Z', look for dynamic variable
9A8B  48                              ASLA
9A8C  48                              ASLA
9A8D  972D                            STA     ZP_INT_WA + 3                   ; Multiply by 4 in case <uc>% variable
9A8F  A6C4                            LDA     0,U                             ; Get next character
9A91  8125                            CMPA    #'%'
9A93  2610                            BNE     skfindVarDynamic                ; Not <uc>%, jump to look for dynamic variable
9A95  8604                            LDA     #BASWKSP_INTVAR / 256
9A97  972C                            STA     ZP_INT_WA + 2                   ; High byte of static variable address
                      ;;              LDA     #VAR_TYPE_INT                   ; both == 4
9A99  972A                            STA     ZP_INT_WA + 0                   ; Type=Integer
9A9B  3341                            LEAU    1,U
9A9D  A6C4                            LDA     ,U                              ; Get next character
9A9F  8128                            CMPA    #'('                            ; check to see if it was an array access after all  
9AA1  2655                            BNE     findVarCheckForIndirectAfter
9AA3  335F                            LEAU    -1,U
                      ;                       ;  Not <uc>%(, so jump to check <uc>%!n and <uc>%?n
                      ;                       ;  Look for a dynamic variable
                      ;                       ;  ---------------------------
9AA5                  skfindVarDynamic
9AA5  C605                            LDB     #$05
9AA7  D72A                            STB     ZP_INT_WA + 0
                      ;               LDU     ZP_TXTPTR2
9AA9  305E                            LEAX    -2,U
9AAB  9F39                            STX     ZP_GEN_PTR+2                    ;  $37/8=>1 byte BEFORE start of variable name
9AAD  C601                            LDB     #1                              ; variable name length
                      ;               LEAU    1,Y
9AAF  A65F                            LDA     -1,U                            ; re-get first char
9AB1  8141                            CMPA    #'A'
9AB3  2419                            BHS     findVarDyn_sk2
9AB5  8130                            CMPA    #'0'
9AB7  2521                            BLO     findVarDyn_skEnd
9AB9  813A                            CMPA    #'9'+1
9ABB  241D                            BHS     findVarDyn_skEnd
9ABD                  findVarDyn_lp                                           ; L9959
9ABD  5C                              INCB
9ABE  A6C0                            LDA     ,U+
9AC0  8141                            CMPA    #'A'
9AC2  240A                            BHS     findVarDyn_sk2
9AC4  8130                            CMPA    #'0'
9AC6  2512                            BLO     findVarDyn_skEnd
9AC8  813A                            CMPA    #'9'+1
9ACA  25F1                            BLO     findVarDyn_lp
9ACC  200C                            BRA     findVarDyn_skEnd
9ACE                  findVarDyn_sk2                                          ; L996B
9ACE  815B                            CMPA    #'Z'+1
9AD0  25EB                            BLO     findVarDyn_lp
9AD2  815F                            CMPA    #'_'
9AD4  2504                            BLO     findVarDyn_skEnd
9AD6  817B                            CMPA    #'z'+1
9AD8  25E3                            BLO     findVarDyn_lp
9ADA                  findVarDyn_skEnd                                        ; L9977
9ADA  C101                            CMPB    #$01                            ; B = len + 1
9ADC  2727                            BEQ     findVarDyn_skInvalid            ; Checked length=1, invalid name, exit
9ADE  8124                            CMPA    #'$'
9AE0  274F                            BEQ     findVarDyn_gotDollar            ; String variable
9AE2  8125                            CMPA    #'%'
9AE4  2605                            BNE     findVarDyn_skNotInt             ; Not integer variable
9AE6  0A2A                            DEC     ZP_INT_WA + 0                   ; Set type=4 - Integer
9AE8  5C                              INCB
9AE9  A6C0                            LDA     ,U+                             ; Get next character
9AEB                  findVarDyn_skNotInt                                     ; L9989
9AEB  8128                            CMPA    #'('
9AED  273E                            BEQ     findVarDyn_skArray              ; Jump if array
9AEF  335F                            LEAU    -1,U
9AF1                                  CALL    findVarDynLL_NewAPI
9AF1                  9
9AF3                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9AF1  BD8499                                  JSR     \1
                              ENDIF
9AF4  2713                            BEQ     findVarDyn_skNotFound           ; Search for variable, exit if not found
9AF6                  findVarDyn_skGotArrayTryInd                             ; L9994
9AF6  A6C4                            LDA     ,U                              ; Get next character
9AF8                  findVarCheckForIndirectAfter                            ; L9998
9AF8  8121                            CMPA    #'!'
9AFA  270F                            BEQ     findVarIndWord                  ; Jump for <var>!...
9AFC  883F                            EORA    #'?'
9AFE  270D                            BEQ     findVarIndByte                  ; Jump for <var>?...
9B00                                  CLC
9B00  1CFE                    ANDCC   #~CC_C
9B02  DF19                            STU     ZP_TXTPTR2                      ; Update PTRB offset
                                      ;;LDA   #$FF
9B04  39                              RTS                                     ; NE/CC = variable found
9B05                  findVarDyn_skInvalid                                    ; L99A6
9B05  4F                              CLRA
9B06                                  SEC
9B06  1A01                    ORCC    #CC_C
9B08  39                              RTS                                     ; EQ/CS = invalid variable name
9B09                  findVarDyn_skNotFound
9B09  4F                              CLRA
9B0A  39                              RTS                                     ;  EQ/CC = valid name, not found
                      
                      ;               <var>!...
9B0B                  findVarIndWord                                          ; L99AE:
9B0B  8602                            LDA     #VAR_TYPE_INT_LE
                                      ;  <var>?...
9B0D                  findVarIndByte                                          ;L99B0:
9B0D  3402                            PSHS    A
9B0F                                  CALL    GetVarValNewAPI
9B0F                  9
9B11                  __XBSR                  SET 9B+2
1600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B0F  BDB1BF                                  JSR     \1
                              ENDIF
9B12                                  CALL    checkTypeInAConvert2INT
9B12                  9
9B14                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B12  BD986F                                  JSR     \1
                              ENDIF
9B15  9E2C                            LDX     ZP_INT_WA + 2
9B17  3410                            PSHS    X
9B19  3341                            LEAU    1,U
9B1B                                  CALL    evalLevel1checkTypeStoreAsINT
9B1B                  9
9B1D                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B1B  BD9865                                  JSR     \1
                              ENDIF
9B1E  3506                            PULS    D
9B20  D32C                            ADDD    ZP_INT_WA + 2
9B22  DD2C                            STD     ZP_INT_WA + 2                           ; add stacked and eval'd addresses
9B24                  popAasVarType                                                 ;L99CE
9B24  3502                            PULS    A
9B26  972A                            STA     ZP_INT_WA + 0                           ;  Store returned type
9B28                                  CLC
9B28  1CFE                    ANDCC   #~CC_C
9B2A  86FF                            LDA     #$FF
9B2C  39                              RTS                                             NE/CC = variable found
                      
                      
                      ;                       ;  array(
                      ;                       ;  ------
9B2D                  findVarDyn_skArray
9B2D                                  CALL findVarDyn_Subscripts                      ;  get array element address
9B2D                  9
9B2F                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0027                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9B2D  8D27                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9B2F  20C5                            BRA findVarDyn_skGotArrayTryInd                 ;  Check for array()!... and array()?...
9B31                  findVarDyn_gotDollar
9B31  0A2A                            DEC     ZP_INT_WA + 0   ; set type to int? and return that 
9B33  5C                              INCB
9B34  A6C0                            LDA     ,U+
9B36  8128                            CMPA    #'('
9B38  2710                            BEQ     findVarDyn_skArrayStr           ; got an array
9B3A  335F                            LEAU    -1,U
9B3C                                  CALL    findVarDynLL_NewAPI
9B3C                  9
9B3E                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B3C  BD8499                                  JSR     \1
                              ENDIF
9B3F  27C8                            BEQ     findVarDyn_skNotFound
9B41                  findVarDyn_retDynStr                                    ; L99EB
9B41  DF19                            STU     ZP_TXTPTR2
9B43  8681                            LDA     #VAR_TYPE_STRING_DYN
9B45  972A                            STA     ZP_INT_WA + 0
9B47                                  SEC
9B47  1A01                    ORCC    #CC_C
9B49  39                              RTS
9B4A                  findVarDyn_skArrayStr                                   ; L99F1
9B4A                                  CALL    findVarDyn_Subscripts
9B4A                  9
9B4C                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9B4A  8D0A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9B4C  20F3                            BRA     findVarDyn_retDynStr
9B4E                  brkArray                                                ; L99F6
9B4E                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9B4E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9B4F  0E417272617900                  FCB     $0E, "Array", 0
                      
                      
                                              ;  Process array dimensions
                                              ;  ------------------------
                                              ;  new API
                                              ;  On entry,    B=1 + length of name
                                              ;               [ZP_GEN_PTR+2]+1=>first character of name
                                              ;               [ZP_INT_WA + 0]=type
                                              ;  On exit,     ZP_INT_WA+2 and X => data block for cell
                                              ;  ------------------------
                                              ;  old API
                                              ;  On entry,    [ZP_GEN_PTR],Y=>'('
                                              ;               ZP_INT_WA + 2=type
                                              ;  On exit,     ZP_INT_WA =>data block
                                              ;
                                              ;  DIM r(100)                           r(37)=val           ->   r(37)
                                              ;  DIM r(100,200)                       r(37,50)=val        ->   r(37*100+50)
                                              ;  DIM r(100,200,300)                   r(37,50,25)=val     ->  r((37*100+50)*200+25)
                                              ;  DIM r(100,200,300,400)               r(37,50,25,17)=val  -> r(((37*100+50)*200+25)*300+17)
                                              ;
9B56                  findVarDyn_Subscripts                                   ; L99FE
9B56  5C                              INCB
                      ;               INY                                     ; Step past '('
9B57                                  CALL findVarDynLL_NewAPI
9B57                  9
9B59                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0040                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B57  BD8499                                  JSR     \1
                              ENDIF
9B5A  27F2                            BEQ brkArray                            ; If not found, generate error
9B5C  D62A                            LDB     ZP_INT_WA + 0
                      
9B5E  A680                            LDA     ,X+                             ; Get offset to data (number of dimensions)*2+1
9B60  44                              LSRA
9B61  4A                              DECA
9B62  3416                            PSHS    D,X                             ; push type and pointer to array data ()
9B64  6FE2                            CLR     ,-S
9B66  6FE2                            CLR     ,-S
                      
                      
                                      ; stack now contains
                      
                                      ;       +4              pointer to DIM block
                                      ;       +3              var type (size 4/5)
                                      ;       +2              data offset (counter) i.e. n (not 2*n+1)
                                      ;       +0              0 (accumulator for previous subscript calc)
                      
9B68  6D62                            TST     2,S
9B6A  273A                            BEQ     findVarDyn_Subscripts_one
9B6C                  findVarDyn_Subscripts_lp
9B6C  2733                            BEQ     findVarDyn_Subscripts_last
9B6E                                  CALL    evalAtYcheckTypeInAConvert2INT  ;  Evaluate integer expression
9B6E                  9
9B70                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B6E  BD9860                                  JSR     \1
                              ENDIF
9B71  E6C0                            LDB     ,U+
9B73  C12C                            CMPB    #','
9B75  26D7                            BNE     brkArray                        ;  If not ',', error as must be some more dimensions
9B77                  findVarDynCalc_one_subs
9B77  AE64                            LDX     4,S
9B79                                  CALL    findVarDyn_SubsCheck
9B79                  9
9B7B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9B79  8D3A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9B7B  EC81                            LDD     ,X++                            ; get current DIM subscript
9B7D                                  CALL    cmdDIM_mul_D_by_S               ; multiply accumulator by row size
9B7D                  9
9B7F                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B7D  BD96DF                                  JSR     \1
                              ENDIF
9B80  D32C                            ADDD    ZP_INT_WA + 2                   ; add current subscript
9B82  2543                            BCS     brkSubscript
9B84  2B41                            BMI     brkSubscript
9B86  EDE4                            STD     ,S
9B88  AF64                            STX     4,S
9B8A  6A62                            DEC     2,S                             ; decrement subscripts counter
9B8C  2ADE                            BPL     findVarDyn_Subscripts_lp
9B8E                  findVarDyn_SubsDone
                                      ; we're done
9B8E  E663                            LDB     3,S                             ; cell data size
9B90  D72A                            STB     ZP_INT_WA + 0                   ; restore var type
9B92  4F                              CLRA
9B93                                  CALL    cmdDIM_mul_D_by_S               ; multiply acc by size of cells for byte offset
9B93                  9
9B95                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9B93  BD96DF                                  JSR     \1
                              ENDIF
9B96  3410                            PSHS    X                               ; use X as base of cells
9B98  E3E4                            ADDD    ,S                              ; add cell byte offset
9B9A  3268                            LEAS    8,S                             ; unstack workspace
9B9C  DD2C                            STD     ZP_INT_WA + 2
9B9E  9E2C                            LDX     ZP_INT_WA + 2
9BA0  39                              RTS
                      
                      
9BA1                  findVarDyn_Subscripts_last
9BA1                                  CALL    evalL1BracketAlreadyOpenConvert2INT     ; final subscript
9BA1                  9
9BA3                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BA1  BD9858                                  JSR     \1
                              ENDIF
9BA4  20D1                            BRA     findVarDynCalc_one_subs
                      
9BA6                  findVarDyn_Subscripts_one
9BA6                                  CALL    evalL1BracketAlreadyOpenConvert2INT     ; final subscript
9BA6                  9
9BA8                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BA6  BD9858                                  JSR     \1
                              ENDIF
9BA9  AE64                            LDX     4,S
9BAB                                  CALL    findVarDyn_SubsCheck
9BAB                  9
9BAD                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9BAB  8D08                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9BAD  DC2C                            LDD     ZP_INT_WA + 2
9BAF  EDE4                            STD     ,S
9BB1  3002                            LEAX    2,X
9BB3  20D9                            BRA     findVarDyn_SubsDone
                      
9BB5                  findVarDyn_SubsCheck
9BB5  962C                            LDA     ZP_INT_WA + 2
9BB7  84C0                            ANDA    #$C0
9BB9  9A2A                            ORA     ZP_INT_WA + 0
9BBB  9A2B                            ORA     ZP_INT_WA + 1
9BBD  2608                            BNE     brkSubscript
9BBF  DC2C                            LDD     ZP_INT_WA + 2
9BC1  10A384                          CMPD    ,X                              ; check against subscript in var block
9BC4  2401                            BHS     brkSubscript
9BC6  39                              RTS
9BC7                  brkSubscript
9BC7                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9BC7  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9BC8  0F53756273637269707400                 FCB     $0F, "Subscript", 0
                      
9BD3                  fnProcScanYplus1varname
9BD3  C601                            LDB     #$01
                                      * API:
                                      *       On Entry
                                      *               Y points at 1 before the string to be scanned
                                      *               B points at first char after ZP_GEN_PTR to be checked
                                      *       On Exit
                                      *               B index of char after last matching
                                      *               A contains unmatched char (may be "%","$","(")
                                      *               X points at char after last matching
                                      ; scans chars that are allowed in variable names
9BD5                  fnProcScanYplusBvarname
9BD5  4F                              CLRA
9BD6  30CB                            LEAX    D,U
9BD8                  1               
9BD8  A680                            LDA     ,X+
9BDA  8130                            CMPA    #'0'
9BDC  2517                            BLO     L9B16
9BDE  8140                            CMPA    #'@'
9BE0  240B                            BHS     L9B0E
9BE2  813A                            CMPA    #'9'+1
9BE4  240F                            BHS     L9B16
9BE6  C101                            CMPB    #1      ; don't allow numbers as char 1 (note when called with a FN/PROC B is 2 on entry!)
9BE8  270B                            BEQ     L9B16
9BEA                  L9B0A
9BEA  5C                              INCB
9BEB  26EB                            BNE     1B
9BED                  L9B0E
9BED  815F                            CMPA    #'_'
9BEF  2405                            BHS     L9B17
9BF1  815A                            CMPA    #'Z'
9BF3  23F5                            BLS     L9B0A
9BF5                  L9B16
9BF5  39                              RTS
9BF6                  L9B17
9BF6  817A                            CMPA    #'z'
9BF8  23F0                            BLS     L9B0A
9BFA  39                              RTS
                      ;               
                      ;               
                                      ; API changed used to scan from ZP_TXTPTR now scan from Y
9BFB                  skipSpacesDecodeLineNumberNewAPI
                                      ;               LDU     ZP_TXTPTR
9BFB                                  CALL    skipSpacesY
9BFB                  9
9BFD                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9BFB  BD928C                                  JSR     \1
                              ENDIF
9BFE  818D                            CMPA    #tknLineNo
9C00  2706                            BEQ     decodeLineNumber
9C02  335F                            LEAU    -1,U
9C04  DF0B                            STU     ZP_TXTPTR
9C06  2019                            BRA     __rtsCLC                                ;  Not line number, return CC
9C08                  decodeLineNumber
9C08  A6C0                            LDA     ,U+
9C0A  48                              ASLA
9C0B  48                              ASLA
9C0C  1F89                            TFR     A,B
9C0E  84C0                            ANDA    #$C0
9C10  A8C0                            EORA    ,U+
9C12  972D                            STA     ZP_INT_WA + 3
9C14  1F98                            TFR     B,A
9C16  48                              ASLA
9C17  48                              ASLA
9C18  A8C0                            EORA    ,U+
9C1A  972C                            STA     ZP_INT_WA + 2
9C1C  DF0B                            STU     ZP_TXTPTR
9C1E                                  SEC
9C1E  1A01                    ORCC    #CC_C
9C20  39                              RTS
                      ;                       ;  Line number, return CS
9C21                  __rtsCLC
9C21                                  CLC
9C21  1CFE                    ANDCC   #~CC_C
9C23  39                              RTS
                      ;                       ;  Expression Evaluator
                      ;                       ;  ====================
                      ;                       ;  ExpectEquals - evalute =<expr>
                      ;                       ;  ------------------------------
9C24                  styZP_TXTPTR2_skipSpacesExectEqEvalExp
9C24  DF19                            STU     ZP_TXTPTR2
                      ;;              LDA ZP_TXTPTR
                      ;;              STA ZP_TXTPTR2
                      ;;              LDA ZP_TXTPTR + 1
                      ;;              STA ZP_TXTPTR2 + 1
                      ;;              LDA ZP_TXTOFF
                      ;;              STA ZP_TXTOFF2
9C26                  skipSpacesExpectEqEvalExp                               ; L9B52
9C26                                  CALL    skipSpacesPTRB                  ;  Skip spaces
9C26                  9
9C28                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C26  BD928A                                  JSR     \1
                              ENDIF
9C29  813D                            CMPA    #'='
9C2B  2731                            BEQ     evalAtYExpectColonElseCRThenRTS ;  '=' found, evaluate following expression
9C2D                  brkMistake
9C2D                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9C2D  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9C2E  04                              FCB  $04
9C2F  4D697374616B6500                 FCB  "Mistake", 0
9C37                  brkSyntax
9C37                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9C37  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9C38  10                              FCB  $10
9C39  53796E746178206572726F7200                 FCB  "Syntax error", 0
9C46                  brkNoPROC
9C46                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9C46  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9C47  0D                              FCB  $0D
9C48  4E6F20F200                      FCB  "No ", tknPROC, 0
9C4D                  errEscape
9C4D                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9C4D  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9C4E  11                              FCB  $11
9C4F  45736361706500                  FCB  "Escape", 0
                                      
                      ;               
                      ;               
9C56                  skipToEqualsOrBRKY
9C56                                  CALL    skipSpacesY
9C56                  9
9C58                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C56  BD928C                                  JSR     \1
                              ENDIF
9C59  813D                            CMPA    #'='
9C5B  26D0                            BNE     brkMistake
9C5D  39                              RTS
9C5E                  evalAtYExpectColonElseCRThenRTS                         ; L9B8E
9C5E                                  CALL    evalAtY
9C5E                  9
9C60                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C5E  BD9DC1                                  JSR     \1
                              ENDIF
9C61  2011                            BRA     scanNextStmtFromY
9C63                  LDUZP_TXTPTR2scanNextStmtFromY                          ; L9B96
9C63  DE19                            LDU     ZP_TXTPTR2                      ; restore Y from ZP_TXTPTR2 - eg after FN/PROCcall
9C65  200D                            BRA     scanNextStmtFromY
                      
                      ;               ;  ENDPROC
                      ;               ;  =======
9C67                  cmdENDPROC
9C67  118C01FB                        CMPS    #MACH_STACK_TOP - 5
9C6B  24D9                            BHS     brkNoPROC                       ; Stack too empty, not in a PROC
9C6D  B601FD                          LDA     MACH_STACK_TOP - 3              ; the PROC/FN token on the stack (below pushed Y)
9C70  81F2                            CMPA    #tknPROC
9C72  26D2                            BNE     brkNoPROC                       ; No PROC on the stack
                                                                              ; drop through to an RTS
                      ;scanNextStmt   LDU ZP_TXTPTR    -- obsolete?
9C74                  scanNextStmtFromY
9C74                                  CALL    skipSpacesYStepBack
9C74                  9
9C76                  __XBSR                  SET 9B+2
F600                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9C74  BD9295                                  JSR     \1
                              ENDIF
9C77                  scanNextExpectColonElseCR
9C77  813A                            CMPA    #':'
9C79  2708                            BEQ     1F                                      ;  colon, end of statement
9C7B  810D                            CMPA    #$0D
9C7D  2704                            BEQ     1F                                      ;  <cr>, end of statement
9C7F  818B                            CMPA    #tknELSE
9C81  26B4                            BNE     brkSyntax                               ;  Not correctly terminated, error
9C83                  1
9C83  DF0B            storeYasTXTPTR  STU     ZP_TXTPTR
9C85                  checkForESC     
9C85  6D9F0050                        TST     [ZP_ESCPTR]
9C89  2BC2                            BMI     errEscape                               ;  Escape set, give Escape error
9C8B  39              anRTS9          RTS
                      
                      ;
                      ;
9C8C                  scanNextStmtAndTrace                                            ; L9BCF
9C8C                                  CALL    scanNextStmtFromY
9C8C                  9
9C8E                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9C8C  8DE6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9C8E  A6C0                            LDA     ,U+
9C90  813A                            CMPA    #':'
9C92  27F7                            BEQ     anRTS9
9C94  1F30                            TFR     U,D
9C96  8100                            CMPA    #BAS_InBuf
9C98  1027F653                        LBEQ    immedPrompt
9C9C                  doTraceOrEndAtELSE                                              ; L9BDE
9C9C  ECC4                            LDD     ,U
9C9E  102BF64D                        LBMI    immedPrompt                             ; is end of program?
9CA2  0D20                            TST     ZP_TRACE                                ; got here it must be an 0d?
9CA4  2704                            BEQ     skNoTrace
9CA6  DD2C                            STD     ZP_INT_WA + 2                           ; store line # (big endian in ZP_INT_WA)
9CA8                                  CALL    doTRACE
9CA8                  9
9CAA                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9CA8  8D3B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9CAA                  skNoTrace                                                       ;L9BF2:
                                                                                      ;L9BF4: -- check API
9CAA  3343                            LEAU    3,U                                     ; skip to next token (after line number)
                                                                                      ;L9BFD: -- check API
9CAC                  L9C01rts
9CAC  39                              RTS
9CAD                  cmdIF                   ; L9C08
9CAD                                  CALL    evalExpressionMAIN
9CAD                  9
9CAF                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0012                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CAD  BD9DC1                                  JSR     \1
                              ENDIF
9CB0  1027F737                        LBEQ    brkTypeMismatch
9CB4  2A03                            BPL     skCmdIfNotReal
9CB6                                  CALL    fpReal2Int
9CB6                  9
9CB8                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CB6  BD9876                                  JSR     \1
                              ENDIF
9CB9                  skCmdIfNotReal                                          ; L9C12:
9CB9                                  CALL    IntWAZero
9CB9                  9
9CBB                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CB9  BDB9D6                                  JSR     \1
                              ENDIF
9CBC  2718                            BEQ     skCmdIFFALSE
9CBE  C18C                            CMPB    #tknTHEN
9CC0  2703                            BEQ     skCmdIfTHEN
9CC2                                  JUMP    skipSpacesAtYexecImmed
9CC2  7E936A                                  JMP     \1
9CC5                  skCmdIfTHEN                                             ; L9C27:
9CC5  3341                            LEAU    1,U                             ; skip THEN token
9CC7                  execTHENorELSEimpicitGOTO                               ; L9C29 
9CC7                                  CALL    skipSpacesDecodeLineNumberNewAPI; look for line number
9CC7                  9
9CC9                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CC7  BD9BFB                                  JSR     \1
                              ENDIF
9CCA  1024F69C                        LBCC    skipSpacesAtYexecImmed          ; if not found exec after THEN/ELSE
9CCE                                  CALL    findProgLineOrBRK
9CCE                  9
9CD0                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CCE  BDB814                                  JSR     \1
                              ENDIF
9CD1                                  CALL    checkForESC
9CD1                  9
9CD3                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9CD1  8DB2                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9CD3                                  JUMP    cmdGOTODecodedLineNumber
9CD3  7EB712                                  JMP     \1
9CD6                  skCmdIFFALSE                                            ; L9C37
                                                                              ; L9C39
9CD6  A6C0                            LDA     ,U+                             ; look for ELSE, if not found exec as next line
9CD8  818B                            CMPA    #tknELSE
9CDA  27EB                            BEQ     execTHENorELSEimpicitGOTO
9CDC  810D                            CMPA    #$0D
9CDE  26F6                            BNE     skCmdIFFALSE
9CE0  335F                            LEAU    -1,U
9CE2                                  JUMP    stepNextLineOrImmedPrompt
9CE2  7E9327                                  JMP     \1
9CE5                  doTRACE                                         ; L9C4B
                      
                                      ; line number is now in WA+2 - this needs changed
                      
9CE5  DC2C                            LDD     ZP_INT_WA + 2
9CE7  109321                          CMPD    ZP_MAXTRACLINE
9CEA  24C0                            BHS     L9C01rts
9CEC  865B                            LDA     #'['
9CEE                                  CALL    list_printANoEDIT
9CEE                  9
9CF0                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CEE  BDBC73                                  JSR     \1
                              ENDIF
9CF1                                  CALL    int16print_AnyLen
9CF1                  9
9CF3                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CF1  BDA0CC                                  JSR     \1
                              ENDIF
                      
9CF4  865D                            LDA     #']'
9CF6                                  CALL    list_printANoEDIT
9CF6                  9
9CF8                  __XBSR                  SET 9B+2
1F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9CF6  BDBC73                                  JSR     \1
                              ENDIF
9CF9                                  JUMP    list_print1Space
9CF9  7EBC6D                                  JMP     \1
                      
9CFC                  evalDoComparePopIntFromMachineStackConvertToRealAndCompare
9CFC  3516                            PULS    D,X             ; get back stacked int
9CFE  9F2A                            STX     ZP_INT_WA
9D00  DD2C                            STD     ZP_INT_WA + 2
9D02                                  CALL    fpStackWAtoStackReal            ; stack LHS real
9D02                  9
9D04                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0036                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D02  BDBB3A                                  JSR     \1
                              ENDIF
9D05                                  CALL    IntToReal                       ; convert INT_WA to real in FPA
9D05                  9
9D07                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D05  BD856A                                  JSR     \1
                              ENDIF
9D08                                  CALL    fpCopyFPAtoFPB                  ; copy it to FPB
9D08                  9
9D0A                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D08  BDA498                                  JSR     \1
                              ENDIF
9D0B                                  CALL    popFPFromStackToPTR1
9D0B                  9
9D0D                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0021                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D0B  BDBB2E                                  JSR     \1
                              ENDIF
9D0E                                  CALL    fpCopyPTR1toFPA         ; get back stacked LHS real
9D0E                  9
9D10                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D0E  BDA593                                  JSR     \1
                              ENDIF
9D11                                  CALL    evalDoCompareRealFPAwithFPB     ; compare
9D11                  9
9D13                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9D11  8D17                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9D13  3584                            PULS    B,PC                            ; get back stored token and finish
                      ;                       ;  <real> <compare> ...
                      ;                       ;  --------------------
                      
                                      ; API CHANGE - alter return CC to match behaviour of 6809
9D15                  evalDoCompareReal                             ;L9C82
9D15                                  CALL    fpStackWAtoStackReal
9D15                  9
9D17                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D15  BDBB3A                                  JSR     \1
                              ENDIF
9D18                                  CALL    evalLevel4
9D18                  9
9D1A                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D18  BD9EE8                                  JSR     \1
                              ENDIF
9D1B  3404                            PSHS    B                               ; save B (next char)
9D1D                                  CALL    checkTypeIntToReal
9D1D                  9
9D1F                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0066                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D1D  BD9885                                  JSR     \1
                              ENDIF
9D20                                  CALL    popFPFromStackToPTR1
9D20                  9
9D22                  __XBSR                  SET 9B+2
1E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D20  BDBB2E                                  JSR     \1
                              ENDIF
9D23                                  CALL    evalDoCompareRealFPAwithPTR1
9D23                  9
9D25                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9D23  8D02                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9D25  3584                            PULS    B,PC
                      
9D27                  evalDoCompareRealFPAwithPTR1                            ; L9C8F
9D27                                  CALL    fpMoveRealAtPTR1toFPB
9D27                  9
9D29                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D27  BDA542                                  JSR     \1
                              ENDIF
9D2A                  evalDoCompareRealFPAwithFPB                             ; L9C92
9D2A  8680                            LDA     #$80
9D2C  943B                            ANDA    ZP_FPB
9D2E  973B                            STA     ZP_FPB                  ; make FPB sign bit top bit only
9D30  962E                            LDA     ZP_FPA
9D32  8480                            ANDA    #$80                            ; same with FPA
9D34  913B                            CMPA    ZP_FPB                  ; compare
9D36  2614                            BNE     L9CBE
9D38  963C                            LDA     ZP_FPB + 1
9D3A  9130                            CMPA    ZP_FPA + 2                      ;compare exponent
9D3C  260F                            BNE     L9CBF                           ;if not equal return C,Z as is
9D3E  DC3D                            LDD     ZP_FPB + 2                      ;otherwise compare matissa and swap C depeding on sign if NE
9D40  109331                          CMPD    ZP_FPA + 3
9D43  2608                            BNE     L9CBF
9D45  DC3F                            LDD     ZP_FPB + 4
9D47  109333                          CMPD    ZP_FPA + 5
9D4A  2601                            BNE     L9CBF
9D4C                  L9CBE
9D4C  39                              RTS
9D4D                  L9CBF
9D4D  46                              RORA                                    ; C into top bit of A
9D4E  983B                            EORA    ZP_FPB                  ; if -ve swap
9D50  49                              ROLA                                    ; put it back
9D51  8601                            LDA     #$01                            ; return NE, C
9D53  39                              RTS
9D54                  L9CC6brkTypeMismatch                                    ; L9CC9:
9D54                                  JUMP brkTypeMismatch
9D54  7E93EB                                  JMP     \1
                      ;;evalDoCompareTypeInB                                                          ; TODO: can be deleted?
                      ;;              TFR     B,A                             ;  Pass type to A
                      
                                      ; API CHANGE - alter return CC to match behaviour of 6809, trashes B,X
9D57                  evalDoCompare                                           ; L9CCA
9D57  4D                              TSTA
9D58  2730                            BEQ     evalDoCompareString             ;  type=0, compare strings
9D5A  2BB9                            BMI     evalDoCompareReal               ;  type<0, compare reals
9D5C  9E2A                            LDX     ZP_INT_WA                       ; note reverse order with least sig 
9D5E  DC2C                            LDD     ZP_INT_WA + 2                   ; bytes pulled first! this meakes thing simpler below
9D60  327F                            LEAS    -1,S                            ; reserving some stack space for storing after EVAL
9D62  3416                            PSHS    D,X                             ;  stack current int 
9D64                                  CALL    evalLevel4                      ;  Call Evaluator Level 4 - +, -
9D64                  9
9D66                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0082                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D64  BD9EE8                                  JSR     \1
                              ENDIF
9D67  E764                            STB     4,S                             ; store B in reserved stack space
9D69  4D                              TSTA
9D6A  27E8                            BEQ      L9CC6brkTypeMismatch;          ;  <int> <compare> <string> - Type mismatch
9D6C  2B8E                            BMI      evalDoComparePopIntFromMachineStackConvertToRealAndCompare                             ;  <int> <compare> <real> - convert and compare
9D6E  962A                            LDA      ZP_INT_WA + 0
9D70  8880                            EORA     #$80
9D72  972A                            STA      ZP_INT_WA + 0                  ; swap RHS sign bit
                                                              ;  Compare current integer with stacked integer
9D74  3506                            PULS    D
9D76  932C                            SUBD    ZP_INT_WA + 2
9D78  DD2C                            STD     ZP_INT_WA + 2   ; subtract least sig
9D7A  3506                            PULS    D
9D7C  D22B                            SBCB    ZP_INT_WA + 1
9D7E  8880                            EORA    #$80
9D80  922A                            SBCA    ZP_INT_WA + 0   ; subtract most sig
9D82  9A2B                            ORA     ZP_INT_WA + 1
9D84  9A2C                            ORA     ZP_INT_WA + 2
9D86  9A2D                            ORA     ZP_INT_WA + 3   ; set Z if all 0
9D88  3584                            PULS    B,PC
                      
                                      ; API CHANGE - alter return CC to match behaviour of 6809
9D8A                  evalDoCompareString ;                                  ; L9D02
9D8A                                  CALL    StackString
9D8A                  9
9D8C                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D8A  BDBB74                                  JSR     \1
                              ENDIF
9D8D                                  CALL    evalLevel4
9D8D                  9
9D8F                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0059                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9D8D  BD9EE8                                  JSR     \1
                              ENDIF
9D90  3444                            PSHS    B,U
9D92  4D                              TSTA
9D93  26BF                            BNE     L9CC6brkTypeMismatch
9D95  9E04                            LDX     ZP_BAS_SP
9D97  E684                            LDB     0,X                             ; get stacked string length
9D99  D136                            CMPB    ZP_STRBUFLEN                    ; get shortest length in ZP_GEN_PTR
9D9B  2302                            BLS     L9D13
9D9D  D636                            LDB     ZP_STRBUFLEN
9D9F                  L9D13
9D9F  D737                            STB     ZP_NAMELENORVT
9DA1  5F                              CLRB
9DA2  3001                            LEAX    1,X                             ; point X at 1st byte of stacked string
9DA4  CE0600                          LDU     #BASWKSP_STRING                 ; point Y at LHS string
9DA7                  L9D15
9DA7  D137                            CMPB    ZP_NAMELENORVT                  ; compare strings
9DA9  2709                            BEQ     L9D23
9DAB  5C                              INCB
9DAC  A680                            LDA     ,X+
9DAE  A1C0                            CMPA    ,U+
9DB0  27F5                            BEQ     L9D15
9DB2  2006                            BRA     L9D27
9DB4                  L9D23
9DB4  A69F0004                        LDA     [ZP_BAS_SP]                     ; if we got here the strings matched
9DB8  9136                            CMPA    ZP_STRBUFLEN                    ; so compare lengths instead
9DBA                  L9D27
9DBA  3401                            PSHS    CC
9DBC                                  CALL    unstackString
9DBC                  9
9DBE                  __XBSR                  SET 9B+2
1100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DBC  BDAF8C                                  JSR     \1
                              ENDIF
9DBF  35C5                            PULS    CC,B,U,PC
                      ;                       ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                      ;                       ; ;;                                                                       ;;
                      ;                       ; ;; EXPRESSION EVALUATOR                                                  ;;
                      ;                       ; ;; --------------------                                                  ;;
                      ;                       ; ;; Recursively calls seven expression levels, evaluating expressions at  ;;
                      ;                       ; ;; each level, looping within each level until all operators at that     ;;
                      ;                       ; ;; level are exhausted.                                                  ;;
                      ;                       ; ;;                                                                       ;;
                      ;                       ; ;; On entry, Y=>start of expression to evaluate                          ;;
                      ;                       ; ;; On exit,  Y=>first character after evaluated expression               ;;
                      ;                       ; ;;           $2A/B/C/D = returned value                                  ;;
                      ;                       ; ;;           A,ZP_VARTYPE=type                                           ;;
                      ;                       ; ;;             ZP_FPB + 5 - integer                              ;;
                      ;                       ; ;;                                                                       ;;
                      ;                       ; ;; Within the evaluator, B=next character, A=current type                ;;
                      ;                       ; ;; X trampled                                                            ;;
                      ;                       ; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                              ; internally changed so that next token is in B instead of X
9DC1                  evalExpressionMAIN
                      ;               LDA ZP_TXTPTR
                      ;               STA ZP_TXTPTR2
                      ;               LDA ZP_TXTPTR + 1
                      ;               STA ZP_TXTPTR2 + 1
                      ;               LDA ZP_TXTOFF
                      ;               STA ZP_TXTOFF2
                      
                      ;                       ;  Evaluator Level 7 - OR, EOR
                      ;                       ;  ===========================
9DC1                  evalAtY         CALL     evalLevel6                     ;  Call Level 6 Evaluator - AND
9DC1                  9
9DC3                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9DC1  8D51                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9DC3                  evalLevel7lp0
9DC3  C184                            CMPB     #tknOR
9DC5  2709                            BEQ      evalLevel7OR                   ;  Jump to do OR
9DC7  C182                            CMPB     #tknEOR
9DC9  2728                            BEQ      evalLevel7EOR                  ;  Jump to do EOR
9DCB  9727                            STA      ZP_VARTYPE
9DCD  335F                            LEAU     -1,U
9DCF  39                              RTS                                     ;  Store type in ZP_VARTYPE and return
                      ;                       ;  OR <numeric>
                      ;                       ;  ------------
9DD0                  evalLevel7OR                                            ; L9D4C
9DD0                                  CALL    INTevalLevel6
9DD0                  9
9DD2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9DD0  8D3C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9DD2                                  CALL    checkTypeInAConvert2INT         ;  Stack integer, call Level 6 Evaluator, ensure integer
9DD2                  9
9DD4                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DD2  BD986F                                  JSR     \1
                              ENDIF
9DD5  3404                            PSHS    B
9DD7  9E04                            LDX     ZP_BAS_SP
9DD9  EC84                            LDD     0,X
                              IF CPU_6309
                                      ORD     ZP_INT_WA+0
                              ELSE
9DDB  9A2A                            ORA     ZP_INT_WA+0
9DDD  DA2B                            ORB     ZP_INT_WA+1
                              ENDIF
9DDF  DD2A                            STD     ZP_INT_WA
9DE1  EC02                            LDD     2,X
                              IF CPU_6309
                                      ORD     ZP_INT_WA+2
                              ELSE
9DE3  9A2C                            ORA     ZP_INT_WA+2
9DE5  DA2D                            ORB     ZP_INT_WA+3
                              ENDIF
9DE7  DD2C                            STD     ZP_INT_WA+2
9DE9                  evalL7unstackreturnInt_evalL7lp0                        ; L9D5F
9DE9  3004                            LEAX    4,X                             ;  Drop integer from stack
9DEB  9F04                            STX     ZP_BAS_SP
9DED  8640                            LDA     #$40
9DEF  3504                            PULS    B
9DF1  20D0                            BRA     evalLevel7lp0                   ;  Integer result, jump to check for more OR/EORs
                      ;                       ;  EOR <numeric>
                      ;                       ;  -------------
9DF3                  evalLevel7EOR                                           ; L9D4C
9DF3                                  CALL    INTevalLevel6
9DF3                  9
9DF5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9DF3  8D19                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9DF5                                  CALL    checkTypeInAConvert2INT         ;  Stack integer, call Level 6 Evaluator, ensure integer
9DF5                  9
9DF7                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9DF5  BD986F                                  JSR     \1
                              ENDIF
9DF8  3404                            PSHS    B
9DFA  9E04                            LDX     ZP_BAS_SP
9DFC  EC84                            LDD     0,X
                              IF CPU_6309
                                      EORD    ZP_INT_WA+0
                              ELSE
9DFE  982A                            EORA    ZP_INT_WA+0
9E00  D82B                            EORB    ZP_INT_WA+1
                              ENDIF
9E02  DD2A                            STD     ZP_INT_WA
9E04  EC02                            LDD     2,X
                              IF CPU_6309
                                      EORD    ZP_INT_WA+2
                              ELSE
9E06  982C                            EORA    ZP_INT_WA+2
9E08  D82D                            EORB    ZP_INT_WA+3
                              ENDIF
9E0A  DD2C                            STD     ZP_INT_WA+2
9E0C  20DB                            BRA     evalL7unstackreturnInt_evalL7lp0;  Jump to drop integer from stack and loop for more OR/EORs
                      
                      ;                       
                      ;                       ;  Integer Evaluate Level 6 - xxx OR/EOR yyy
                      ;                       ;  =========================================
9E0E                  INTevalLevel6                                           ; L9D7B
9E0E                                  CALL   checkTypeInAConvert2INT
9E0E                  9
9E10                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E0E  BD986F                                  JSR     \1
                              ENDIF
9E11                                  CALL   stackINT_WAasINT                 ;  Ensure number is integer and push onto stack
9E11                  9
9E13                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E11  BDBB5A                                  JSR     \1
                              ENDIF
                      
                      ;                       ;  Evaluator Level 6 - AND
                      ;                       ;  =======================
9E14                  evalLevel6                                              ; L9D81 
9E14                                  CALL    evalLevel5                      ;  Call Evaluator Level 5 - < <= = >= > <>
9E14                  9
9E16                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9E14  8D2E                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9E16                  evalLevel6Lp0                                           ; ;L9D84:               
9E16  C180                            CMPB    #tknAND
9E18  2701                            BEQ     evalDoAND                       ;  Jump to do AND
9E1A  39                              RTS
                      ;                       ;  AND <numeric>
                      ;                       ;  -------------
9E1B                  evalDoAND                                               ; L9D89
9E1B                                  CALL     checkTypeInAConvert2INT
9E1B                  9
9E1D                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0052                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E1B  BD986F                                  JSR     \1
                              ENDIF
9E1E                                  CALL     stackINT_WAasINT                ;  Ensure number is integer and push onto stack
9E1E                  9
9E20                  __XBSR                  SET 9B+2
1D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E1E  BDBB5A                                  JSR     \1
                              ENDIF
9E21                                  CALL    evalLevel5
9E21                  9
9E23                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0021                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
9E21  8D21                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
9E23                                  CALL    checkTypeInAConvert2INT         ;  Call Evaluator Level 5, ensure integer
9E23                  9
9E25                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E23  BD986F                                  JSR     \1
                              ENDIF
                      
9E26  3404                            PSHS    B
9E28  9E04                            LDX     ZP_BAS_SP
9E2A  EC84                            LDD     0,X
                              IF CPU_6309
                                      ANDD    ZP_INT_WA+0
                              ELSE
9E2C  942A                            ANDA    ZP_INT_WA+0
9E2E  D42B                            ANDB    ZP_INT_WA+1
                              ENDIF
9E30  DD2A                            STD     ZP_INT_WA
9E32  EC02                            LDD     2,X
                              IF CPU_6309
                                      ANDD    ZP_INT_WA+2
                              ELSE
9E34  942C                            ANDA    ZP_INT_WA+2
9E36  D42D                            ANDB    ZP_INT_WA+3
                              ENDIF
9E38  DD2C                            STD     ZP_INT_WA+2
9E3A  3004                            LEAX    4,X                             ;  Drop integer from stack
9E3C  9F04                            STX     ZP_BAS_SP
9E3E  8640                            LDA     #$40
9E40  3504                            PULS    B
9E42  20D2                            BRA     evalLevel6Lp0                   ;  Loop to check for more ANDs
                      
                      ;               ; Evaluator Level 5 - < <= = >= > <>
                      ;               ; ==================================
9E44                  evalLevel5      CALL    evalLevel4                      ;  Call Evaluator Level 4 - +, -
9E44                  9
9E46                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E44  BD9EE8                                  JSR     \1
                              ENDIF
9E47  C13E                            CMPB    #'>'
9E49  2204                            BHI     eval5rts                        ;  Not <,=,>, exit
9E4B  C13C                            CMPB    #'<'
9E4D  2401                            BHS     evalComparison          ;  <,=,>, evaluate comparison
9E4F  39              eval5rts        RTS
                      ;                       ;  <expression> <comparison> <expression>
                      ;                       ;  --------------------------------------
9E50                  evalComparison
9E50  2718                            BEQ     evalCompLt1                     ;  '<' - check for <, <=, <>
9E52  C13E                            CMPB    #'>'
9E54  2735                            BEQ     evalComplGt1                    ;  '>' - check for >, >=
9E56                                  CALL    evalDoCompare                   ;  Must be '=', pass type to A, compare expressions
9E56                  9
9E58                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E56  BD9D57                                  JSR     \1
                              ENDIF
9E59  2605                            BNE     evalCompRetFALSE                ;  LHS<>RHS, jump to return 0
9E5B                  evalCompRetTRUE                                 ;  L9DC1
9E5B  8EFFFF                          LDX    #$FFFF                   ;  LHS=RHS, Y = $FF to return -1
9E5E  2003                            BRA    1F
9E60                  evalCompRetFALSE                                ; L9DC2
9E60  8E0000                          LDX    #0
9E63  9F2A            1               STX ZP_INT_WA
9E65  9F2C                            STX ZP_INT_WA + 2
9E67  8640                            LDA #$40
9E69  39                              RTS
                      ;                       ;  Return integer
                      ;                       ;  <, <=, <>
                      ;                       ;  ---------
9E6A                  evalCompLt1                                     ;L9DCD:
9E6A  E6C0                            LDB     ,U+                     ;  Get next character
9E6C  C13D                            CMPB    #'='
9E6E  270D                            BEQ     evalCompLtEq1           ;  Jump with <=
9E70  C13E                            CMPB    #'>'
9E72  2710                            BEQ     evalComplNE             ;  Jump with <>
                      ;                       ;  Compare <
                      ;                       ;  ---------
9E74  335F                            LEAU    -1,U
9E76                                  CALL    evalDoCompare                   ;  Must be <, compare expressions
9E76                  9
9E78                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E76  BD9D57                                  JSR     \1
                              ENDIF
9E79  25E0                            BLO     evalCompRetTRUE
9E7B  20E3                            BRA     evalCompRetFALSE                ;  < - TRUE, >= - FALSE
                      ;               
                      ;                       ;  Compare <=
                      ;                       ;  ----------
9E7D                  evalCompLtEq1                                   ;L9DE1:
                                      
9E7D                                  CALL    evalDoCompare           ;  Step past character, compare expressions
9E7D                  9
9E7F                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E7D  BD9D57                                  JSR     \1
                              ENDIF
9E80  23D9                            BLS     evalCompRetTRUE         ;  < or = - TRUE
9E82  20DC                            BRA     evalCompRetFALSE
                      
                      ;                       ;  > - FALSE
                      ;                       ;  Compare <>
                      ;                       ;  ----------
9E84                  evalComplNE                                     ;L9DEC:
9E84                                  CALL    evalDoCompare           ;  Step past character, compare expressions
9E84                  9
9E86                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E84  BD9D57                                  JSR     \1
                              ENDIF
9E87  26D2                            BNE     evalCompRetTRUE
9E89  20D5                            BRA     evalCompRetFALSE
                      
                      ;                       ;  <> - TRUE, = - FALSE
                      ;                       ;  > or >=
                      ;                       ;  -------
9E8B                  evalComplGt1                                      ;L9DF5:
9E8B  E6C0                            LDB    ,U+                      ;  Get next character
9E8D  C13D                            CMPB   #'='
9E8F  2709                            BEQ    evalCompGE1              ;  Jump with >=
9E91  335F                            LEAU    -1,U
                      ;                       ;  Compare >
                      ;                       ;  ---------
9E93                                  CALL    evalDoCompare                   ;  Must be >, compare expressions
9E93                  9
9E95                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E93  BD9D57                                  JSR     \1
                              ENDIF
9E96  22C3                            BHI     evalCompRetTRUE                 ;  = - FALSE, > - TRUE
9E98  20C6                            BRA     evalCompRetFALSE
                      ;                       ;  < - FALSE
                      ;                       ;  Compare >=
                      ;                       ;  ----------
9E9A                  evalCompGE1                     ;L9E07:
9E9A                                  CALL    evalDoCompare                   ;  Step past character, compare expressions
9E9A                  9
9E9C                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9E9A  BD9D57                                  JSR     \1
                              ENDIF
9E9D  24BC                            BHS     evalCompRetTRUE
9E9F  20BF                            BRA     evalCompRetFALSE                ;  >= - TRUE, < - FALSE
9EA1                  brkStringTooLong
9EA1                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
9EA1  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
9EA2  13537472696E6720746F6F206C6F6E6700                 FCB     $13, "String too long", 0
9EB3                  evalL4StringPlus                                        ; L9E22
9EB3                                  CALL    StackString                     ; stack current
9EB3                  9
9EB5                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EB3  BDBB74                                  JSR     \1
                              ENDIF
9EB6                                  CALL    evalLevel2                      ; eval next phrase
9EB6                  9
9EB8                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EB6  BDA0AF                                  JSR     \1
                              ENDIF
9EB9  3444                            PSHS    B,U                             ; B contains next token
9EBB  4D                              TSTA                                    ; if not a string
9EBC  102600B1                        LBNE    __skbrkTypeMismatch             ; error
9EC0  9E04                            LDX     ZP_BAS_SP
9EC2  E684                            LDB     ,X                              ; get length of stacked
9EC4  DB36                            ADDB    ZP_STRBUFLEN                    ; add length of current
9EC6  25D9                            BCS     brkStringTooLong                ; if there's a carry its too big
9EC8  D737                            STB     ZP_NAMELENORVT                  ; store combined len
                                      ; move current string (RH) along by the length of (LH)
9ECA  8E0600                          LDX     #BASWKSP_STRING
9ECD  3A                              ABX                                     ; X points to last char of combined string + 1
9ECE  3384                            LEAU    ,X                              ; stick it in Y
9ED0  8E0600                          LDX     #BASWKSP_STRING                 
9ED3  D636                            LDB     ZP_STRBUFLEN                    ; length of LH
9ED5  3A                              ABX
9ED6  A682            1               LDA     ,-X
9ED8  A7C2                            STA     ,-U
9EDA  5A                              DECB
9EDB  26F9                            BNE     1B                              ; shift current string along
9EDD                                  CALL    popStackedStringNew             ; pop stacked string
9EDD                  9
9EDF                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EDD  BDBBD6                                  JSR     \1
                              ENDIF
9EE0  D637                            LDB     ZP_NAMELENORVT
9EE2  D736                            STB     ZP_STRBUFLEN
9EE4  3544                            PULS    B,U                             ; pop next token
9EE6  2003                            BRA     _skEvalLevel4_noLevel3
                      ;                       ;  Evaluator Level 4 - + -
                      ;                       ;  =======================
9EE8                  evalLevel4                                              ; L9E4C
9EE8                                  CALL    evalLevel3                      ;  Call Evaluator Level 3 - * / DIV MOD
9EE8                  9
9EEA                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EE8  BDA060                                  JSR     \1
                              ENDIF
9EEB                  _skEvalLevel4_noLevel3                                  ; L9E4F
9EEB  C12B                            CMPB    #'+'
9EED  2705                            BEQ     evalL4Plus                      ;  Jump to do +
9EEF  C12D                            CMPB    #'-'
9EF1  2757                            BEQ     evalL4Minus                     ;  Jump to do -
9EF3  39                              RTS
                      ;                       ;  <expression> + <expression>
                      ;                       ;  ---------------------------
9EF4                  evalL4Plus                                              ; L9E58
9EF4  4D                              TSTA
9EF5  27BC                            BEQ     evalL4StringPlus                ;  <string> +
9EF7  2B26                            BMI     evalL4RealPlus                  ;  <real> +
9EF9                                  CALL    stackIntThenEvalL3              ;  Stack integer, call Evaluator Level 3 - * / DIV MOD
9EF9                  9
9EFB                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9EF9  BDA05D                                  JSR     \1
                              ENDIF
9EFC  4D                              TSTA
9EFD  1027F4EA                        LBEQ    brkTypeMismatch                 ;  <int> + <string> - Type mismatch
9F01  2B3A                            BMI     evalL4IntPlusReal               ;  <int> + <real> - convert
9F03  3404                            PSHS    B
9F05  9E04                            LDX     ZP_BAS_SP
9F07  EC02                            LDD     2,X
9F09  D32C                            ADDD    ZP_INT_WA + 2
9F0B  DD2C                            STD     ZP_INT_WA + 2
9F0D  EC84                            LDD     ,X
                              IF CPU_6309
                                      ADCD    ZP_INT_WA
                              ELSE
9F0F  D92B                            ADCB    ZP_INT_WA + 1
9F11  992A                            ADCA    ZP_INT_WA + 0
                              ENDIF
9F13  DD2A                            STD     ZP_INT_WA
9F15  3504                            PULS    B
                      ;                       ;  Drop integer from stack and return integer
                      ;                       ;  ------------------------------------------
9F17                  evalL4PopIntStackReturnIntX                             ; L9E80
9F17  3004                            LEAX    4,X
9F19  9F04                            STX     ZP_BAS_SP
9F1B  8640                            LDA     #$40
9F1D  20CC                            BRA     _skEvalLevel4_noLevel3          ;  Update SP, loop to do any more +, -
                      
9F1F                  evalL4RealPlus                                          ;L9E94
9F1F                                  CALL    fpStackWAtoStackReal
9F1F                  9
9F21                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F1F  BDBB3A                                  JSR     \1
                              ENDIF
9F22                                  CALL    evalLevel3
9F22                  9
9F24                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F22  BDA060                                  JSR     \1
                              ENDIF
9F25  D727                            STB     ZP_VARTYPE
9F27  4D                              TSTA
9F28  1027F4BF                        LBEQ    brkTypeMismatch
9F2C  2B03                            BMI     L9EA4
9F2E                                  CALL    IntToReal
9F2E                  9
9F30                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F2E  BD856A                                  JSR     \1
                              ENDIF
9F31                  L9EA4           CALL    popFPFromStackToPTR1
9F31                  9
9F33                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F31  BDBB2E                                  JSR     \1
                              ENDIF
9F34                                  CALL    fpFPAeqPTR1addFPA
9F34                  9
9F36                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F34  BDA6C3                                  JSR     \1
                              ENDIF
9F37                  evalTokenFromVarTypeReturnReal                          ; L9EAA
9F37  D627                            LDB     ZP_VARTYPE                      ; Get back saved token
9F39  86FF                            LDA     #$FF
9F3B  20AE                            BRA _skEvalLevel4_noLevel3              ;  Loop to do any more +, -
                      
                      
                      
9F3D                  evalL4IntPlusReal                                       ; L9EB0
9F3D  D727                            STB     ZP_VARTYPE
9F3F                                  CALL    popIntANew
9F3F                  9
9F41                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F3F  BDBBEC                                  JSR     \1
                              ENDIF
9F42                                  CALL    fpStackWAtoStackReal
9F42                  9
9F44                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F42  BDBB3A                                  JSR     \1
                              ENDIF
9F45                                  CALL    IntToReal
9F45                  9
9F47                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F45  BD856A                                  JSR     \1
                              ENDIF
9F48  20E7                            BRA     L9EA4
                      
                                      ;  <expression> - <expression>
                                      ;  ---------------------------
9F4A                  evalL4Minus                                             ; L9E58
9F4A  4D                              TSTA
9F4B  1027F49C                        LBEQ    brkTypeMismatch                 ;  <string> - Type mismatch
9F4F  2B23                            BMI     evalL4RealMinus                 ;  <real> -
9F51                                  CALL    stackIntThenEvalL3
9F51                  9
9F53                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F51  BDA05D                                  JSR     \1
                              ENDIF
9F54  4D                              TSTA                                    ;  Stack integer, call Evaluator Level 3 - * / DIV MOD
9F55  1027F492                        LBEQ    brkTypeMismatch                 ;  <int> - <string> - Type mismatch
9F59  2B31                            BMI     evalL4IntMinusReal              ;  <int> - <real> - convert
9F5B  3404                            PSHS    B
9F5D  9E04                            LDX     ZP_BAS_SP
9F5F  EC02                            LDD     2,X
9F61  932C                            SUBD    ZP_INT_WA + 2
9F63  DD2C                            STD     ZP_INT_WA + 2
9F65  EC84                            LDD     0,X
                              IF CPU_6309
                                      SBCD    ZP_INT_WA + 0
                              ELSE
9F67  D22B                            SBCB    ZP_INT_WA + 1
9F69  922A                            SBCA    ZP_INT_WA + 0
                              ENDIF
9F6B  DD2A                            STD     ZP_INT_WA + 0
9F6D  3504                            PULS    B
9F6F  20A6                            BRA evalL4PopIntStackReturnIntX         ;  Drop integer from stack and return
                      
9F71                  __skbrkTypeMismatch
9F71                                  JUMP brkTypeMismatch
9F71  7E93EB                                  JMP     \1
                      
                      
                      ;                       ;  <real> - <expression>
                      ;                       ;  ---------------------
9F74                  evalL4RealMinus                                         ; L9EE7
9F74                                  CALL    fpStackWAtoStackReal
9F74                  9
9F76                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F74  BDBB3A                                  JSR     \1
                              ENDIF
9F77                                  CALL    evalLevel3
9F77                  9
9F79                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F77  BDA060                                  JSR     \1
                              ENDIF
9F7A  D727                            STB     ZP_VARTYPE
9F7C  4D                              TSTA
9F7D  27F2                            BEQ     __skbrkTypeMismatch
9F7F  2B03                            BMI     1F
9F81                                  CALL    IntToReal
9F81                  9
9F83                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F81  BD856A                                  JSR     \1
                              ENDIF
9F84                  1                                                       ; L9EF7
9F84                                  CALL    popFPFromStackToPTR1
9F84                  9
9F86                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F84  BDBB2E                                  JSR     \1
                              ENDIF
9F87                                  CALL    fpFPAeqPTR1subFPA
9F87                  9
9F89                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F87  BDA6C0                                  JSR     \1
                              ENDIF
9F8A  20AB                            BRA     evalTokenFromVarTypeReturnReal
                      
                      
9F8C                  evalL4IntMinusReal                                      ; L9EFF
9F8C  D727                            STB     ZP_VARTYPE                      ; preserve token
9F8E                                  CALL    popIntANew
9F8E                  9
9F90                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F8E  BDBBEC                                  JSR     \1
                              ENDIF
9F91                                  CALL    fpStackWAtoStackReal
9F91                  9
9F93                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F91  BDBB3A                                  JSR     \1
                              ENDIF
9F94                                  CALL    IntToReal
9F94                  9
9F96                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F94  BD856A                                  JSR     \1
                              ENDIF
9F97                                  CALL    popFPFromStackToPTR1
9F97                  9
9F99                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0095                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F97  BDBB2E                                  JSR     \1
                              ENDIF
9F9A                                  CALL    fpFPAeqPTR1subFPAnegFPA
9F9A                  9
9F9C                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F9A  BDAD03                                  JSR     \1
                              ENDIF
9F9D  2098                            BRA     evalTokenFromVarTypeReturnReal
9F9F                  L9F12
9F9F                                  CALL    IntToReal                       ; convert RHS to real and mult
9F9F                  9
9FA1                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9F9F  BD856A                                  JSR     \1
                              ENDIF
9FA2                  L9F15                                                   ; convert LHS to real and mult
9FA2                                  CALL    popIntANew
9FA2                  9
9FA4                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FA2  BDBBEC                                  JSR     \1
                              ENDIF
9FA5                                  CALL    fpStackWAtoStackReal
9FA5                  9
9FA7                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FA5  BDBB3A                                  JSR     \1
                              ENDIF
9FA8                                  CALL    IntToReal
9FA8                  9
9FAA                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FA8  BD856A                                  JSR     \1
                              ENDIF
9FAB  200C                            BRA     L9F2D
9FAD                  eval3Mul_IntAsRealEvalAndMul                            ; L9F20
9FAD                                  CALL    IntToReal
9FAD                  9
9FAF                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FAD  BD856A                                  JSR     \1
                              ENDIF
9FB0                  eval3Mul_StackRealEvalAndMul                    ; L9F23
9FB0                                  CALL    fpStackWAtoStackReal
9FB0                  9
9FB2                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0088                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FB0  BDBB3A                                  JSR     \1
                              ENDIF
9FB3                                  CALL    evalLevel2                      ; call eval level 2
9FB3                  9
9FB5                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FB3  BDA0AF                                  JSR     \1
                              ENDIF
9FB6                                  CALL    checkTypeIntToReal
9FB6                  9
9FB8                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FB6  BD9885                                  JSR     \1
                              ENDIF
9FB9                  L9F2D           CALL    popFPFromStackToPTR1
9FB9                  9
9FBB                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FB9  BDBB2E                                  JSR     \1
                              ENDIF
9FBC                                  CALL    fpFPAeqPTR1mulFPA
9FBC                  9
9FBE                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FBC  BDA6DC                                  JSR     \1
                              ENDIF
9FBF  86FF                            LDA     #$FF
9FC1  E65F                            LDB     -1,U
9FC3                                  JUMP    _skevalLevel3noLevel2
9FC3  7EA062                                  JMP     \1
                                      
                                      ;  <expression> * <expression>
                                      ;  ---------------------------
9FC6                  Eval3Mul
9FC6  4D                              TSTA
9FC7  27A8                            BEQ     __skbrkTypeMismatch             ; can't multiply a string
9FC9  2BE5                            BMI     eval3Mul_StackRealEvalAndMul
9FCB  D62A                            LDB     ZP_INT_WA + 0
9FCD  D12B                            CMPB    ZP_INT_WA + 1                   ; if top two bytes of integer aren't the same
9FCF  26DC                            BNE     eval3Mul_IntAsRealEvalAndMul
9FD1  962C                            LDA     ZP_INT_WA + 2
9FD3  48                              ASLA
9FD4  C900                            ADCB    #$00                            ; or top byte + MS bit of 2nd byte <> 0 
9FD6  26D5                            BNE     eval3Mul_IntAsRealEvalAndMul                            ; do a real mult
9FD8                                  CALL    stackINTEvalLevel2
9FD8                  9
9FDA                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FD8  BDA0AC                                  JSR     \1
                              ENDIF
9FDB  D727                            STB     ZP_VARTYPE                      ; save B
9FDD  4D                              TSTA
9FDE  2791                            BEQ     __skbrkTypeMismatch
9FE0  2BC0                            BMI     L9F15
9FE2  D62A                            LDB     ZP_INT_WA + 0
9FE4  D12B                            CMPB    ZP_INT_WA + 1                   ; if top two bytes aren't the same then do real multiply
9FE6  26B7                            BNE     L9F12                           ; convert to real both WA and stacked and do real
9FE8  962C                            LDA     ZP_INT_WA + 2
9FEA  48                              ASLA                                    ; shift top bit of 2 into A (top byte)
9FEB  C900                            ADCB    #$00
9FED  26B0                            BNE     L9F12
                      
                              IF CPU_6309
                                      LDX     ZP_BAS_SP
                                      LDD     ZP_INT_WA+2
                                      MULD    2,X
                                      STQ     0,X
                              ELSE
                                      ; work out what sign changes (if any) we need to do at the end and pop result from stack
9FEF  962A                            LDA     ZP_INT_WA + 0
9FF1  A89F0004                        EORA    [ZP_BAS_SP]
9FF5  9737                            STA     ZP_GEN_PTR                      ; ZP_GEN_PTR contains sign flip bit in bit 7
                      
                      
9FF7                                  CALL    intWA_ABS                       ; ABS int 
9FF7                  9
9FF9                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0001                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FF7  BDACFA                                  JSR     \1
                              ENDIF
9FFA  8E0039                          LDX     #ZP_GEN_PTR+2
9FFD                                  CALL    CopyIntWA2X                     ; and move to temp areas
9FFD                  9
9FFF                  __XBSR                  SET 9B+2
1C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
9FFD  BDBCA3                                  JSR     \1
                              ENDIF
A000  9E04                            LDX     ZP_BAS_SP
A002  EC84                            LDD     ,X
A004  DD2A                            STD     ZP_INT_WA
A006  EC02                            LDD     2,X
A008  DD2C                            STD     ZP_INT_WA + 2                   ; retrieve int from U stack but leave room (we'll place result there)
A00A                                  CALL    intWA_ABS                       ; ABS it
A00A                  9
A00C                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A00A  BDACFA                                  JSR     \1
                              ENDIF
                      
A00D  4F                              CLRA
A00E  5F                              CLRB
A00F  ED84                            STD     0,X
A011  ED02                            STD     2,X
                      
                                      ; now X points to B, WA contains A both only bottom 15 bits, multiply into 4 bytes at ZP_GEN_PTR+2
A013  962D                            LDA     ZP_INT_WA + 3
A015  2707                            BEQ     1F
A017  D63C                            LDB     ZP_GEN_PTR + 5
A019  2703                            BEQ     1F
A01B  3D                              MUL
A01C  ED02                            STD     2,X
                      
A01E                  1               ; now contains two LSbytes multiplied together, multiply 2nd byte of A with LSB of B and add to acc
A01E  962C                            LDA     ZP_INT_WA + 2
A020  270D                            BEQ     1F
A022  D63C                            LDB     ZP_GEN_PTR + 5
A024  2709                            BEQ     1F
A026  3D                              MUL
A027  E301                            ADDD    1,X
A029  ED01                            STD     1,X
A02B  2402                            BCC     1F
A02D  6C84                            INC     0,X
A02F                  1
                                      ;  multiply 1st byte of A with 2nd byte of B and add to acc
A02F  962D                            LDA     ZP_INT_WA + 3
A031  270D                            BEQ     1F
A033  D63B                            LDB     ZP_GEN_PTR + 4
A035  2709                            BEQ     1F
A037  3D                              MUL
A038  E301                            ADDD    1,X
A03A  ED01                            STD     1,X
A03C  2402                            BCC     1F
A03E  6C84                            INC     0,X
A040                  1
                                      ;  multiply 2nd byte of A with 2nd byte of B and add to acc
A040  962C                            LDA     ZP_INT_WA + 2
A042  2709                            BEQ     1F
A044  D63B                            LDB     ZP_GEN_PTR + 4
A046  2705                            BEQ     1F
A048  3D                              MUL
A049  E384                            ADDD    0,X
A04B  ED84                            STD     0,X
A04D                  1
                              ENDIF ; 6809
                                      ; no check - this should never overflow!
                                      ; now U should contain ABS result
A04D                                  CALL    popIntANew
A04D                  9
A04F                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A04D  BDBBEC                                  JSR     \1
                              ENDIF
A050                  divmodNegateWAifZP_GEN_PTR
A050  0D37                            TST     ZP_GEN_PTR
A052                  divmodNegateWAifMI
A052  2A03                            BPL     1F
A054                                  CALL    negateIntA
A054                  9
A056                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A054  BDAD1B                                  JSR     \1
                              ENDIF
A057  8640            1               LDA     #$40
A059  D627            divmodfinish    LDB     ZP_VARTYPE
A05B  2005                            BRA     _skevalLevel3noLevel2
                      
                      
                      
                      
                      ;                       ;  Evaluator Level 3 - * / DIV MOD
                      ;                       ;  ===============================
A05D                  stackIntThenEvalL3                                      ; L9FC4
A05D                                  CALL stackINT_WAasINT                   ;  Stack current integer
A05D                  9
A05F                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A05D  BDBB5A                                  JSR     \1
                              ENDIF
A060                  evalLevel3                                              ; L9FC7
A060                                  CALL    evalLevel2                      ;  Call Evaluator Level 2 - ^
A060                  9
A062                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A060  8D4D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A062                  _skevalLevel3noLevel2                                   ; L9FCA
A062  C12A                            CMPB    #'*'
A064  1027FF5E                        LBEQ    Eval3Mul                        ;  Jump with *
A068  C12F                            CMPB    #'/'
A06A  2709                            BEQ     evalL3DoRealDiv                 ;  Jump with /
A06C  C183                            CMPB    #tknMOD
A06E  271C                            BEQ     evalL3DoMOD                     ;  Jump with MOD
A070  C181                            CMPB    #tknDIV
A072  2725                            BEQ     evalL3DoDIV                             ;  Jump with DIV
A074  39                              RTS
                      ;                       ;  <expression> / <expression>
                      ;                       ;  ---------------------------
A075                  evalL3DoRealDiv                                         ; L9FDB
A075                                  CALL    checkTypeIntToReal
A075                  9
A077                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
000E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A075  BD9885                                  JSR     \1
                              ENDIF
A078                                  CALL    fpStackWAtoStackReal            ; Error if string, ensure real, stack real
A078                  9
A07A                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A078  BDBB3A                                  JSR     \1
                              ENDIF
A07B                                  CALL    evalLevel2                      ; Call Evaluator Level 2 - ^
A07B                  9
A07D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A07B  8D32                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A07D  D727                            STB     ZP_VARTYPE                      ; save current token
A07F                                  CALL    checkTypeIntToReal
A07F                  9
A081                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A07F  BD9885                                  JSR     \1
                              ENDIF
A082                                  CALL    popFPFromStackToPTR1
A082                  9
A084                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A082  BDBB2E                                  JSR     \1
                              ENDIF
A085                                  CALL    fpFPAeqPTR1divFPA
A085                  9
A087                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A085  BDA625                                  JSR     \1
                              ENDIF
A088  86FF                            LDA     #$FF
A08A  20CD                            BRA     divmodfinish
                      ;                       ;  <expression> MOD <expression>
                      ;                       ;  -----------------------------
A08C                  evalL3DoMOD                                             ; L9FF5
A08C                                  CALL    evalDoIntDivide
A08C                  9
A08E                  __XBSR                  SET 9B+2
E400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A08C  BD84E3                                  JSR     \1
                              ENDIF
A08F  8E003D                          LDX     #ZP_INT_WA_C
A092                                  CALL    intLoadWAFromX
A092                  9
A094                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A092  BDAAEF                                  JSR     \1
                              ENDIF
A095  9637                            LDA     ZP_GEN_PTR
A097  20B9                            BRA     divmodNegateWAifMI
                      ;                       ;  <expression> DIV <expression>
                      ;                       ;  -----------------------------
A099                  evalL3DoDIV                                             ; L9FFD
A099                                  CALL    evalDoIntDivide
A099                  9
A09B                  __XBSR                  SET 9B+2
E400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A099  BD84E3                                  JSR     \1
                              ENDIF
A09C  093C                            ROL     ZP_INT_WA_B + 3
A09E  093B                            ROL     ZP_INT_WA_B + 2
A0A0  093A                            ROL     ZP_INT_WA_B + 1
A0A2  0939                            ROL     ZP_INT_WA_B + 0
A0A4  8E0039                          LDX     #ZP_INT_WA_B
A0A7                                  CALL    intLoadWAFromX
A0A7                  9
A0A9                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0046                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A0A7  BDAAEF                                  JSR     \1
                              ENDIF
A0AA  20A4                            BRA     divmodNegateWAifZP_GEN_PTR
                      ;
                      ;                       ;  Evaluator Level 2 - ^
                      ;                       ;  =====================
A0AC                  stackINTEvalLevel2                                      ; LA00F
A0AC                                  CALL stackINT_WAasINT                   ; Stack current integer
A0AC                  9
A0AE                  __XBSR                  SET 9B+2
1A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A0AC  BDBB5A                                  JSR     \1
                              ENDIF
A0AF                  evalLevel2                                              ; LA012
A0AF                                  CALL evalLevel1                         ; Call Evaluator Level 1 - everything else
A0AF                  9
A0B1                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A0AF  BDAD70                                  JSR     \1
                              ENDIF
A0B2                  evalLevel2again                                         ; LA015
A0B2  E6C0            evalL2lp1       LDB     ,U+
A0B4  C120                            CMPB    #' '
A0B6  27FA                            BEQ     evalL2lp1                       ;  Skip spaces
A0B8  C15E                            CMPB    #'^'
A0BA  2701                            BEQ     evalDoCARET                     ;  Jump with ^
A0BC  39                              RTS
                      ;                       ;  <expression> ^ <expression>
                      ;                       ;  ---------------------------
A0BD                  evalDoCARET                                             ;LA027:
A0BD                                  CALL checkTypeIntToReal
A0BD                  9
A0BF                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A0BD  BD9885                                  JSR     \1
                              ENDIF
A0C0                                  TODODEADEND "evalDo^"
A0C0                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A0C0  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A0C1  7E443A                          FCB             $7E,"D:"
A0C4  6576616C446F5E                  FCB             \1
A0CB  00                              FCB             0
                      ;               CALL fpStackWAtoStackReal
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA ZP_FPA + 2
                      ;               CMP #$87
                      ;               BCS LA079
                      ;               CALL L82E0
                      ;               BNE LA049
                      ;               CALL popFPFromStackToPTR1
                      ;               CALL fpCopyPTR1toFPA
                      ;               LDA ZP_FP_TMP + 6
                      ;               CALL LA5BE
                      ;               BRA LA075
                      ;LA049:
                      ;               CALL fpCopyFPA_FPTEMP3
                      ;               LDA ZP_BAS_SP
                      ;               STA ZP_FP_TMP_PTR1
                      ;               LDA ZP_BAS_SP + 1
                      ;               STA ZP_FP_TMP_PTR1 + 1
                      ;               CALL fpCopyPTR1toFPA
                      ;               LDA ZP_FP_TMP + 6
                      ;               CALL LA5BE
                      ;LA05C:
                      ;               LDA #$71
                      ;               CALL fpCopyFPA_X----check was 400+A
                      ;               CALL popFPFromStackToPTR1
                      ;               CALL fpCopyPTR1toFPA
                      ;               CALL fnLN_FPA
                      ;               CALL fpFPAeqFPTEMP3mulFPA
                      ;               CALL LA9E2
                      ;               LDA #$71
                      ;               CALL LA9A1
                      ;LA075:
                      ;               LDA #$FF
                      ;               BRA evalLevel2again
                      ;LA079:
                      ;               CALL fpCopyFPA_FPTEMP3
                      ;               CALL fpLoad1                    ;  FloatA=1.0
                      ;               BRA LA05C
                      
                      
                                      ; formats a 16 bit integer at ZP_INT_WA + 2 to a string
                                      ; NEW API
                                      ;       A contains preferred length or 0 for any
                                      ;       Y preserved
                                      ;       X preserved                                     TODO, needed?
                                      ;       ZP_INT_WA + 2 = 0                               TODO, needed?
                                      ;       returns with B = $FF
                      
                                      ; OLD API
                                      ;       A contains preferred length or 0 for any
                                      ;       Y preserved
                                      ;       ZP_INT_WA + 2 = 0
                                      ;       returns with X = $FF
                      
A0CC                  int16print_AnyLen                               ; LA081
A0CC  8600                            LDA     #$00
A0CE  2002                            BRA     int16print_fmtA
A0D0                  int16print_fmt5                                 ; LA085
A0D0  8605                            LDA     #$05
A0D2                  int16print_fmtA                                 ; LA087
A0D2  9714                            STA     ZP_PRINTBYTES
A0D4  308DE024                        LEAX    tblTENS_BE, PCR         ; point at tens table
A0D8  3440                            PSHS    U
A0DA  CE003F                          LDU     #ZP_FPB + 4
A0DD  DC2C                            LDD     ZP_INT_WA + 2
A0DF  6F44                            CLR     4,U
A0E1  6F43                            CLR     3,U
A0E3  6F42                            CLR     2,U
A0E5  6F41                            CLR     1,U
A0E7  6FC4                            CLR     0,U
                      
A0E9  A308            int16dig4_lp    SUBD    8,X                     ; try and subtract ten
A0EB  2504                            BCS     int16dig4_sk
A0ED  6C44                            INC     4,U                     ; it it doesn't overflow increment digit
A0EF  20F8                            BRA     int16dig4_lp            
A0F1  E308            int16dig4_sk    ADDD    8,X                     ; add number back
A0F3  272C                            BEQ     int16dig_skiprest
                      
A0F5  A306            int16dig3_lp    SUBD    6,X                     ; try and subtract ten
A0F7  2504                            BCS     int16dig3_sk
A0F9  6C43                            INC     3,U                     ; it it doesn't overflow increment digit
A0FB  20F8                            BRA     int16dig3_lp            
A0FD  E306            int16dig3_sk    ADDD    6,X                     ; add number back
A0FF  2720                            BEQ     int16dig_skiprest
                      
A101  A304            int16dig2_lp    SUBD    4,X                     ; try and subtract ten
A103  2504                            BCS     int16dig2_sk
A105  6C42                            INC     2,U                     ; it it doesn't overflow increment digit
A107  20F8                            BRA     int16dig2_lp            
A109  E304            int16dig2_sk    ADDD    4,X                     ; add number back
A10B  2714                            BEQ     int16dig_skiprest
                      
A10D  A302            int16dig1_lp    SUBD    2,X                     ; try and subtract ten
A10F  2504                            BCS     int16dig1_sk
A111  6C41                            INC     1,U                     ; it it doesn't overflow increment digit
A113  20F8                            BRA     int16dig1_lp            
A115  E302            int16dig1_sk    ADDD    2,X                     ; add number back
A117  2708                            BEQ     int16dig_skiprest
                      
A119  A384            int16dig0_lp    SUBD    0,X                     ; try and subtract ten
A11B  2504                            BCS     int16dig_skiprest
A11D  6CC4                            INC     0,U                     ; it it doesn't overflow increment digit
A11F  20F8                            BRA     int16dig0_lp            
                      
A121                  int16dig_skiprest
                      
                                      ; number now decoded (reversed at ZP_FPB + 4)
                      
                      
A121  C605                            LDB     #$05
A123                  int16_scan0_lp                                  ;LA0A8
A123  5A                              DECB                            ; scan for first non zero element
A124  2704                            BEQ     int16_scan0_sk
A126  A6C5                            LDA     B,U
A128  27F9                            BEQ     int16_scan0_lp
A12A                  int16_scan0_sk                                  ;LA0AF:
A12A  D737                            STB     ZP_GEN_PTR
A12C  9614                            LDA     ZP_PRINTBYTES
A12E  270B                            BEQ     int16_printDigits
A130  9037                            SUBA    ZP_GEN_PTR
A132  2707                            BEQ     int16_printDigits
A134  1F89                            TFR     A,B
A136                                  CALL    list_printBSpaces
A136                  9
A138                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0065                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A136  BDBC9D                                  JSR     \1
                              ENDIF
A139  D637                            LDB     ZP_GEN_PTR
A13B                  int16_printDigits                               ;LA0BF:
A13B  A6C5                            LDA     B,U
A13D  8A30                            ORA     #$30
A13F                                  CALL    list_printA
A13F                  9
A141                  __XBSR                  SET 9B+2
1B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A13F  BDBC6F                                  JSR     \1
                              ENDIF
A142  5A                              DECB
A143  2AF6                            BPL     int16_printDigits
A145  35C0                            PULS    U,PC                    ; RTS restore Y
                      
                      
                      ;                       ;  Convert number to hex string
                      ;                       ;  ----------------------------
A147                  cmdPRINT_num2str_hex                                    ; LA0CA
A147  3440                            PSHS    U
A149  0D27                            TST     ZP_VARTYPE                      ; real?
A14B  2A03                            BPL     1F                              ; no
A14D                                  CALL    fpReal2Int                      ;  Convert real to integer
A14D                  9
A14F                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0027                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A14D  BD9876                                  JSR     \1
                              ENDIF
A150                  1                                                       ; LA0D0:
A150  8E003F                          LDX     #ZP_FPB + 4
A153  CE002E                          LDU     #ZP_INT_WA + 4
A156  C604                            LDB     #4
A158  A6C2            1               LDA     ,-U                             ; unwind nibbles into a buffer
A15A  840F                            ANDA    #$0F
A15C  A780                            STA     ,X+
A15E  A6C4                            LDA     ,U                              ; reload for low nibble
A160  44                              LSRA
A161  44                              LSRA
A162  44                              LSRA
A163  44                              LSRA
A164  A780                            STA     ,X+
A166  5A                              DECB
A167  26EF                            BNE     1B
A169  C607                            LDB     #7                              ; note skip at most 7, print 0 for 0!
A16B                  1                                                       ; LA0EA
A16B  A682                            LDA     ,-X                             ; skip leading 0's
A16D  2603                            BNE     1F
A16F  5A                              DECB
A170  2AF9                            BPL     1B
A172                  1                                                       ; LA0F1
A172  810A                            CMPA    #10                             ; Get byte from workspace
A174  2502                            BLO     2F
A176  8B07                            ADDA    #'A'-'9'-1                      ; Convert byte to hex
A178                  2                                                       ; LA0F9
A178  8B30                            ADDA    #'0'
A17A                                  CALL    cmdPRINT_num2str_storeA         ;  Convert to digit and store
A17A                  9
A17C                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A17A  BDA363                                  JSR     \1
                              ENDIF
A17D  5A                              DECB
A17E  2B04                            BMI     3F
A180  A682                            LDA     ,-X
A182  20EE                            BRA     1B
A184  35C0            3               PULS    U,PC
                      
                      
                      ;                       ;  Loop for all digits
                      ;                       ;  Output nonzero real number
                      ;                       ;  --------------------------
A186                  cmdPRINT_num2str_realNon0                               ; LA102
A186  2A07                            BPL     cmdPRINT_num2str_realNon0_lp1   ;  Jump forward if positive
A188  862D                            LDA     #'-'
A18A  0F2E                            CLR     ZP_FPA                  ;  A='-', clear sign flag
A18C                                  CALL    cmdPRINT_num2str_storeA                         ;  Add '-' to string buffer
A18C                  9
A18E                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A18C  BDA363                                  JSR     \1
                              ENDIF
A18F                  cmdPRINT_num2str_realNon0_lp1                           ;LA10B:
A18F  9630                            LDA     ZP_FPA + 2                      ;  Get exponent
A191  8181                            CMPA    #$81
A193  244B                            BCC     cmdPRINT_num2str_digit                  ;  If m*2^1 or larger, number>=1, jump to output it
A195                                  CALL    fmMulBy10                       ;  FloatA=FloatA*10
A195                  9
A197                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A195  BDA4B6                                  JSR     \1
                              ENDIF
A198  0A48                            DEC     ZP_FP_TMP + 5
A19A  20F3                            BRA     cmdPRINT_num2str_realNon0_lp1   ;  Loop until number is >=1
                      
                      
                      ;                       ;  Convert numeric value to string
                      ;                       ;  ===============================
                      ;                       ;  On entry, FloatA ($2E-$35)   = number
                      ;                       ;            or IntA (ZP_INT_WA)= number
                      ;                       ;               ZP_VAR_TYPE     = type
                      ;                       ;               @%              = print format
                      ;                       ;               ZP_PRINTFLAG[7] = 1 if hex
                      ;                       ;  On exit,  StrA contains string version of number
                      ;                       ;
A19C                  cmdPRINT_num2str                                        ; LA118
A19C  F60401                          LDB     BASWKSP_INTVAR + 1              ;  Get @% format byte
A19F  C103                            CMPB    #$03
A1A1  2502                            BCS     cmdPRINT_num2str_skFMTOK        ;  Use it if valid
A1A3  C600                            LDB     #$00
                      ;                       ;  If @% invalid, use General format
A1A5                  cmdPRINT_num2str_skFMTOK                                ;LA121:
A1A5  D737                            STB     ZP_GEN_PTR                      ; Store format type
A1A7  B60402                          LDA     BASWKSP_INTVAR + 2              ; Num dec places
A1AA  2706                            BEQ     cmdPRINT_num2str_0dp            ; If digits is zero, check format
A1AC  810A                            CMPA    #$0A
A1AE  2406                            BCC     cmdPRINT_num2str_invaldp        ; If digits>10, jump to use 10 digits
A1B0  2006                            BRA     cmdPRINT_num2str_dp_sk          ; Use this number of digits
A1B2                  cmdPRINT_num2str_0dp                                    ; LA12E
A1B2  C102                            CMPB    #$02
A1B4  2702                            BEQ     cmdPRINT_num2str_dp_sk          ; If fixed format, use zero digits
A1B6                  cmdPRINT_num2str_invaldp                                ; LA132
A1B6  860A                            LDA     #$0A                            ; Otherwise, use ten digits
A1B8                  cmdPRINT_num2str_dp_sk                                  ; LA134
A1B8  9738                            STA     ZP_GEN_PTR + 1
A1BA  974D                            STA     ZP_FP_TMP + 10                  ;  Store digit length
A1BC  0F36                            CLR     ZP_STRBUFLEN
A1BE  0F48                            CLR     ZP_FP_TMP + 5                   ;  Set initial output to 0, initial exponent to 0
A1C0  0D15                            TST     ZP_PRINTFLAG
A1C2  2B83                            BMI     cmdPRINT_num2str_hex            ;  Jump for hex conversion
A1C4  0D27                            TST     ZP_VARTYPE
A1C6  2B03                            BMI     cmdPRINT_num2str_dec_sk1
A1C8                                  CALL    IntToReal                       ;  Convert integer to real
A1C8                  9
A1CA                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A1C8  BD856A                                  JSR     \1
                              ENDIF
A1CB                  cmdPRINT_num2str_dec_sk1                                ;LA146:
A1CB                                  CALL    fpCheckMant0SetSignExp0
A1CB                  9
A1CD                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A1CB  BDA47F                                  JSR     \1
                              ENDIF
A1CE  26B6                            BNE     cmdPRINT_num2str_realNon0       ; Get sign, jump if not zero to output nonzero number
A1D0  9637                            LDA     ZP_GEN_PTR
A1D2  10260084                        LBNE    cmdPRINT_num2str_fmtFixedOrExp0 ; If not General format, output fixed or exponential zero
A1D6  8630                            LDA     #'0'
A1D8                                  JUMP    cmdPRINT_num2str_storeA         ;  Store '0' and return
A1D8  7EA363                                  JMP     \1
A1DB                  setFloatA1_cmdPRINT_num2str_digit
A1DB                                  CALL    fpLoad1                         ;  FloatA=1.0
A1DB                  9
A1DD                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0035                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A1DB  BDA612                                  JSR     \1
                              ENDIF
A1DE  200F                            BRA     cmdPRINT_num2str_digit_sk2
                      
                      
                      ;                       ;  FloatA now is >=1, check that it is <10
                      ;                       ;  ---------------------------------------
A1E0                  cmdPRINT_num2str_digit                                  ; LA15C
A1E0  8184                            CMPA    #$84
A1E2  250F                            BCS     cmdPRINT_num2str_digit_1_9      ; Exponent<4, FloatA<10, jump to convert it
A1E4  2606                            BNE     cmdPRINT_num2str_digit_sk1      ; Exponent<>4, need to divide it
A1E6  9631                            LDA     ZP_FPA + 3                      ; Get mantissa top byte
A1E8  81A0                            CMPA    #$A0
A1EA  2507                            BCS     cmdPRINT_num2str_digit_1_9      ; Less than $A0, less than ten, jump to convert it
A1EC                  cmdPRINT_num2str_digit_sk1                              ; LA168:
A1EC                                  CALL    fpFloatADiv10                   ; FloatA=FloatA / 10
A1EC                  9
A1EE                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A1EC  BDA4EA                                  JSR     \1
                              ENDIF
A1EF                  cmdPRINT_num2str_digit_sk2                              ; LA16B:
A1EF  0C48                            INC     ZP_FP_TMP + 5                   ; incremenet exponent
A1F1  209C                            BRA     cmdPRINT_num2str_realNon0_lp1
                      ;                       ;  Jump back to get the number >=1 again
                      ;                       ;  FloatA is now between 1 and 9.999999999
                      ;                       ;  ---------------------------------------
A1F3                  cmdPRINT_num2str_digit_1_9                              ;LA16F:
A1F3  9635                            LDA     ZP_FPA + 7
A1F5  9727                            STA     ZP_VARTYPE
A1F7                                  CALL    fpCopyFPA_FPTEMP1                               ;  Copy FloatA to FloatTemp at $27/$046C
A1F7                  9
A1F9                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A1F7  BDA56C                                  JSR     \1
                              ENDIF
A1FA  964D                            LDA     ZP_FP_TMP + 10
A1FC  9738                            STA     ZP_GEN_PTR + 1                  ;  Get number of digits
A1FE  D637                            LDB     ZP_GEN_PTR                      ;  Get print format
A200  C102                            CMPB    #$02
A202  2612                            BNE     cmdPRINT_num2str_digit_1_9_sknf                         ;  Not fixed format, jump to do exponent/general
A204                                  SEC
A204  1A01                    ORCC    #CC_C
A206  9948                            ADCA    ZP_FP_TMP + 5
A208  2B54                            BMI     cmdPRINT_num2str_clearZeroFPAandPrintFMT2
A20A  9738                            STA     ZP_GEN_PTR + 1
A20C  810B                            CMPA    #$0B
A20E  2506                            BCS     cmdPRINT_num2str_digit_1_9_sknf
A210  860A                            LDA     #$0A
A212  9738                            STA     ZP_GEN_PTR + 1
A214  0F37                            CLR     ZP_GEN_PTR
A216                  cmdPRINT_num2str_digit_1_9_sknf                         ; LA190
A216                                  CALL    zero_FPA_sign_expO_manlo        ;  Clear FloatA
A216                  9
A218                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A216  BDA6F1                                  JSR     \1
                              ENDIF
A219  86A0                            LDA     #$A0
A21B  9731                            STA     ZP_FPA + 3
A21D  8683                            LDA     #$83
A21F  9730                            STA     ZP_FPA + 2
A221  D638                            LDB     ZP_GEN_PTR + 1
A223  270A                            BEQ     LA1A5
A225                  LA19F
A225  3404                            PSHS    B
A227                                  CALL    fpFloatADiv10                   ;  FloatA=FloatA/10
A227                  9
A229                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A227  BDA4EA                                  JSR     \1
                              ENDIF
A22A  3504                            PULS    B
A22C  5A                              DECB
A22D  26F6                            BNE     LA19F
A22F  8E046C          LA1A5           LDX     #BASWKSP_FPTEMP1                ;  Point to $46C
A232                                  CALL    fpMoveRealAtXtoFPB              ;  Unpack to FloatB
A232                  9
A234                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A232  BDA544                                  JSR     \1
                              ENDIF
A235  9627                            LDA     ZP_VARTYPE
A237  9741                            STA     ZP_FPB + 6
A239                                  CALL    fpAddAtoBStoreA                         ;  Add
A239                  9
A23B                  __XBSR                  SET 9B+2
E400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A239  BD871E                                  JSR     \1
                              ENDIF
A23C                  LA1B2
A23C  9630                            LDA     ZP_FPA + 2
A23E  8184                            CMPA    #$84
A240  240E                            BHS     LA1C6                           ; if >= $84
A242  0431                            LSR     ZP_FPA + 3
A244  0632                            ROR     ZP_FPA + 4
A246  0633                            ROR     ZP_FPA + 5
A248  0634                            ROR     ZP_FPA + 6
A24A  0635                            ROR     ZP_FPA + 7
A24C  0C30                            INC     ZP_FPA + 2
A24E  26EC                            BNE     LA1B2
A250                  LA1C6
A250  9631                            LDA     ZP_FPA + 3
A252  81A0                            CMPA    #$A0
A254  2485                            BHS     setFloatA1_cmdPRINT_num2str_digit
A256  9638                            LDA     ZP_GEN_PTR + 1
A258  260E                            BNE     LA1DE
A25A                  cmdPRINT_num2str_fmtFixedOrExp0
A25A  8101                            CMPA    #$01                            ; If format == 1 (exp)
A25C  2742                            BEQ     cmdPRINT_numstr_strAasDigLenPrintDigs
A25E                  cmdPRINT_num2str_clearZeroFPAandPrintFMT2               ; LA1D4
A25E                                  CALL    zero_FPA                        ; Clear FloatA
A25E                  9
A260                  __XBSR                  SET 9B+2
0400                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A25E  BDA6ED                                  JSR     \1
                              ENDIF
A261  0F48                            CLR     ZP_FP_TMP + 5                   ; clear 10's exponent
A263  964D                            LDA     ZP_FP_TMP + 10                  ; digit length
A265  4C                              INCA
A266  9738                            STA     ZP_GEN_PTR + 1
A268                  LA1DE
A268  8601                            LDA     #1
A26A  9137                            CMPA    ZP_GEN_PTR
A26C  2732                            BEQ     cmdPRINT_numstr_strAasDigLenPrintDigs                           ; if format == 1 (exp)
A26E  D648                            LDB     ZP_FP_TMP + 5                   ; B = 10's exponent
A270  2B0B                            BMI     cmdPRINT_numstr_printLead0point ; negative 10's exponent
A272  D138                            CMPB    ZP_GEN_PTR + 1
A274  242A                            BCC     cmdPRINT_numstr_strAasDigLenPrintDigs                           ; 
A276  0F48                            CLR     ZP_FP_TMP + 5
A278  5C                              INCB
A279  1F98                            TFR     B,A
A27B  2623                            BNE     cmdPRINT_numstr_strAasDigLenPrintDigs
A27D                  cmdPRINT_numstr_printLead0point                         ; LA1F2
A27D  9637                            LDA     ZP_GEN_PTR
A27F  8102                            CMPA    #$02                            ; if format == 2 (fixed)
A281  2706                            BEQ     cmdPRINT_numstr_print0point
A283  8601                            LDA     #1
A285  C1FF                            CMPB    #$FF
A287  2617                            BNE     cmdPRINT_numstr_strAasDigLenPrintDigs
A289                  cmdPRINT_numstr_print0point                             ; LA1FE
A289  8630                            LDA     #'0'
A28B                                  CALL    cmdPRINT_num2str_storeA         ; Output '0'
A28B                  9
A28D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A28B  BDA363                                  JSR     \1
                              ENDIF
A28E  862E                            LDA     #'.'
A290                                  CALL    cmdPRINT_num2str_storeA         ; Output '.'
A290                  9
A292                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A290  BDA363                                  JSR     \1
                              ENDIF
A293  8630                            LDA     #'0'                            ; Prepare '0'
A295                  cmdPRINT_numstr_print0point_lp                          ;LA20A:
A295  0C48                            INC     ZP_FP_TMP + 5
A297  2705                            BEQ     cmdPRINT_numstr_print0point_sk
A299                                  CALL    cmdPRINT_num2str_storeA         ; Output
A299                  9
A29B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A299  BDA363                                  JSR     \1
                              ENDIF
A29C  20F7                            BRA     cmdPRINT_numstr_print0point_lp
A29E                  cmdPRINT_numstr_print0point_sk                          ;LA213:
A29E  8680                            LDA     #$80
A2A0                  cmdPRINT_numstr_strAasDigLenPrintDigs                   ;
A2A0  974D                            STA     ZP_FP_TMP + 10
A2A2                  cmdPRINT_numstr_print_lp2                               ;LA217:
A2A2                                  CALL    cmdPRINT_numstr_printAhigh_nyb_asdigit_thenmul10
A2A2                  9
A2A4                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A2A2  8D51                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A2A4  0A4D                            DEC     ZP_FP_TMP + 10
A2A6  2605                            BNE     cmdPRINT_numstr_print_sk2
A2A8  862E                            LDA     #'.'
A2AA                                  CALL    cmdPRINT_num2str_storeA
A2AA                  9
A2AC                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A2AA  BDA363                                  JSR     \1
                              ENDIF
A2AD                  cmdPRINT_numstr_print_sk2                               ;LA223:
A2AD  0A38                            DEC     ZP_GEN_PTR + 1
A2AF  26F1                            BNE     cmdPRINT_numstr_print_lp2
A2B1  D637                            LDB     ZP_GEN_PTR
A2B3  5A                              DECB
A2B4  271A                            BEQ     cmdPRINT_numstr_print_exponent_exp                              ; format = 1 (exp)
A2B6  5A                              DECB
A2B7  2713                            BEQ     cmdPRINT_numstr_print_exponent_fix      ; format = 2 (fixed)
A2B9  D636                            LDB     ZP_STRBUFLEN
A2BB  8E0600                          LDX     #BAS_StrA
A2BE                  cmdPRINT_numstr_removetrail0_lp                         ; LA231
A2BE  5A                              DECB
A2BF  A685                            LDA     B,X
A2C1  8130                            CMPA    #'0'
A2C3  27F9                            BEQ     cmdPRINT_numstr_removetrail0_lp
A2C5  812E                            CMPA    #'.'
A2C7  2701                            BEQ     cmdPRINT_numstr_removetrail0_sk
A2C9  5C                              INCB
A2CA                  cmdPRINT_numstr_removetrail0_sk                         ; LA23E:
A2CA  D736                            STB     ZP_STRBUFLEN
A2CC                  cmdPRINT_numstr_print_exponent_fix                      ; LA240
A2CC  9648                            LDA     ZP_FP_TMP + 5
A2CE  2724                            BEQ     rtsLA26B
A2D0                  cmdPRINT_numstr_print_exponent_exp                      ; LA244
A2D0  8645                            LDA     #'E'
A2D2                                  CALL    cmdPRINT_num2str_storeA         ;  Output 'E'
A2D2                  9
A2D4                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A2D2  BDA363                                  JSR     \1
                              ENDIF
A2D5  9648                            LDA     ZP_FP_TMP + 5
A2D7  2A09                            BPL     cmdPRINT_numstr_print_exponent_exp_sk
A2D9  862D                            LDA     #'-'
A2DB                                  CALL    cmdPRINT_num2str_storeA         ; Output '-'
A2DB                  9
A2DD                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A2DB  BDA363                                  JSR     \1
                              ENDIF
A2DE  0048                            NEG     ZP_FP_TMP + 5                   ;  Negate
A2E0  9648                            LDA     ZP_FP_TMP + 5
A2E2                  cmdPRINT_numstr_print_exponent_exp_sk                   ; LA257:
A2E2                                  CALL    cmdPRINT_numstr_convert_10_1
A2E2                  9
A2E4                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A2E2  8D6B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A2E4  9637                            LDA     ZP_GEN_PTR
A2E6  270C                            BEQ     rtsLA26B
A2E8  8620                            LDA     #$20
A2EA  D648                            LDB     ZP_FP_TMP + 5
A2EC  2B02                            BMI     LA267
A2EE                                  CALL    cmdPRINT_num2str_storeA
A2EE                  9
A2F0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A2EE  8D73                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A2F0                  LA267
A2F0  C100                            CMPB    #$00
A2F2  276F                            BEQ     cmdPRINT_num2str_storeA
A2F4                  rtsLA26B
A2F4  39                              RTS
A2F5                  cmdPRINT_numstr_printAhigh_nyb_asdigit_thenmul10
A2F5  9631                            LDA     ZP_FPA + 3
A2F7  44                              LSRA
A2F8  44                              LSRA
A2F9  44                              LSRA
A2FA  44                              LSRA
A2FB                                  CALL    cmdPRINT_numstr_printAlow_nyb_asdigit
A2FB                  9
A2FD                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0064                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A2FB  8D64                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A2FD  860F                            LDA     #$0F
A2FF  9431                            ANDA    ZP_FPA + 3
A301  9731                            STA     ZP_FPA + 3
                      
                      
                      ;                       ;  FloatA=FloatA*10
                      ;                       ;  ----------------
A303                  parseDMul10                                     ;LA279 - TODO, speed up, make 16 bitted                          
A303  3402                            PSHS    A
A305  D634                            LDB     ZP_FPA + 6
A307  9631                            LDA     ZP_FPA + 3
A309  3402                            PSHS    A
A30B  9632                            LDA     ZP_FPA + 4
A30D  3402                            PSHS    A
A30F  9633                            LDA     ZP_FPA + 5
A311  3402                            PSHS    A
A313  9635                            LDA     ZP_FPA + 7
A315  48                              ASLA
A316  0934                            ROL     ZP_FPA + 6
A318  0933                            ROL     ZP_FPA + 5
A31A  0932                            ROL     ZP_FPA + 4
A31C  0931                            ROL     ZP_FPA + 3
A31E  48                              ASLA
A31F  0934                            ROL     ZP_FPA + 6
A321  0933                            ROL     ZP_FPA + 5
A323  0932                            ROL     ZP_FPA + 4
A325  0931                            ROL     ZP_FPA + 3
A327  9935                            ADCA    ZP_FPA + 7
A329  9735                            STA     ZP_FPA + 7
A32B  1F98                            TFR     B,A
A32D  9934                            ADCA    ZP_FPA + 6
A32F  9734                            STA     ZP_FPA + 6
A331  3502                            PULS    A
A333  9933                            ADCA    ZP_FPA + 5
A335  9733                            STA     ZP_FPA + 5
A337  3502                            PULS    A
A339  9932                            ADCA    ZP_FPA + 4
A33B  9732                            STA     ZP_FPA + 4
A33D  3502                            PULS    A
A33F  9931                            ADCA    ZP_FPA + 3
A341  0835                            ASL     ZP_FPA + 7
A343  0934                            ROL     ZP_FPA + 6
A345  0933                            ROL     ZP_FPA + 5
A347  0932                            ROL     ZP_FPA + 4
A349  49                              ROLA
A34A  9731                            STA     ZP_FPA + 3
A34C  3502                            PULS    A
A34E  39                              RTS
                      
                      
                      
                                      ; convert number, B ends up counting 10's, A ends up containing units
A34F                  cmdPRINT_numstr_convert_10_1                            ; LA2BC
A34F  1F89                            TFR     A,B
A351  86FF                            LDA     #$FF
A353                  LA2BF
A353  4C                              INCA
A354  C00A                            SUBB    #$0A
A356  24FB                            BCC     LA2BF
A358  CB0A                            ADDB    #$0A
A35A  4D                              TSTA
A35B  2702                            BEQ     LA2CD
A35D                                  CALL    cmdPRINT_numstr_printAlow_nyb_asdigit   ; if not 0 print 10's
A35D                  9
A35F                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A35D  8D02                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A35F                  LA2CD
A35F  1F98                            TFR     B,A                             ; print 1's
A361                  cmdPRINT_numstr_printAlow_nyb_asdigit                   ; LA2CE
A361  8A30                            ORA     #'0'
                      
                      ;                       ;  Store character in string buffer
                      ;                       ;  --------------------------------
A363                  cmdPRINT_num2str_storeA                                 ; LA2D0
A363  3414                            PSHS    B,X
A365  D636                            LDB     ZP_STRBUFLEN
A367  8E0600                          LDX     #BAS_StrA
A36A  3A                              ABX
A36B  A784                            STA     ,X                              ; Store character
A36D  0C36                            INC     ZP_STRBUFLEN
A36F  3594                            PULS    B,X,PC                          ;  Increment string length
                      
A371                  parseDecNAN                                             ; LA2DA
A371                                  CALL    fpSetSignExp0                   ;  Set IntA to zero
A371                  9
A373                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A371  BDA491                                  JSR     \1
                              ENDIF
A374                                  CLC                                     ;  CLC=no number, return Real
A374  1CFE                    ANDCC   #~CC_C
A376  86FF                            LDA     #$FF
A378  39                              RTS
                      
                      
                      ;                       ;  Scan decimal number
                      ;                       ;  -------------------
A379                  parseDecimalLiteral
A379  0F31                            CLR     ZP_FPA + 3
A37B  0F32                            CLR     ZP_FPA + 4
A37D  0F33                            CLR     ZP_FPA + 5                      ;  Clear FloatA
A37F  0F34                            CLR     ZP_FPA + 6
A381  0F35                            CLR     ZP_FPA + 7
A383  0F47                            CLR     ZP_FP_TMP + 4                   ;  Clear 'Decimal point found'
A385  0F48                            CLR     ZP_FP_TMP + 5                   ;  Set exponent to zero
A387  812E                            CMPA    #'.'
A389  272B                            BEQ     parseD_skDPFound                ;  Decimal point
A38B  8139                            CMPA    #'9'
A38D  22E2                            BHI     parseDecNAN                     ;  Not a decimal digit, return 'no number'
A38F  8030                            SUBA    #'0'
A391  25DE                            BLO     parseDecNAN                     ;  Convert to binary, if not digit, return 'no number'
A393  9735                            STA     ZP_FPA + 7                      ;  Store digit
A395  A6C0                            LDA     ,U+                             ;  Get next character
A397  8139                            CMPA    #'9'
A399  2223                            BHI     parseD_sknotdp                  ;  Not a digit, check for E or end of number
A39B  8030                            SUBA    #'0'
A39D  2511                            BLO     parseD_sknotdig                 ;  Not a digit, check for decimal point
A39F  972E                            STA     ZP_FPA                          ;  Store this digit
A3A1  9635                            LDA     ZP_FPA + 7
A3A3  48                              ASLA
A3A4  48                              ASLA                                    ;  A=num*4
A3A5  9B35                            ADDA    ZP_FPA + 7
A3A7  48                              ASLA                                    ;  A=(num*4+num)*2 = num*10
A3A8  9B2E                            ADDA    ZP_FPA
A3AA  9735                            STA     ZP_FPA + 7                      ;  num=num*10+digit
A3AC  A6C0            parseD_lp1      LDA     ,U+                             ;  Step to next character       
A3AE  2002                            BRA     1F                              ; TODO: this is a bit of a kludge, maybe make '.' do branch?
A3B0  A65F            parseD_sknotdig LDA     -1,U                            ; reload previous char
A3B2  812E            1               CMPA    #'.'
A3B4  2608                            BNE     parseD_sknotdp                  ;  Not decimal point, jump to check if digit
A3B6                  parseD_skDPFound
A3B6  9647                            LDA     ZP_FP_TMP + 4
A3B8  2643                            BNE     parseD_skDone                           ;  If already have a decimal point, finish
A3BA  0C47                            INC     ZP_FP_TMP + 4
A3BC  20EE                            BRA     parseD_lp1                      ;  Set 'decimal point found', and get next digit
                      
                      
                      
                      ;                       ;  First two digits processed, scan rest of number
                      ;                       ;  -----------------------------------------------
A3BE                  parseD_sknotdp
A3BE  8145                            CMPA    #'E'
A3C0  2735                            BEQ     parseD_skScanExp        ;  Jump to scan exponent
A3C2  8139                            CMPA    #'9'
A3C4  2237                            BHI     parseD_skDone           ;  Not a digit, jump to finish
A3C6  8030                            SUBA    #'0'
A3C8  2533                            BLO     parseD_skDone           ;  Not a digit, jump to finish
A3CA  D631                            LDB     ZP_FPA + 3              ;  Get mantissa top byte
A3CC  C11A                            CMPB    #26
A3CE  2508                            BLO     parseD_sk2              ;  If <=25, still small enough to add to
A3D0  0D47                            TST     ZP_FP_TMP + 4
A3D2  26D8                            BNE     parseD_lp1              ;  Decimal point found, skip digits until end of number
A3D4  0C48                            INC     ZP_FP_TMP + 5
A3D6  20D4                            BRA     parseD_lp1              ;  No decimal point, increment exponent and loop skip digits
A3D8  0D47            parseD_sk2      TST     ZP_FP_TMP + 4
A3DA  2702                            BEQ     parseD_sk1
A3DC  0A48                            DEC     ZP_FP_TMP + 5           ;  Decimal point found, decrement exponent
A3DE                  parseD_sk1      CALL    parseDMul10             ;  Multiply FloatA by 10
A3DE                  9
A3E0                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A3DE  BDA303                                  JSR     \1
                              ENDIF
A3E1  9B35                            ADDA    ZP_FPA + 7
A3E3  9735                            STA     ZP_FPA + 7              ;  Add digit to mantisa low byte
A3E5  24C5                            BCC     parseD_lp1              ;  No overflow
A3E7  0C34                            INC     ZP_FPA + 6
A3E9  26C1                            BNE     parseD_lp1              ;  Add carry through mantissa
A3EB  0C33                            INC     ZP_FPA + 5
A3ED  26BD                            BNE     parseD_lp1
A3EF  0C32                            INC     ZP_FPA + 4
A3F1  26B9                            BNE     parseD_lp1
A3F3  0C31                            INC     ZP_FPA + 3
A3F5  20B5                            BRA     parseD_lp1              ;  Loop to check next digit
                                      
                      ;                       ;  Deal with Exponent in scanned number
                      ;                       ;  ------------------------------------
A3F7                  parseD_skScanExp
A3F7                                  CALL    parseD_scanExp                  ;  Scan following number
A3F7                  9
A3F9                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A3F7  8D5A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A3F9  9B48                            ADDA    ZP_FP_TMP + 5
A3FB  9748                            STA     ZP_FP_TMP + 5           ;  Add to current exponent
                      
                      ;                       ;  End of number found
                      ;                       ;  -------------------
A3FD  335F            parseD_skDone   LEAU    -1,U
A3FF  DF19                            STU     ZP_TXTPTR2              ;  Store PtrB offset
A401  9648                            LDA     ZP_FP_TMP + 5
A403  9A47                            ORA     ZP_FP_TMP + 4           ;  Check exponent and 'decimal found'
A405  272D                            BEQ     parseD_skReturnInt      ;  No exp, no dec, jump to return integer
A407                                  CALL    fpCheckMant0SetSignExp0
A407                  9
A409                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A407  8D76                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A409  2724                            BEQ     parseD_skReturnInt0
A40B                  parseD_skNormalise
A40B  86A8                            LDA     #$A8
A40D  9730                            STA     ZP_FPA + 2
A40F  0F2F                            CLR     ZP_FPA + 1
A411  0F2E                            CLR     ZP_FPA
A413                                  CALL    NormaliseRealA
A413                  9
A415                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A413  BD85D1                                  JSR     \1
                              ENDIF
A416  9648                            LDA     ZP_FP_TMP + 5
A418  2B0B                            BMI     parseD_lp3
A41A  2710                            BEQ     parseD_sk3
A41C                  parseD_lp2      CALL    fmMulBy10
A41C                  9
A41E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0098                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A41C  BDA4B6                                  JSR     \1
                              ENDIF
A41F  0A48                            DEC     ZP_FP_TMP + 5
A421  26F9                            BNE     parseD_lp2
A423  2007                            BRA     parseD_sk3
A425                  parseD_lp3      CALL    fpFloatADiv10
A425                  9
A427                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A425  BDA4EA                                  JSR     \1
                              ENDIF
A428  0C48                            INC     ZP_FP_TMP + 5
A42A  26F9                            BNE     parseD_lp3
A42C                  parseD_sk3              CALL fpRoundMantissaFPA
A42C                  9
A42E                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A42C  BDA6CB                                  JSR     \1
                              ENDIF
A42F                  parseD_skReturnInt0
A42F                                  SEC
A42F  1A01                    ORCC    #CC_C
A431  86FF                            LDA     #$FF
A433  39                              RTS
A434                  parseD_skReturnInt
A434  9632                            LDA     ZP_FPA + 4             ; TODO - optimise using D - not sure if we need B preserved tho
A436  972A                            STA     ZP_INT_WA + 0          ; DB - endiannes change
A438  8480                            ANDA    #$80
A43A  9A31                            ORA     ZP_FPA + 3
A43C  26CD                            BNE     parseD_skNormalise
A43E  9635                            LDA     ZP_FPA + 7
A440  972D                            STA     ZP_INT_WA + 3
A442  9634                            LDA     ZP_FPA + 6
A444  972C                            STA     ZP_INT_WA + 2
A446  9633                            LDA     ZP_FPA + 5
A448  972B                            STA     ZP_INT_WA + 1
A44A  8640                            LDA     #$40
A44C                                  SEC
A44C  1A01                    ORCC    #CC_C
A44E  39                              RTS
A44F                  parseD_skNegExp                                         ;LA3B3
A44F                                  CALL    parseD_scanExpReadDigits                                ;  Scan following number
A44F                  9
A451                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A44F  8D0C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A451  40                              NEGA                                    ; complement it
A452  39                              RTS                             ;  Negate it, return CS=Ok
                      ;                       ;  Scan exponent, allows E E+ E- followed by one or two digits
                      ;                       ;  -----------------------------------------------------------
A453                  parseD_scanExp
A453  A6C0                            LDA     ,U+                             ;  Get next character
A455  812D                            CMPA    #'-'
A457  27F6                            BEQ     parseD_skNegExp                 ;  Jump to scan and negate
A459  812B                            CMPA    #'+'
A45B  2602                            BNE     parseD_scanExpSkipNotPlus       ;  If '+', just step past it
A45D                  parseD_scanExpReadDigits                                ; LA3C5
A45D  A6C0                            LDA     ,U+     ;                       ;  Get next character
A45F                  parseD_scanExpSkipNotPlus                               ; LA3C8
A45F  8139                            CMPA    #'9'
A461  221A                            BHI     parseD_scanExpSkipRet0          ;  Not a digit, exit with CC
A463  8030                            SUBA    #'0'
A465  2516                            BCS     parseD_scanExpSkipRet0          ;  Not a digit, exit with CC
A467  E6C0                            LDB     ,U+                             ;  Get next character in B!
A469  C139                            CMPB    #'9'
A46B  220F                            BHI     parseD_scanExpSkipRetA          ;  Not a digit, exit with CC=Ok
A46D  C030                            SUBB    #'0'
A46F  250B                            BCS      parseD_scanExpSkipRetA         ;  Not a digit, exit with CC=Ok
A471  3404                            PSHS    B
A473  C60A                            LDB     #10
A475  3D                              MUL                                     ; multiply A by 10
A476  1F98                            TFR     B,A                             ; into A
A478  ABE0                            ADDA    ,S+                             ; add second digit
A47A  3341                            LEAU    1,U                             ; skip forward one, it gets put back later!
A47C                  parseD_scanExpSkipRetA
A47C  39                              RTS
                                              ;  exp=exp*10+digit
A47D                  parseD_scanExpSkipRet0                                  ; go back one and return 0
A47D  4F                              CLRA
A47E  39                              RTS
                                              ;  Return exp=0 and return CC=Ok
                                              ;  IsZero?
                                              ;  -------
A47F                  fpCheckMant0SetSignExp0
A47F  9631                            LDA     ZP_FPA + 3              ; Mantissa MSB  ; TODO use D?
A481  9A32                            ORA     ZP_FPA + 4              
A483  9A33                            ORA     ZP_FPA + 5
A485  9A34                            ORA     ZP_FPA + 6
A487  9A35                            ORA     ZP_FPA + 7              ; Mantissa LSB
A489  2706                            BEQ     fpSetSignExp0
A48B  962E                            LDA     ZP_FPA          ; sign
A48D  2608                            BNE     anRTS5
A48F  4C                              INCA                            ; return A=1, Z=0, PL
A490  39                              RTS
                      ;                       ;  Return zero
                      ;                       ;  -----------
A491                  fpSetSignExp0
A491  0F2E                            CLR     ZP_FPA
A493  0F30                            CLR     ZP_FPA + 2
A495  0F2F                            CLR     ZP_FPA + 1
A497  39              anRTS5          RTS
                      
A498                  fpCopyFPAtoFPB
A498  962E                            LDA     ZP_FPA
A49A  973B                            STA     ZP_FPB                  ; copy sign
A49C  DC30                            LDD     ZP_FPA + 2
A49E  DD3C                            STD     ZP_FPB + 1
A4A0  DC32                            LDD     ZP_FPA + 4
A4A2  DD3E                            STD     ZP_FPB + 3
A4A4  DC34                            LDD     ZP_FPA + 6
A4A6  DD40                            STD     ZP_FPB + 5
A4A8  39                              RTS
A4A9                  fpCopyFPAtoFPBAndShiftRight
A4A9                                  CALL    fpCopyFPAtoFPB
A4A9                  9
A4AB                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00ED                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4A9  8DED                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4AB                  fpShiftBMantissaRight
A4AB  043D                            LSR     ZP_FPB + 2
A4AD  063E                            ROR     ZP_FPB + 3
A4AF  063F                            ROR     ZP_FPB + 4
A4B1  0640                            ROR     ZP_FPB + 5
A4B3  0641                            ROR     ZP_FPB + 6
A4B5  39                              RTS
A4B6                  fmMulBy10                                               ; LA436
A4B6  DC2F                            LDD     ZP_FPA + 1                      ; mantissa + 3 (i.e. * 8)
A4B8  C30003                          ADDD    #$03
A4BB  DD2F                            STD     ZP_FPA + 1
A4BD                                  CALL    fpCopyFPAtoFPBAndShiftRight     ; fpB = fpA / 4 i.e.
A4BD                  9
A4BF                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4BD  8DEA                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4BF                                  CALL    fpShiftBMantissaRight           ; note C is brought in here!
A4BF                  9
A4C1                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4BF  8DEA                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4C1                  fpAddAtoBstoreinA_sameExp
A4C1  DC34                            LDD     ZP_FPA + 6
A4C3  D941                            ADCB    ZP_FPB + 6
A4C5  9940                            ADCA    ZP_FPB + 5
A4C7  DD34                            STD     ZP_FPA + 6
                      
A4C9  DC32                            LDD     ZP_FPA + 4              
A4CB  D93F                            ADCB    ZP_FPB + 4
A4CD  993E                            ADCA    ZP_FPB + 3
A4CF  DD32                            STD     ZP_FPA + 4
                      
A4D1  9631                            LDA     ZP_FPA + 3
A4D3  993D                            ADCA    ZP_FPB + 2
A4D5  9731                            STA     ZP_FPA + 3
A4D7  2410                            BCC     anRTS11
A4D9                  fpRORMantAincExp
A4D9  0631                            ROR     ZP_FPA + 3
A4DB  0632                            ROR     ZP_FPA + 4
A4DD  0633                            ROR     ZP_FPA + 5
A4DF  0634                            ROR     ZP_FPA + 6
A4E1  0635                            ROR     ZP_FPA + 7
A4E3  0C30                            INC     ZP_FPA + 2
A4E5  2602                            BNE     anRTS11
A4E7  0C2F                            INC     ZP_FPA + 1
A4E9  39              anRTS11         RTS
A4EA                  fpFloatADiv10                                           ; LA478
A4EA  9630                            LDA     ZP_FPA + 2                      ; exponent low
A4EC  8004                            SUBA    #4
A4EE  9730                            STA     ZP_FPA + 2
A4F0  2402                            BCC     fpFloatADiv10_sk1
A4F2  0A2F                            DEC     ZP_FPA + 1
A4F4                  fpFloatADiv10_sk1                                       ; LA483:
A4F4                                  CALL    fpCopyFPAtoFPBAndShiftRight
A4F4                  9
A4F6                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4F4  8DB3                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4F6                                  CALL    fpAddAtoBstoreinA_sameExp
A4F6                  9
A4F8                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4F6  8DC9                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4F8                                  CALL    fpCopyFPAtoFPBAndShiftRight
A4F8                  9
A4FA                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4F8  8DAF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4FA                                  CALL    fpShiftBMantissaRight
A4FA                  9
A4FC                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4FA  8DAF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4FC                                  CALL    fpShiftBMantissaRight
A4FC                  9
A4FE                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4FC  8DAD                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A4FE                                  CALL    fpShiftBMantissaRight
A4FE                  9
A500                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A4FE  8DAB                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A500                                  CALL    fpAddAtoBstoreinA_sameExp
A500                  9
A502                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A500  8DBF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A502  0F3D                            CLR     ZP_FPB + 2
A504  DC31                            LDD     ZP_FPA + 3
A506  DD3E                            STD     ZP_FPB + 3
A508  DC33                            LDD     ZP_FPA + 5
A50A  DD40                            STD     ZP_FPB + 5
A50C  9635                            LDA     ZP_FPA + 7
A50E  49                              ROLA
A50F                                  CALL    fpAddAtoBstoreinA_sameExp
A50F                  9
A511                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A50F  8DB0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A511  0F3E                            CLR     ZP_FPB + 3                      ; TODO - 16 bit this!
                      
A513  9631                            LDA     ZP_FPA + 3
A515  973F                            STA     ZP_FPB + 4
                      
A517  9632                            LDA     ZP_FPA + 4
A519  9740                            STA     ZP_FPB + 5
A51B  9633                            LDA     ZP_FPA + 5
A51D  9741                            STA     ZP_FPB + 6              
A51F  9634                            LDA     ZP_FPA + 6
A521  49                              ROLA
A522                                  CALL    fpAddAtoBstoreinA_sameExp
A522                  9
A524                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A522  8D9D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A524  9632                            LDA     ZP_FPA + 4
A526  49                              ROLA
A527  9631                            LDA     ZP_FPA + 3
A529  9935                            ADCA    ZP_FPA + 7
A52B  9735                            STA     ZP_FPA + 7
A52D  2412                            BCC     rtsLA4DF
A52F  0C34                            INC     ZP_FPA + 6
A531  260E                            BNE     rtsLA4DF
A533                  fpIncFPAMantMSBs                                        ; LA4D3
A533  0C33                            INC     ZP_FPA + 5                      ; TODO more 16 bitting?
A535  260A                            BNE     rtsLA4DF
A537  0C32                            INC     ZP_FPA + 4
A539  2606                            BNE     rtsLA4DF
A53B  0C31                            INC     ZP_FPA + 3
A53D                                  SEC
A53D  1A01                    ORCC    #CC_C
A53F  2798                            BEQ     fpRORMantAincExp
A541                  rtsLA4DF
A541  39                              RTS
A542                  fpMoveRealAtPTR1toFPB
A542  9E4A                            LDX     ZP_FP_TMP_PTR1
A544                  fpMoveRealAtXtoFPB
                      *               PSHS    B                               ; TODO - check if needed
A544  0F41                            CLR     ZP_FPB + 6                      ; zero overflow
A546  EC03                            LDD     3,X                             ; copy mantissa low bytes
A548  DD3F                            STD     ZP_FPB + 4
                      
A54A  EC01                            LDD     1,X                             ; copy mantissa msb into sign bit and next into mantissa
A54C  D73E                            STB     ZP_FPB + 3
A54E  973B                            STA     ZP_FPB
                      
A550  E684                            LDB     ,X                              ; get exponent
A552  D73C                            STB     ZP_FPB + 1                      ; store
A554  2608                            BNE     fpMoveRealAtXtoFPB_sk1          ; if not 0 continue
A556  9A3E                            ORA     ZP_FPB + 3
A558  9A3F                            ORA     ZP_FPB + 4
A55A  9A40                            ORA     ZP_FPB + 5
A55C  2704                            BEQ     fpMoveRealAtXtoFPB_sk2          ; if rest is zero were done just store 0
A55E                  fpMoveRealAtXtoFPB_sk1
A55E  963B                            LDA     ZP_FPB                          ; get back mantissa MSB from sign 
A560  8A80                            ORA     #$80                            ; set top bit
A562                  fpMoveRealAtXtoFPB_sk2
A562  973D                            STA     ZP_FPB + 2                      ; store in mantissa
A564  39                              RTS
                      ;               
                      ;               
                      ;               
A565                  fpCopyFPA_FPTEMP3                                       ; LA50D
A565  8E0476                          LDX     #BASWKSP_FPTEMP3
A568  9F4A                            STX     ZP_FP_TMP_PTR1                  ; TODO - this may seem unnecessary but there are functions that expect PTR1 to point to last used location
A56A  2007                            BRA     fpCopyFPA_X
A56C                  fpCopyFPA_FPTEMP1                                       ; LA511
A56C  8E046C                          LDX     #BASWKSP_FPTEMP1
A56F  9F4A                            STX     ZP_FP_TMP_PTR1                  ; TODO - this may seem unnecessary but there are functions that expect PTR1 to point to last used location
                      ;;              BRA     fpCopyFPA_X
A571                  fpCopyFPA_PTR1
A571  9E4A                            LDX     ZP_FP_TMP_PTR1
A573                  fpCopyFPA_X
A573  9630                            LDA     ZP_FPA + 2
A575  A780                            STA     ,X+
A577  962E                            LDA     ZP_FPA
A579  9831                            EORA    ZP_FPA + 3
A57B  8480                            ANDA    #$80
A57D  9831                            EORA    ZP_FPA + 3
A57F  A780                            STA     ,X+
A581  9632                            LDA     ZP_FPA + 4
A583  A780                            STA     ,X+
A585  9633                            LDA     ZP_FPA + 5
A587  A780                            STA     ,X+
A589  9634                            LDA     ZP_FPA + 6
A58B  A784                            STA     ,X
A58D  39                              RTS
                      
                      
A58E                  fpCopyFPTEMP1toFPA                              ; LA539
                                      ; note now trashes X
A58E  8E046C                          LDX     #BASWKSP_FPTEMP1
A591  2002                            BRA     fpCopyXtoFPA
                      ;;fpCopyXtoFPA--was 400+A                               ; LA53B
                      ;;;             STA ZP_FP_TMP_PTR1
                      ;;;             LDA #$04
                      ;;;             STA ZP_FP_TMP_PTR1 + 1
                      
                      
A593                  fpCopyPTR1toFPA
A593  9E4A                            LDX     ZP_FP_TMP_PTR1
A595                  fpCopyXtoFPA
                      *               PSHS    B                               ; TODO - check if needed
A595  4F                              CLRA
A596  9735                            STA     ZP_FPA + 7                      ; zero overflow
A598  972F                            STA     ZP_FPA + 1                      ; zero overflow exp
A59A  EC03                            LDD     3,X                             ; copy mantissa low bytes
A59C  DD33                            STD     ZP_FPA + 5
                      
A59E  EC01                            LDD     1,X                             ; copy mantissa msb into sign bit and next into mantissa
A5A0  D732                            STB     ZP_FPA + 4
A5A2  972E                            STA     ZP_FPA
                      
A5A4  E684                            LDB     ,X                              ; get exponent
A5A6  D730                            STB     ZP_FPA + 2                      ; store
A5A8  2608                            BNE     fpCopyXtoFPA_sk1                ; if not 0 continue
A5AA  9A32                            ORA     ZP_FPA + 4
A5AC  9A33                            ORA     ZP_FPA + 5
A5AE  9A34                            ORA     ZP_FPA + 6
A5B0  2704                            BEQ     fpCopyXtoFPA_sk2                ; if rest is zero were done just store 0
A5B2                  fpCopyXtoFPA_sk1
A5B2  962E                            LDA     ZP_FPA                  ; get back mantissa MSB from sign 
A5B4  8A80                            ORA     #$80                            ; set top bit
A5B6                  fpCopyXtoFPA_sk2
A5B6  9731                            STA     ZP_FPA + 3                      ; store in mantissa
A5B8  39                              RTS
                      
                      
                      
A5B9  0F3B            fpSetRealBto0   CLR ZP_FPB
A5BB  0F3C                            CLR ZP_FPB + 1
A5BD  0F3D                            CLR ZP_FPB + 2
A5BF                  fpSetRealBMantTo0
A5BF  0F3E                            CLR ZP_FPB + 3
A5C1  0F3F                            CLR ZP_FPB + 4
A5C3  0F40                            CLR ZP_FPB + 5
A5C5  0F41                            CLR ZP_FPB + 6
A5C7  39                              RTS
                      
A5C8                  fpAdd5toPTR2copytoPTR1                          ; LA57F
A5C8  9E4C                            LDX     ZP_FP_TMP_PTR2
A5CA  3005                            LEAX    5,X
A5CC  9F4C                            STX     ZP_FP_TMP_PTR2
A5CE  9F4A                            STX     ZP_FP_TMP_PTR1
A5D0  39                              RTS
                      
                      
                      
                      ;;;; TODO Check whether any of these are needed should use X and 
                      ;;;;fpPTR1==pi/2:                               ; LA589
                      ;;;;            LDA #<fpConstPiDiv2
                      ;;;;fpPTR1==constant at A (near pi/2):          ; LA58B
                      ;;;;            STA ZP_FP_TMP_PTR1
                      ;;;;            LDA #>fpConstPiDiv2
                      ;;;;            STA ZP_FP_TMP_PTR1 + 1
                      ;;;;            RTS
                      ;;;FPPTR1=BASWKSP_FPTEMP1:                      ; LA592
                      ;;;             LDA #$6C
                      ;;;FPPTR1=BASWKSP_400+A:                        ; LA594
                      ;;;             STA ZP_FP_TMP_PTR1
                      ;;;             LDA #$04
                      ;;;             STA ZP_FP_TMP_PTR1 + 1
                      ;;;             RTS
A5D1                  fnTAN                   ; LA59B!
A5D1                                  CALL    trigNormaltheta
A5D1                  9
A5D3                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5D1  BDA98E                                  JSR     \1
                              ENDIF
A5D4  8E047B                          LDX     #BASWKSP_FPTEMP4
A5D7                                  CALL    fpCopyFPA_X                     ; save theta to FPTEMP4
A5D7                  9
A5D9                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5D7  8D9A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5D9                                  CALL    fnSIN_internal1         ; get sin theta
A5D9                  9
A5DB                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0090                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5D9  BDA96B                                  JSR     \1
                              ENDIF
A5DC  8E0476                          LDX     #BASWKSP_FPTEMP3
A5DF                                  CALL    fpCopyFPA_X                     ; save sin theta to FPTEMP3
A5DF                  9
A5E1                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5DF  8D92                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5E1  8E047B                          LDX     #BASWKSP_FPTEMP4
A5E4                                  CALL    fpCopyXtoFPA                    ; get back theta from FPTEMP4
A5E4                  9
A5E6                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5E4  8DAF                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5E6                                  CALL    fnCOS_internal1                 ; get cos theta
A5E6                  9
A5E8                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A5E6  BDA969                                  JSR     \1
                              ENDIF
A5E9                  LA5B3
A5E9  8E0476                          LDX     #BASWKSP_FPTEMP3
A5EC  9F4A                            STX     ZP_FP_TMP_PTR1
A5EE                                  CALL    fpFPAeqPTR1divFPA
A5EE                  9
A5F0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0035                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5EE  8D35                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5F0  86FF                            LDA     #$FF
A5F2  39                              RTS
A5F3                  LA5BE
A5F3  1F89                            TFR     A,B
A5F5  5D                              TSTB
A5F6  2A07                            BPL     LA5C9
A5F8  40                              NEGA
A5F9  3402                            PSHS    A
A5FB                                  CALL    fpFPAeq1.0divFPA
A5FB                  9
A5FD                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A5FB  8D23                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A5FD  3504                            PULS    B
A5FF                  LA5C9
A5FF  2711                            BEQ     fpLoad1                 ;  Floata=1.0
A601                                  CALL    fpCopyFPA_FPTEMP1
A601                  9
A603                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A601  BDA56C                                  JSR     \1
                              ENDIF
A604  5A                              DECB
A605  270A                            BEQ     LA5D7
A607  3404            LA5D1           PSHS    B
A609                                  CALL    fpFPAeqPTR1mulFPA
A609                  9
A60B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A609  BDA6DC                                  JSR     \1
                              ENDIF
A60C  3504                            PULS    B
A60E  5A                              DECB
A60F  26F6                            BNE     LA5D1
A611                  LA5D7
A611  39                              RTS
                      ;                       ;  FloatA=1.0
                      ;                       ;  ----------
A612                  fpLoad1
A612  8680                            LDA     #$80
A614  9731                            STA     ZP_FPA + 3                      ;  Set mantissa = $80000000
A616  4C                              INCA
A617  9730                            STA     ZP_FPA + 2                      ;  Set exponent = $81 - exp=2^1
A619                                  JUMP    zero_FPA_sign_expO_manlo                ;  Zero rest of mantissa
A619  7EA6F1                                  JMP     \1
A61C                  tblDivConsts
A61C  02080808                        FCB     $02,$08,$08,$08
A620                  fpFPAeq1.0divFPA                                        ; LA5E9
A620                                  LDX_FPC fpConst1
A620  8EBE51                                  LDX     #\1             ; leave as LDX for now for faster execution
A623  9F4A                            STX     ZP_FP_TMP_PTR1
A625                  fpFPAeqPTR1divFPA
                      
A625  9631                            LDA     ZP_FPA + 3
A627  1027DF2C                        LBEQ    brkDivideByZero                 ; if MSB of divisor mantissa 0 then error
A62B                                  CALL    fpMoveRealAtPTR1toFPB           ; get dividend, if zero return 0
A62B                  9
A62D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0015                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A62B  BDA542                                  JSR     \1
                              ENDIF
A62E  2603                            BNE     1F
A630                                  JUMP    zero_FPA
A630  7EA6ED                                  JMP     \1
                      
A633                  1                                                       ;LA5FA:
                      ;;              STU     ZP_TXTPTR
                              IF CPU_6309
                                      PSHSW                                   
                              ENDIF
A633  DC3B                            LDD     ZP_FPB                          ; get b for use below
A635  982E                            EORA    ZP_FPA
A637  972E                            STA     ZP_FPA                          ; store quotient sign in sign of FPA
                      
                      ;;              LDB     ZP_FPB + 1                      ; B got in LDD above
A639  4F                              CLRA
A63A  C30081                          ADDD    #$81
A63D  932F                            SUBD    ZP_FPA + 1
A63F  DD2F                            STD     ZP_FPA + 1                      ; subtract divisor exponent from quotient exponent and add 1
                      
A641  8E0005                          LDX     #$05
A644  C608                            LDB     #$08
A646  D73C                            STB     ZP_FPB+1
                              IF CPU_6309
                                      LDW     ZP_FPB + 2                      ; cache top bits of mantissa
                              ENDIF
A648  200B                            BRA     LA622
A64A                  LA619
A64A  E78842                          STB     ZP_FP_TMP-1,X                   ; store ZP_FPB from end of loop
A64D  E689A61B                        LDB     tblDivConsts-1,X                ; get new loop counter value from table
A651  D73C                            STB     ZP_FPB+1
A653                  LA620
A653  2518                            BCS     LA638                           ; carry here has come from ROLA at POINT X
A655                  LA622
                              IF CPU_6309
                                      LDD     ZP_FPA + 3
                                      CMPR    W,D
                              ELSE
A655  9631                            LDA     ZP_FPA + 3                      ; this is kept as 8 bit for speed!
A657  913D                            CMPA    ZP_FPB + 2
A659  2610                            BNE     LA636
A65B  9632                            LDA     ZP_FPA + 4
A65D  913E                            CMPA    ZP_FPB + 3
                      ;;              LDD     ZP_FPA + 3                      ; or 16 bit for size?
                      ;;              CMPD    ZP_FPB + 2
                              ENDIF
                      
A65F  260A                            BNE     LA636
A661  9633                            LDA     ZP_FPA + 5                      ; keep this 16 bit - unlikely to be hit?
A663  913F                            CMPA    ZP_FPB + 4
A665  2604                            BNE     LA636
A667  9634                            LDA     ZP_FPA + 6                      ; keep this 16 bit - unlikely to be hit?
A669  9140                            CMPA    ZP_FPB + 5
A66B                  LA636
A66B  2414                            BCC     LA64F
A66D                  LA638
                                      
A66D  DC3F                            LDD     ZP_FPB + 4
A66F  9333                            SUBD    ZP_FPA + 5
A671  DD3F                            STD     ZP_FPB + 4
                              IF CPU_6309
                                      LDD     ZP_FPA + 3
                                      SBCR    D,W
                              ELSE
A673  963E                            LDA     ZP_FPB + 3
A675  9232                            SBCA    ZP_FPA + 4
A677  973E                            STA     ZP_FPB + 3
A679  963D                            LDA     ZP_FPB + 2
A67B  9231                            SBCA    ZP_FPA + 3
A67D  973D                            STA     ZP_FPB + 2
                              ENDIF
                      
A67F                                  SEC
A67F  1A01                    ORCC    #CC_C
A681                  LA64F
A681  093B                            ROL     ZP_FPB                          ; store result bit into FPB
A683  0840                            ASL     ZP_FPB + 5
A685  093F                            ROL     ZP_FPB + 4
                              IF CPU_6309
                                      ROLW
                              ELSE
A687  093E                            ROL     ZP_FPB + 3
A689  093D                            ROL     ZP_FPB + 2                      ;;;POINT X
                              ENDIF
A68B  0A3C                            DEC     ZP_FPB + 1                      ; B here is loop counter
A68D  26C4                            BNE     LA620
A68F  D63B                            LDB     ZP_FPB
A691  301F                            LEAX    -1,X
A693  26B5                            BNE     LA619
                              IF CPU_6309
                                      LDD     ZP_FPB + 4
                                      ORR     W,D
                              ELSE
A695  963D                            LDA     ZP_FPB + 2
A697  9A3E                            ORA     ZP_FPB + 3
A699  9A3F                            ORA     ZP_FPB + 4
A69B  9A40                            ORA     ZP_FPB + 5
                              ENDIF
A69D  2702                            BEQ     LA66B
A69F                                  SEC
A69F  1A01                    ORCC    #CC_C
A6A1                  LA66B
                      
                      ;;              LDU     ZP_TXTPTR                       ; restore text pointer
                              IF CPU_6309
                                      PULSW
                              ENDIF
                      
A6A1  56                              RORB
A6A2  56                              RORB
A6A3  56                              RORB
A6A4  C4E0                            ANDB    #$E0
A6A6  D735                            STB     ZP_FPA + 7
                      
                      
A6A8  DC43                            LDD     ZP_FP_TMP
A6AA  9734                            STA     ZP_FPA + 6
A6AC  D733                            STB     ZP_FPA + 5
                      
A6AE  DC45                            LDD     ZP_FP_TMP + 2
A6B0  9732                            STA     ZP_FPA + 4
A6B2  D731                            STB     ZP_FPA + 3
                      
A6B4  2B15                            BMI     fpRoundMantissaFPA
A6B6                                  CALL    NormaliseRealA_3
A6B6                  9
A6B8                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6B6  BD85D5                                  JSR     \1
                              ENDIF
                      ;;              CALL    __NormaliseRealA_sk2
A6B9  2010                            BRA     fpRoundMantissaFPA
                      
                      
A6BB                  fpFPAeqXaddFPA
A6BB                                  CALL    fpMoveRealAtXtoFPB
A6BB                  9
A6BD                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6BB  BDA544                                  JSR     \1
                              ENDIF
A6BE  2008                            BRA     fpAddAtoBStoreAndRoundA
A6C0                  fpFPAeqPTR1subFPA
A6C0                                  CALL fpNegateFP_A
A6C0                  9
A6C2                  __XBSR                  SET 9B+2
0600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6C0  BDAD06                                  JSR     \1
                              ENDIF
A6C3                  fpFPAeqPTR1addFPA
A6C3                                  CALL    fpMoveRealAtPTR1toFPB
A6C3                  9
A6C5                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6C3  BDA542                                  JSR     \1
                              ENDIF
A6C6  2735                            BEQ     anRTS2
A6C8                  fpAddAtoBStoreAndRoundA                                 ; LA692
A6C8                                  CALL    fpAddAtoBStoreA
A6C8                  9
A6CA                  __XBSR                  SET 9B+2
E000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6C8  BD871E                                  JSR     \1
                              ENDIF
A6CB                  fpRoundMantissaFPA                                      ; LA695
A6CB  9635                            LDA     ZP_FPA + 7
A6CD  8180                            CMPA    #$80
A6CF  2516                            BLO     2F
A6D1  270D                            BEQ     1F
A6D3  0C34                            INC     ZP_FPA + 6
A6D5  2610                            BNE     2F
A6D7                                  CALL    fpIncFPAMantMSBs
A6D7                  9
A6D9                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A6D7  BDA533                                  JSR     \1
                              ENDIF
A6DA  200B                            BRA     2F
A6DC                  fpFPAeqPTR1mulFPA
A6DC                                  CALL    fpFPAeqPTR1mulFPA_internal
A6DC                  9
A6DE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
002A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A6DC  8D2A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A6DE  20EB                            BRA     fpRoundMantissaFPA
A6E0                  1                                                       ; LA6AB
A6E0                                  SEC
A6E0  1A01                    ORCC    #CC_C
A6E2  49                              ROLA
A6E3  9A34                            ORA     ZP_FPA + 6
A6E5  9734                            STA     ZP_FPA + 6
A6E7                  2                                                       ; LA6AE
A6E7  962F                            LDA     ZP_FPA + 1
A6E9  2710                            BEQ     zero_FPA_matLsb
A6EB  2A11                            BPL     brkTooBig
                                      ; TODO - speed up with 16bits?
A6ED                  zero_FPA
A6ED  0F30                            CLR     ZP_FPA + 2              ; exp
A6EF  0F31                            CLR     ZP_FPA + 3              ; mantissa MSB
A6F1                  zero_FPA_sign_expO_manlo
A6F1  0F2E                            CLR     ZP_FPA                  ; sign
A6F3  0F2F                            CLR     ZP_FPA + 1                      ; exponent overflow
A6F5  0F32                            CLR     ZP_FPA + 4                      ; mantissa 
A6F7  0F33                            CLR     ZP_FPA + 5                      ; mantissa
A6F9  0F34                            CLR     ZP_FPA + 6                      ; mantissa
A6FB                  zero_FPA_matLsb                                         ; LA6C2
A6FB  0F35                            CLR     ZP_FPA + 7                      ; mantissa LSB
A6FD  39              anRTS2          RTS
                      ;
                      ;
A6FE                  brkTooBig       DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A6FE  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A6FF  14546F6F2062696700                 FCB $14, "Too big", 0
                      
                                      *************************************************
                                      *                                               *
                                      * Multiply FPA and 5 byte FP at PTR1            *
                                      * first PTR1 is unpacked to FPB in 7 byte format*
                                      * i.e. 1 byte for exponent                      *
                                      *************************************************
                                      
A708                  fpFPAeqPTR1mulFPA_internal
A708  9631                            LDA     ZP_FPA + 3                      ; check for 0 in FPA, if 0 return 0
A70A  27F1                            BEQ     anRTS2
A70C                                  CALL    fpMoveRealAtPTR1toFPB           ; unpack to FPB in 7 byte form
A70C                  9
A70E                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A70C  BDA542                                  JSR     \1
                              ENDIF
A70F  27DC                            BEQ     zero_FPA                        ; if that is zero, clear FPA and return
                      
A711  D63C                            LDB     ZP_FPB + 1                      ; add exponents
A713  4F                              CLRA
A714  D32F                            ADDD    ZP_FPA + 1
A716  830080                          SUBD    #$0080
A719  DD2F                            STD     ZP_FPA + 1
                      
A71B  962E                            LDA     ZP_FPA                          ; multiply signs
A71D  983B                            EORA    ZP_FPB
A71F  972E                            STA     ZP_FPA
                      
                      
A721  3450                            PSHS    X,U                             ; nothing to really save here but keep for later pops? X=D in BAS4128
A723  DC31                            LDD     ZP_FPA + 3
A725  DD43                            STD     ZP_FP_TMP
A727  DC33                            LDD     ZP_FPA + 5
A729  DD45                            STD     ZP_FP_TMP + 2
A72B  4F                              CLRA
A72C  5F                              CLRB
A72D  DD31                            STD     ZP_FPA + 3
A72F  DD33                            STD     ZP_FPA + 5
A731  9735                            STA     ZP_FPA + 7
                      
                                                                              ; do a long multiply adding result into FPA mantissa after
                                                                              ; each byte is multiplied from the "bottom" number (in tmp)
                                                                              ; shift FPA mantissa to the right by one byte, except last
                                                                              ; like long multiplication at primary school
                      
A733  108E0047                        LDY     #ZP_FP_TMP + 4                  ; point at current byte in "bottom" mantissa
A737  8E0040          mulloop         LDX     #ZP_FPB + 5                     ; point at number in "top" row (FPB)
A73A  CE0034          mulloop3        LDU     #ZP_FPA + 6                     ; point at number in result (16 bit)
A73D  A6A4            mulloop2        LDA     ,Y
A73F  2719                            BEQ     mul_skip_car1
A741  E684                            LDB     ,X
A743  2715                            BEQ     mul_skip_car1
A745  3D                              MUL
A746  E3C4                            ADDD    ,U
A748  EDC4                            STD     ,U
A74A  240E                            BCC     mul_skip_car1
A74C  3440                            PSHS    U
A74E  11830031        1               CMPU    #ZP_FPA + 3
A752  2304                            BLS     2F
A754  6CC2                            INC     ,-U
A756  27F6                            BEQ     1B
A758  3540            2               PULS    U
A75A  335F            mul_skip_car1   LEAU    -1,U
A75C  301F                            LEAX    -1,X
A75E  8C003D                          CMPX    #ZP_FPB + 2
A761  24DA                            BHS     mulloop2
A763  108C0043                        CMPY    #ZP_FP_TMP
A767  230E                            BLS     mul_done
                                      ; shift result right one byte
A769  DC33                            LDD     ZP_FPA + 5
A76B  DD34                            STD     ZP_FPA + 6
A76D  DC31                            LDD     ZP_FPA + 3
A76F  DD32                            STD     ZP_FPA + 4
A771  0F31                            CLR     ZP_FPA + 3
A773  313F                            LEAY    -1,Y
A775  20C0                            BRA     mulloop
A777                  mul_done
A777  3550                            PULS    X,U
                      ;               LDA     ZP_FPA + 3
A779  4D                              TSTA                                    ; top byte of mant still in A
A77A  102ADE57                        LBPL    NormaliseRealA_3                ; if top bit of FPA's mantissa not set then normalize it
A77E  39                              RTS
A77F                  fnLN                                                    ;  =LN
A77F                                  CALL evalLevel1ConvertReal
A77F                  9
A781                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0001                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A77F  BD9882                                  JSR     \1
                              ENDIF
A782                  fnLN_FPA                                                ; LA749
A782  3440                            PSHS    U
A784                                  CALL    fpCheckMant0SetSignExp0
A784                  9
A786                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A784  BDA47F                                  JSR     \1
                              ENDIF
A787  2702                            BEQ     brkLogRange
A789  2A17                            BPL     LA766
A78B                  brkLogRange
A78B                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A78B  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A78C  164C6F672072616E676500                 FCB     $16, "Log range", 0
A797                  brkNegRoot
A797                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A797  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A798  152D766520726F6F7400                 FCB     $15, "-ve root", 0
A7A2                  LA766
A7A2                                  CALL    fpSetRealBMantTo0
A7A2                  9
A7A4                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7A2  BDA5BF                                  JSR     \1
                              ENDIF
A7A5  8680                            LDA     #$80
A7A7  973B                            STA     ZP_FPB
A7A9  973D                            STA     ZP_FPB + 2
A7AB  4C                              INCA    
A7AC  973C                            STA     ZP_FPB + 1
A7AE  D630                            LDB     ZP_FPA + 2
A7B0  2708                            BEQ     LA77C
A7B2  9631                            LDA     ZP_FPA + 3
A7B4  81B5                            CMPA    #$B5
A7B6  8681                            LDA     #$81
A7B8  2502                            BCS     LA77E
A7BA                  LA77C
A7BA  5C                              INCB
A7BB  4A                              DECA
A7BC                  LA77E
A7BC  3404                            PSHS    B
A7BE  9730                            STA     ZP_FPA + 2
A7C0                                  CALL    fpAddAtoBStoreAndRoundA
A7C0                  9
A7C2                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7C0  BDA6C8                                  JSR     \1
                              ENDIF
A7C3  8E047B                          LDX     #BASWKSP_FPTEMP4
A7C6                                  CALL    fpCopyFPA_X
A7C6                  9
A7C8                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7C6  BDA573                                  JSR     \1
                              ENDIF
A7C9  8EBE10                          LDX     #fpConst0_54625
A7CC  CEBE2E                          LDU     #fpConstMin0_5
A7CF  C602                            LDB     #$02
A7D1                                  CALL    LA861NewAPI
A7D1                  9
A7D3                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7D1  BDA8BF                                  JSR     \1
                              ENDIF
A7D4  8E047B                          LDX     #BASWKSP_FPTEMP4
A7D7                                  CALL    fpFPAeqXmulFPA
A7D7                  9
A7D9                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
002F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7D7  BDAA08                                  JSR     \1
                              ENDIF
A7DA                                  CALL    fpFPAeqPTR1mulFPA
A7DA                  9
A7DC                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0000                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7DA  BDA6DC                                  JSR     \1
                              ENDIF
A7DD                                  CALL    fpFPAeqPTR1addFPA
A7DD                  9
A7DF                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7DD  BDA6C3                                  JSR     \1
                              ENDIF
A7E0                                  CALL    fpCopyFPA_FPTEMP1
A7E0                  9
A7E2                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7E0  BDA56C                                  JSR     \1
                              ENDIF
A7E3  3502                            PULS    A
A7E5  8081                            SUBA    #$81
A7E7                                  CALL    IntToReal_8signedA2real_check
A7E7                  9
A7E9                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7E7  BD85B0                                  JSR     \1
                              ENDIF
A7EA  8EBE0B                          LDX     #fpConst_ln_2
A7ED                                  CALL    fpFPAeqXmulFPA
A7ED                  9
A7EF                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7ED  BDAA08                                  JSR     \1
                              ENDIF
A7F0  8E046C                          LDX     #BASWKSP_FPTEMP1
A7F3  9F4A                            STX     ZP_FP_TMP_PTR1
A7F5                                  CALL    fpFPAeqPTR1addFPA
A7F5                  9
A7F7                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7F5  BDA6C3                                  JSR     \1
                              ENDIF
A7F8  86FF                            LDA     #$FF
A7FA  35C0                            PULS    U,PC
                      
A7FC                  retAeqFF
A7FC  86FF                            LDA     #$FF
A7FE  39                              RTS
                      ;               
                      ;               
A7FF                  fnSQR
                      
                                              ;  =cmd
A7FF                                  CALL    evalLevel1ConvertReal
A7FF                  9
A801                  __XBSR                  SET 9B+2
F000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0081                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A7FF  BD9882                                  JSR     \1
                              ENDIF
A802                  fpFPAeq_sqr_FPA
A802                                  CALL    fpCheckMant0SetSignExp0
A802                  9
A804                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A802  BDA47F                                  JSR     \1
                              ENDIF
A805  27F5                            BEQ     retAeqFF
A807  2B8E                            BMI     brkNegRoot
A809  9630                            LDA     ZP_FPA + 2
A80B  44                              LSRA
A80C  3401                            PSHS    CC
A80E  8941                            ADCA    #$41
A810  9730                            STA     ZP_FPA + 2
A812  3501                            PULS    CC
A814  240A                            BCC     fpFPAeq_sqr_FPA_sk6
A816  0431                            LSR     ZP_FPA + 3
A818  0632                            ROR     ZP_FPA + 4
A81A  0633                            ROR     ZP_FPA + 5
A81C  0634                            ROR     ZP_FPA + 6
A81E  0635                            ROR     ZP_FPA + 7
A820                  fpFPAeq_sqr_FPA_sk6
A820                                  CALL    fpSetRealBto0
A820                  9
A822                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0097                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A820  BDA5B9                                  JSR     \1
                              ENDIF
A823  4F                              CLRA
A824  9743                            STA     ZP_FP_TMP
A826  9744                            STA     ZP_FP_TMP + 1
A828  9745                            STA     ZP_FP_TMP + 2
A82A  9746                            STA     ZP_FP_TMP + 3
A82C  8640                            LDA     #$40
A82E  973D                            STA     ZP_FPB + 2
A830  9742                            STA     ZP_FPB + 7
A832  8E0000                          LDX     #$0
A835  C610                            LDB     #$10
A837  D74C                            STB     ZP_FP_TMP_PTR2
A839  9631                            LDA     ZP_FPA + 3
A83B  8040                            SUBA    #$40
A83D  9731                            STA     ZP_FPA + 3
A83F                  fpFPAeq_sqr_FPA_lp1             
A83F  964C                            LDA     ZP_FP_TMP_PTR2
A841  A8883D                          EORA    ZP_FPB + 2,X
A844  A78842                          STA     ZP_FP_TMP - 1,X
A847  9631                            LDA     ZP_FPA + 3
A849  9142                            CMPA    ZP_FPB + 7
A84B  2616                            BNE     fpFPAeq_sqr_FPA_sk2
A84D  3410                            PSHS    X
A84F  8E0000                          LDX     #$0                             
A852                  fpFPAeq_sqr_FPA_lp2
A852  A68832                          LDA     ZP_FPA + 4, X
A855  A18843                          CMPA    ZP_FP_TMP, X
A858  2607                            BNE     fpFPAeq_sqr_FPA_sk1
A85A  3001                            LEAX    1,X
A85C  8C0004                          CMPX    #4
A85F  26F1                            BNE     fpFPAeq_sqr_FPA_lp2
A861                  fpFPAeq_sqr_FPA_sk1
A861  3510                            PULS    X
A863                  fpFPAeq_sqr_FPA_sk2
A863  2523                            BCS     fpFPAeq_sqr_FPA_sk3
A865  DC34                            LDD     ZP_FPA + 6
A867  9345                            SUBD    ZP_FP_TMP + 2
A869  DD34                            STD     ZP_FPA + 6
A86B  DC32                            LDD     ZP_FPA + 4
A86D  D244                            SBCB    ZP_FP_TMP + 1
A86F  9243                            SBCA    ZP_FP_TMP + 0
A871  DD32                            STD     ZP_FPA + 4
A873  9631                            LDA     ZP_FPA + 3
A875  9242                            SBCA    ZP_FPB + 7
A877  9731                            STA     ZP_FPA + 3
A879  964C                            LDA     ZP_FP_TMP_PTR2
A87B  48                              ASLA
A87C  240F                            BCC     fpFPAeq_sqr_FPA_sk4
A87E  4C                              INCA
A87F  A8883C                          EORA    ZP_FPB + 1,X
A882  A7883C                          STA     ZP_FPB + 1,X
A885  A78841                          STA     ZP_FP_TMP  - 2,X
A888                  fpFPAeq_sqr_FPA_sk3
A888  A6883D                          LDA     ZP_FPB + 2,X
A88B  2006                            BRA     fpFPAeq_sqr_FPA_sk5
A88D                  fpFPAeq_sqr_FPA_sk4
A88D  A8883D                          EORA    ZP_FPB + 2,X
A890  A7883D                          STA     ZP_FPB + 2,X
A893                  fpFPAeq_sqr_FPA_sk5
A893  A78842                          STA     ZP_FP_TMP - 1,X
A896  0835                            ASL     ZP_FPA + 7
A898  0934                            ROL     ZP_FPA + 6
A89A  0933                            ROL     ZP_FPA + 5
A89C  0932                            ROL     ZP_FPA + 4
A89E  0931                            ROL     ZP_FPA + 3
A8A0  044C                            LSR     ZP_FP_TMP_PTR2
A8A2  249B                            BCC     fpFPAeq_sqr_FPA_lp1
A8A4  C680                            LDB     #$80
A8A6  D74C                            STB     ZP_FP_TMP_PTR2
A8A8  3001                            LEAX    1,X
A8AA  8C0005                          CMPX    #5
A8AD  2690                            BNE     fpFPAeq_sqr_FPA_lp1
A8AF                                  CALL    fpCopyBManttoA_NewAPI
A8AF                  9
A8B1                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8AF  BD8711                                  JSR     \1
                              ENDIF
A8B2                  fpNormalizeAndReturnFPA                                 ; LA854
A8B2  9631                            LDA     ZP_FPA + 3
A8B4  2B03                            BMI     1F
A8B6                                  CALL    NormaliseRealA_3
A8B6                  9
A8B8                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8B6  BD85D5                                  JSR     \1
                              ENDIF
A8B9                  1               CALL    fpRoundMantissaFPA
A8B9                  9
A8BB                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8B9  BDA6CB                                  JSR     \1
                              ENDIF
A8BC  86FF                            LDA     #$FF
A8BE  39                              RTS
A8BF                  LA861NewAPI
                      *               B -> # of iterations
                      *               X -> table of constants to use
                      *               Y -> constant to use if FPA is too small                ( was A )
                      * IF FPA < 0.5e-40 THEN FPA = U
                      * ELSE 
                      *       FPTEMP1 = 1/FPA
                      *       FPA     = X(0) + FPTEMP1
                      *       I%=1
                      *       REPEAT
                      *               FPA = FPTEMP1 + X(I% + 1) + X(I%) / FPA
                      *               B = B - 1
                      *               I% = I% + 2
                      *       UNTIL B = 0
                      
                      
A8BF  D747                            STB     ZP_FP_TMP + 4                   ;                                               iter = B
A8C1  9F4C                            STX     ZP_FP_TMP_PTR2                  ;                                               PTR2 = tablestart
A8C3  9630                            LDA     ZP_FPA + 2                      ; get FPA exponent                              
A8C5  8140                            CMPA    #$40                            ;                                               if ABS(FPA)<1E-64
A8C7  2527                            BLO     fpYtoPTR1toFPA                  ; if <-$40 approximate as constant at Y                 RETURN default from Y
A8C9                                  CALL    fpFPAeq1.0divFPA                ;                                               FPA=1/FPA
A8C9                  9
A8CB                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8C9  BDA620                                  JSR     \1
                              ENDIF
A8CC                                  CALL    fpCopyFPA_FPTEMP1               ;                                               TMP=FPA
A8CC                  9
A8CE                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8CC  BDA56C                                  JSR     \1
                              ENDIF
A8CF  9E4C                            LDX     ZP_FP_TMP_PTR2                  ;                       
A8D1  9F4A                            STX     ZP_FP_TMP_PTR1                  ;                                               PTR1 = tablestart
A8D3                                  CALL    fpFPAeqPTR1addFPA               ;                                               FPA = X(0) + 1/FPA
A8D3                  9
A8D5                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8D3  BDA6C3                                  JSR     \1
                              ENDIF
A8D6                  LA879                                                   ;                                               REPEAT
A8D6                                  CALL    LA886                           ;                                                       CALL LA886
A8D6                  9
A8D8                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A8D6  8D0C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A8D8  8E046C                          LDX     #BASWKSP_FPTEMP1
A8DB  9F4A                            STX     ZP_FP_TMP_PTR1
A8DD                                  CALL    fpFPAeqPTR1addFPA
A8DD                  9
A8DF                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8DD  BDA6C3                                  JSR     \1
                              ENDIF
A8E0  0A47                            DEC     ZP_FP_TMP + 4
A8E2  26F2                            BNE     LA879
A8E4                  LA886
A8E4                                  CALL    fpAdd5toPTR2copytoPTR1
A8E4                  9
A8E6                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8E4  BDA5C8                                  JSR     \1
                              ENDIF
A8E7                                  CALL    fpFPAeqPTR1divFPA
A8E7                  9
A8E9                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8E7  BDA625                                  JSR     \1
                              ENDIF
A8EA                                  CALL    fpAdd5toPTR2copytoPTR1
A8EA                  9
A8EC                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A8EA  BDA5C8                                  JSR     \1
                              ENDIF
A8ED                                  JUMP    fpFPAeqPTR1addFPA
A8ED  7EA6C3                                  JMP     \1
A8F0                  fpYtoPTR1toFPA                                          ; LA896
A8F0  DF4A                            STU     ZP_FP_TMP_PTR1
A8F2                                  JUMP    fpCopyPTR1toFPA
A8F2  7EA593                                  JMP     \1
A8F5                  fnACS
                      
A8F5                                          TODO_CMD "ACS"
A8F5                                          TODODEADEND "\1"
A8F5                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A8F5  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A8F6  7E443A                          FCB             $7E,"D:"
A8F9  414353                          FCB             \1
A8FC  00                              FCB             0
                                              
                      ;                       ;  =ACS
                      ;               CALL fnASN
                      ;               BRA fpFPAEqPiDiv2SubFPA
A8FD                  fnASN
                      
A8FD                                          TODO_CMD "ASN"
A8FD                                          TODODEADEND "\1"
A8FD                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
A8FD  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
A8FE  7E443A                          FCB             $7E,"D:"
A901  41534E                          FCB             \1
A904  00                              FCB             0
                                              
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA ZP_FPA
                      ;               BPL LA8AF
                      ;               STZ ZP_FPA
                      ;               CALL LA8AF
                      ;               BRA LA8D2
                      ;LA8AF:
                      ;               CALL fpCopyFPA_FPTEMP3
                      ;               CALL LA929
                      ;               LDA ZP_FPA + 3
                      ;               BEQ fpSetFPAPIdiv2
                      ;               CALL LA5B3
                      ;               BRA LA8C6
A905                  fpSetFPAPIdiv2                                          ; LA8BE
A905  8EBDED                          LDX     #fpConstPiDiv2
A908                                  JUMP    fpCopyXtoFPA
A908  7EA595                                  JMP     \1
A90B                  fnATN
A90B                                  CALL evalLevel1ConvertReal
A90B                  9
A90D                  __XBSR                  SET 9B+2
EF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A90B  BD9882                                  JSR     \1
                              ENDIF
A90E                  LA8C6
A90E                                  CALL    fpCheckMant0SetSignExp0
A90E                  9
A910                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A90E  BDA47F                                  JSR     \1
                              ENDIF
A911  2766                            BEQ     LA926_retFF
A913  2A07                            BPL     LA8D5
A915  0F2E                            CLR     ZP_FPA
A917                                  CALL    LA8D5
A917                  9
A919                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A917  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A919  972E            LA8D2           STA     ZP_FPA                          ; set minus result and return FF
A91B  39                              RTS
A91C                  LA8D5
A91C  9630                            LDA     ZP_FPA + 2
A91E  8181                            CMPA    #$81
A920  2510                            BLO     LA8EA
A922                                  CALL    fpFPAeq1.0divFPA
A922                  9
A924                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A922  BDA620                                  JSR     \1
                              ENDIF
A925                                  CALL    LA8EA
A925                  9
A927                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A925  8D0B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A927                  fpFPAEqPiDiv2SubFPA                                     ; LA8E1
A927  8EBDED                          LDX     #fpConstPiDiv2
A92A  9F4A                            STX     ZP_FP_TMP_PTR1
A92C                                  CALL    fpFPAeqPTR1subFPA
A92C                  9
A92E                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A92C  BDA6C0                                  JSR     \1
                              ENDIF
A92F  86FF                            LDA     #$FF
A931  39                              RTS
A932                  LA8EA
A932  9630                            LDA     ZP_FPA + 2
A934  8173                            CMPA    #$73
A936  2541                            BLO     LA926_retFF
A938                                  CALL    fpCopyFPA_FPTEMP3
A938                  9
A93A                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A938  BDA565                                  JSR     \1
                              ENDIF
A93B                                  CALL    fpSetRealBMantTo0
A93B                  9
A93D                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0082                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A93B  BDA5BF                                  JSR     \1
                              ENDIF
A93E  8680                            LDA     #$80
A940  973C                            STA     ZP_FPB + 1
A942  973D                            STA     ZP_FPB + 2
A944  973B                            STA     ZP_FPB
A946                                  CALL    fpAddAtoBStoreAndRoundA
A946                  9
A948                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A946  BDA6C8                                  JSR     \1
                              ENDIF
A949  3440                            PSHS    U
A94B  8EBE56                          LDX     #fpConstMin0_08005
A94E  CEBE88                          LDU     #fpConst0_9273
A951  C604                            LDB     #$04
A953                                  CALL    LA861NewAPI
A953                  9
A955                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A953  BDA8BF                                  JSR     \1
                              ENDIF
A956                                  CALL    fpFPAeqFPTEMP3mulFPA
A956                  9
A958                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A956  BDAA05                                  JSR     \1
                              ENDIF
A959  35C0                            PULS    U,PC
                      
                      
                      
A95B                  fnSIN                   ; LA90D!
                      
                      ;                       ;  =SIN
A95B                                  CLC
A95B  1CFE                    ANDCC   #~CC_C
A95D  2002                            BRA     fnSINenter
                      
A95F                  fnCOS
A95F                                  SEC
A95F  1A01                    ORCC    #CC_C
                      ;                       ;  =COS
A961                  fnSINenter
A961  3401                            PSHS    CC                      ; Save CC to see whether its sin or cos
A963                                  CALL    trigNormaltheta
A963                  9
A965                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0029                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A963  8D29                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A965  3501                            PULS    CC
A967  2402                            BCC     fnSIN_internal1
A969                  fnCOS_internal1                                 ; LA915
A969  0C49                            INC     ZP_FP_TMP + 6
A96B                  fnSIN_internal1                                 ; LA917
A96B  9649                            LDA     ZP_FP_TMP + 6
A96D  8502                            BITA    #$02
A96F  2705                            BEQ     LA923
A971                                  CALL    LA923
A971                  9
A973                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A971  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A973                                  JUMP    fpNegateFP_A
A973  7EAD06                                  JMP     \1
A976                  LA923
A976  44                              LSRA
A977  2503                            BCS     LA929
A979                  LA926_retFF                                     ; LA926
A979  86FF                            LDA     #$FF
A97B  39                              RTS
A97C                  LA929
A97C                                  CALL    fpCopyFPA_FPTEMP1
A97C                  9
A97E                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A97C  BDA56C                                  JSR     \1
                              ENDIF
A97F                                  CALL    fpFPAeqPTR1mulFPA
A97F                  9
A981                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A97F  BDA6DC                                  JSR     \1
                              ENDIF
A982                                  LDX_FPC fpConst1
A982  8EBE51                                  LDX     #\1             ; leave as LDX for now for faster execution
A985  9F4A                            STX     ZP_FP_TMP_PTR1
A987                                  CALL    fpFPAeqPTR1subFPA
A987                  9
A989                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A987  BDA6C0                                  JSR     \1
                              ENDIF
A98A                                  CALL    fpFPAeq_sqr_FPA
A98A                  9
A98C                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0076                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A98A  BDA802                                  JSR     \1
                              ENDIF
A98D  39                              RTS
A98E                  trigNormaltheta                                                 ; LA93A
A98E                                  CALL    evalLevel1ConvertReal
A98E                  9
A990                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A98E  BD9882                                  JSR     \1
                              ENDIF
A991  9630                            LDA     ZP_FPA + 2
A993  8198                            CMPA    #$98
A995  2479                            BHS     brkAccuracyLost
A997                                  CALL    fpCopyFPA_FPTEMP1
A997                  9
A999                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A997  BDA56C                                  JSR     \1
                              ENDIF
A99A                                  LDX_FPC fpConstPiDiv2
A99A  8EBDED                                  LDX     #\1             ; leave as LDX for now for faster execution
A99D                                  CALL    fpMoveRealAtXtoFPB                      ; FPB = PI/2
A99D                  9
A99F                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A99D  BDA544                                  JSR     \1
                              ENDIF
A9A0  962E                            LDA     ZP_FPA
A9A2  973B                            STA     ZP_FPB                          ; change FPB's sign to same as FPA
A9A4  0A3C                            DEC     ZP_FPB + 1                              ; decrement exponent FPB = PI
A9A6                                  CALL    fpAddAtoBStoreAndRoundA                 ; add to FPA
A9A6                  9
A9A8                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9A6  BDA6C8                                  JSR     \1
                              ENDIF
A9A9                                  LDX_FPC fpConst2DivPi                           ; multiply by 2/PI
A9A9  8EBDF2                                  LDX     #\1             ; leave as LDX for now for faster execution
A9AC                                  CALL    fpFPAeqXmulFPA
A9AC                  9
A9AE                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A9AC  8D5A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A9AE                                  CALL    fpReal2Int                              ; take the real part
A9AE                  9
A9B0                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9AE  BD9876                                  JSR     \1
                              ENDIF
A9B1  962D                            LDA     ZP_INT_WA + 3                           ; get low byte
A9B3  9749                            STA     ZP_FP_TMP + 6                           ; store number of PIs (gets inc'd for sin in main routine...)
A9B5  9A2B                            ORA     ZP_INT_WA + 1
A9B7  9A2C                            ORA     ZP_INT_WA + 2
A9B9  272C                            BEQ     LA98D
A9BB                                  CALL    IntToReal2                              ; if not zero then store
A9BB                  9
A9BD                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9BB  BD856F                                  JSR     \1
                              ENDIF
A9BE  8E0471                          LDX     #BASWKSP_FPTEMP2                        ; integer part (as real)
A9C1                                  CALL    fpCopyFPA_X                             ; to BASWKSP_FPTEMP2
A9C1                  9
A9C3                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9C1  BDA573                                  JSR     \1
                              ENDIF
A9C4                                  LDX_FPC fpConstMinPiDiv2
A9C4  8EBDE3                                  LDX     #\1             ; leave as LDX for now for faster execution
A9C7                                  CALL    fpFPAeqXmulFPA                          ; now equals number of PI/2's to add to original param
A9C7                  9
A9C9                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
003F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A9C7  8D3F                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ;;;;?           CALL    FPPTR1=BASWKSP_FPTEMP1
A9C9  8E046C                          LDX     #BASWKSP_FPTEMP1
A9CC  9F4A                            STX     ZP_FP_TMP_PTR1
A9CE                                  CALL    fpFPAeqPTR1addFPA                       ; add them to normalize param
A9CE                  9
A9D0                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9CE  BDA6C3                                  JSR     \1
                              ENDIF
A9D1                                  CALL    fpCopyFPA_PTR1                          ; store normalized param at FPTEMP1
A9D1                  9
A9D3                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9D1  BDA571                                  JSR     \1
                              ENDIF
A9D4  8E0471                          LDX     #BASWKSP_FPTEMP2
A9D7                                  CALL    fpCopyXtoFPA
A9D7                  9
A9D9                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9D7  BDA595                                  JSR     \1
                              ENDIF
A9DA                                  LDX_FPC fpConst4_454e_6                         ; multiply number of cycles by 4.454e-6??? correction???
A9DA  8EBDE8                                  LDX     #\1             ; leave as LDX for now for faster execution
A9DD                                  CALL    fpFPAeqXmulFPA
A9DD                  9
A9DF                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0029                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
A9DD  8D29                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
A9DF  8E046C                          LDX     #BASWKSP_FPTEMP1
A9E2                                  CALL    fpFPAeqXaddFPA
A9E2                  9
A9E4                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9E2  BDA6BB                                  JSR     \1
                              ENDIF
A9E5  2003                            BRA     LA990
A9E7                  LA98D
A9E7                                  CALL fpCopyFPTEMP1toFPA
A9E7                  9
A9E9                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9E7  BDA58E                                  JSR     \1
                              ENDIF
A9EA                  LA990
A9EA  8E0476                          LDX     #BASWKSP_FPTEMP3
A9ED  9F4A                            STX     ZP_FP_TMP_PTR1
A9EF                                  CALL    fpCopyFPA_PTR1
A9EF                  9
A9F1                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0080                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9EF  BDA571                                  JSR     \1
                              ENDIF
A9F2                                  CALL    fpFPAeqPTR1mulFPA                       ; FPA = FPA * FPA ???
A9F2                  9
A9F4                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
A9F2  BDA6DC                                  JSR     \1
                              ENDIF
A9F5                                  LDX_FPC fpConstMin0_011909
A9F5  8EBE33                                  LDX     #\1             ; leave as LDX for now for faster execution
A9F8  3440                            PSHS    U
A9FA                                  LDU_FPC fpConst1
A9FA  108EBE51                                LDY     #\1             ; leave as LDX for now for faster execution
A9FE  C602                            LDB     #$02
AA00                                  CALL    LA861NewAPI
AA00                  9
AA02                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA00  BDA8BF                                  JSR     \1
                              ENDIF
AA03  3540                            PULS    U
AA05                  fpFPAeqFPTEMP3mulFPA
AA05  8E0476                          LDX     #BASWKSP_FPTEMP3
                      
                      **      NOTE: API change here was YA not X
                      ;;LA9A1 removed was A + $400, now X
                      
AA08                  fpFPAeqXmulFPA
AA08  9F4A                            STX     ZP_FP_TMP_PTR1
AA0A                                  CALL    fpFPAeqPTR1mulFPA
AA0A                  9
AA0C                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA0A  BDA6DC                                  JSR     \1
                              ENDIF
AA0D  86FF                            LDA     #$FF
AA0F  39                              RTS
AA10                  brkAccuracyLost                                         ; LA9AD
AA10                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA10  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA11  174163637572616379206C6F737400                 FCB     $17, "Accuracy lost", 0
AA20                  brkExpRange                                             ; LA9BC
AA20                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA20  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA21  184578702072616E676500                 FCB     $18, "Exp range", 0
                      
AA2C                  fnRAD                   ; LA9C8!
                      
AA2C                                          TODO_CMD "RAD"
AA2C                                          TODODEADEND "\1"
AA2C                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA2C  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA2D  7E443A                          FCB             $7E,"D:"
AA30  524144                          FCB             \1
AA33  00                              FCB             0
                                              
                      ;                       ;  =RAD
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA #<fpConstDeg2Rad
                      ;               BRA fpFPAeqXmulFPA_checkusingX!
AA34                  fnLOG
                      
AA34                                          TODO_CMD "LOG"
AA34                                          TODODEADEND "\1"
AA34                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA34  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA35  7E443A                          FCB             $7E,"D:"
AA38  4C4F47                          FCB             \1
AA3B  00                              FCB             0
                                              
                      ;                       ;  =LOG
                      ;?              CALL    fnLN
                      ;?              LDX     #fpConst0_43429
                      ;?              BRA     fpFPAeqXmulFPA
AA3C                  fnDEG
                      
AA3C                                          TODO_CMD "DEG"
AA3C                                          TODODEADEND "\1"
AA3C                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AA3C  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AA3D  7E443A                          FCB             $7E,"D:"
AA40  444547                          FCB             \1
AA43  00                              FCB             0
                                              
                      ;                       ;  =DEG
                      ;               CALL evalLevel1ConvertReal
                      ;               LDA #<fpConstRad2Deg
                      ;               BRA fpFPAeqXmulFPA_checkusingX!
AA44                  fnEXP                   ;  =EXP
AA44                                  CALL    evalLevel1ConvertReal
AA44                  9
AA46                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA44  BD9882                                  JSR     \1
                              ENDIF
AA47  3440                            PSHS    U
AA49                  LA9E2
AA49  9630                            LDA     ZP_FPA + 2
AA4B  8187                            CMPA    #$87
AA4D  250F                            BLO     LA9F7
AA4F  2606                            BNE     LA9F0
AA51  D631                            LDB     ZP_FPA + 3
AA53  C1B3                            CMPB    #$B3
AA55  2507                            BLO     LA9F7
AA57  962E            LA9F0           LDA     ZP_FPA
AA59  2AC5                            BPL     brkExpRange
AA5B                                  JUMP    zero_FPA
AA5B  7EA6ED                                  JMP     \1
AA5E                  LA9F7           CALL    L82E0
AA5E                  9
AA60                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
003F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA5E  BD869F                                  JSR     \1
                              ENDIF
AA61  8EBE8D                          LDX     #fpConst0_07121
AA64  CEBEB5                          LDU     #fpConst1__2
AA67  C603                            LDB     #$03
AA69                                  CALL    LA861NewAPI
AA69                  9
AA6B                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA69  BDA8BF                                  JSR     \1
                              ENDIF
AA6C                                  CALL    fpCopyFPA_FPTEMP3
AA6C                  9
AA6E                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA6C  BDA565                                  JSR     \1
                              ENDIF
AA6F  CEBE06                          LDU     #fpConst_e
AA72                                  CALL    fpYtoPTR1toFPA
AA72                  9
AA74                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA72  BDA8F0                                  JSR     \1
                              ENDIF
AA75  9649                            LDA     ZP_FP_TMP + 6
AA77                                  CALL    LA5BE
AA77                  9
AA79                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA77  BDA5F3                                  JSR     \1
                              ENDIF
AA7A                                  CALL    fpFPAeqFPTEMP3mulFPA
AA7A                  9
AA7C                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0089                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AA7A  8D89                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AA7C  35C0                            PULS    U,PC
                      
                              IF FLEX != 1
AA7E                  callOSByte81withXYfromINT
AA7E                                  CALL    evalLevel1checkTypeStoreAsINT
AA7E                  9
AA80                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA7E  BD9865                                  JSR     \1
                              ENDIF
AA81  8681                            LDA     #$81
AA83  9E2C                            LDX     ZP_INT_WA + 2
AA85  109E2B                          LDY     ZP_INT_WA + 1
AA88  7EFFF4                          JMP     OSBYTE
                                                              ; Returns X=16bit OSBYTE return value
                      
                                      ; note: the RND accumulator is in a different order to 6502
                                      ; 0->3
                                      ; 1->2
                                      ; 2->1
                                      ; 3->0
                                      ; 4->4
                                      ; this makes integer ops easier but adds slight complexity to loading into FPA 
                              ENDIF
                      
AA8B                  fnRND_1                                                 ; LAA1E
AA8B                                  CALL    rndNext
AA8B                  9
AA8D                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
004D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AA8B  BD86DA                                  JSR     \1
                              ENDIF
AA8E                  fnRND_0                                                 ; LAA21
AA8E  0F2E                            CLR     ZP_FPA
AA90  0F2F                            CLR     ZP_FPA + 1
AA92  0F35                            CLR     ZP_FPA + 7
AA94  8680                            LDA     #$80
AA96  9730                            STA     ZP_FPA + 2
                      ;               PSHS    U
                      ;               LDB     #3
                      ;               LDX     #ZP_RND_WA + 4                  ; copy random accumulator
                      ;               LDU     #ZP_FPA + 7                     ; int mantissa 6 downto 3
AA98                  1;              EORA    ,-X
                      ;               STA     ,-U
                      ;               DECB
                      ;               BPL     1B
                      ;               PULS    U
AA98  9610                            LDA     ZP_RND_WA+3
AA9A  9731                            STA     ZP_FPA+3
AA9C  960F                            LDA     ZP_RND_WA+2
AA9E  9732                            STA     ZP_FPA+4
AAA0  960E                            LDA     ZP_RND_WA+1
AAA2  9733                            STA     ZP_FPA+5
AAA4  960D                            LDA     ZP_RND_WA+0
AAA6  9734                            STA     ZP_FPA+6
AAA8                                  JUMP    fpNormalizeAndReturnFPA
AAA8  7EA8B2                                  JMP     \1
AAAB                  fnRND_int                                               ; RND(X)
AAAB  3341                            LEAU    1,U
AAAD                                  CALL    evalL1BracketAlreadyOpenConvert2INT
AAAD                  9
AAAF                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAAD  BD9858                                  JSR     \1
                              ENDIF
AAB0  962A                            LDA     ZP_INT_WA + 0                   ; see if sign is -ve, if so randomize
AAB2  2B24                            BMI     fnRND_randomize
AAB4  9A2C                            ORA     ZP_INT_WA + 2
AAB6  9A2B                            ORA     ZP_INT_WA + 1
AAB8  2608                            BNE     LAA52                           ; >255
AABA  962D                            LDA     ZP_INT_WA + 3   
AABC  27D0                            BEQ     fnRND_0                         ; ==0
AABE                  LAA4E
AABE  8101                            CMPA    #$01
AAC0  27C9                            BEQ     fnRND_1
AAC2                  LAA52
AAC2                                  CALL    IntToReal
AAC2                  9
AAC4                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAC2  BD856A                                  JSR     \1
                              ENDIF
AAC5                                  CALL    fpStackWAtoStackReal
AAC5                  9
AAC7                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAC5  BDBB3A                                  JSR     \1
                              ENDIF
AAC8                                  CALL    fnRND_1
AAC8                  9
AACA                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AAC8  8DC1                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AACA                                  CALL    popFPFromStackToPTR1
AACA                  9
AACC                  __XBSR                  SET 9B+2
1000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0062                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AACA  BDBB2E                                  JSR     \1
                              ENDIF
AACD                                  CALL    fpFPAeqPTR1mulFPA_internal
AACD                  9
AACF                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0039                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AACD  BDA708                                  JSR     \1
                              ENDIF
AAD0                                  CALL    fpReal2Int
AAD0                  9
AAD2                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAD0  BD9876                                  JSR     \1
                              ENDIF
AAD3                                  CALL    inc_INT_WA
AAD3                  9
AAD5                  __XBSR                  SET 9B+2
1200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAD3  BDBDB5                                  JSR     \1
                              ENDIF
AAD6  201F                            BRA     LAA90_rtsA40
AAD8                  fnRND_randomize                                         ; LAA69
AAD8  8E000D                          LDX     #ZP_RND_WA
AADB                                  CALL    CopyIntWA2X
AADB                  9
AADD                  __XBSR                  SET 9B+2
1100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AADB  BDBCA3                                  JSR     \1
                              ENDIF
AADE  8640                            LDA     #$40
AAE0  9711                            STA     ZP_RND_WA + 4
AAE2  39                              RTS
AAE3                  fnRND                   ; LAA73!
AAE3  A6C4                            LDA     ,U
AAE5  8128                            CMPA    #'('
AAE7  27C2                            BEQ     fnRND_int
AAE9                                  CALL    rndNext
AAE9                  9
AAEB                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAE9  BD86DA                                  JSR     \1
                              ENDIF
AAEC  8E000D                          LDX     #ZP_RND_WA
AAEF                  intLoadWAFromX
AAEF  EC84                            LDD     0,X
AAF1  DD2A                            STD     ZP_INT_WA + 0
AAF3  EC02                            LDD     2,X
AAF5  DD2C                            STD     ZP_INT_WA + 2
AAF7                  LAA90_rtsA40
AAF7  8640                            LDA     #$40
AAF9  39                              RTS
                      ;                       ;  =NOT
AAFA                  fnNOT
                      
AAFA                                  CALL    evalLevel1checkTypeStoreAsINT
AAFA                  9
AAFC                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AAFA  BD9865                                  JSR     \1
                              ENDIF
AAFD  C603                            LDB     #$03
AAFF  8E002A                          LDX     #ZP_INT_WA
AB02  6385            LAA98           COM     B,X
AB04  5A                              DECB
AB05  2AFB                            BPL     LAA98
AB07  20EE                            BRA     LAA90_rtsA40
AB09                  fnPOS                   ; LAAA3!
AB09                                  CALL    fnVPOS
AB09                  9
AB0B                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AB09  8D1B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AB0B  9F2C                            STX     ZP_INT_WA+2
AB0D  39                              RTS
AB0E                  fnUSR                   ; LAAA9!
                      
                                              
                                              ;  =USR
AB0E                                  CALL    evalLevel1checkTypeStoreAsINT
AB0E                  9
AB10                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB0E  BD9865                                  JSR     \1
                              ENDIF
AB11  3440                            PSHS    U
AB13                                  CALL    callusrSetRegsEnterCode
AB13                  9
AB15                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB13  BD9618                                  JSR     \1
                              ENDIF
AB16  3401                            PSHS    CC
AB18  DF2B                            STU     ZP_INT_WA + 1                   ; note store 16 bit regs one less to get low bytes
AB1A  9F2A                            STX     ZP_INT_WA + 0
AB1C  972D                            STA     ZP_INT_WA + 3
AB1E  3502                            PULS    A
AB20  972A                            STA     ZP_INT_WA + 0
AB22  3540                            PULS    U
AB24  20D1                            BRA     LAA90_rtsA40
AB26                  fnVPOS                  ; LAABC!
                              IF FLEX
                                      JUMP    brkFlexNotImpl
                              ELSE
AB26  8686                            LDA     #$86
AB28  BDFFF4                          JSR     OSBYTE
AB2B  1F20                            TFR     Y,D
AB2D                                  JUMP    retB8asUINT
AB2D  7EAE56                                  JMP     \1
                              ENDIF
                      
                                              ;  =EXT#channel - read open file extent
                                              ; -------------------------------------
AB30                  fnEXT
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB30  8602                            LDA     #$02                    ; 02=Read EXT
AB32  2001                            BRA     varGetFInfo
                              ENDIF
                                              ;  =PTR#channel - read open file pointer
                                              ; --------------------------------------
AB34                  varGetPTR
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB34  4F                              CLRA                            ; 00=Read PTR
AB35                  varGetFInfo
AB35  3402                            PSHS    A
AB37                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
AB37                  9
AB39                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB37  BDBA04                                  JSR     \1
                              ENDIF
AB3A  8E002A                          LDX     #ZP_INT_WA
AB3D  3502                            PULS    A
AB3F  BDFFDA                          JSR     OSARGS                  ; Read to INTA
AB42  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
AB44  0D54                            TST     ZP_BIGEND
AB46  102B034A                        LBMI    SwapEndian              ; Swap INTA
AB4A  39                              RTS
                              ENDIF
                                              ;  =BGET#channel - get byte from open file
                                              ; ----------------------------------------
AB4B                  fnBGET
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB4B                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
AB4B                  9
AB4D                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB4B  BDBA04                                  JSR     \1
                              ENDIF
AB4E  BDFFD7                          JSR     OSBGET                  ; Read byte
AB51  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
AB53                                  JUMP    retA8asUINT
AB53  7EAE54                                  JMP     \1
                              ENDIF
                                              ;  =OPENIN f$ - open file for input
                                              ;  ================================
AB56                  fnOPENIN
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB56  8640                            LDA #$40
AB58  2006                            BRA fileOpen                    ;  OPENIN is OSFIND $40
                              ENDIF
                                              ;  =OPENOUT f$ - open file for output
                                              ;  ==================================
AB5A                  fnOPENOUT
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB5A  8680                            LDA #$80
AB5C  2002                            BRA fileOpen                    ;  OPENOUT is OSFIND $80
                              ENDIF
                      ;                       ;  =OPENUP f$ - open file for update
                      ;                       ;  =================================
AB5E                  fnOPENUP
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB5E  86C0                            LDA #$C0                        ;  OPENUP is OSFIND $C0
                              ENDIF
AB60                  fileOpen
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AB60  3402                            PSHS    A
AB62                                  CALL    evalLevel1
AB62                  9
AB64                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
000C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB62  BDAD70                                  JSR     \1
                              ENDIF
AB65  1026E882                        LBNE    brkTypeMismatch
AB69                                  CALL    str600CRterm
AB69                  9
AB6B                  __XBSR                  SET 9B+2
1100                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB69  BDBCF9                                  JSR     \1
                              ENDIF
AB6C  3502                            PULS    A
AB6E  BDFFCE                          JSR     OSFIND
AB71                                  JUMP    retA8asUINT
AB71  7EAE54                                  JMP     \1
                              ENDIF
                      ;
AB74                  fnPI                                                    ; LAAFF!
AB74                                  CALL    fpSetFPAPIdiv2                  ; load PI/2 into FPA and increment exponent for PI
AB74                  9
AB76                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB74  BDA905                                  JSR     \1
                              ENDIF
AB77  0C30                            INC     ZP_FPA + 2
AB79  39                              RTS
                      
                      ;                       ;  =EVAL string$ - Tokenise and evaluate expression
                      ;                       ;  ================================================
AB7A                  fnEVAL
                      
AB7A                                  TODO_CMD "EVAL"
AB7A                                          TODODEADEND "\1"
AB7A                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
AB7A  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
AB7B  7E443A                          FCB             $7E,"D:"
AB7E  4556414C                        FCB             \1
AB82  00                              FCB             0
                                              
                      ;               CALL evalLevel1
                      ;               BNE JUMPBrkTypeMismatch3                ;  Evaluate value, error if not string
                      ;               INC ZP_STRBUFLEN
                      ;               LDU ZP_STRBUFLEN                        ;  Increment string length to add a <cr>
                      ;               LDA #$0D
                      ;               STA $0600 - 1,Y                         ;  Put in terminating <cr>
                      ;               CALL StackString                                ;  Stack the string
                      ;                       ;  String has to be stacked as otherwise would
                      ;                       ;   be overwritten by any string operations
                      ;                       ;   called by Evaluator
                      ;               rep             #PF_I16
                      ;               .i16
                      ;               ldx             ZP_TXTPTR2
                      ;               phx
                      ;               lda             ZP_TXTOFF2
                      ;               pha
                      ;               ldx             ZP_BAS_SP
                      ;               inx
                      ;               stx             ZP_TXTPTR2
                      ;               stx             ZP_GEN_PTR
                      ;               sep             #PF_I16
                      ;               .i8
                      ;               CALL L8E1F                              ;  Tokenise string on stack at GPTR
                      ;               STZ ZP_TXTOFF2                          ;  Point PTRB offset back to start
                      ;               CALL evalAtY                            ;  Call expression evaluator
                      ;               CALL LBCE1                              ;  Drop string from stack
                      ;pullPTRBandRTS:
                      ;               rep                     #PF_I16
                      ;               .i16
                      ;               PLA
                      ;               STA ZP_TXTOFF2                          ;  Restore PTRB
                      ;               PLX
                      ;               STX ZP_TXTPTR
                      ;               sep                     #PF_A16
                      ;               .i8
                      ;               LDA ZP_VARTYPE                          ;  Get expression return value
                      ;               RTS                                     ;  And return
AB83                  JUMPBrkTypeMismatch3
AB83                                  JUMP brkTypeMismatch
AB83  7E93EB                                  JMP     \1
                      ;
                      ;
AB86                  fnVAL
                      
                                              ;  =VAL
AB86                                  CALL    evalLevel1
AB86                  9
AB88                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB86  BDAD70                                  JSR     \1
                              ENDIF
AB89  26F8                            BNE     JUMPBrkTypeMismatch3
AB8B  D636            str2Num         LDB     ZP_STRBUFLEN
AB8D  8E0600                          LDX     #BASWKSP_STRING
AB90  3A                              ABX
AB91  6F84                            CLR     ,X
AB93  3440                            PSHS    U
AB95  CE0600                          LDU     #BASWKSP_STRING
AB98                                  CALL    skipSpacesY
AB98                  9
AB9A                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AB98  BD928C                                  JSR     \1
                              ENDIF
AB9B  812D                            CMPA    #'-'
AB9D  270C                            BEQ     1F
AB9F  812B                            CMPA    #'+'
ABA1  2603                            BNE     2F
ABA3                                  CALL    skipSpacesY
ABA3                  9
ABA5                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABA3  BD928C                                  JSR     \1
                              ENDIF
ABA6                  2               CALL    parseDecimalLiteral
ABA6                  9
ABA8                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABA6  BDA379                                  JSR     \1
                              ENDIF
ABA9  200B                            BRA     3F
ABAB                  1               CALL    skipSpacesY
ABAB                  9
ABAD                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABAB  BD928C                                  JSR     \1
                              ENDIF
ABAE                                  CALL    parseDecimalLiteral
ABAE                  9
ABB0                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABAE  BDA379                                  JSR     \1
                              ENDIF
ABB1  2403                            BCC     3F
ABB3                                  CALL    evalLevel1CheckNotStringAndNegate
ABB3                  9
ABB5                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0060                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABB3  BDAD15                                  JSR     \1
                              ENDIF
ABB6  9727            3               STA     ZP_VARTYPE
ABB8  35C0                            PULS    U,PC
                      ;               
                      ;               
ABBA                  fnINT
                      
ABBA                                  CALL    evalLevel1
ABBA                  9
ABBC                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABBA  BDAD70                                  JSR     \1
                              ENDIF
ABBD  1027E82A                        LBEQ    brkTypeMismatch
ABC1  2A23                            BPL     1F                      ; already an INT
ABC3  962E                            LDA     ZP_FPA
ABC5  3401                            PSHS    CC                      ; get sign in Z flag and save
ABC7                                  CALL    fpFPAMant2Int_remainder_inFPB
ABC7                  9
ABC9                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0072                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABC7  BD863B                                  JSR     \1
                              ENDIF
ABCA  3501                            PULS    CC
ABCC  2A13                            BPL     LABAD                   ; if positive don't round down, just return FPA mant as int
ABCE  963D                            LDA     ZP_FPB + 2
ABD0  9A3E                            ORA     ZP_FPB + 3
ABD2  9A3F                            ORA     ZP_FPB + 4
ABD4  9A40                            ORA     ZP_FPB + 5
ABD6  2709                            BEQ     LABAD                   ; if remainder is 0 don't round down
ABD8                                  CALL    fpReal2Int_NegateMantissa       ; round down by decrementing mantissa - TODO: speed this up if room
ABD8                  9
ABDA                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABD8  BD868E                                  JSR     \1
                              ENDIF
ABDB                                  CALL    fpIncrementFPAMantissa
ABDB                  9
ABDD                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABDB  BD86C9                                  JSR     \1
                              ENDIF
ABDE                                  CALL    fpReal2Int_NegateMantissa
ABDE                  9
ABE0                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABDE  BD868E                                  JSR     \1
                              ENDIF
ABE1                  LABAD
ABE1                                  CALL    fpCopyAmant2intWA
ABE1                  9
ABE3                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0096                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABE1  BD9879                                  JSR     \1
                              ENDIF
ABE4  8640                            LDA     #$40
ABE6  39              1               RTS                             ;LABB2:
                      
                      
                      
ABE7                  fnASC
ABE7                                  CALL    evalLevel1
ABE7                  9
ABE9                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABE7  BDAD70                                  JSR     \1
                              ENDIF
ABEA  1026E7FD                        LBNE    brkTypeMismatch
ABEE  9636                            LDA     ZP_STRBUFLEN
ABF0  271F                            BEQ     returnINTminus1
ABF2  F60600                          LDB     BAS_StrA
ABF5                                  JUMP    retB8asUINT
ABF5  7EAE56                                  JMP     \1
                      
ABF8                  fnINKEY         ;  =INKEY
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
ABF8                                  CALL    callOSByte81withXYfromINT
ABF8                  9
ABFA                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0084                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ABF8  BDAA7E                                  JSR     \1
                              ENDIF
ABFB  8C8000                          CMPX    #$8000                          ; Check if X<0
ABFE  2411                            BHS     returnINTminus1
AC00                                  JUMP    retX16asUINT
AC00  7EAE60                                  JMP     \1
                              ENDIF
                      
                                              ;  =EOF#channel - return EndOfFile status - here to be near fnTRUE and fnFALSE
                                              ;  ===========================================================================
AC03                  fnEOF
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AC03                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
AC03                  9
AC05                  __XBSR                  SET 9B+2
0D00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC03  BDBA04                                  JSR     \1
                              ENDIF
AC06  30A4                            LEAX    ,Y                      ; X=channel
AC08  867F                            LDA     #$7F
AC0A  BDFFF4                          JSR     OSBYTE                  ; OSBYTE $7F to read EOF
AC0D  3084                            LEAX    0,X                     ; Test X
AC0F  270C                            BEQ     varFALSE                ; If &00, return FALSE
                                                                      ; Otherwise, return TRUE
                                                                      ;  Otherwise, return TRUE
                              ENDIF
                                              ;  =TRUE
                                              ;  =====
AC11                  returnINTminus1                                 ; TODO - possibly use D?
AC11  C6FF                            LDB #$FF                        ;  Return -1
AC13  1D              returnB8asINT_S SEX
AC14  972A                            STA ZP_INT_WA
AC16  972B                            STA ZP_INT_WA + 1
AC18  DD2C                            STD ZP_INT_WA + 2
AC1A  8640            returnINT       LDA #$40
AC1C  39                              RTS                             ;  Return Integer
                                              ;  =FALSE
                                              ;  ======
AC1D                  varFALSE                        
AC1D  5F                              CLRB
AC1E  20F3                            BRA returnB8asINT_S                     ;  Jump to return 0
                      
                      
AC20                  fnSGN_real                                              ; LABEC
AC20                                  CALL    fpCheckMant0SetSignExp0
AC20                  9
AC22                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC20  BDA47F                                  JSR     \1
                              ENDIF
AC23  27F8                            BEQ     varFALSE
AC25  2A17                            BPL     fnSGN_pos
AC27  20E8                            BRA     returnINTminus1
AC29                  fnSGN                                                   ; LABF5!
AC29                                  CALL    evalLevel1
AC29                  9
AC2B                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0045                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC29  BDAD70                                  JSR     \1
                              ENDIF
AC2C  1027E7BB                        LBEQ    brkTypeMismatch
AC30  2BEE                            BMI     fnSGN_real
AC32  962A                            LDA     ZP_INT_WA + 0
AC34  2BDB                            BMI     returnINTminus1
AC36  9A2B                            ORA     ZP_INT_WA + 1
AC38  9A2C                            ORA     ZP_INT_WA + 2
AC3A  9A2D                            ORA     ZP_INT_WA + 3
AC3C  27DC                            BEQ     returnINT
AC3E  C601            fnSGN_pos       LDB     #1
AC40  20D1                            BRA     returnB8asINT_S
                      
                      
AC42                  fnPOINT                 ; LAC0E!
                                              ; TODO: use hw stack?
AC42                                  CALL    evalAtYcheckTypeInAConvert2INT
AC42                  9
AC44                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC42  BD9860                                  JSR     \1
                              ENDIF
AC45                                  CALL    stackINT_WAasINT                ; stack X coord
AC45                  9
AC47                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC45  BDBB5A                                  JSR     \1
                              ENDIF
AC48                                  CALL    skipSpacesCheckCommaAtYOrBRK
AC48                  9
AC4A                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC48  BD929E                                  JSR     \1
                              ENDIF
AC4B                                  CALL    evalL1BracketAlreadyOpenConvert2INT
AC4B                  9
AC4D                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC4B  BD9858                                  JSR     \1
                              ENDIF
AC4E  DC2C                            LDD     ZP_INT_WA+2                     ; get Y coordinate big-endian
AC50  3406                            PSHS    D
AC52                                  CALL    popIntANew
AC52                  9
AC54                  __XBSR                  SET 9B+2
0F00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0098                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC52  BDBBEC                                  JSR     \1
                              ENDIF
AC55  DC2C                            LDD     ZP_INT_WA+2                     ; get X coordinate big-endian
AC57  1E89                            EXG     A,B
AC59  DD2A                            STD     ZP_INT_WA                       ; store X coordinate little-endian
AC5B  3506                            PULS    D
AC5D  1E89                            EXG     A,B
AC5F  DD2C                            STD     ZP_INT_WA+2                     ; store Y coordinate little-endian
AC61  8E002A                          LDX     #ZP_INT_WA
AC64  8609                            LDA     #9
AC66  BDFFF1                          JSR     OSWORD
AC69  D62E                            LDB     ZP_INT_WA+4
AC6B  2BA4                            BMI     returnINTminus1
AC6D  20A4                            BRA     returnB8asINT_S
AC6F                  fnINSTR
                      
AC6F                                  CALL    evalAtY
AC6F                  9
AC71                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC6F  BD9DC1                                  JSR     \1
                              ENDIF
AC72  4D                              TSTA
AC73  1026E774                        LBNE    brkTypeMismatch
AC77  C12C                            CMPB    #','
AC79  1026E626                        LBNE    brkMissingComma
AC7D  0C1B                            INC     ZP_TXTOFF2
AC7F                                  CALL    StackString
AC7F                  9
AC81                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC7F  BDBB74                                  JSR     \1
                              ENDIF
AC82  3341                            LEAU    1,U
AC84                                  CALL    evalAtY
AC84                  9
AC86                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC84  BD9DC1                                  JSR     \1
                              ENDIF
AC87  4D                              TSTA
AC88  1026E75F                        LBNE    brkTypeMismatch
AC8C                                  CALL    StackString
AC8C                  9
AC8E                  __XBSR                  SET 9B+2
0E00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC8C  BDBB74                                  JSR     \1
                              ENDIF
AC8F  8601                            LDA     #$01
AC91  972D                            STA     ZP_INT_WA + 3                   ; Default starting index (rest of INT_WA ignored)
AC93  3341                            LEAU    1,U
                      ;;              INC     ZP_TXTOFF2
AC95  C129                            CMPB    #')'
AC97  2709                            BEQ     fnINSTR_sk_nop3
AC99  C12C                            CMPB    #','
AC9B  1026E604                        LBNE    brkMissingComma
AC9F                                  CALL    evalL1BracketAlreadyOpenConvert2INT
AC9F                  9
ACA1                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AC9F  BD9858                                  JSR     \1
                              ENDIF
                      
ACA2  0D2D            fnINSTR_sk_nop3 TST     ZP_INT_WA + 3
ACA4  2602                            BNE     1F
ACA6  0C2D                            INC     ZP_INT_WA + 3                   ; if 0 make 1
ACA8  0A2D            1               DEC     ZP_INT_WA + 3                   ; now make it 0 based!
                      
ACAA  3440                            PSHS    U                               ; save Y we're about to use it for matching
ACAC  4F                              CLRA
ACAD  DE04                            LDU     ZP_BAS_SP
ACAF  E6C0                            LDB     ,U+                             ; D now contains length of second string
ACB1  D72A                            STB     ZP_INT_WA
ACB3  30C4                            LEAX    ,U                              ; X now points to start of second string
ACB5  33CB                            LEAU    D,U                             ; unstack string but leave in place for tests below
ACB7  E6C0                            LDB     ,U+                             ; D now contains length of first string
ACB9  D72B                            STB     ZP_INT_WA + 1
ACBB  31C4                            LEAY    ,U                              ; U points to start of 1st string
ACBD  33CB                            LEAU    D,U                             ; unstack string but leave in place
ACBF  DF04                            STU     ZP_BAS_SP
ACC1  D62D                            LDB     ZP_INT_WA + 3
ACC3  31AB                            LEAY    D,Y                             ; skip to param 3 offset
                      
ACC5                  fnINSTR_lp1     
ACC5  962D                            LDA     ZP_INT_WA + 3
ACC7  9B2A                            ADDA    ZP_INT_WA
ACC9  912B                            CMPA    ZP_INT_WA + 1
ACCB  221F                            BHI     fnINSTR_notfound                ; if length of match and offset > length of 1st param no match
ACCD  3430                            PSHS    X,Y                             ; save X,Y
ACCF  D62A                            LDB     ZP_INT_WA
ACD1  A680            1               LDA     ,X+
ACD3  A1A0                            CMPA    ,Y+
ACD5  260D                            BNE     fnINSTR_sknom                   ; nomatch try moving on one
ACD7  5A                              DECB
ACD8  26F7                            BNE     1B
                                      ; we have a match
ACDA  3264                            LEAS    4,S                             ; discard saved X,Y
ACDC  3540                            PULS    U                               ; get back original Y
ACDE  962D                            LDA     ZP_INT_WA + 3
ACE0  4C                              INCA                                    ; make back to 1 based
ACE1                                  JUMP    retA8asUINT
ACE1  7EAE54                                  JMP     \1
ACE4  3530            fnINSTR_sknom   PULS    X,Y
ACE6  3121                            LEAY    1,Y
ACE8  0C2D                            INC     ZP_INT_WA + 3
ACEA  20D9                            BRA     fnINSTR_lp1
                      
ACEC                  fnINSTR_notfound
ACEC  3540                            PULS    U
ACEE  4F                              CLRA
ACEF                                  JUMP    retA8asUINT
ACEF  7EAE54                                  JMP     \1
                      
                      
                      ;               CALL    popStackedString
                      ;LAC60:
                      ;               LDX ZP_INT_WA
                      ;               BNE LAC66
                      ;               LDX #$01
                      ;LAC66:
                      ;               STX ZP_INT_WA
                      ;               TXA
                      ;               DEX
                      ;               STX ZP_INT_WA + 3
                      ;               CLC
                      ;               ADC ZP_BAS_SP
                      ;               STA ZP_GEN_PTR
                      ;               LDA #$00
                      ;               ADC ZP_BAS_SP + 1
                      ;               STA ZP_GEN_PTR + 1
                      ;               LDA (ZP_BAS_SP)
                      ;               SEC
                      ;               SBC ZP_INT_WA + 3
                      ;               BCC LAC9F
                      ;               SBC ZP_STRBUFLEN
                      ;               BCC LAC9F
                      ;               ADC #$00
                      ;               STA ZP_INT_WA + 1
                      ;               CALL LBCE1
                      ;LAC89:
                      ;               LDU #$00
                      ;               LDX ZP_STRBUFLEN
                      ;               BEQ LAC9A
                      ;LAC8F:
                      ;               LDA (ZP_GEN_PTR),Y
                      ;               CMP $0600,Y
                      ;               BNE LACA6
                      ;               INY
                      ;               DEX
                      ;               BNE LAC8F
                      ;LAC9A:
                      ;               LDA ZP_INT_WA
                      ;LAC9C:
                      ;               LBRA retA8asUINT
                      ;LAC9F:
                      ;               CALL LBCE1
                      ;LACA2:
                      ;               LDA #$00
                      ;               BRA LAC9C
                      ;LACA6:
                      ;               INC ZP_INT_WA
                      ;               DEC ZP_INT_WA + 1
                      ;               BEQ LACA2
                      ;               INC ZP_GEN_PTR
                      ;               BNE LAC89
                      ;               INC ZP_GEN_PTR + 1
                      ;               BRA LAC89
                      ;JUMPBrkTypeMismatch:
                      ;               JUMP brkTypeMismatch
                      ;               
ACF2                  fnABS                   ;  =ABS
ACF2                                  CALL    evalLevel1
ACF2                  9
ACF4                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
ACF2  8D7C                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
ACF4  1027E6F3                        LBEQ    brkTypeMismatch
ACF8  2B06                            BMI     fpClearWA_A_sign
ACFA  0D2A            intWA_ABS       TST     ZP_INT_WA + 0
ACFC  2B1D                            BMI     negateIntA
ACFE  202B                            BRA     A_eq_40_rts
AD00                  fpClearWA_A_sign
AD00  0F2E                            CLR     ZP_FPA
AD02  39                              RTS
                      ;                       ;  Negate real
                      ;                       ;  -----------
AD03                  fpFPAeqPTR1subFPAnegFPA                                 ; LACC7
AD03                                  CALL    fpFPAeqPTR1subFPA               ; A = PTR1 - A, then negate A == A - PTR1
AD03                  9
AD05                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD03  BDA6C0                                  JSR     \1
                              ENDIF
AD06                  fpNegateFP_A
AD06  9631                            LDA     ZP_FPA + 3
AD08  2706                            BEQ     1F                              ;  Mantissa=0 - zero
AD0A  962E                            LDA     ZP_FPA
AD0C  8880                            EORA    #$80
AD0E  972E                            STA     ZP_FPA                  ;  Negate sign fp sign
AD10  86FF            1               LDA #$FF
AD12  39                              RTS                                     ;  Return real
                      
                      ;                       ;  -<value>
                      ;                       ;  --------
AD13                  evalLevel1UnaryMinus
AD13                                  CALL    evalLevel1UnaryPlus             ;  Call Level 1 Evaluator, get next value
AD13                  9
AD15                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AD13  8D6D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AD15                  evalLevel1CheckNotStringAndNegate                       ; LACDA
AD15  1027E6D2                        LBEQ    brkTypeMismatch                 ;  -<string> - Type mismatch
AD19  2BEB                            BMI     fpNegateFP_A                    ;  -<real> - Jump to negate real
                      ;               
AD1B                  negateIntA      
AD1B  CC0000                          LDD     #0
AD1E  932C                            SUBD    ZP_INT_WA + 2
AD20  DD2C                            STD     ZP_INT_WA + 2
AD22  CC0000                          LDD     #0
AD25  D22B                            SBCB    ZP_INT_WA + 1
AD27  922A                            SBCA    ZP_INT_WA + 0
AD29  DD2A                            STD     ZP_INT_WA + 0
AD2B  8640            A_eq_40_rts     LDA     #$40
AD2D  39                              RTS
                      ;               
                      ;               
AD2E                  readCommaSepString                                      ; LACF8
AD2E                                  CALL    skipSpacesY
AD2E                  9
AD30                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
005C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD2E  BD928C                                  JSR     \1
                              ENDIF
AD31  8122                            CMPA    #'"'
AD33  271B                            BEQ     evalLevel1StringLiteral
AD35  8E0600                          LDX     #BAS_StrA
AD38  335F                            LEAU    -1,U
AD3A  A6C0            1               LDA     ,U+
AD3C  A780                            STA     ,X+
AD3E  810D                            CMPA    #$0D
AD40  2704                            BEQ     LAD10
AD42  812C                            CMPA    #','
AD44  26F4                            BNE     1B
AD46  335F            LAD10           LEAU    -1,U
AD48  1F10                            TFR     X,D
AD4A  5A                              DECB
AD4B  D736                            STB     ZP_STRBUFLEN
AD4D  8600                            LDA #$00
AD4F  39                              RTS
                      ;                       ;  String value
                      ;                       ;  ------------
AD50                  evalLevel1StringLiteral                         ;LAD19:
AD50  8E0600                          LDX     #BAS_StrA
AD53                  evalLevel1StringLiteral_lp                      ;LAD1C:
AD53  A6C0                            LDA     ,U+
AD55  810D                            CMPA    #$0D
AD57  1027E860                        LBEQ    brkMissingQuote
AD5B  A780                            STA     ,X+
AD5D  8122                            CMPA    #'"'
AD5F  26F2                            BNE     evalLevel1StringLiteral_lp
AD61  A6C0                            LDA     ,U+
AD63  8122                            CMPA    #'"'
AD65  27EC                            BEQ     evalLevel1StringLiteral_lp
AD67  335F                            LEAU    -1,U
AD69  1F10                            TFR     X,D
AD6B  5A                              DECB
AD6C  D736                            STB     ZP_STRBUFLEN
AD6E  4F                              CLRA
AD6F  39                              RTS
                      ;               
                      ;                       ;  Evaluator Level 1 - $ - + () " ? ! | $ function variable
                      ;                       ;  ========================================================
                      ;                       ;  Evaluate a value - called by functions for value parameters
                      ;                       ;
AD70                  evalLevel1                                              ; LAD36
                      ;                               LEAU    1,Y             ; TODO - not sure whether to inc here or after
AD70  A6C0                            LDA     ,U+                             ;  Get next character
AD72  8120                            CMPA    #' '
AD74  27FA                            BEQ     evalLevel1                      ;  Skip spaces
AD76  812D                            CMPA    #'-'
AD78  2799                            BEQ     evalLevel1UnaryMinus            ;  Unary minus
AD7A  8122                            CMPA    #'"'
AD7C  27D2                            BEQ     evalLevel1StringLiteral         ;  String
AD7E  812B                            CMPA    #'+'
AD80  2603                            BNE     _sk2NotUnPlus                   ;  Not unary plus
                      ;                       
                      ;               ;  +<value>
                      ;               ;  --------                
AD82                  evalLevel1UnaryPlus                                     ; LAD4C
AD82                                  CALL    skipSpacesY
AD82                  9
AD84                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AD82  BD928C                                  JSR     \1
                              ENDIF
AD85  818E            _sk2NotUnPlus   CMPA    #tknOPENIN
AD87  2507                            BLO     evalL1_sk1                      ;  Not a function, try indirection and immediate value
AD89  81C6                            CMPA    #tknAUTO
AD8B  242F                            BHS     brkNoSuchVar                    ;  A command, not a function
AD8D                                  JUMP    exeTokenInA                     ;  Jump to dispatch function
AD8D  7E9375                                  JMP     \1
AD90  813F            evalL1_sk1      CMPA    #'?'
AD92  240C                            BHS     evalL1MemOrVar                  ;  ?, @, A+ - variable or ?value
AD94  812E                            CMPA    #'.'
AD96  2410                            BHS     evalL1ImmedNum                  ;  ./0-9    - decimal number
AD98  8126                            CMPA    #'&'
AD9A  274D                            BEQ     evalL1ImmedHex                  ;  Jump for &hex
AD9C  8128                            CMPA    #'('
AD9E  273E                            BEQ     evalL1BracketAlreadyOpen                ;  Jump for (expression
                                                                              ; Fall through with !value
                      
                      ;               ;  !value, ?value, variable
                      ;               ;  ------------------------
ADA0                  evalL1MemOrVar                                          ;LAD6A
                                                                              ;  Point to start of name + 1
ADA0                                  CALL    findVarAtYMinus1                ;  Search for !value ?value or variable
ADA0                  9
ADA2                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADA0  BD9A83                                  JSR     \1
                              ENDIF
ADA3  2709                            BEQ     NoSuchVar                       ;  Look for variable, jump if doesn't exist
ADA5                                  JUMP    GetVarValNewAPI                 ;  Fetch variable's value
ADA5  7EB1BF                                  JMP     \1
                      ;               ;  Immediate number
                      ;               ;  ----------------
ADA8                  evalL1ImmedNum                                          ;LAD74:
ADA8                                  CALL    parseDecimalLiteral             ;  Scan in decimal number
ADA8                  9
ADAA                  __XBSR                  SET 9B+2
F500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADA8  BDA379                                  JSR     \1
                              ENDIF
ADAB  240F                            BCC     brkNoSuchVar
ADAD  39                              RTS                             ;  Error if not a decimal number
                      ;               
                      ;               ;  Variable not found
                      ;               ;  ------------------
ADAE  9628            NoSuchVar       LDA     ZP_OPT                  ;  Get assembler OPTion
ADB0  8402                            ANDA    #$02
ADB2  2608                            BNE     brkNoSuchVar            ;  If OPT 2 set, give No such variable error
ADB4  2506                            BCS     brkNoSuchVar            ;  If invalid variable name, also give error
                      ;;              TODODEADEND "NoSuchVar - assembler OPT 2 - skip TXTPTR2?"
                      ;;              STX ZP_TXTOFF2                  ;  Store
ADB6  FC0442          GetP_percent    LDD     VAR_P_PERCENT+2
ADB9                                  JUMP    retD16asUINT
ADB9  7EAE57                                  JMP     \1
ADBC                  brkNoSuchVar
ADBC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
ADBC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
ADBD  1A4E6F2073756368207661726961626C6500                 FCB     $1A, "No such variable", 0
ADCF                  brkMissingEndBracket                            ; LAD9E
ADCF                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
ADCF  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
ADD0  1B8D2900                        FCB     $1B, tknMissing, ")", 0
ADD4                  brkBadHex                                       ; LADA2
ADD4                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
ADD4  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
ADD5  1C4261642048657800                 FCB     $1C, "Bad Hex", 0
                      
                      ;                       ;  (expression
                      ;                       ;  -----------
ADDE                  evalL1BracketAlreadyOpen                                        ; LADAC
ADDE                                  CALL    evalAtY                         ;  Call Level 7 Expression Evaluator
ADDE                  9
ADE0                  __XBSR                  SET 9B+2
EF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADDE  BD9DC1                                  JSR     \1
                              ENDIF
ADE1  3341                            LEAU    1,U
ADE3  C129                            CMPB    #')'
ADE5  26E8                            BNE     brkMissingEndBracket            ;  No terminating ')'
ADE7  4D                              TSTA
ADE8  39                              RTS                                     ;  Return result
                      
                      
ADE9                  evalL1ImmedHex                        ;LADB7
ADE9                                  CALL    varFALSE                        ; 0 intA
ADE9                  9
ADEB                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0032                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
ADE9  BDAC1D                                  JSR     \1
                              ENDIF
ADEC  5F                              CLRB
ADED                  evalL1ImmedHex_lp                                       ; LADBB
ADED  A6C0                            LDA     ,U+                             ; get digit
ADEF  8130                            CMPA    #'0'
ADF1  2522                            BLO     evalL1ImmedHex_skNotDig
ADF3  8139                            CMPA    #'9'
ADF5  230A                            BLS     evalL1ImmedHex_skGotDig
ADF7  8037                            SUBA    #'A' - $A                       ; hopefully got 'A-F', subtract to make 10-15
ADF9  810A                            CMPA    #$0A
ADFB  2518                            BLO     evalL1ImmedHex_skNotDig
ADFD  8110                            CMPA    #$10
ADFF  2414                            BHS     evalL1ImmedHex_skNotDig
AE01                  evalL1ImmedHex_skGotDig
AE01  48                              ASLA
AE02  48                              ASLA
AE03  48                              ASLA
AE04  48                              ASLA                                    ; shift into top nybble
AE05  C603                            LDB     #$03
AE07                  evalL1ImmedHex_lpShiftAcc
AE07  48                              ASLA                                    ; shift into IntA
AE08  092D                            ROL     ZP_INT_WA + 3
AE0A  092C                            ROL     ZP_INT_WA + 2
AE0C  092B                            ROL     ZP_INT_WA + 1
AE0E  092A                            ROL     ZP_INT_WA + 0
AE10  5A                              DECB
AE11  2AF4                            BPL     evalL1ImmedHex_lpShiftAcc
AE13  20D8                            BRA     evalL1ImmedHex_lp
AE15                  evalL1ImmedHex_skNotDig                                 ; LADE4
AE15  5D                              TSTB
AE16  2ABC                            BPL     brkBadHex
AE18  335F                            LEAU    -1,U
AE1A  DF19                            STU     ZP_TXTPTR2
AE1C  8640                            LDA     #$40
AE1E  39                              RTS
                      
AE1F                  fnADVAL
                              IF FLEX  = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AE1F                                  CALL    evalLevel1checkTypeStoreAsINT
AE1F                  9
AE21                  __XBSR                  SET 9B+2
EA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE1F  BD9865                                  JSR     \1
                              ENDIF
AE22  3420                            PSHS    y
AE24  9E2C                            LDX     ZP_INT_WA + 2                                   
AE26  8680                            LDA     #$80
AE28  BDFFF4                          JSR     OSBYTE
AE2B  3540                            PULS    U
AE2D  2031                            BRA     retX16asUINT
                              ENDIF
AE2F                  fnTO                    ; LADF9!
                      
AE2F  A6C0                            LDA     ,U+
AE31  8150                            CMPA    #'P'
AE33  1026FF85                        LBNE    brkNoSuchVar
AE37  DC12                            LDD     ZP_TOP
AE39  201C                            BRA retD16asUINT
AE3B                  varGetPAGE
                      
                      ;                       ;  =PAGE
AE3B  9618                            LDA     ZP_PAGE_H
AE3D  5F                              CLRB
AE3E  2017                            BRA     retD16asUINT
                      ;JUMPBrkTypeMismatch4:
                      ;               JUMP brkTypeMismatch
AE40                  fnLEN
                      ;                       ;  =LEN
AE40                                  CALL    evalLevel1
AE40                  9
AE42                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AE40  BDAD70                                  JSR     \1
                              ENDIF
AE43  1026E5A4                        LBNE    brkTypeMismatch
AE47  D636                            LDB     ZP_STRBUFLEN
AE49  200B                            BRA     retB8asUINT
                      
                      
AE4B  0F2C            retD16asUINT_LE CLR     ZP_INT_WA + 2           ; little endian version!
AE4D  0F2D                            CLR     ZP_INT_WA + 3           
AE4F  DD2A                            STD     ZP_INT_WA + 0
AE51  8640                            LDA     #$40
AE53  39                              RTS
                      
                      
AE54  1E89            retA8asUINT     EXG     A,B
AE56  4F              retB8asUINT     CLRA
AE57  DD2C            retD16asUINT    STD     ZP_INT_WA + 2
AE59  0F2A            retWA16asUINT   CLR     ZP_INT_WA + 0
AE5B  0F2B                            CLR     ZP_INT_WA + 1
AE5D  8640                            LDA     #$40
AE5F  39                              RTS
AE60  9F2C            retX16asUINT    STX     ZP_INT_WA + 2
AE62  20F5                            BRA     retWA16asUINT
                      
AE64                  fnCOUNT
                      
AE64  D61E                            LDB ZP_PRLINCOUNT
AE66  20EE                            BRA retB8asUINT
                      
AE68                  varGetLOMEM
                      
AE68  DC00                            LDD ZP_LOMEM
AE6A  20EB                            BRA retD16asUINT
AE6C                  varGetHIMEM
                      
AE6C  DC06                            LDD ZP_HIMEM
AE6E  20E7                            BRA retD16asUINT
AE70                  varERL
                                              ;  =ERL
AE70  DC08                            LDD     ZP_ERL
AE72  20E3                            BRA     retD16asUINT
AE74                  varERR
                                              ;  =ERR
AE74  E69F00FD                        LDB     [ZP_MOS_ERROR_PTR_QRY]
AE78  20DC                            BRA     retB8asUINT
AE7A                  fnGET
                                              ;  =GET
AE7A  BDFFE0                          JSR     OSRDCH
AE7D  20D5                            BRA     retA8asUINT
AE7F                  varGetTIME
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
                                              ;  =TIME
AE7F  A6C4                            LDA     ,U      
AE81  8124                            CMPA    #'$'
AE83  2720                            BEQ     varGetTIME_DOLLAR
AE85  3440                            PSHS    U
AE87  8E002A                          LDX     #ZP_INT_WA
AE8A  CE0000                          LDU     #$00                            ;DP
AE8D  8601                            LDA     #$01
AE8F  BDFFF1                          JSR     OSWORD
AE92  3540                            PULS    U
                                      
                      ; Swap endianness of Integer Accumulator
AE94                  SwapEndian                                              
                      ;;;             LDD     ZP_INT_WA                       ; 5     2
                      ;;;             PSHS    D                               ; 6     2
                      ;;;             LDD     ZP_INT_WA + 2                   ; 5     2
                      ;;;             EXG     A,B                             ; 7     2
                      ;;;             STD     ZP_INT_WA                       ; 5     2
                      ;;;             PULS    D                               ; 6     2
                      ;;;             EXG     A,B                             ; 7     2
                      ;;;             STD     ZP_INT_WA + 2                   ; 5     2
                                                                              ; 46    16
                      
AE94  9E2A                            LDX     ZP_INT_WA                       ; 5     2
AE96  DC2C                            LDD     ZP_INT_WA + 2                   ; 5     2
AE98  1E89                            EXG     A,B                             ; 7     2
AE9A  DD2A                            STD     ZP_INT_WA                       ; 5     2
AE9C  1F10                            TFR     X,D                             ; 7     2
AE9E  1E89                            EXG     A,B                             ; 7     2
AEA0  DD2C                            STD     ZP_INT_WA + 2                   ; 5     2
                                                                              ;41     14
                      
AEA2  8604                            LDA     #VAR_TYPE_INT
AEA4  39                              RTS
                              ENDIF
                      
AEA5                  varGetTIME_DOLLAR
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
AEA5  3341                            LEAU    1,U
AEA7  3440                            PSHS    U
AEA9  860E                            LDA     #$0E
AEAB  8E0600                          LDX     #BASWKSP_STRING
AEAE  6F84                            CLR     ,X
AEB0  BDFFF1                          JSR     OSWORD
AEB3  8618                            LDA     #$18
AEB5  3540                            PULS    U
AEB7  2037                            BRA     staZpStrBufLen
                              ENDIF
AEB9                  fnGETDOLLAR             ; LAE69!
                      
                                              
                      ;                       ;  =GET$
AEB9  BDFFE0                          JSR     OSRDCH
AEBC                  returnAAsString                                         ; LAE6C
AEBC  B70600                          STA     BASWKSP_STRING
AEBF                  returnString1
AEBF  8601                            LDA     #$01
AEC1  202D                            BRA     staZpStrBufLen
AEC3  F70600          returnBAsString STB     BASWKSP_STRING
AEC6  20F7                            BRA     returnString1
                      
AEC8                  fnLEFT                  ; LAE73!
AEC8                                  CLC
AEC8  1CFE                    ANDCC   #~CC_C
AECA  2002                            BRA     1F
AECC                  fnRIGHT                 ; LAE74!
                      
AECC                                  SEC
AECC  1A01                    ORCC    #CC_C
AECE  3401            1               PSHS    CC                      ; flag we want LEFT$ below
AED0                                  CALL    evalAtY
AED0                  9
AED2                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AED0  BD9DC1                                  JSR     \1
                              ENDIF
AED3  4D                              TSTA
AED4  1026E513                        LBNE    brkTypeMismatch
AED8  C12C                            CMPB    #','
AEDA  1026E3C5                        LBNE    brkMissingComma
AEDE  3341                            LEAU    1,U
AEE0                                  CALL    evalstackStringExpectINTCloseBracket
AEE0                  9
AEE2                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AEE0  BD9855                                  JSR     \1
                              ENDIF
AEE3                                  CALL    popStackedStringNew
AEE3                  9
AEE5                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AEE3  BDBBD6                                  JSR     \1
                              ENDIF
AEE6  3501                            PULS    CC
AEE8  250B                            BCS     fnRIGHT_do_RIGHT                ; DO RIGHT$
AEEA  962D                            LDA     ZP_INT_WA + 3
AEEC  9136                            CMPA    ZP_STRBUFLEN
AEEE  2402                            BCC     retAeq0
AEF0  9736            staZpStrBufLen  STA     ZP_STRBUFLEN
AEF2  8600            retAeq0         LDA     #$00
AEF4  39              rts_AE93        RTS
                      
                      
AEF5                  fnRIGHT_do_RIGHT                                        ; LAE94
AEF5  D636                            LDB     ZP_STRBUFLEN                    ; length of string
AEF7  D02D                            SUBB    ZP_INT_WA + 3                   ; minus length of amount to copy == length to skip
AEF9  25F7                            BCS     retAeq0
AEFB  27F7                            BEQ     rts_AE93
AEFD  962D                            LDA     ZP_INT_WA + 3
AEFF  9736                            STA     ZP_STRBUFLEN
AF01  27F1                            BEQ     rts_AE93
                      
AF03  108E0600                        LDY     #BASWKSP_STRING
AF07  8E0600                          LDX     #BASWKSP_STRING
AF0A  3A                              ABX
AF0B  D62D                            LDB     ZP_INT_WA + 3
AF0D                  LAEA5
AF0D  A680                            LDA     ,X+
AF0F  A7A0                            STA     ,Y+
AF11  5A                              DECB
AF12  26F9                            BNE     LAEA5
AF14  20DC                            BRA retAeq0
                      
                      
AF16                  fnINKEYDOLLAR           ; LAEB3!
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
                                              ;  =INKEY$
AF16                                  CALL callOSByte81withXYfromINT
AF16                  9
AF18                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0066                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF16  BDAA7E                                  JSR     \1
                              ENDIF
AF19  1F10                            TFR     X,D
AF1B  24A6                            BCC     returnBAsString
                              ENDIF
AF1D                  strRet0LenStr                                                   ; LAEBB
AF1D  4F                              CLRA    
AF1E  20D0                            BRA     staZpStrBufLen
                              
                                      ; YUSWAP - use Y and no push?
AF20                  fnMIDstr
AF20                                  CALL    evalAtY
AF20                  9
AF22                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF20  BD9DC1                                  JSR     \1
                              ENDIF
AF23  4D                              TSTA
AF24  1026E4C3                        LBNE    brkTypeMismatch                         ; must be a string!
AF28  C12C                            CMPB    #','
AF2A  1026E375                        LBNE    brkMissingComma                         ; expect ,
AF2E                                  CALL    StackString
AF2E                  9
AF30                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF2E  BDBB74                                  JSR     \1
                              ENDIF
AF31  3341                            LEAU    1,U                                     ; skip ,
AF33                                  CALL    evalAtYcheckTypeInAConvert2INT
AF33                  9
AF35                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
002B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF33  BD9860                                  JSR     \1
                              ENDIF
AF36  962D                            LDA     ZP_INT_WA + 3                           ; store low byte on stack
AF38  3402                            PSHS    A
AF3A  86FF                            LDA     #$FF
AF3C  972A                            STA     ZP_INT_WA                               ; default length to 255
AF3E  E6C4                            LDB     ,U                                      ; reload this, it may have been eaten converting to INT above
AF40  3341                            LEAU    1,U                                     ; skip next char
AF42  C129                            CMPB    #')'
AF44  2709                            BEQ     LAEEA                                   ; don't eval length
AF46  C12C                            CMPB    #','
AF48  1026E357                        LBNE    brkMissingComma
AF4C                                  CALL    evalL1BracketAlreadyOpenConvert2INT
AF4C                  9
AF4E                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF4C  BD9858                                  JSR     \1
                              ENDIF
AF4F  3504            LAEEA           PULS    B                                       ; get back 2nd param (start 1-based index)
AF51  3440                            PSHS    U                                       ; remember Y
AF53  2601                            BNE     1F
AF55  5C                              INCB                                            ; if 0 passed as index bump to 1
AF56  E19F0004        1               CMPB    [ZP_BAS_SP]
AF5A  222C                            BHI     strRet0LenStrPopYU                      ; branch if 2nd param > strlen
AF5C  D72C                            STB     ZP_INT_WA + 2
AF5E  9E04                            LDX     ZP_BAS_SP
AF60  3A                              ABX                                             ; X points at start of string to return
AF61  E69F0004                        LDB     [ZP_BAS_SP]
AF65  D02C                            SUBB    ZP_INT_WA + 2                           ; A=orig.len-ix
AF67  5C                              INCB
AF68  D12D                            CMPB    ZP_INT_WA + 3                           ; compare to 3rd param
AF6A  2402                            BHS     LAF08                                   ; if >= continue
AF6C  D72D                            STB     ZP_INT_WA + 3                           ; if < use that as required len
AF6E  D62D            LAF08           LDB     ZP_INT_WA + 3
AF70  2716                            BEQ     strRet0LenStrPopYU
AF72  D736                            STB     ZP_STRBUFLEN
AF74  8C0600                          CMPX    #BASWKSP_STRING
AF77  270A                            BEQ     unstackStringMIDS                               ; pointless copy?
AF79  CE0600                          LDU     #BASWKSP_STRING
AF7C  A680            LAF0C           LDA     ,X+
AF7E  A7C0                            STA     ,U+
AF80  5A                              DECB
AF81  26F9                            BNE     LAF0C
AF83                  unstackStringMIDS
AF83                                  CALL    unstackString
AF83                  9
AF85                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0007                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
AF83  8D07                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
AF85  4F                              CLRA
AF86  35C0                            PULS    U,PC
AF88                  strRet0LenStrPopYU
AF88  0F36                            CLR     ZP_STRBUFLEN
AF8A  20F7                            BRA     unstackStringMIDS
                      
AF8C  9E04            unstackString   LDX     ZP_BAS_SP
AF8E  E680                            LDB     ,X+                                     ; get stack str len to unstack
AF90  3A                              ABX                                             ; discard string and length byte
AF91  9F04                            STX     ZP_BAS_SP
AF93  39                              rts
                      
                      
AF94                  fnSTR                   ; LAF1C!
                      
AF94                                  CALL    skipSpacesY
AF94                  9
AF96                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AF94  BD928C                                  JSR     \1
                              ENDIF
AF97  C6FF                            LDB     #$FF
AF99  817E                            CMPA    #'~'
AF9B  2703                            BEQ     LAF29
AF9D  5F                              CLRB
AF9E  335F                            LEAU    -1,U
AFA0                  LAF29
AFA0  3404                            PSHS    B
AFA2                                  CALL    evalLevel1
AFA2                  9
AFA4                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFA2  BDAD70                                  JSR     \1
                              ENDIF
AFA5  9727                            STA     ZP_VARTYPE
AFA7  2717                            BEQ     LAF44brkTypeMismatch
AFA9  3504                            PULS    B
AFAB  3440                            PSHS    U
AFAD  D715                            STB     ZP_PRINTFLAG                    ; dec/hex flag
AFAF  B60400                          LDA     BASWKSP_INTVAR + 0              ; high byte of @%
AFB2  2607                            BNE     LAF3F
AFB4  9737                            STA     ZP_GEN_PTR
AFB6                                  CALL    cmdPRINT_num2str_invaldp
AFB6                  9
AFB8                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFB6  BDA1B6                                  JSR     \1
                              ENDIF
AFB9  2048                            BRA     LAF7AclrArts
AFBB                  LAF3F
AFBB                                  CALL    cmdPRINT_num2str
AFBB                  9
AFBD                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFBB  BDA19C                                  JSR     \1
                              ENDIF
AFBE  2043                            BRA     LAF7AclrArts
AFC0                  LAF44brkTypeMismatch
AFC0                                  JUMP brkTypeMismatch
AFC0  7E93EB                                  JMP     \1
AFC3                  fnSTRING                        ; LAF47!
                                              
                      ;                       ;  =STRING$
AFC3                                  CALL    evalAtYcheckTypeInAConvert2INT
AFC3                  9
AFC5                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
009B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFC3  BD9860                                  JSR     \1
                              ENDIF
AFC6                                  CALL    stackINT_WAasINT
AFC6                  9
AFC8                  __XBSR                  SET 9B+2
0B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0092                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFC6  BDBB5A                                  JSR     \1
                              ENDIF
AFC9                                  CALL    skipSpacesCheckCommaAtYOrBRK
AFC9                  9
AFCB                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFC9  BD929E                                  JSR     \1
                              ENDIF
AFCC                                  CALL    evalL1BracketAlreadyOpen
AFCC                  9
AFCE                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFCC  BDADDE                                  JSR     \1
                              ENDIF
AFCF  26EF                            BNE     LAF44brkTypeMismatch
AFD1  3440                            PSHS    U
AFD3                                  CALL    popIntANew
AFD3                  9
AFD5                  __XBSR                  SET 9B+2
0C00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
AFD3  BDBBEC                                  JSR     \1
                              ENDIF
AFD6  D636                            LDB     ZP_STRBUFLEN
AFD8  2729                            BEQ     LAF7AclrArts
AFDA  962D                            LDA     ZP_INT_WA + 3
AFDC  2728                            BEQ     fnStringRetBlank                ; 0 copies return ""
AFDE  0A2D                            DEC     ZP_INT_WA + 3
AFE0  2721                            BEQ     LAF7AclrArts                    ; 1 copy return string in buffer
AFE2  8E0600                          LDX     #BASWKSP_STRING
AFE5  D636                            LDB     ZP_STRBUFLEN
AFE7  3A                              ABX
AFE8                  fnStringCopyOuterLoop                                   ; copy string at end of buffer
AFE8  CE0600                          LDU     #BASWKSP_STRING
AFEB                  fnStringCopyInnerLoop                                   ; LAF66
AFEB  A6C0                            LDA     ,U+
AFED  A780                            STA     ,X+
AFEF  8C0700                          CMPX    #BASWKSP_STRING + $100
AFF2  1027EEAB                        LBEQ    brkStringTooLong
AFF6  5A                              DECB
AFF7  26F2                            BNE     fnStringCopyInnerLoop
AFF9  D636                            LDB     ZP_STRBUFLEN
AFFB  0A2D                            DEC     ZP_INT_WA + 3                   ; decrement outer loop counter
AFFD  26E9                            BNE     fnStringCopyOuterLoop
AFFF  1F10                            TFR     X,D                             ; get back low part of Y in B
B001  D736                            STB     ZP_STRBUFLEN                    ; use that as new string len
B003                  LAF7AclrArts
B003  4F                              CLRA
B004  35C0                            PULS    U,PC
B006                  fnStringRetBlank                                        ; LAF7D
B006  9736                            STA ZP_STRBUFLEN
B008  35C0                            PULS    U,PC
B00A                  brkNoSuchFN                             ; LAF83
                      ;;;;            PLA
                      ;;;;            STA ZP_TXTPTR + 1
                      ;;;;            PLA
                      ;;;;            STA ZP_TXTPTR
B00A  EE61                            LDU     1,S             ; get back stacked Y pointer (from callproc)
B00C  DF0B                            STU     ZP_TXTPTR       ; point back at caller so that ERL is reported correctly
B00E                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B00E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B00F  1D4E6F207375636820A42FF200                 FCB     $1D,"No such ", tknFN, "/", tknPROC,0
                      
                              *****************************************************************
                              *       Search Program For DEF PROC/FN                          *
                              *       On entry                                                *
                              *               [ZP_GEN_PTR + 2] + 1 = tknFN or tknPROC         *
                              *               [ZP_GEN_PTR + 2] + 2 = proc name                *
                              *               ZP_NAMELENORVT is proc name length + 2          *
                              *       Trashes A,B,X,U                                         *
                              *****************************************************************
                      
B01C                  progFndDEF_skNxtLinPULSU
B01C                  progFndDEF_skNxtLin                                     ; LAFB0
B01C  E603                            LDB     3,X                             ; line length add to X
B01E  3A                              ABX
B01F  2005                            BRA     progFndDEF_linLp
                      
B021                  progFindDEFPROC                                         ; LAF97
B021  9618                            LDA ZP_PAGE_H
B023  5F                              CLRB
B024  1F01                            TFR     D,X
B026                  progFndDEF_linLp                                        ; LAF9D
B026  6D01                            TST     1,X
B028  2BE0                            BMI     brkNoSuchFN                     ; check for end of program
B02A  3304                            LEAU    4,X                             ; point Y after 0D and line number
B02C                                  CALL    skipSpacesY
B02C                  9
B02E                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
005E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B02C  BD928C                                  JSR     \1
                              ENDIF
B02F  81DD                            CMPA    #tknDEF
B031  26E9                            BNE     progFndDEF_skNxtLin
B033                  progFndDEF_skDefFnd                                     ; LAFBF
B033  BD9295                          JSR     skipSpacesYStepBack
B036  109E39                          LDY     ZP_GEN_PTR + 2
B039  3121                            LEAY    1,Y                             ; point at FN/PROC token, Y already points at one hopefully
B03B  C601                            LDB     #1
B03D  DF0B                            STU     ZP_TXTPTR
B03F  A6C0            1               LDA     ,U+
B041  A1A0                            CMPA    ,Y+
B043  26D7                            BNE     progFndDEF_skNxtLinPULSU        ; compare caller / DEF token and name
B045  5C                              INCB
B046  D137                            CMPB    ZP_NAMELENORVT
B048  26F5                            BNE     1B
B04A  A6C4                            LDA     ,U                              ; get next char
B04C                                  CALL    checkIsValidVariableNameChar    ; if it looks like a variable name char
B04C                  9
B04E                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
000F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B04C  BD915D                                  JSR     \1
                              ENDIF
B04F  25CB                            BCS     progFndDEF_skNxtLinPULSU        ; then the DEF is for a longer name, keep searching
                      
                                      ; Y now points at parameters or whatever after DEFFNname
                                      ; ZP_TXTPTR starts at FN/PROC token
                                      ; X points at start of DEFFN line 
                      
                      
                      ;;;             INY
                      ;;;             STU ZP_TXTOFF
B051                                  CALL    skipSpacesYStepBack
B051                  9
B053                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0042                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B051  BD9295                                  JSR     \1
                              ENDIF
B054  DF0B                            STU     ZP_TXTPTR
                      ;;;             TYA
                      ;;;             TAX
                      ;;;             CLC
                      ;;;             ADC ZP_TXTPTR
                      ;;;             LDU ZP_TXTPTR + 1
                      ;;;             BCC LAFD0
                      ;;;             INY
                      ;;;             CLC
                      ;;;LAFD0:
                      ;;;             SBC #$00
                      ;;;             STA ZP_FPB + 1
                      ;;;             TYA
                      ;;;             SBC #$00
                      ;;;             STA ZP_FPB + 2
                      ;;;             LDU #$01
                      ;LAFDB:
                      
                      ;;;             INX
                      ;;;             LDA (ZP_FPB + 1),Y
                      ;;;             CMP (ZP_GEN_PTR),Y
                      ;;;             BNE progFndDEF_skNxtLin
                      ;;;             INY
                      ;;;             CPY ZP_NAMELENORVT
                      ;;;             BNE LAFDB
                      ;;;             LDA (ZP_FPB + 1),Y
                      ;;;             CALL checkIsValidVariableNameChar
                      ;;;             BCS progFndDEF_skNxtLin
                      ;               TXA
                      ;               TAY
                      ;               CALL storeYasTXTPTR
                      
B056                                  CALL    allocFNPROC
B056                  9
B058                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
007B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B056  BD99D3                                  JSR     \1
                              ENDIF
B059  8601                            LDA     #$01
B05B                                  CALL    AllocVarSpaceOnHeap
B05B                  9
B05D                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B05B  BD9A15                                  JSR     \1
                              ENDIF
B05E  DC0B                            LDD     ZP_TXTPTR
B060  9E02                            LDX     ZP_VARTOP
B062  ED81                            STD     ,X++
                      ;;;             LDA ZP_TXTPTR
                      ;;;             STA (ZP_VARTOP)
                      ;;;             LDU #$01
                      ;;;             LDA ZP_TXTPTR + 1
                      ;;;             STA (ZP_VARTOP),Y
                      ;;;             INY
B064                                  CALL    CheckVarFitsX
B064                  9
B066                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B064  BD9A1D                                  JSR     \1
                              ENDIF
B067  204A                            BRA     LB072                           ; back to main PROC call routine
                      ;
B069                  brkBadCall                                              ; LB00C
B069                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B069  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B06A  1E4261642063616C6C00                 FCB     $1E,"Bad call",0
                      
                      ;               ;  =FN / PROC
                      ;               ; ====
B074                  fnFN
                      ;                       
B074  86A4                            LDA     #tknFN
B076  9727            doFNPROCcall    STA     ZP_VARTYPE                      ;  Save PROC/FN token
B078  1F40                            TFR     S,D                             ; calculate new BASIC stack pointer 
B07A  830202                          SUBD    #MACH_STACK_TOP+2               ; by subtracting size of used machine stack + 2 (to store original stack pointer)
B07D  9E04                            LDX     ZP_BAS_SP
B07F  308B                            LEAX    D,X                             
B081                                  CALL    UpdStackFromXCheckFull          ;  Store new BASIC stack pointer, checking for free space
B081                  9
B083                  __XBSR                  SET 9B+2
0B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B081  BDBC14                                  JSR     \1
                              ENDIF
B084  10EF81                          STS     ,X++                            ; Store current machine stack pointer
B087  118C0200        1               CMPS    #MACH_STACK_TOP                 ; Copy machine stack contents to BASIC stack
B08B  2406                            BHS     2F                              ; TODO: use 16bit copy? Require test on first/last loop for single byte tfr
B08D  3502                            PULS    A
B08F  A780                            STA     ,X+
B091  20F4                            BRA     1B
B093                  2               ; S now points at top of stack X points at OLD U value
                                      ; stack active variables on machine stack
                                      ; note this is different to 6502!
B093  9627                            LDA     ZP_VARTYPE
B095  3442                            PSHS    A,U                             ; store PROC/FN token on the stack
                      ;;;             LDA ZP_VARTYPE
                      ;;;             PHA                                     ;  Push PROC/FN token
                      ;;;             LDA ZP_TXTOFF
                      ;;;             PHA
                      ;;;             LDA ZP_TXTPTR
                      ;;;             PHA                                     ;  Push PtrA line pointer
                      ;;;             LDA ZP_TXTPTR + 1
                      ;;;             PHA                                     ;  Push Prea line offset
                      ;;;             LDA ZP_TXTOFF2
                      ;;;             TAX
                      ;;;             CLC
                      ;;;             ADC ZP_TXTPTR2
                      ;;;             LDU ZP_TXTPTR2 + 1
                      ;;;             BCC LB04C
                      ;;;             INY
                      ;;;             CLC
                      ;;;;LB04C:
B097  335E                            LEAU    -2,U                            ; step back scan pointer
B099  DF39                            STU     ZP_GEN_PTR+2                    ; this is picked up in findFNPROC below
B09B  C602                            LDB     #$02
                      *               LEAU    1,U
B09D                                  CALL    fnProcScanYplusBvarname; Check name is valid
B09D                  9
B09F                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0036                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B09D  BD9BD5                                  JSR     \1
                              ENDIF
B0A0  C102                            CMPB    #2
B0A2  27C5                            BEQ     brkBadCall                      ; No valid characters
B0A4  301F                            LEAX    -1,X                            ; point ZP_TXTPTR2 at char after name
B0A6  9F19                            STX     ZP_TXTPTR2
B0A8                                  CALL    findFNPROC                      ; note: this also saves length in B at ZP_NAMELENORVT
B0A8                  9
B0AA                  __XBSR                  SET 9B+2
D300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B0A8  BD8487                                  JSR     \1
                              ENDIF
                                                                              ; Look for PROC/FN in heap
B0AB  1027FF72                        LBEQ    progFindDEFPROC                 ; Not in heap, jump to look in program
                                                                              ; LB068
B0AF  EE9F002C                        LDU     [ZP_INT_WA + 2]
B0B3                  LB072
B0B3  6FE2                            CLR     ,-S                             ; Store a 0 on the stack to mark 0 params
                      ;               STZ ZP_TXTOFF
B0B5                                  CALL    skipSpacesY
B0B5                  9
B0B7                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B0B5  BD928C                                  JSR     \1
                              ENDIF
B0B8  8128                            CMPA    #'('
B0BA  273A                            BEQ     doFNPROCargumentsEntry
B0BC  335F                            LEAU    -1,U
B0BE                  LB080
B0BE  9E19                            LDX     ZP_TXTPTR2
B0C0  3410                            PSHS    X
B0C2                                  CALL    skipSpacesAtYexecImmed          ; execute PROC/FN body
B0C2                  9
B0C4                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B0C2  BD936A                                  JSR     \1
                              ENDIF
B0C5  3510                            PULS    X
B0C7  9F19                            STX     ZP_TXTPTR2
B0C9  9F0B                            STX     ZP_TXTPTR
B0CB  A6E0                            LDA     ,S+                             ; get back params flag (use LD for flags)
B0CD  270C                            BEQ     doFnProcExit_NoParams
B0CF  973F                            STA     ZP_FPB + 4                      ; get number of "params" (and locals) to reset
B0D1                  LB09A
B0D1                                  CALL    popIntAtZP_GEN_PTRNew           ; get back variable pointer etc
B0D1                  9
B0D3                  __XBSR                  SET 9B+2
0B00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0029                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B0D1  BDBBFC                                  JSR     \1
                              ENDIF
B0D4                                  CALL    delocaliseAtZP_GEN_PTR
B0D4                  9
B0D6                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B0D4  BDBB94                                  JSR     \1
                              ENDIF
B0D7  0A3F                            DEC     ZP_FPB + 4
B0D9  26F6                            BNE     LB09A
B0DB                  doFnProcExit_NoParams
                      ;;;             PULS    A,Y
                      ;;;             LEAU    -1,Y
                      ;;;             LEAS    3,S                     ; discard stacked 
                      
                      ;               
                      ;               stz     $fef0                   ; TODO - TUBE ????
                      
B0DB  109E04                          LDY     ZP_BAS_SP
B0DE  10EEA1                          LDS     ,Y++                    ; get old machine stack pointer from
                                                                      ; BASIC stack
B0E1  30E4                            LEAX    ,S
B0E3  8C0200          1               CMPX    #MACH_STACK_TOP         ; copy bytes from BASIC stack to machine stack
B0E6  2406                            BHS     2F
B0E8  A6A0                            LDA     ,Y+
B0EA  A780                            STA     ,X+
B0EC  20F5                            BRA     1B
B0EE                  2
B0EE  DE0B                            LDU     ZP_TXTPTR
B0F0  9627                            LDA     ZP_VARTYPE              ; from FN =
B0F2  109F04                          STY     ZP_BAS_SP
B0F5  39                              RTS
                      
                      
                      
B0F6                  doFNPROCargumentsEntry
                                      ; Y is pointing at first char of params (after bracket) in DEF
                                      ; ZP_TXTPTR     at opening bracket of params in DEF
                                      ; ZP_TXTPTR2    at opening bracket of call
B0F6  9E19                            LDX     ZP_TXTPTR2
B0F8  3410                            PSHS    X
B0FA                                  CALL    findVarOrAllocEmpty
B0FA                  9
B0FC                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0035                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B0FA  BD9A31                                  JSR     \1
                              ENDIF
B0FD  2749                            BEQ     doBrkArguments
B0FF  3510                            PULS    X
B101  9F19                            STX     ZP_TXTPTR2
B103  3502                            PULS    A                               ; bet back "params flag"
B105  9E2C                            LDX     ZP_INT_WA + 2
B107  D62A                            LDB     ZP_INT_WA
B109  4C                              INCA
B10A  3416                            PSHS    D,X                             ; push back incremented var ptr, var type, params flag
B10C                                  CALL    localVarAtIntA                  ; push the variable value and pointer onto the BASIC stack
B10C                  9
B10E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B10C  BDB19F                                  JSR     \1
                              ENDIF
B10F                                  CALL    skipSpacesCheckCommaAtY         ; try and get another parameter
B10F                  9
B111                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B10F  BD90C8                                  JSR     \1
                              ENDIF
B112  27E2                            BEQ     doFNPROCargumentsEntry
B114  8129                            CMPA    #')'
B116  2630                            BNE     doBrkArguments                  ; check for closing bracket
B118  DF56                            STU     ZP_EXTRA_SAVE_PROC              ; TODO, stack this or get from somewhere else?
B11A  6FE2                            CLR     ,-S                             ; store a 0 on stack (to be used as another arguments counter)
B11C                                  CALL    skipSpacesPTRB
B11C                  9
B11E                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
006C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B11C  BD928A                                  JSR     \1
                              ENDIF
B11F  8128                            CMPA    #'('
B121  2625                            BNE     doBrkArguments
B123                  LB108
B123                                  CALL    evalAtY                         ; get value of argument
B123                  9
B125                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
009C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B123  BD9DC1                                  JSR     \1
                              ENDIF
B126  4D                              TSTA
B127                                  CALL    stackVarTypeInFlags             ; push it to BASIC stack
B127                  9
B129                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B127  BDBB56                                  JSR     \1
                              ENDIF
B12A  9627                            LDA     ZP_VARTYPE                      ; store "shadow" var type
B12C  972B                            STA     ZP_INT_WA + 1                   ; TODO: check we actually need all this, can probably just store ZP_VARTYPE on stack as rest is discarded!
B12E                                  CALL    stackINT_WAasINT                ; stack intA on BASIC stack
B12E                  9
B130                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
002A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B12E  BDBB5A                                  JSR     \1
                              ENDIF
B131  6CE4                            INC     ,S                              ; increment arguments counter
B133                                  CALL    skipSpacesCheckCommaAtY
B133                  9
B135                  __XBSR                  SET 9B+2
DF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B133  BD90C8                                  JSR     \1
                              ENDIF
B136  27EB                            BEQ     LB108
B138  8129                            CMPA    #')'
B13A  260C                            BNE     doBrkArguments
B13C  DF19                            STU     ZP_TXTPTR2
B13E  3506                            PULS    A,B                             ; get back two arguments counters
B140  D74C                            STB     ZP_FP_TMP + 9
B142  D74D                            STB     ZP_FP_TMP + 10
B144  914C                            CMPA    ZP_FP_TMP + 9                   ; check they're the same
B146  2714                            BEQ     LB140                           ; if so continue
B148                  doBrkArguments
B148  10CE01FE                        LDS     #MACH_STACK_TOP - 2
B14C  EEC1                            LDU     ,U++
B14E  DF0B                            STU     ZP_TXTPTR
B150                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B150  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B151  1F417267756D656E747300                 FCB     $1F,"Arguments",0
B15C                  LB140
B15C                                  CALL    popIntANew                      ; get back eval'd type from stack
B15C                  9
B15E                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B15C  BDBBEC                                  JSR     \1
                              ENDIF
B15F  3512                            PULS    A,X                             ; get back var type and variable pointer for argument variable
B161  972A                            STA     ZP_INT_WA + 0
B163  9F2C                            STX     ZP_INT_WA + 2
B165  4D                              TSTA
B166  2B20                            BMI     LB16D                           ; do string arg
B168  9737                            STA     ZP_NAMELENORVT
B16A  962B                            LDA     ZP_INT_WA + 1
B16C  27DA                            BEQ     doBrkArguments
B16E  9727                            STA     ZP_VARTYPE
B170  9E2C                            LDX     ZP_INT_WA + 2
B172  9F39                            STX     ZP_GEN_PTR+2                    ; stick var pointer at ZP_GEN_PTR+2
B174  9627                            LDA     ZP_VARTYPE
B176  2A08                            BPL     LB165
B178                                  CALL    popFPFromStackToPTR1
B178                  9
B17A                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B178  BDBB2E                                  JSR     \1
                              ENDIF
B17B                                  CALL    fpCopyPTR1toFPA
B17B                  9
B17D                  __XBSR                  SET 9B+2
F400                  __XBSR2                 SET (\1-__XBSR) & $FF00
0016                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B17B  BDA593                                  JSR     \1
                              ENDIF
B17E  2003                            BRA     LB168
B180                  LB165           CALL    popIntANew
B180                  9
B182                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
006A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B180  BDBBEC                                  JSR     \1
                              ENDIF
B183                  LB168           CALL    storeEvaledExpressioninVarAtZP_GEN_PTR
B183                  9
B185                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B183  BDB349                                  JSR     \1
                              ENDIF
B186  200A                            BRA     LB177
B188  962B            LB16D           LDA     ZP_INT_WA + 1
B18A  26BC                            BNE     doBrkArguments
B18C                                  CALL    popStackedStringNew
B18C                  9
B18E                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B18C  BDBBD6                                  JSR     \1
                              ENDIF
B18F                                  CALL    copyStringToVar2
B18F                  9
B191                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0077                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B18F  BD9408                                  JSR     \1
                              ENDIF
B192  0A4C            LB177           DEC     ZP_FP_TMP + 9
B194  26C6                            BNE     LB140
B196  964D                            LDA     ZP_FP_TMP + 10
B198  3402                            PSHS    A
B19A  DE56                            LDU     ZP_EXTRA_SAVE_PROC
B19C                                  JUMP    LB080
B19C  7EB0BE                                  JMP     \1
                      
                      
B19F                  localVarAtIntA                                          ; LB181
B19F  D62A                            LDB     ZP_INT_WA + 0                   ; get variable type
B1A1  C105                            CMPB    #VAR_TYPE_REAL
B1A3  3401                            PSHS    CC
B1A5  2406                            BHS     1F                              ; for not int
B1A7  8E0037                          LDX     #ZP_GEN_PTR
B1AA                                  CALL    CopyIntWA2X                     ; copy pointer to ZP_GEN_PTR, GetVarVal will overwrite it!
B1AA                  9
B1AC                  __XBSR                  SET 9B+2
0A00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B1AA  BDBCA3                                  JSR     \1
                              ENDIF
B1AD                  1                                                       ; LB18C
B1AD                                  CALL    GetVarValNewAPI
B1AD                  9
B1AF                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B1AD  8D10                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B1AF                                  CALL    stackVarTypeInFlags
B1AF                  9
B1B1                  __XBSR                  SET 9B+2
0900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B1AF  BDBB56                                  JSR     \1
                              ENDIF
B1B2  3501                            PULS    CC
B1B4  2406                            BHS     1F
B1B6  8E0037                          LDX     #ZP_GEN_PTR                     ; restore var pointer
B1B9                                  CALL    intLoadWAFromX                  ; get back variable pointer if we saved it
B1B9                  9
B1BB                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0034                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B1B9  BDAAEF                                  JSR     \1
                              ENDIF
B1BC                  1               JUMP    stackINT_WAasINT                ; and stack pointer
B1BC  7EBB5A                                  JMP     \1
                      
                                      ; trashses A, B, X
                      
B1BF                  GetVarValNewAPI                                         ; LB1A0
B1BF  962A                            LDA     ZP_INT_WA + 0                   ; Get type
B1C1  2B55                            BMI     GetVarValStr                    ; b7=String
B1C3  2726                            BEQ     store_wa_byte                   ; &00=Byte
B1C5  8105                            CMPA    #VAR_TYPE_REAL
B1C7  2729                            BEQ     GetVarValReal                   ; &05=Real
                      ;;JGH
B1C9  8104                            CMPA    #VAR_TYPE_INT
B1CB  2711                            BEQ     GetVarValInt                    ; &04=Integer
                      ; little-endian integer
B1CD  9E2C                            LDX     ZP_INT_WA + 2                   ; &02=Little-endian integer, TODO: check speed / size trade off with swapendian defined elsewhere if short of space
B1CF  EC81                            LDD     ,X++
B1D1  1E89                            EXG     A,B
B1D3  DD2C                            STD     ZP_INT_WA + 2
B1D5  EC81                            LDD     ,X++
B1D7  1E89                            EXG     A,B
B1D9  DD2A                            STD     ZP_INT_WA + 0
B1DB  8604                            LDA     #VAR_TYPE_INT
B1DD  39                              RTS
                      ;;^^^
                      
B1DE                  GetVarValInt
B1DE  9E2C                            LDX     ZP_INT_WA + 2
B1E0  EC81                            LDD     ,X++
B1E2  DD2A                            STD     ZP_INT_WA + 0
B1E4  EC81                            LDD     ,X++
B1E6  DD2C                            STD     ZP_INT_WA + 2
B1E8  8604                            LDA     #VAR_TYPE_INT
B1EA  39                              RTS
                      
B1EB  E69F002C        store_wa_byte   LDB     [ZP_INT_WA + 2]
B1EF                                  JUMP    retB8asUINT
B1EF  7EAE56                                  JMP     \1
                      
B1F2                  GetVarValReal                                           ; LB1C7
B1F2  4F                              CLRA
B1F3  9735                            STA     ZP_FPA + 7                      ; zero overflow mantissa and exponent bytes
B1F5  972F                            STA     ZP_FPA + 1
B1F7  EC03                            LDD     3,X
B1F9  DD33                            STD     ZP_FPA + 5
B1FB  EC01                            LDD     1,X
B1FD  D732                            STB     ZP_FPA + 4
B1FF  972E                            STA     ZP_FPA
B201  E684                            LDB     ,X
B203  D730                            STB     ZP_FPA + 2
B205  2608                            BNE     LB1EF
B207  9A32                            ORA     ZP_FPA + 4
B209  9A33                            ORA     ZP_FPA + 5
B20B  9A34                            ORA     ZP_FPA + 6
B20D  2704                            BEQ     LB1F2
B20F                  LB1EF
B20F  962E                            LDA     ZP_FPA
B211  8A80                            ORA     #$80
B213                  LB1F2
B213  9731                            STA     ZP_FPA + 3
B215  86FF                            LDA     #$FF
B217  39                              RTS                     ;  Return real
                      
                      
                      
B218  3440            GetVarValStr    PSHS    U               ; LB1F7
B21A  8180                            CMPA    #$80            ; check type of string
B21C  2717                            BEQ     GetVarValStr_Ind
B21E  DE2C                            LDU     ZP_INT_WA + 2   ; get address of param block
B220  A643                            LDA     3,U             ; get string len
B222  9736                            STA     ZP_STRBUFLEN
B224  270C                            BEQ     1F
B226  EEC4                            LDU     ,U              ; get address of actual string
B228  8E0600                          LDX     #BASWKSP_STRING
B22B                  2                                       ; LB20F:
B22B  E6C0                            LDB     ,U+
B22D  E780                            STB     ,X+
B22F  4A                              DECA
B230  26F9                            BNE     2B
B232                  1                                       ;LB218:
B232  4F                              CLRA                    ; indicate string returned
B233  35C0                            PULS    U,PC
                      
                                      ; read string from memory
B235                  GetVarValStr_Ind                                        ; LB219
B235  962C                            LDA     ZP_INT_WA + 2                   ; if MSB of string addr is 0 treat as a single char!
B237  271A                            BEQ     GetVarValStr_SingleCharAtINTWA3
B239  5F                              CLRB
B23A  9E2C                            LDX     ZP_INT_WA + 2
B23C  CE0600                          LDU     #BASWKSP_STRING
B23F                  1                                                       ; LB21F
B23F  A680                            LDA     ,X+
B241  A7C0                            STA     ,U+
B243  880D                            EORA    #$0D                            ; eor here ensures 0 A on exit
B245  2704                            BEQ     2F
B247  5C                              INCB
B248  26F5                            BNE     1B
B24A  4F                              CLRA
B24B                  2                                                       ; LB22C:
B24B  D736                            STB     ZP_STRBUFLEN
B24D  4F                              CLRA                    ; indicate string returned
B24E  35C0                            PULS    U,PC
                      
                      
B250                  fnCHR                   ; LB22F!
                      ;                       ;  =CHR$
B250                                  CALL    evalLevel1checkTypeStoreAsINT
B250                  9
B252                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B250  BD9865                                  JSR     \1
                              ENDIF
B253                  GetVarValStr_SingleCharAtINTWA3                         ; LB232
B253  962D                            LDA     ZP_INT_WA + 3                   ; get single char and return in ZP_STR_BUF
B255                                  JUMP    returnAAsString
B255  7EAEBC                                  JMP     \1
                      
                      
B258                  HandleBRKFindERL                                        ; LB237
B258  0F08                            CLR     ZP_ERL
B25A  0F09                            CLR     ZP_ERL + 1
B25C  9618                            LDA     ZP_PAGE_H
B25E  C600                            LDB     #0
B260  1F01                            TFR     D,X                     ; X points at start of program
B262  D60B                            LDB     ZP_TXTPTR
B264  C107                            CMPB    #BAS_InBuf / 256
B266  271C                            BEQ     HandleBRKFindERL_sk1
                      
B268                  HandleBRKFindERL_lp                             ;LB251:
B268  A680                            LDA     ,X+
B26A  810D                            CMPA    #$0D
B26C  2612                            BNE     HandleBRKFindERL_sk2
B26E  9C0B                            CMPX    ZP_TXTPTR
B270  2412                            BHS     HandleBRKFindERL_sk1
B272  A680                            LDA     ,X+
B274  8A00                            ORA     #$00                    ; check end of program
B276  2B0C                            BMI     HandleBRKFindERL_sk1
B278  9708                            STA     ZP_ERL
B27A  A680                            LDA     ,X+
B27C  9709                            STA     ZP_ERL + 1
B27E  A680                            LDA     ,X+
B280                  HandleBRKFindERL_sk2                                    ;LB270:
B280  9C0B                            CMPX    ZP_TXTPTR
B282  25E4                            BLO     HandleBRKFindERL_lp
B284                  HandleBRKFindERL_sk1                                    ;LB277:
B284  39                              RTS
B285                  HandleBRK
                              IF FLEX = 1
                                      LDX     ,S                              ; get stacked PC TODOFLEX: check for 6309?
                              ENDIF
B285  9FFD                            STX     ZP_MOS_ERROR_PTR_QRY            ; TODO: look at JGH API?
B287  C6FF                            LDB     #$FF
B289  D728                            STB     ZP_OPT
B28B                                  RESET_MACH_STACK
B28B  10CE0200                                LDS     #MACH_STACK_TOP
                              IF FLEX = 1
                              ELSE
B28F  3410                            PSHS    X
B291  8E0000                          LDX     #0
B294  CE0000                          LDU     #$00
B297  86DA                            LDA     #$DA
B299  BDFFF4                          JSR     OSBYTE                          ; clear VDU queue
B29C  867E                            LDA     #$7E
B29E  BDFFF4                          JSR     OSBYTE                          ; Acknowledge any Escape state
                              ENDIF
                      
B2A1                                  CALL    HandleBRKFindERL
B2A1                  9
B2A3                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B2A1  8DB5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B2A3  0F20                            CLR     ZP_TRACE
                      ;;              LDA     [ZP_MOS_ERROR_PTR_QRY]
B2A5  A6F1                            LDA     [,S++]
B2A7  2602                            BNE     HandleBRKsk1
B2A9                                  CALL    ONERROROFF
B2A9                  9
B2AB                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B2A9  8D0A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B2AB                  HandleBRKsk1                                            ; LB296
B2AB  DE16                            LDU     ZP_ERR_VECT
B2AD  DF0B                            STU     ZP_TXTPTR
B2AF                                  CALL    ResetStackProgStartRepeatGosubFor
B2AF                  9
B2B1                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2AF  BDBB18                                  JSR     \1
                              ENDIF
B2B2                                  JUMP    skipSpacesAtYexecImmed
B2B2  7E936A                                  JMP     \1
B2B5                  ONERROROFF
B2B5  308C03                          LEAX    defErrBas, PCR
B2B8  9F16                            STX     ZP_ERR_VECT
B2BA  39                              RTS
                      ;                       ;  Default error handler
                      ;                       ;  ---------------------
B2BB                  defErrBas
B2BB  F63AE79EF122206174206C696E6520223B                 FCB  tknREPORT, ':', tknIF, tknERL, tknPRINT, $22, " at line ", $22, ';'
B2CC  9E3AE08BF13AE0                  FCB  tknERL, ':', tknEND, tknELSE, tknPRINT, ":", tknEND
B2D3  0D                              FCB  13
                      
B2D4                  cmdSOUND                                                ; LB2C8
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
B2D4                                  CALL    evalForceINT
B2D4                  9
B2D6                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2D4  BD95A1                                  JSR     \1
                              ENDIF
B2D7  8607                            LDA     #OSWORD_SOUND
B2D9  3402                            PSHS    A                               ; store OSWORD # on stack
B2DB  C604                            LDB     #$04                            ; read 4 params
B2DD  9E2C            LB2CD           LDX     ZP_INT_WA + 2                   ; store 16 bit number on stack - reversing bytes
B2DF  3410                            PSHS    X
B2E1  5A                              DECB
B2E2  2709                            BEQ     1F
B2E4  3404                            PSHS    B
B2E6                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
B2E6                  9
B2E8                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2E6  BD985D                                  JSR     \1
                              ENDIF
B2E9  3504                            PULS    B
B2EB  20F0                            BRA     LB2CD
B2ED                  1               CALL    LDUZP_TXTPTR2scanNextStmtFromY
B2ED                  9
B2EF                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0074                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2ED  BD9C63                                  JSR     \1
                              ENDIF
B2F0  C607                            LDB     #$07                            ; # bytes to restore minus 1
B2F2  201E                            BRA     sndPullBthenAtoZP_SAVE_BUF_OSWORD_A
                              ENDIF
B2F4                  cmdENVELOPE                     ; LB2EC!
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
B2F4                                  CALL    evalForceINT
B2F4                  9
B2F6                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B2F4  BD95A1                                  JSR     \1
                              ENDIF
B2F7  8608                            LDA     #OSWORD_ENVELOPE
B2F9  3402                            PSHS    A                               ; store OSWORD #
B2FB  C60E                            LDB     #14                             ; read 14 params
B2FD  962D            LB2F1           LDA     ZP_INT_WA + 3                   ; get low byte of int
B2FF  3402                            PSHS    A
B301  5A                              DECB
B302  2709                            BEQ     1F
B304  3404                            PSHS    B
B306                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
B306                  9
B308                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0055                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B306  BD985D                                  JSR     \1
                              ENDIF
B309  3504                            PULS    B
B30B  20F0                            BRA     LB2F1
B30D                  1               CALL    LDUZP_TXTPTR2scanNextStmtFromY
B30D                  9
B30F                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0054                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B30D  BD9C63                                  JSR     \1
                              ENDIF
B310  C60D                            LDB     #13
B312                  sndPullBthenAtoZP_SAVE_BUF_OSWORD_A                             ; LB307
B312  8E0037                          LDX     #ZP_SAVE_BUF
B315  3502            1               PULS    A
B317  A785                            STA     B,X
B319  5A                              DECB
B31A  2AF9                            BPL     1B
B31C  3502                            PULS    A                               ; get back OSWORD #
B31E                  OSWORD_continue
B31E  3440                            PSHS    U
B320  BDFFF1                          JSR     OSWORD
B323  3540                            PULS    U
B325  200B                            BRA     LB322continue                   ; Call OSWORD, return to execution loop
                              ENDIF
                      
                      
B327                  cmdWIDTH
                      
B327                                  CALL    evalForceINT
B327                  9
B329                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B327  BD95A1                                  JSR     \1
                              ENDIF
B32A                                  CALL    scanNextStmtFromY
B32A                  9
B32C                  __XBSR                  SET 9B+2
E900                  __XBSR2                 SET (\1-__XBSR) & $FF00
0048                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B32A  BD9C74                                  JSR     \1
                              ENDIF
B32D  D62D                            LDB     ZP_INT_WA+3
B32F  5A                              DECB
B330  D723                            STB     ZP_WIDTH
B332                  LB322continue
B332                                  JUMP    continue
B332  7E9362                                  JMP     \1
B335                  LB325brkMismatch
B335                                  JUMP    brkTypeMismatch
B335  7E93EB                                  JMP     \1
B338                  evalAtYAndStoreEvaledExpressioninStackedVarPTr          ; LB328
B338                                  CALL evalAtY
B338                  9
B33A                  __XBSR                  SET 9B+2
EA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0087                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B338  BD9DC1                                  JSR     \1
                              ENDIF
                                      ; the pointer to the variable (and it's type) are on the stack above the return pointer
B33B                  storeEvaledExpressioninStackedVarPTr                    ; LB32B
                      ;               PLY
                      ;               PLX
                      ;               PLA
                      ;               STA ZP_NAMELENORVT
                      ;               PLA
                      ;               STA ZP_GEN_PTR + 1
                      ;               PLA
                      ;               STA ZP_GEN_PTR
                      ;               PHX
                      ;               PHY
B33B  A662                            LDA     2,S
B33D  9737                            STA     ZP_NAMELENORVT
B33F  AE63                            LDX     3,S
B341  9F39                            STX     ZP_GEN_PTR+2
B343  3510                            PULS    X
B345  3263                            LEAS    3,S
B347  3410                            PSHS    X
B349                  storeEvaledExpressioninVarAtZP_GEN_PTR                  ; LB338
B349  9637                            LDA     ZP_NAMELENORVT
B34B  8105                            CMPA    #VAR_TYPE_REAL
B34D  2732                            BEQ     storeEvaledExpressioninRealVarAtZP_GEN_PTR
B34F  9627                            LDA     ZP_VARTYPE
B351  27E2                            BEQ     LB325brkMismatch
B353  2A03                            BPL     storeInt1
B355                                  CALL    fpReal2Int
B355                  9
B357                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B355  BD9876                                  JSR     \1
                              ENDIF
B358                  storeInt1                                               ;LB347:
                      ;;;JGH
                      ;               TST     ZP_NAMELENORVT
B358  9637                            LDA     ZP_NAMELENORVT
B35A  271E                            BEQ     storeByte
B35C  8102                            CMPA    #$02
B35E  270B                            BEQ     storeInt2                       ; little-endian word
B360  9E39                            LDX     ZP_GEN_PTR+2
B362  DC2A                            LDD     ZP_INT_WA
B364  ED84                            STD     0,X
B366  DC2C                            LDD     ZP_INT_WA + 2
B368  ED02                            STD     2,X
B36A  39                              RTS
B36B                  storeInt2                                               ; Store little-endian word
B36B  9E39                            LDX     ZP_GEN_PTR+2
B36D  DC2A                            LDD     ZP_INT_WA
B36F  1E89                            EXG     A,B
B371  ED02                            STD     2,X
B373  DC2C                            LDD     ZP_INT_WA + 2
B375  1E89                            EXG     A,B
B377  ED84                            STD     0,X
B379  39                              RTS
                      ;;;^^^
B37A                  storeByte
B37A  962D                            LDA     ZP_INT_WA + 3
B37C  A79F0039                        STA     [ZP_GEN_PTR+2]
B380  39                              RTS
B381                  storeEvaledExpressioninRealVarAtZP_GEN_PTR              ; LB360
B381  9627                            LDA     ZP_VARTYPE
B383  27B0                            BEQ     LB325brkMismatch
B385  2B03                            BMI     skIntToReal1
B387                                  CALL    IntToReal
B387                  9
B389                  __XBSR                  SET 9B+2
D100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B387  BD856A                                  JSR     \1
                              ENDIF
B38A                  skIntToReal1                                            ; LB369
B38A  9E39                            LDX     ZP_GEN_PTR+2
B38C                  fpCopyFPAtoX
B38C  9630                            LDA     ZP_FPA + 2
B38E  A780                            STA     ,X+
B390  962E                            LDA     ZP_FPA                  ; get mantissa sign back from sign byte
B392  9831                            EORA    ZP_FPA + 3
B394  8480                            ANDA    #$80
B396  9831                            EORA    ZP_FPA + 3
B398  A780                            STA     ,X+
B39A  9632                            LDA     ZP_FPA + 4
B39C  A780                            STA     ,X+
B39E  9633                            LDA     ZP_FPA + 5
B3A0  A780                            STA     ,X+
B3A2  9634                            LDA     ZP_FPA + 6
B3A4  A780                            STA     ,X+
B3A6  39                              RTS
                      
B3A7                  cmdEDIT                 
B3A7                                  CALL    ResetVars
B3A7                  9
B3A9                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3A7  BDBAF0                                  JSR     \1
                              ENDIF
B3AA  8680                            LDA     #$80
B3AC  971F                            STA     ZP_LISTO
                      
B3AE                  doLIST
B3AE  0F3B                            CLR     ZP_FPB
B3B0  0F3C                            CLR     ZP_FPB + 1
B3B2                                  CALL    varFALSE                        ; set start line no to 0
B3B2                  9
B3B4                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3B2  BDAC1D                                  JSR     \1
                              ENDIF
B3B5                                  CALL    skipSpacesDecodeLineNumberNewAPI
B3B5                  9
B3B7                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0044                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3B5  BD9BFB                                  JSR     \1
                              ENDIF
B3B8  3401                            PSHS    CC
B3BA                                  CALL    stackINT_WAasINT                ; stack start line no
B3BA                  9
B3BC                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
009E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3BA  BDBB5A                                  JSR     \1
                              ENDIF
B3BD                                  CALL    returnINTminus1                 ; set end line no to FFFF
B3BD                  9
B3BF                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0052                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3BD  BDAC11                                  JSR     \1
                              ENDIF
B3C0  042C                            LSR     ZP_INT_WA + 2                   ; note line number in +2,3, clear top bit end 
                                                                              ; line no. max is 32767
                                                                              ; LB3AD:
B3C2  3501                            PULS    CC
B3C4  240D                            BCC     doListSkNoLineSpec
B3C6                                  CALL    skipSpacesCheckCommaAtYStepBack         ; look for a comma, 
B3C6                  9
B3C8                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3C6  BD90CE                                  JSR     \1
                              ENDIF
B3C9  270B                            BEQ     doListSkLineSpec2
                                      ; no second spec, pop first speccd line and use as 2nd param
B3CB                                  CALL    popIntANew                      ; unstack then stack - TODO: check if can load using off,U
B3CB                  9
B3CD                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
001F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3CB  BDBBEC                                  JSR     \1
                              ENDIF
B3CE                                  CALL    stackINT_WAasINT
B3CE                  9
B3D0                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
008A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3CE  BDBB5A                                  JSR     \1
                              ENDIF
B3D1  2006                            BRA     doListSkStart
B3D3                  doListSkNoLineSpec                                      ;LB3BF:
B3D3                                  CALL    skipSpacesCheckCommaAtYStepBack ; if there's a comma skip it 
B3D3                  9
B3D5                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3D3  BD90CE                                  JSR     \1
                              ENDIF
B3D6                  doListSkLineSpec2                                       ;LB3C6:
B3D6                                  CALL    skipSpacesDecodeLineNumberNewAPI; this will return $FFFF if no match (i.e. go to the end!)
B3D6                  9
B3D8                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0023                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3D6  BD9BFB                                  JSR     \1
                              ENDIF
B3D9                  doListSkStart                                           ;LB3C9:
B3D9  8E0031                          LDX     #ZP_FPA + 3
B3DC                                  CALL    CopyIntWA2X
B3DC                  9
B3DE                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3DC  BDBCA3                                  JSR     \1
                              ENDIF
B3DF                                  CALL    skipSpacesYStepBack
B3DF                  9
B3E1                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B4                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3DF  BD9295                                  JSR     \1
                              ENDIF
B3E2  81E7                            CMPA    #tknIF
B3E4  261A                            BNE     doListSkStart2
B3E6                                  CALL    inySkipSpacesYStepBack
B3E6                  9
B3E8                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3E6  BD9293                                  JSR     \1
                              ENDIF
B3E9  2018                            BRA     doListSkStart3
B3EB                  cmdLIST
                      
                                              
                      ;                       ;  LIST
B3EB  A6C4                            LDA     ,U
                      
B3ED  814F                            CMPA    #'O'
B3EF  26BD                            BNE     doLIST
B3F1  3341                            LEAU    1,U
B3F3                                  CALL    evalForceINT
B3F3                  9
B3F5                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00AC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3F3  BD95A1                                  JSR     \1
                              ENDIF
B3F6                                  CALL    scanNextStmtFromY
B3F6                  9
B3F8                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B3F6  BD9C74                                  JSR     \1
                              ENDIF
B3F9  962D                            LDA     ZP_INT_WA + 3
B3FB  971F                            STA     ZP_LISTO
B3FD                                  JUMP    immedPrompt
B3FD  7E92EF                                  JMP     \1
B400                  doListSkStart2                                          ; LB3F3:
B400                                  CALL    scanNextExpectColonElseCR
B400                  9
B402                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0075                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B400  BD9C77                                  JSR     \1
                              ENDIF
B403                  doListSkStart3                                          ; LB3F6:
B403  DF19                            STU     ZP_TXTPTR2                      ; point at first non-space after IF token or <CR> if not LIST IF
B405                                  CALL    findTOP
B405                  9
B407                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B405  BDBCBF                                  JSR     \1
                              ENDIF
B408                                  CALL    popIntANew                      ; intWA now contains ending line no
B408                  9
B40A                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B408  BDBBEC                                  JSR     \1
                              ENDIF
B40B                                  CALL    findProgLineNewAPI
B40B                  9
B40D                  __XBSR                  SET 9B+2
D000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B40B  BD84C9                                  JSR     \1
                              ENDIF
B40E  2515                            BCS     doListSkGotCorrectLine
B410  200F                            BRA     doListSkGotNearestLine
B412                  doListPrintLFThenLoop                                   ; LB410
B412                                  CALL    list_printA
B412                  9
B414                  __XBSR                  SET 9B+2
0800                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B412  BDBC6F                                  JSR     \1
                              ENDIF
B415  0D1F                            TST     ZP_LISTO
B417  2B05                            BMI     doListLoop
B419  860A                            LDA     #$0A
B41B  BDFFEE                          JSR     OSWRCH
B41E                  doListLoop                                              ;LB41C
                      ;;              CALL storeYasTXTPTR
B41E                                  CALL    checkForESC
B41E                  9
B420                  __XBSR                  SET 9B+2
E800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0065                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B41E  BD9C85                                  JSR     \1
                              ENDIF
B421                  doListSkGotNearestLine                                  ;LB41F:
B421  AE41                            LDX     1,U                              ; get the actual line number found
B423  9F2C                            STX     ZP_INT_WA + 2
B425                  doListSkGotCorrectLine                                  ;LB428:
B425  9E2C                            LDX     ZP_INT_WA + 2
B427  9C33                            CMPX    ZP_FPA + 5      
B429  2316                            BLS     doListStartLine
B42B  0D1F                            TST     ZP_LISTO
B42D  102ADEBE                        LBPL    immedPrompt
B431  308C03                          LEAX    strEdit12_2,PCR
B434  7EFFF7                          JMP     OSCLI
                      
                      ;                       ;  EDIT
                      ;                       ;  ====
B437                  strEdit12_2                             ;LB389:
B437  454449542031322C320D                 FCB     "EDIT 12,2", $0d
                      
                      
B441                  doListStartLine                                         ; LB43E:
B441  0F4C                            CLR     ZP_FP_TMP + 9                   ; flag Quote/REM open
B443  0F4D                            CLR     ZP_FP_TMP + 10                  ; flag whether to display line
B445  3344                            LEAU    4,U                             ; point at first char/token of actual line 
B447  DF0B                            STU     ZP_TXTPTR                       ; store pointer for later after scan
                      
                                      ; scan the line for UNTIL/NEXT for indents
                                      ; scan the line for matches if doing LIST IF
                      
                                      ; reset indent levels if -ve
B449  0D3B                            TST     ZP_FPB
B44B  2A02                            BPL     doListSk0
B44D  0F3B                            CLR     ZP_FPB
B44F                  doListSk0                                               ;LB44E:
B44F  0D3C                            TST     ZP_FPB + 1
B451  2A02                            BPL     doListSk1
B453  0F3C                            CLR     ZP_FPB + 1
B455                  doListSk1                                               ;LB454:
B455                  doListScanLoop
B455  A6C4                            LDA     ,U                              ;  Get character
B457  810D                            CMPA    #$0D
B459  2738                            BEQ     doListScanDone                  ;  End of line
B45B  81F4                            CMPA    #tknREM
B45D  2706                            BEQ     doListSkREM                     ; ignore quotes in REMs
B45F  8122                            CMPA    #'"'
B461  2604                            BNE     doListSkREMQuot
B463  984C                            EORA    ZP_FP_TMP + 9                   ;  Toggle quote flag (no effect after REM!)
B465                  doListSkREM                                             ;LB464:
B465  974C                            STA     ZP_FP_TMP + 9                   ; if a REM store tknREM, if a Quote toggle
B467                  doListSkREMQuot                                         ; LB466
B467  0D4C                            TST     ZP_FP_TMP + 9
B469  260C                            BNE     doListSkUntil                   ;  Within quotes / REM
B46B  81ED                            CMPA    #tknNEXT
B46D  2602                            BNE     doListSkNext
B46F  0A3B                            DEC     ZP_FPB                          ; decrement NEXT indent level
B471                  doListSkNext                                            ; LB470
B471  81FD                            CMPA    #tknUNTIL
B473  2602                            BNE     doListSkUntil
B475  0A3C                            DEC     ZP_FPB + 1                      ; decrement UNTIL indent level
B477                  doListSkUntil                                           ; LB476
                      
                                      ; LIST IF
                      
B477  9E19                            LDX     ZP_TXTPTR2                      ; LIST IF 
B479  3440                            PSHS    U                               
B47B                  doListLp_Uk1                                            ; LB478
B47B  A684                            LDA     ,X                              ; scan line after LIST IF and try and match within the current line
B47D  810D                            CMPA    #$0D
B47F  270A                            BEQ     doListSk_Uk1
B481  A1C4                            CMPA    ,U
B483  2608                            BNE     doListSk_Uk2
B485  3341                            LEAU    1,U
B487  3001                            LEAX    1,X
B489  20F0                            BRA     doListLp_Uk1
                      
B48B                  doListSk_Uk1                                            ; LB489:
B48B  974D                            STA     ZP_FP_TMP + 10                  ; matched LIST IF (or there wasn't one) do print this line
B48D                  doListSk_Uk2                                            ; LB48B:
B48D  3540                            PULS    U
B48F  3341                            LEAU    1,U
B491  20C2                            BRA     doListScanLoop
B493                  doListScanDone                                          ;LB491:
B493  964D                            LDA     ZP_FP_TMP + 10
B495  2787                            BEQ     doListLoop
B497                                  CALL    int16print_fmt5                 ; print line number
B497                  9
B499                  __XBSR                  SET 9B+2
EC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B497  BDA0D0                                  JSR     \1
                              ENDIF
B49A  8601                            LDA     #$01
B49C  5C                              INCB                                    ; set to 0
B49D                                  SEC
B49D  1A01                    ORCC    #CC_C
B49F                                  CALL    doLISTOSpaces                   ; LISTO1 - space after Line no
B49F                  9
B4A1                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B49F  BDBC94                                  JSR     \1
                              ENDIF
B4A2  D63B                            LDB     ZP_FPB
B4A4  8602                            LDA     #$02
B4A6                                  CALL    doLISTOSpacesCLC                ; LISTO2 - NEXT indents
B4A6                  9
B4A8                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4A6  BDBC92                                  JSR     \1
                              ENDIF
B4A9  D63C                            LDB     ZP_FPB + 1
B4AB  8604                            LDA     #$04                            ; LISTO4 - REPEAT/UNTIL indents
B4AD                                  CALL    doLISTOSpacesCLC
B4AD                  9
B4AF                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4AD  BDBC92                                  JSR     \1
                              ENDIF
B4B0  0F4C                            CLR     ZP_FP_TMP + 9
B4B2                  doListNextTok2                                          ;LB4AF:
B4B2  DE0B                            LDU     ZP_TXTPTR                       ; TODO reset Y pointer here?
B4B4                  doListNextTok                                           ; LB4B1:
B4B4  A6C4                            LDA     ,U
B4B6  810D                            CMPA    #$0D
B4B8  1027FF56                        LBEQ    doListPrintLFThenLoop
B4BC  8122                            CMPA    #'"'
B4BE  260D                            BNE     doListSkNotQuot2
B4C0  984C                            EORA    ZP_FP_TMP + 9
B4C2  974C                            STA     ZP_FP_TMP + 9                   ; Toggle quote flag
B4C4  8622                            LDA     #'"'
B4C6                  doListQuoteLp2                                          ; LB4C1
B4C6                                  CALL    list_printA
B4C6                  9
B4C8                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4C6  BDBC6F                                  JSR     \1
                              ENDIF
B4C9  3341                            LEAU    1,U
B4CB  20E7                            BRA     doListNextTok
B4CD                  doListSkNotQuot2                                        ; LB4C7:
B4CD  0D4C                            TST     ZP_FP_TMP + 9
B4CF  26F5                            BNE     doListQuoteLp2
B4D1  818D                            CMPA    #tknLineNo
B4D3  260A                            BNE     doList_sknotLineNo
B4D5  3341                            LEAU    1,U
B4D7                                  CALL    decodeLineNumber
B4D7                  9
B4D9                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
002F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4D7  BD9C08                                  JSR     \1
                              ENDIF
                                                                              ;               STU ZP_TXTOFF - don't think this is needed any longer
B4DA                                  CALL    int16print_AnyLen
B4DA                  9
B4DC                  __XBSR                  SET 9B+2
EB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4DA  BDA0CC                                  JSR     \1
                              ENDIF
B4DD  20D5                            BRA     doListNextTok                   ;               DB: changes to not restore Y as int16print not longer trashes it
B4DF                  doList_sknotLineNo                                      ; LB4D9:
B4DF  81E3                            CMPA    #tknFOR
B4E1  2602                            BNE     doList_sknotFOR
B4E3  0C3B                            INC     ZP_FPB
B4E5                  doList_sknotFOR                                         ; LB4DF:
B4E5  81F5                            CMPA    #tknREPEAT
B4E7  2602                            BNE     doList_sknotREPEAT
B4E9  0C3C                            INC     ZP_FPB + 1
B4EB                  doList_sknotREPEAT                                      ; LB4E5:
B4EB  81F4                            CMPA    #tknREM
B4ED  2602                            BNE     doList_sknotREM
B4EF  974C                            STA     ZP_FP_TMP + 9
B4F1                  doList_sknotREM                                         ;LB4EB:
B4F1                                  CALL    doListPrintTokenA
B4F1                  9
B4F3                  __XBSR                  SET 9B+2
0700                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4F1  BDBC21                                  JSR     \1
                              ENDIF
B4F4  3341                            LEAU    1,U
B4F6  20BC                            BRA     doListNextTok
                      
                      
                                              ; cmdNEXT
                                              ; =======
B4F8                  cmdNEXT
B4F8                                  CALL    findVarAtYSkipSpaces
B4F8                  9
B4FA                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B4F8  BD9A7D                                  JSR     \1
                              ENDIF
B4FB  2609                            BNE     cmdNextSkSpecdLoopVar
B4FD  D626                            LDB     ZP_FOR_LVL_X_15
B4FF  273B                            BEQ     brkNoFOR
B501  2542                            BCS     cmdNEXTTopLoopVar
B503                  cmdNextskSyntax JUMP    brkSyntax
B503  7E9C37                                  JMP     \1
B506                  cmdNextSkSpecdLoopVar                                   ; LB4FF
B506  25FB                            BCS     cmdNextskSyntax                 ; TODO: should this not be can't match for? Bug in original BASIC?
B508  3440                            PSHS    U                               ; use Y as gen ptr, remember to pop before BRKs
B50A  D626                            LDB     ZP_FOR_LVL_X_15
B50C  8E0519                          LDX     #BASWKSP_FORSTACK-FORSTACK_ITEM_SIZE
B50F  3A                              ABX     
B510  3384                            LEAU    ,X                              ; Y points at last item on FOR stack
B512  2728                            BEQ     brkNoFOR
B514                  cmdNEXTstacklp                                          ; LB505
B514  9E2C                            LDX     ZP_INT_WA + 2                   ; search FOR stack for a loop with matching variable pointer and type
B516  ACC4                            CMPX    FORSTACK_OFFS_VARPTR,U
B518  2608                            BNE     cmdNEXTstacklpsk1
B51A  962A                            LDA     ZP_INT_WA + 0
B51C  A142                            CMPA    FORSTACK_OFFS_VARTYPE,U
B51E  2602                            BNE     cmdNEXTstacklpsk1
B520  2034                            BRA     cmdNEXTfoundLoopVar             
B522                  cmdNEXTstacklpsk1                                       ; LB51A
B522  3351                            LEAU    -FORSTACK_ITEM_SIZE,U
B524  C00F                            SUBB    #FORSTACK_ITEM_SIZE
B526  D726                            STB     ZP_FOR_LVL_X_15
B528  26EA                            BNE     cmdNEXTstacklp
B52A  3540                            PULS    U
B52C                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B52C  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B52D  2143616E2774206D6174636820E300                 FCB     $21, "Can't match ", tknFOR, 0
B53C                  brkNoFOR
B53C  3540                            PULS    U
B53E                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B53E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B53F  204E6F20E300                    FCB     $20, "No ", tknFOR, 0
B545                  cmdNEXTTopLoopVar                                       ; LB539
B545  335F                            LEAU    -1,U                            ; if no var found go back a char : TODO - check whether we can change API
B547  3440                            PSHS    U                               ; use Y as gen ptr, remember to pop before BRKs
B549  CE0519                          LDU     #BASWKSP_FORSTACK - FORSTACK_ITEM_SIZE
B54C  33C5                            LEAU    B,U
B54E  AEC4                            LDX     FORSTACK_OFFS_VARPTR,U
B550  A642                            LDA     FORSTACK_OFFS_VARTYPE,U
B552  972A                            STA     ZP_INT_WA + 0
B554  9F2C                            STX     ZP_INT_WA + 2
B556                  cmdNEXTfoundLoopVar
                                      ; X => variable
                                      ; Y => FOR stack
                                      ; B => ZP_FOR_LVL_X_15
                                      ; A is var type
B556  8105                            CMPA    #VAR_TYPE_REAL
B558  10270091                        LBEQ    cmdNEXTdoREAL
B55C  8102                            CMPA    #VAR_TYPE_INT_LE
B55E  2741                            BEQ     cmdNEXTdoINT_LE
                      
                                      ; 32 bit add of integer control VAR, also store at ZP_GEN_PTR (bigendian)
B560  EC02                            LDD     2,X
B562  E345                            ADDD    (2+FORSTACK_OFFS_STEP),U
B564  ED02                            STD     2,X
B566  EC84                            LDD     ,X
B568  E944                            ADCB    (1+FORSTACK_OFFS_STEP),U
B56A  A943                            ADCA    (0+FORSTACK_OFFS_STEP),U
B56C  ED84                            STD     0,X
                      
B56E  EC02                            LDD     2,X                             ;6
B570  A34A                            SUBD    (2+FORSTACK_OFFS_TO),U          ;7
B572  260D                            BNE     cmdNEXTnoZ                      ;3
B574  EC84                            LDD     0,X                             ;5
B576  E249                            SBCB    (1+FORSTACK_OFFS_TO),U          ;5
B578  A248                            SBCA    (0+FORSTACK_OFFS_TO),U          ;5
B57A  260B                            BNE     cmdNEXTnoZ2                     ;3
B57C  5D                              TSTB                                    ;2
B57D  2608                            BNE     cmdNEXTnoZ2                     ;3
                      ;                                                       ;=39
B57F  2014                            BRA     cmdNEXTexecLoop                 ;3
B581                  cmdNEXTnoZ
B581  EC84                            LDD     0,X                             ;5
B583  E249                            SBCB    (1+FORSTACK_OFFS_TO),U          ;5
B585  A248                            SBCA    (0+FORSTACK_OFFS_TO),U          ;5
                                                                              ;=31
B587                  cmdNEXTnoZ2
B587  A684                            LDA     0,X
B589  A848                            EORA    (0+FORSTACK_OFFS_TO),U
B58B  A843                            EORA    (0+FORSTACK_OFFS_STEP),U
B58D  2A04                            BPL     cmdNEXTcksign2
B58F  2404                            BCC     cmdNEXTexecLoop
B591  2048                            BRA     cmdNEXTloopFinished
B593                  cmdNEXTcksign2                                          ; LB59C
B593  2446                            BCC     cmdNEXTloopFinished
B595                  cmdNEXTexecLoop                                         ; LB59E
B595  3262                            LEAS    2,S                             ; don't pull Y we don't want it
B597  EE4D                            LDU     FORSTACK_OFFS_LOOP,U
B599  DF0B                            STU     ZP_TXTPTR
B59B                                  CALL    checkForESC
B59B                  9
B59D                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B59B  BD9C85                                  JSR     \1
                              ENDIF
B59E                                  JUMP    skipSpacesAtYexecImmed
B59E  7E936A                                  JMP     \1
                      
B5A1                  cmdNEXTdoINT_LE                                         ; TODO: see about shortening / sharing this!
                                      ; 32 bit add of integer control VAR, also store at ZP_GEN_PTR (bigendian)
B5A1  EC84                            LDD     0,X
B5A3  AB46                            ADDA    (3+FORSTACK_OFFS_STEP),U
B5A5  E945                            ADCB    (2+FORSTACK_OFFS_STEP),U
B5A7  ED84                            STD     0,X
B5A9  EC02                            LDD     2,X
B5AB  A944                            ADCA    (1+FORSTACK_OFFS_STEP),U
B5AD  E943                            ADCB    (0+FORSTACK_OFFS_STEP),U
B5AF  ED02                            STD     2,X
                      
B5B1  EC84                            LDD     0,X                             ;6
B5B3  A04B                            SUBA    (3+FORSTACK_OFFS_TO),U          ;7
B5B5  E24A                            SBCB    (2+FORSTACK_OFFS_TO),U          ;7
B5B7  2610                            BNE     cmdNEXTnoZLE                    ;3
B5B9  4D                              TSTA
B5BA  260D                            BNE     cmdNEXTnoZLE                    ;3
B5BC  EC02                            LDD     2,X                             ;5
B5BE  A249                            SBCA    (1+FORSTACK_OFFS_TO),U          ;5
B5C0  E248                            SBCB    (0+FORSTACK_OFFS_TO),U          ;5
B5C2  260B                            BNE     cmdNEXTnoZ2LE                   ;3
B5C4  4D                              TSTA                                    ;2
B5C5  2608                            BNE     cmdNEXTnoZ2LE                   ;3
                      ;                                                       ;=39
B5C7  20CC                            BRA     cmdNEXTexecLoop                 ;3
B5C9                  cmdNEXTnoZLE
B5C9  EC02                            LDD     2,X                             ;5
B5CB  A249                            SBCA    (1+FORSTACK_OFFS_TO),U          ;5
B5CD  E248                            SBCB    (0+FORSTACK_OFFS_TO),U          ;5
                                                                              ;=31
B5CF                  cmdNEXTnoZ2LE
B5CF  A603                            LDA     3,X
B5D1  A848                            EORA    (0+FORSTACK_OFFS_TO),U
B5D3  A843                            EORA    (0+FORSTACK_OFFS_STEP),U
B5D5  2ABC                            BPL     cmdNEXTcksign2
B5D7  24BC                            BCC     cmdNEXTexecLoop
B5D9  2000                            BRA     cmdNEXTloopFinished
                      
B5DB                  cmdNEXTloopFinished                                     ; LB5AE
B5DB  D626                            LDB     ZP_FOR_LVL_X_15
B5DD  C00F                            SUBB    #FORSTACK_ITEM_SIZE
B5DF  D726                            STB     ZP_FOR_LVL_X_15
B5E1  3540                            PULS    U
B5E3                                  CALL    skipSpacesCheckCommaAtY
B5E3                  9
B5E5                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5E3  BD90C8                                  JSR     \1
                              ENDIF
B5E6  1026DD73                        LBNE    decYGoScanNextContinue
B5EA                                  JUMP    cmdNEXT                         ; found a comma, do another round of NEXTing
B5EA  7EB4F8                                  JMP     \1
                      
B5ED                  cmdNEXTdoREAL                                           ; LB5C0
B5ED                                  CALL    GetVarValReal                   ; get current variable value
B5ED                  9
B5EF                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5ED  BDB1F2                                  JSR     \1
                              ENDIF
B5F0  3043                            LEAX    FORSTACK_OFFS_STEP,U            ; get STEP value
B5F2  9F4A                            STX     ZP_FP_TMP_PTR1
B5F4                                  CALL    fpFPAeqPTR1addFPA               ; TODO jump straight in with X?
B5F4                  9
B5F6                  __XBSR                  SET 9B+2
F000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5F4  BDA6C3                                  JSR     \1
                              ENDIF
                      
B5F7  9E2C                            LDX     ZP_INT_WA + 2                   ; Get variable pointer
B5F9                                  CALL    fpCopyFPAtoX                    ; store result of STEP add
B5F9                  9
B5FB                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0091                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B5F9  BDB38C                                  JSR     \1
                              ENDIF
                      
B5FC  3048                            LEAX    FORSTACK_OFFS_TO,U              ; Get pointer to TO value
B5FE  9F4A                            STX     ZP_FP_TMP_PTR1
B600                                  CALL    evalDoCompareRealFPAwithPTR1    ; TODO: use X direct
B600                  9
B602                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0025                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B600  BD9D27                                  JSR     \1
                              ENDIF
B603  2790                            BEQ     cmdNEXTexecLoop
B605  6D44                            TST     FORSTACK_OFFS_STEP + 1,U        ; if STEP -ve
B607  2B04                            BMI     LB5F1
B609  248A                            BCC     cmdNEXTexecLoop
B60B  20CE                            BRA     cmdNEXTloopFinished
B60D                  LB5F1
B60D  2586                            BCS     cmdNEXTexecLoop
B60F  20CA                            BRA     cmdNEXTloopFinished
                      
B611                  brkFORVariable
B611                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B611  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B612  22E3207661726961626C6500                 FCB     $22, tknFOR, " variable", 0
B61E                  brkTooManyFORs
B61E                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B61E  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B61F  23546F6F206D616E7920E37300                 FCB     $23, "Too many ", tknFOR, "s", 0
B62C                  brkNoTO
B62C                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B62C  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B62D  244E6F20B800                    FCB     $24, "No ", tknTO, 0
                                              ;============================
                                              ; FOR
                                              ;============================
B633                  cmdFOR
                                      ; TODO some recalcs of X could be done by LEAX?
                                              ;  FOR
B633                                  CALL    findVarOrAllocEmpty
B633                  9
B635                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B633  BD9A31                                  JSR     \1
                              ENDIF
B636  27D9                            BEQ     brkFORVariable
B638  25D7                            BCS     brkFORVariable
B63A                                  CALL    pushVarPtrAndType
B63A                  9
B63C                  __XBSR                  SET 9B+2
0500                  __XBSR2                 SET (\1-__XBSR) & $FF00
002C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B63A  BDBB68                                  JSR     \1
                              ENDIF
B63D                                  CALL    skipToEqualsOrBRKY
B63D                  9
B63F                  __XBSR                  SET 9B+2
E600                  __XBSR2                 SET (\1-__XBSR) & $FF00
0017                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B63D  BD9C56                                  JSR     \1
                              ENDIF
B640                                  CALL    evalAtYAndStoreEvaledExpressioninStackedVarPTr
B640                  9
B642                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B640  BDB338                                  JSR     \1
                              ENDIF
B643                                  CALL    skipSpacesY
B643                  9
B645                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0047                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B643  BD928C                                  JSR     \1
                              ENDIF
B646  81B8                            CMPA    #tknTO
B648  26E2                            BNE     brkNoTO
B64A  D626                            LDB     ZP_FOR_LVL_X_15
B64C  C196                            CMPB    #FORSTACK_ITEM_SIZE*FORSTACK_MAX_ITEMS
B64E  24CE                            BCC     brkTooManyFORs
B650  8E0528                          LDX     #BASWKSP_FORSTACK
B653  3A                              ABX
B654  9F52                            STX     ZP_EXTRA_SAVE
B656  D626                            LDB     ZP_FOR_LVL_X_15
B658  CB0F                            ADDB    #FORSTACK_ITEM_SIZE
B65A  D726                            STB     ZP_FOR_LVL_X_15
B65C  DC39                            LDD     ZP_GEN_PTR+2                    ; addr of control var
B65E  ED84                            STD     FORSTACK_OFFS_VARPTR,X
B660  9637                            LDA     ZP_NAMELENORVT
B662  A702                            STA     FORSTACK_OFFS_VARTYPE,X         ; type of control var
B664  8105                            CMPA    #$05
B666  2739                            BEQ     cmdFORskipskReal
B668                                  CALL    evalAtYcheckTypeInAConvert2INT
B668                  9
B66A                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B668  BD9860                                  JSR     \1
                              ENDIF
B66B  9E52                            LDX     ZP_EXTRA_SAVE
B66D  DC2A                            LDD     ZP_INT_WA                       ; store INT TO val at +8
B66F  ED08                            STD     FORSTACK_OFFS_TO,X
B671  DC2C                            LDD     ZP_INT_WA + 2
B673  ED0A                            STD     FORSTACK_OFFS_TO+2,X
B675  8601                            LDA     #$01
B677                                  CALL    retA8asUINT                     ; default STEP to 1
B677                  9
B679                  __XBSR                  SET 9B+2
F700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B677  BDAE54                                  JSR     \1
                              ENDIF
B67A                                  CALL    skipSpacesY             
B67A                  9
B67C                  __XBSR                  SET 9B+2
DC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0010                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B67A  BD928C                                  JSR     \1
                              ENDIF
B67D  8188                            CMPA    #tknSTEP
B67F  2609                            BNE     cmdFORskINTnoSTEP
B681  3410                            PSHS    X
B683                                  CALL    evalAtYcheckTypeInAConvert2INT
B683                  9
B685                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B683  BD9860                                  JSR     \1
                              ENDIF
B686  3510                            PULS    X
B688  3341                            LEAU    1,U                             ; TODO - sort this back and forth out?
B68A                  cmdFORskINTnoSTEP                                       ; LB677
B68A  335F                            LEAU    -1,U
B68C  DC2A                            LDD     ZP_INT_WA                       ; store INT STEP val at + 5
B68E  ED03                            STD     FORSTACK_OFFS_STEP,X
B690  DC2C                            LDD     ZP_INT_WA + 2
B692  ED05                            STD     FORSTACK_OFFS_STEP + 2,X
B694                  cmdFORskipExecBody                                      ; LB68F
B694                                  CALL    scanNextStmtAndTrace
B694                  9
B696                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B694  BD9C8C                                  JSR     \1
                              ENDIF
B697  D626                            LDB     ZP_FOR_LVL_X_15
B699  8E0526                          LDX     #BASWKSP_FORSTACK + FORSTACK_OFFS_LOOP - FORSTACK_ITEM_SIZE
B69C  EF85                            STU     B,X                             ; store Y pointer to body statement in FOR stack (2 before next pointer!)
B69E                                  JUMP    skipSpacesAtYexecImmed
B69E  7E936A                                  JMP     \1
B6A1                  cmdFORskipskReal                                        ; LB6A1
                      
B6A1                                  CALL    evalAtY
B6A1                  9
B6A3                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
001E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6A1  BD9DC1                                  JSR     \1
                              ENDIF
B6A4                                  CALL    checkTypeIntToReal
B6A4                  9
B6A6                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DF                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6A4  BD9885                                  JSR     \1
                              ENDIF
B6A7  9E52                            LDX     ZP_EXTRA_SAVE
B6A9  C608                            LDB     #FORSTACK_OFFS_TO
B6AB  3A                              ABX
B6AC                                  CALL    fpCopyFPA_X                     ; store TO value (real)
B6AC                  9
B6AE                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6AC  BDA573                                  JSR     \1
                              ENDIF
B6AF                                  CALL    fpLoad1                         ; FloatA=1.0 (load default STEP)
B6AF                  9
B6B1                  __XBSR                  SET 9B+2
EF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0061                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6AF  BDA612                                  JSR     \1
                              ENDIF
B6B2                                  CALL    skipSpacesY
B6B2                  9
B6B4                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6B2  BD928C                                  JSR     \1
                              ENDIF
B6B5  8188                            CMPA    #tknSTEP
B6B7  2608                            BNE     cmdFORrealNoStep
B6B9                                  CALL    evalAtY
B6B9                  9
B6BB                  __XBSR                  SET 9B+2
E700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6B9  BD9DC1                                  JSR     \1
                              ENDIF
B6BC                                  CALL    checkTypeIntToReal
B6BC                  9
B6BE                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6BC  BD9885                                  JSR     \1
                              ENDIF
B6BF  3341                            LEAU    1,U
B6C1                  cmdFORrealNoStep                                        ; LB6C7
B6C1  335F                            LEAU    -1,U
B6C3  9E52                            LDX     ZP_EXTRA_SAVE
B6C5  C603                            LDB     #FORSTACK_OFFS_STEP
B6C7  3A                              ABX
B6C8                                  CALL    fpCopyFPA_X
B6C8                  9
B6CA                  __XBSR                  SET 9B+2
EE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6C8  BDA573                                  JSR     \1
                              ENDIF
B6CB  20C7                            BRA     cmdFORskipExecBody
                      
                                              ;============================
                                              ; GOSUB         
                                              ;============================
B6CD                  cmdGOSUB
B6CD                                  CALL    decodeLineNumberFindProgLine
B6CD                  9
B6CF                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0037                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6CD  BDB806                                  JSR     \1
                              ENDIF
B6D0                  intGOSUB_FPB_2  CALL    scanNextStmtFromY               ; LB6DC
B6D0                  9
B6D2                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6D0  BD9C74                                  JSR     \1
                              ENDIF
B6D3  D625                            LDB     ZP_GOSUB_LVL                    ; Get GOSUB index
B6D5  C111                            CMPB    #GOSUBSTACK_MAX                 ; Check whether stack is full
B6D7  240B                            BHS     brkTooManyGosubs
B6D9  8E05CC                          LDX     #BASWKSP_GOSUBSTACK
B6DC  58                              ASLB
B6DD  3A                              ABX
B6DE  EF84                            STU     ,X                              ; store text pointer on stack
B6E0  0C25                            INC     ZP_GOSUB_LVL
B6E2  202E                            BRA     cmdGOTODecodedLineNumber
B6E4                  brkTooManyGosubs
B6E4                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B6E4  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B6E5  25546F6F206D616E7920E47300                 FCB     $25, "Too many ", tknGOSUB, "s", 0
B6F2                  brknoGOSUB
B6F2                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B6F2  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B6F3  264E6F20E400                    FCB     $26, "No ", tknGOSUB, 0
                      
                                              ;============================
                                              ; RETURN
                                              ;============================
B6F9                  cmdRETURN
B6F9                                  CALL    scanNextStmtFromY
B6F9                  9
B6FB                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0079                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B6F9  BD9C74                                  JSR     \1
                              ENDIF
B6FC  D625                            LDB     ZP_GOSUB_LVL
B6FE  27F2                            BEQ     brknoGOSUB
B700  0A25                            DEC     ZP_GOSUB_LVL
B702  8E05CA                          LDX     #BASWKSP_GOSUBSTACK-2
B705  58                              ASLB
B706  3A                              ABX
B707  EE84                            LDU     ,X
B709                  LB71A           JUMP    continue
B709  7E9362                                  JMP     \1
                      
                                              ;============================
                                              ; GOTO
                                              ;============================
B70C                  cmdGOTO                                                 ; LB71D!
                      
B70C                                  CALL    decodeLineNumberFindProgLine
B70C                  9
B70E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B70C  BDB806                                  JSR     \1
                              ENDIF
                                      ;;LDU   ZP_TXTPTR
B70F                                  CALL    scanNextStmtFromY
B70F                  9
B711                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B70F  BD9C74                                  JSR     \1
                              ENDIF
B712                  cmdGOTODecodedLineNumber                                ; LB723
B712  9620                            LDA     ZP_TRACE
B714  2703                            BEQ     cmdGOTOskTrace
B716                                  CALL    doTRACE
B716                  9
B718                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B716  BD9CE5                                  JSR     \1
                              ENDIF
B719                  cmdGOTOskTrace                                          ; LB72A
B719  DE3D                            LDU     ZP_FPB + 2
B71B  3344                            LEAU    4,U
B71D                  STUZPTXTPTR_continue                                    ; LB732
B71D  DF0B                            STU     ZP_TXTPTR
B71F                                  JUMP    skipSpacesAtYexecImmed
B71F  7E936A                                  JMP     \1
                      
B722                  cmdONERROROFF                                           ; LB739
B722                                  CALL    scanNextStmtFromY
B722                  9
B724                  __XBSR                  SET 9B+2
E500                  __XBSR2                 SET (\1-__XBSR) & $FF00
0050                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B722  BD9C74                                  JSR     \1
                              ENDIF
B725                                  CALL    ONERROROFF
B725                  9
B727                  __XBSR                  SET 9B+2
FB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B725  BDB2B5                                  JSR     \1
                              ENDIF
B728                                  JUMP    continue
B728  7E9362                                  JMP     \1
B72B                  cmdONERROR                                              ; LB741
B72B                                  CALL    skipSpacesY
B72B                  9
B72D                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B72B  BD928C                                  JSR     \1
                              ENDIF
B72E  8187                            CMPA    #tknOFF
B730  27F0                            BEQ     cmdONERROROFF
B732  335F                            LEAU    -1,U
B734  DF16                            STU     ZP_ERR_VECT
B736                                  JUMP    cmdREM                          ; skip rest
B736  7E9317                                  JMP     \1
                      ;                       ;  ON [ERROR][GOTO][GOSUB]
                      ;                       ;  =======================
B739                  cmdON                                                   ; LB75B!
                      
B739                                  CALL    skipSpacesY
B739                  9
B73B                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0051                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B739  BD928C                                  JSR     \1
                              ENDIF
B73C  8185                            CMPA    #tknERROR
B73E  27EB                            BEQ     cmdONERROR                              ;  ON ERROR
                      
B740  335F                            LEAU    -1,U
B742                                  CALL    evalForceINT                            ;  Evaluate ON <num>
B742                  9
B744                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B742  BD95A1                                  JSR     \1
                              ENDIF
B745  C1F2                            CMPB    #tknPROC
B747  270A                            BEQ     cmdOnGSP                                ;  ON <num> PROC
B749  3341                            LEAU    1,U
B74B  C1E5                            CMPB    #tknGOTO
B74D  2704                            BEQ     cmdOnGSP                                ;  ON <num> GOTO
B74F  C1E4                            CMPB    #tknGOSUB
B751  2679                            BNE     brkONSyntax                             ;  ON <num> GOSUB
B753                  cmdOnGSP                                                        ; LB774
B753  3404                            PSHS    B                                       ;  Save token
B755  962A                            LDA     ZP_INT_WA + 0
B757  9A2B                            ORA     ZP_INT_WA + 1
B759  9A2C                            ORA     ZP_INT_WA + 2           
B75B  2657                            BNE     cmdOnSkipNoMatch                        ; if >255
B75D  0A2D                            DEC     ZP_INT_WA + 3                           ; make 0-based
B75F  2734                            BEQ     cmdOnFound
B761  2B51                            BMI     cmdOnSkipNoMatch
B763                  cmdOnCharloop                                                   ; LB783
B763  A6C0                            LDA     ,U+
B765  810D                            CMPA    #$0D
B767  2749                            BEQ     cmdOnSkipNoMatch2
B769  813A                            CMPA    #':'
B76B  2745                            BEQ     cmdOnSkipNoMatch2
B76D  818B                            CMPA    #tknELSE
B76F  2741                            BEQ     cmdOnSkipNoMatch2
B771  8122                            CMPA    #'"'
B773  2604                            BNE     1F
B775  982B                            EORA    ZP_INT_WA + 1
B777  972B                            STA     ZP_INT_WA + 1                           ; quotes flag
B779  0D2B            1               TST     ZP_INT_WA + 1                           ; LB79A
B77B  26E6                            BNE     cmdOnCharloop                           ; skip over quotes PROC params
B77D  8129                            CMPA    #')'
B77F  2602                            BNE     1F
B781  0A2C                            DEC     ZP_INT_WA + 2
B783  8128            1               CMPA    #'('                                    ; LB7A4
B785  2602                            BNE     1F
B787  0C2C                            INC     ZP_INT_WA + 2
B789  812C            1               CMPA    #','                                    ; LB7AA
B78B  26D6                            BNE      cmdOnCharloop
B78D  0D2C                            TST      ZP_INT_WA + 2                          ; brackets
B78F  26D2                            BNE      cmdOnCharloop
B791  0A2D                            DEC      ZP_INT_WA + 3
B793  26CE                            BNE      cmdOnCharloop
B795                  cmdOnFound                                                      ; LB7B6
B795  3502                            PULS    A       
B797  81F2                            CMPA    #tknPROC
B799  274B                            BEQ     cmdOnFoundPROC
B79B  DF0A                            STU     ZP_TXTOFF
B79D  81E4                            CMPA    #tknGOSUB
B79F  2708                            BEQ     cmdOnFoundGOSUB
B7A1                                  CALL    decodeLineNumberFindProgLine
B7A1                  9
B7A3                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0063                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B7A1  8D63                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B7A3                                  CALL    checkForESC
B7A3                  9
B7A5                  __XBSR                  SET 9B+2
E400                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B7A3  BD9C85                                  JSR     \1
                              ENDIF
B7A6                                  JUMP    cmdGOTODecodedLineNumber
B7A6  7EB712                                  JMP     \1
B7A9                  cmdOnFoundGOSUB                                                 ; LB7CA
B7A9                                  CALL    decodeLineNumberFindProgLine
B7A9                  9
B7AB                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
005B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B7A9  8D5B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B7AB  DE0A                            LDU     ZP_TXTOFF
B7AD                                  CALL    findNextStmt                            ; find $0D or ':' to use as return from GOSUB
B7AD                  9
B7AF                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
004A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B7AD  8D4A                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B7AF                                  JUMP    intGOSUB_FPB_2
B7AF  7EB6D0                                  JMP     \1
B7B2                  cmdOnSkipNoMatch2
B7B2  335F                            LEAU    -1,U
B7B4                  cmdOnSkipNoMatch                                                ; LB7D5
B7B4  3261                            LEAS    1,S                                     ; remove token from stack
B7B6  A6C0            1               LDA     ,U+                                     ; search for ELSE or end of statement
B7B8  818B                            CMPA    #tknELSE
B7BA  1027E509                        LBEQ    execTHENorELSEimpicitGOTO
B7BE  810D                            CMPA    #$0D
B7C0  26F4                            BNE     1B
B7C2                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B7C2  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B7C3  28EE2072616E676500                 FCB     $28, tknON, " range", 0
B7CC                  brkONSyntax
B7CC                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B7CC  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B7CD  27EE2073796E74617800                 FCB     $27, tknON, " syntax", 0
B7D7                  brkNoSuchLine
B7D7                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B7D7  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B7D8  294E6F2073756368206C696E6500                 FCB     $29, "No such line", 0
B7E6                  cmdOnFoundPROC                                                  ; LB803
B7E6  3440                            PSHS    U
B7E8                                  CALL    skipSpacesY
B7E8                  9
B7EA                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B7E8  BD928C                                  JSR     \1
                              ENDIF
B7EB  81F2                            CMPA    #tknPROC
B7ED  26DD                            BNE     brkONSyntax
B7EF                                  CALL    doFNPROCcall
B7EF                  9
B7F1                  __XBSR                  SET 9B+2
F800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0085                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B7EF  BDB076                                  JSR     \1
                              ENDIF
B7F2  3540                            PULS    U
B7F4                                  CALL    findNextStmt
B7F4                  9
B7F6                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0003                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B7F4  8D03                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B7F6                                  JUMP    scanNextContinue
B7F6  7E935F                                  JMP     \1
                      ;;LB81C:
                      ;;              INY
                      ;;LB81D:
                      ;;              LDA (ZP_TXTPTR),Y
                      ;;              CMP #$0D
                      ;;              BEQ LB827
                      ;;              CMP #$3A
                      ;;              BNE LB81C
                      ;;LB827:
                      ;;              STU ZP_TXTOFF
                      ;;              RTS
                      ;;              
B7F9  A6C0            findNextStmt    LDA     ,U+
B7FB  813A                            CMPA    #':'
B7FD  2704                            BEQ     1F
B7FF  810D                            CMPA    #$0D
B801  26F6                            BNE     findNextStmt
B803  335F            1               LEAU    -1,U
B805  39                              RTS
                      
                      
B806                  decodeLineNumberFindProgLine
B806                                  CALL    skipSpacesDecodeLineNumberNewAPI
B806                  9
B808                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B806  BD9BFB                                  JSR     \1
                              ENDIF
B809  2509                            BCS     findProgLineOrBRK                       ; tokenised line number found
B80B                                  CALL    evalForceINT
B80B                  9
B80D                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0094                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B80B  BD95A1                                  JSR     \1
                              ENDIF
B80E  867F                            LDA     #$7F                                    ; clear top bit of line number
B810  942C                            ANDA    ZP_INT_WA + 2
B812  972C                            STA     ZP_INT_WA + 2
B814                  findProgLineOrBRK
B814  3440                            PSHS    U
B816                                  CALL    findProgLineNewAPI
B816                  9
B818                  __XBSR                  SET 9B+2
CC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B816  BD84C9                                  JSR     \1
                              ENDIF
B819  24BC                            BCC     brkNoSuchLine
B81B  35C0                            PULS    U,PC
                      ;LB83C:
                      ;               JUMP brkTypeMismatch
                      ;;LB83F:
                      ;;              JUMP brkSyntax
                      
                      ;;cmdINPUT_HASH_exit
                      ;;              STU ZP_TXTOFF
                      ;;;LB844:
                      ;;              JUMP scanNextContinue
                      
B81D                  cmdINPUTBGETtoX
B81D  BDFFD7          1               JSR     OSBGET
B820  A780                            STA     ,X+
B822  5A                              DECB            
B823  26F8                            BNE     1B
B825  39                              RTS
                      
B826                  cmdINPUT_HASH                                           ; LB847
B826                                  CALL    decYSaveAndEvalHashChannelAPI
B826                  9
B828                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B826  BDBA02                                  JSR     \1
                              ENDIF
B829  3420                            PSHS    Y                               ; save channel #
B82B                  cmdINPUT_HASH_lp                                        ; LB84F
B82B  DE0B                            LDU     ZP_TXTPTR
B82D                                  CALL    skipSpacesCheckCommaAtY
B82D                  9
B82F                  __XBSR                  SET 9B+2
D800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0099                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B82D  BD90C8                                  JSR     \1
                              ENDIF
B830  1026DC8B                        LBNE    cmdPRINTHASH_exit
B834                                  CALL    findVarOrAllocEmpty
B834                  9
B836                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00FB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B834  BD9A31                                  JSR     \1
                              ENDIF
B837  1027E3FC                        LBEQ    brkSyntax
                      ;;              CALL copyTXTOFF2toTXTOFF
B83B  DF0B                            STU     ZP_TXTPTR
                      ;;              PLA
                      ;;              STA ZP_FP_TMP + 9
B83D  3401                            PSHS    CC
B83F                                  CALL    stackINT_WAasINT                ; pointer to variable on stack
B83F                  9
B841                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0019                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B83F  BDBB5A                                  JSR     \1
                              ENDIF
B842  EE61                            LDU     1,S                             ; channel
B844  BDFFD7                          JSR     OSBGET
B847  9727                            STA     ZP_VARTYPE                      ; get VARTYPE as stored in file
B849  3501                            PULS    CC                              ; get back var flags
B84B  2419                            BCC     cmdINPUT_HASH_notdynstr         ; branc if not a dyn string
B84D  0D27                            TST     ZP_VARTYPE                      ; check var type (we want 0 for string!)
B84F  1026DB98                        LBNE    brkTypeMismatch
B853  BDFFD7                          JSR     OSBGET
B856  9736                            STA     ZP_STRBUFLEN
B858  D636                            LDB     ZP_STRBUFLEN                    ; counter
B85A  2705                            BEQ     2F
B85C  8E0600                          LDX     #BASWKSP_STRING
B85F                                  CALL    cmdINPUTBGETtoX
B85F                  9
B861                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B85F  8DBC                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B861                  2               CALL    copyStringToVar
B861                  9
B863                  __XBSR                  SET 9B+2
DB00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A2                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B861  BD9405                                  JSR     \1
                              ENDIF
B864  20C5                            BRA     cmdINPUT_HASH_lp
B866                  cmdINPUT_HASH_notdynstr                                 ; LB88A
B866  0D27                            TST     ZP_VARTYPE
B868  1027DB7F                        LBEQ    brkTypeMismatch
B86C  2B09                            BMI     cmdINPUT_HASH_FP
B86E  C604                            LDB     #$04
B870  8E002A                          LDX     #ZP_INT_WA
B873                                  CALL    cmdINPUTBGETtoX
B873                  9
B875                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B873  8DA8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B875  2010                            BRA     cmdINPUT_HASH_StoreAtVarPtr
B877                  cmdINPUT_HASH_FP                                        ;
B877  C605                            LDB     #$05
B879  8E0471                          LDX     #BASWKSP_FPTEMP1 + 5
B87C  BDFFD7          1               JSR     OSBGET
B87F  A782                            STA     ,-X
B881  5A                              DECB
B882  26F8                            BNE     1B
B884                                  CALL    fpCopyFPTEMP1toFPA
B884                  9
B886                  __XBSR                  SET 9B+2
ED00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0008                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B884  BDA58E                                  JSR     \1
                              ENDIF
B887                  cmdINPUT_HASH_StoreAtVarPtr
B887                                  CALL    popIntAtZP_GEN_PTRNew
B887                  9
B889                  __XBSR                  SET 9B+2
0300                  __XBSR2                 SET (\1-__XBSR) & $FF00
0073                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B887  BDBBFC                                  JSR     \1
                              ENDIF
B88A                                  CALL    storeEvaledExpressioninVarAtZP_GEN_PTR
B88A                  9
B88C                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B88A  BDB349                                  JSR     \1
                              ENDIF
B88D  209C                            BRA     cmdINPUT_HASH_lp
                      ;LB8B2:
                      ;               PLA
                      ;               PLA
                      ;               BRA LB844
B88F                  cmdINPUT                        ; LB8B6!
B88F                                  CALL    skipSpacesCheckHashAtY
B88F                  9
B891                  __XBSR                  SET 9B+2
D800                  __XBSR2                 SET (\1-__XBSR) & $FF00
0031                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B88F  BD90C2                                  JSR     \1
                              ENDIF
B892  2792                            BEQ     cmdINPUT_HASH
                      
B894  8186                            CMPA    #tknLINE
B896  2704                            BEQ     1F
B898  335F                            LEAU    -1,U
B89A                                  SEC                                     ; note the LINE bit is the opposite sense to 6502
B89A  1A01                    ORCC    #CC_C
B89C  064C            1               ROR     ZP_FP_TMP + 9
B89E  044C                            LSR     ZP_FP_TMP + 9
B8A0  86FF                            LDA     #$FF
B8A2  974D                            STA     ZP_FP_TMP + 10                  ; flag "first" item after a prompt?
B8A4                  cmdINPUT_LINE_lp                                        ; LB8CA
B8A4  084C                            ASL     ZP_FP_TMP + 9
B8A6                                  CALL    cmdINPUT_PRINT_prompt
B8A6                  9
B8A8                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0018                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B8A6  BD95C0                                  JSR     \1
                              ENDIF
B8A9  250B                            BCS     LB8D9
B8AB                  1               CALL    cmdINPUT_PRINT_prompt
B8AB                  9
B8AD                  __XBSR                  SET 9B+2
DD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0013                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B8AB  BD95C0                                  JSR     \1
                              ENDIF
B8AE  24FB                            BCC     1B
B8B0  C6FF                            LDB     #$FF
B8B2  D74D                            STB     ZP_FP_TMP + 10                  ; flag "first" item after a prompt?
B8B4                                  CLC
B8B4  1CFE                    ANDCC   #~CC_C
B8B6  064C            LB8D9           ROR     ZP_FP_TMP + 9                   ; bit 7 set if had prompt, bit 6 set if LINE
B8B8  812C                            CMPA    #','
B8BA  27E8                            BEQ     cmdINPUT_LINE_lp                                ; check again for prompts
B8BC  813B                            CMPA    #';'
B8BE  27E4                            BEQ     cmdINPUT_LINE_lp                                ; check again for prompts
B8C0  335F                            LEAU    -1,U
B8C2  DC4C                            LDD     ZP_FP_TMP + 9                   ; stack our flags
B8C4  3406                            PSHS    D
B8C6                                  CALL    findVarOrAllocEmpty
B8C6                  9
B8C8                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0069                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B8C6  BD9A31                                  JSR     \1
                              ENDIF
B8C9  1027DBF2                        LBEQ    cmdPRINTHASH_exit               ; "invalid" i.e. no varaible found
B8CD  3506                            PULS    D
B8CF  DD4C                            STD     ZP_FP_TMP+9
                      ;;              CALL    copyTXTOFF2toTXTOFF
B8D1  3441                            PSHS    CC,U                            ; store carry flag (set if a string var) and current Y
B8D3  C640                            LDB     #$40
B8D5  D54C                            BITB    ZP_FP_TMP + 9                   ; branch if 
B8D7  2706                            BEQ     LB908                           ; note opposite sense! branch for LINE
B8D9  D64D                            LDB     ZP_FP_TMP + 10
B8DB  C1FF                            CMPB    #$FF
B8DD  261F                            BNE     cmdINPUT_LINE_readCommaStrItem
B8DF                  LB908
B8DF  0D4C                            TST     ZP_FP_TMP + 9
B8E1  2A05                            BPL     1F
B8E3  863F                            LDA     #'?'
B8E5  BDFFEE                          JSR     OSWRCH
B8E8  8606            1               LDA     #BASWKSP_STRING / $100
B8EA                                  CALL    ReadKeysTo_PageInA
B8EA                  9
B8EC                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
003A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B8EA  BDBA26                                  JSR     \1
                              ENDIF
B8ED  1F20                            TFR     Y,D
B8EF  D736                            STB     ZP_STRBUFLEN                    ; length of line read in
B8F1  084C                            ASL     ZP_FP_TMP + 9
B8F3                                  CLC
B8F3  1CFE                    ANDCC   #~CC_C
B8F5  064C                            ROR     ZP_FP_TMP + 9                   ; clear "had prompt" flag
B8F7  8640                            LDA     #$40
B8F9  954C                            BITA    ZP_FP_TMP + 9
B8FB  2718                            BEQ     cmdINPUT_LINE_INPUT
B8FD  5F                              CLRB
B8FE                  cmdINPUT_LINE_readCommaStrItem                          ; LB91F
B8FE  8606                            LDA     #$06
B900  1F03                            TFR     D,U
B902                                  CALL    readCommaSepString
B902                  9
B904                  __XBSR                  SET 9B+2
F400                  __XBSR2                 SET (\1-__XBSR) & $FF00
002A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B902  BDAD2E                                  JSR     \1
                              ENDIF
B905                  LB92A
B905                                  CALL    skipSpacesCheckCommaAtY
B905                  9
B907                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B905  BD90C8                                  JSR     \1
                              ENDIF
B908  2707                            BEQ     LB935
B90A  810D                            CMPA    #$0D
B90C  26F7                            BNE     LB92A
B90E  CEFFFF                          LDU     #$FFFF
B911  1F30            LB935           TFR     U,D
B913  D74D            1               STB     ZP_FP_TMP + 10
B915                  cmdINPUT_LINE_INPUT                                     ; LB938
B915  3501                            PULS    CC
B917  250E                            BCS     cmdINPUT_LINE_INPUT_STR
B919                                  CALL    pushVarPtrAndType
B919                  9
B91B                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
004D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B919  BDBB68                                  JSR     \1
                              ENDIF
B91C                                  CALL    str2Num
B91C                  9
B91E                  __XBSR                  SET 9B+2
F200                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B91C  BDAB8B                                  JSR     \1
                              ENDIF
B91F                                  CALL    storeEvaledExpressioninStackedVarPTr
B91F                  9
B921                  __XBSR                  SET 9B+2
FA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
001A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B91F  BDB33B                                  JSR     \1
                              ENDIF
B922  3540            1               PULS    U
B924                                  JUMP    cmdINPUT_LINE_lp
B924  7EB8A4                                  JMP     \1
B927                  cmdINPUT_LINE_INPUT_STR                                 ;LB946:
B927  0F27                            CLR     ZP_VARTYPE
B929                                  CALL    copyStringToVar2
B929                  9
B92B                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B929  BD9408                                  JSR     \1
                              ENDIF
B92C  20F4                            BRA     1B
                      
                      
                      
B92E                  cmdRESTORE
B92E  0F3E                            CLR     ZP_FPB + 3
B930  9618                            LDA     ZP_PAGE_H
B932  973D                            STA     ZP_FPB + 2                      ; FPB+2=>start of program
B934                                  CALL    skipSpacesYStepBack
B934                  9
B936                  __XBSR                  SET 9B+2
D900                  __XBSR2                 SET (\1-__XBSR) & $FF00
005F                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B934  BD9295                                  JSR     \1
                              ENDIF
B937  813A                            CMPA    #':'
B939  270B                            BEQ     LB967
B93B  810D                            CMPA    #$0D
B93D  2707                            BEQ     LB967
B93F  818B                            CMPA    #tknELSE
B941  2703                            BEQ     LB967
B943                                  CALL    decodeLineNumberFindProgLine    ; expect program line number, find it or BRK
B943                  9
B945                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00C1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B943  BDB806                                  JSR     \1
                              ENDIF
B946                  LB967           CALL    scanNextStmtFromY               ; scan to start of next statement
B946                  9
B948                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
002C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B946  BD9C74                                  JSR     \1
                              ENDIF
B949  DC3D                            LDD     ZP_FPB + 2                      ; now pointing at start of line specified or start of program
B94B  DD1C                            STD     ZP_READ_PTR
B94D                                  JUMP    continue
B94D  7E9362                                  JMP     \1
                      
                      
B950                  cmdREAD_next                                            ; LLB975
B950                                  CALL    skipSpacesCheckCommaAtYStepBack         ; look for comma
B950                  9
B952                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
007C                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B950  BD90CE                                  JSR     \1
                              ENDIF
B953  1026DA08                        LBNE    scanNextContinue                ; if not found continue
                                                                              ; or fall through for next READ var
B957                  cmdREAD
B957                                  CALL    findVarOrAllocEmpty
B957                  9
B959                  __XBSR                  SET 9B+2
E000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B957  BD9A31                                  JSR     \1
                              ENDIF
B95A  27F4                            BEQ     cmdREAD_next                    ; bad var name, skip
B95C  250C                            BCS     cmdREAD_readString              ; string ?
B95E  3440                            PSHS    U
B960                                  CALL    cmdREAD_findNextDataItem
B960                  9
B962                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
001D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B960  8D1D                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B962                                  CALL    pushVarPtrAndType
B962                  9
B964                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B962  BDBB68                                  JSR     \1
                              ENDIF
B965                                  CALL    evalAtYAndStoreEvaledExpressioninStackedVarPTr
B965                  9
B967                  __XBSR                  SET 9B+2
F900                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B965  BDB338                                  JSR     \1
                              ENDIF
B968  200F                            BRA     LB99D
B96A                  cmdREAD_readString
B96A  3440                            PSHS    U
B96C                                  CALL    cmdREAD_findNextDataItem
B96C                  9
B96E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0011                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B96C  8D11                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B96E                                  CALL    stackINT_WAasINT
B96E                  9
B970                  __XBSR                  SET 9B+2
0100                  __XBSR2                 SET (\1-__XBSR) & $FF00
00EA                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B96E  BDBB5A                                  JSR     \1
                              ENDIF
B971                                  CALL    readCommaSepString
B971                  9
B973                  __XBSR                  SET 9B+2
F300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B971  BDAD2E                                  JSR     \1
                              ENDIF
B974  9727                            STA     ZP_VARTYPE
B976                                  CALL    copyStringToVar
B976                  9
B978                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B976  BD9405                                  JSR     \1
                              ENDIF
B979                  LB99D
B979  DF1C                            STU     ZP_READ_PTR
B97B  3540                            PULS    U
B97D  20D1                            BRA     cmdREAD_next
                      
B97F                  cmdREAD_findNextDataItem
B97F  DE1C                            LDU     ZP_READ_PTR
B981                                  CALL    skipSpacesCheckCommaAtY
B981                  9
B983                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0045                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B981  BD90C8                                  JSR     \1
                              ENDIF
B984  274F                            BEQ     cmdREAD_dataItemFound
B986  81DC                            CMPA    #tknDATA
B988  274B                            BEQ     cmdREAD_dataItemFound
B98A  810D                            CMPA    #$0D
B98C  2709                            BEQ     cmdREAD_CR
B98E                  LB9C6
B98E                                  CALL    skipSpacesCheckCommaAtY
B98E                  9
B990                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0038                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B98E  BD90C8                                  JSR     \1
                              ENDIF
B991  2742                            BEQ     cmdREAD_dataItemFound
B993  810D                            CMPA    #$0D
B995  26F7                            BNE     LB9C6
B997                  cmdREAD_CR
B997  30C4                            LEAX    ,U                              ; save start of line for skip
B999  A6C0                            LDA     ,U+
B99B  2B13                            BMI     brkOutOfDATA
B99D  3341                            LEAU    1,U                             ; skip 2nd byte of 
B99F  E6C0                            LDB     ,U+                             ; line length
B9A1                  LB9DA
B9A1  A6C0                            LDA     ,U+
B9A3  8120                            CMPA    #' '
B9A5  27FA                            BEQ     LB9DA                           ; skip spaces
B9A7  81DC                            CMPA    #tknDATA                        ; found DATA token that'll do
B9A9  272A                            BEQ     cmdREAD_dataItemFound
B9AB  3A                              ABX                                     ; if not add line length to start of line and continue
B9AC  3384                            LEAU    ,X              
B9AE  20E7                            BRA cmdREAD_CR
B9B0                  brkOutOfDATA
B9B0                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B9B0  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B9B1  2A4F7574206F6620DC00                 FCB     $2A, "Out of ", tknDATA, 0
B9BB                  brkNoREPEAT
B9BB                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B9BB  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B9BC  2B4E6F20F500                    FCB     $2B, "No ", tknREPEAT, 0
B9C2                  brkMissingHash
B9C2                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B9C2  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B9C3  2D8D2300                        FCB     $2D, tknMissing, "#", 0
B9C7                  brkTooManyREPEATs
B9C7                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
B9C7  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
B9C8  2C546F6F206D616E7920F57300                 FCB     $2C, "Too many ", tknREPEAT, "s", 0
                      ;;LBA13:
                      ;;              INY
                      ;;              STU ZP_TXTOFF2
B9D5                  cmdREAD_dataItemFound
                      ;               LEAU    ,X
B9D5  39                              RTS
                      
B9D6                  IntWAZero
B9D6  3402                            PSHS    A
B9D8  962A                            LDA     ZP_INT_WA
B9DA  9A2B                            ORA     ZP_INT_WA + 1
B9DC  9A2C                            ORA     ZP_INT_WA + 2
B9DE  9A2D                            ORA     ZP_INT_WA + 3
B9E0  3582                            PULS    A,PC
                      
                      
B9E2                  cmdUNTIL
                                              
                      ;                       ;  UNTIL
B9E2                                  CALL    evalExpressionMAIN
B9E2                  9
B9E4                  __XBSR                  SET 9B+2
E300                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DD                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B9E2  BD9DC1                                  JSR     \1
                              ENDIF
B9E5                                  CALL    scanNextStmtFromY
B9E5                  9
B9E7                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
008D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B9E5  BD9C74                                  JSR     \1
                              ENDIF
B9E8                                  CALL    checkTypeInZP_VARTYPEConvert2INT
B9E8                  9
B9EA                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
B9E8  BD986D                                  JSR     \1
                              ENDIF
B9EB  D624                            LDB     ZP_REPEAT_LVL
B9ED  27CC                            BEQ     brkNoREPEAT
B9EF                                  CALL    IntWAZero
B9EF                  9
B9F1                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
B9EF  8DE5                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
B9F1  2705                            BEQ     1F
B9F3  0A24                            DEC     ZP_REPEAT_LVL                   ; discard top of repeat stack
B9F5                                  JUMP    continue                        ; continue
B9F5  7E9362                                  JMP     \1
B9F8                  1                                                       ; LBA33
B9F8  5A                              DECB
B9F9  58                              ASLB
B9FA  8E0500                          LDX     #BASWKSP_REPEATSTACK
B9FD  EE85                            LDU     B,X
B9FF                                  JUMP    STUZPTXTPTR_continue
B9FF  7EB71D                                  JMP     \1
                              ; API Change - no longer saves to TXTPTR2
                              ; TODO: TEST: callers don't push Y
BA02                  decYSaveAndEvalHashChannelAPI                           ; LBA3C
BA02  335F                            LEAU    -1,U
BA04                  evalHashChannel                                         ; LBA4A
BA04                                  CALL    skipSpacesCheckHashAtY
BA04                  9
BA06                  __XBSR                  SET 9B+2
D600                  __XBSR2                 SET (\1-__XBSR) & $FF00
00BC                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA04  BD90C2                                  JSR     \1
                              ENDIF
BA07  26B9                            BNE     brkMissingHash
BA09                                  CALL    evalLevel1checkTypeStoreAsINT
BA09                  9
BA0B                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005A                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA09  BD9865                                  JSR     \1
                              ENDIF
BA0C  109E2C                          LDY     ZP_INT_WA+2
BA0F  39                              RTS
                      
                      
BA10                  cmdREPEAT
                                              ;  REPEAT
BA10  D624                            LDB     ZP_REPEAT_LVL
BA12  C114                            CMPB    #$14
BA14  24B1                            BHS     brkTooManyREPEATs
                      ;;              CALL    storeYasTXTPTR
BA16                                  CALL    checkForESC
BA16                  9
BA18                  __XBSR                  SET 9B+2
E200                  __XBSR2                 SET (\1-__XBSR) & $FF00
006D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA16  BD9C85                                  JSR     \1
                              ENDIF
BA19  58                              ASLB
BA1A  8E0500                          LDX     #BASWKSP_REPEATSTACK
BA1D  EF85                            STU     B,X
BA1F  0C24                            INC     ZP_REPEAT_LVL
BA21                                  JUMP    skipSpacesAtYexecImmed
BA21  7E936A                                  JMP     \1
                      
                      
BA24                  ReadKeysTo_InBuf
BA24  8607                            LDA     #BAS_InBuf / $100
                              IF FLEX = 1
                                      CLRB
                                      CALL    FLEX_READLINE
                              ELSE
BA26                  ReadKeysTo_PageInA
BA26  5F                              CLRB
BA27  DD37                            STD     ZP_GEN_PTR
BA29  CCEE20                          LDD     #$EE20
BA2C  DD39                            STD     ZP_GEN_PTR + 2
BA2E  C6FF                            LDB     #$FF
BA30  D73B                            STB     ZP_GEN_PTR + 4
BA32  8E0037                          LDX     #ZP_GEN_PTR
                      ;;              LDU     #0
BA35  4F                              CLRA
BA36  BDFFF1                          JSR     OSWORD          ; OSWORD 0 - read line to buf at XY
                              ENDIF
BA39  2406                            BCC     clearPRLINCOUNT
BA3B                                  JUMP    errEscape
BA3B  7E9C4D                                  JMP     \1
BA3E                  PrintCRclearPRLINCOUNT                                  ; LBA92
BA3E  BDFFE7                          JSR     OSNEWL
BA41                  clearPRLINCOUNT                                         ; LBA95
BA41  0F1E                            CLR     ZP_PRLINCOUNT
BA43  39                              RTS
                      
BA44                  findLineAndDelete                                       ;LBA98
BA44                                  CALL    findProgLineNewAPI
BA44                  9
BA46                  __XBSR                  SET 9B+2
CA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0083                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA44  BD84C9                                  JSR     \1
                              ENDIF
BA47  2420                            BCC     rtsLBAEA
BA49  DF12                            STU     ZP_TOP                          ; we found the line - replace it
BA4B  30C4                            LEAX    ,U
BA4D  E643                            LDB     3,U                             ; get length of existing line
BA4F  4F                              CLRA
                      ;;              ADDD    ZP_TOP          
                      ;;              TFR     D,Y
BA50  33CB                            LEAU    D,U
BA52                  floCopyLp                                               ; LBAB8
BA52                                  CALL    floCopy1bytes
BA52                  9
BA54                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0011                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BA52  8D11                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BA54  810D                            CMPA    #$0D
BA56  26FA                            BNE     floCopyLp
                                                                              ;LBAC7:
BA58                                  CALL    floCopy1bytes                   ; copy first (line number byte - big endian)
BA58                  9
BA5A                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
000B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BA58  8D0B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BA5A  2B06                            BMI     floCopySk1                      ; end of program detected
BA5C                                  CALL    floCopy1bytes                   ; copy line numbers bytes 
BA5C                  9
BA5E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0007                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BA5C  8D07                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BA5E                                  CALL    floCopy1bytes                   ; copy length byte
BA5E                  9
BA60                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0005                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BA5E  8D05                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BA60  20F0                            BRA     floCopyLp
BA62                  floCopySk1                                              ;LBAD3:
                      ;LBADC:
BA62  9F12                            STX     ZP_TOP
BA64  39                              RTS
BA65                  floCopy1bytes
BA65  A6C0                            LDA     ,U+
BA67  A780                            STA     ,X+
BA69  39              rtsLBAEA        RTS
                                              
                                      ;  Tokenise line, enter into program if program line
                                      ;  returns CY=1 if this is a program line
                      
BA6A                  tokenizeAndStore
BA6A  86FF                            LDA     #$FF
BA6C  9728                            STA     ZP_OPT
BA6E  973C                            STA     ZP_FPB + 1
BA70                                  CALL    ResetStackProgStartRepeatGosubFor               ;  do various CLEARs
BA70                  9
BA72                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA70  BDBB18                                  JSR     \1
                              ENDIF
BA73  DE0B                            LDU     ZP_TXTPTR
BA75  0F3B                            CLR     ZP_FPB
BA77                                  CALL    tokenizeATY
BA77                  9
BA79                  __XBSR                  SET 9B+2
D700                  __XBSR2                 SET (\1-__XBSR) & $FF00
0006                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA77  BD917F                                  JSR     \1
                              ENDIF
BA7A  DE0B                            LDU     ZP_TXTPTR
BA7C                                  CALL    skipSpacesDecodeLineNumberNewAPI
BA7C                  9
BA7E                  __XBSR                  SET 9B+2
E100                  __XBSR2                 SET (\1-__XBSR) & $FF00
007D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BA7C  BD9BFB                                  JSR     \1
                              ENDIF
BA7F  24E8                            BCC     rtsLBAEA
BA81                  tokenizeAndStoreAlreadyLineNoDecoded                                    ; LBB08
BA81  5F                              CLRB
BA82  0D1F                            TST     ZP_LISTO
BA84  2703                            BEQ     tokAndStoreListo0
BA86  BD9295                          JSR     skipSpacesYStepBack             
BA89                  tokAndStoreListo0                                                       ;LBB15:
BA89  DF3B                            STU     ZP_FPB
BA8B                                  CALL    findLineAndDelete  
BA8B                  9
BA8D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BA8B  8DB7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BA8D  DE3B                            LDU     ZP_FPB
BA8F  860D                            LDA     #$0D
BA91  C601                            LDB     #1                                              ; count line length
BA93  A1C0                            CMPA    ,U+             
BA95  27D2                            BEQ     rtsLBAEA                                        ; line was nowt but white space, return
BA97  5C              tokas_lp2       INCB                                                    ;LBB26:
BA98  A1C0                            CMPA    ,U+
BA9A  26FB                            BNE     tokas_lp2                                       ; move to EOL marker $D
BA9C  8620                            LDA     #' '
BA9E  335F                            LEAU    -1,U
BAA0  5A              tokas_lp3       DECB                                                    ;LBB2D:
BAA1  A1C2                            CMPA    ,-U
BAA3  27FB                            BEQ tokas_lp3                                           ; skip back over spaces
BAA5  3341            tokas_sk1       LEAU    1,U                                             ;LBB34:
BAA7  860D                            LDA     #$0D
BAA9  A7C4                            STA     ,U                                              ; another EOL marker remove trailing whitespace
BAAB  CB04                            ADDB    #4
BAAD  D73F                            STB     ZP_FPB + 4
BAAF  9E12                            LDX     ZP_TOP
BAB1  4F                              CLRA
BAB2  D312                            ADDD    ZP_TOP
BAB4  DD12                            STD     ZP_TOP          
BAB6  109306                          CMPD    ZP_HIMEM
BAB9  230F                            BLS     tokas_sk2_spaceok
BABB                                  CALL    findTOP
BABB                  9
BABD                  __XBSR                  SET 9B+2
0200                  __XBSR2                 SET (\1-__XBSR) & $FF00
0002                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BABB  BDBCBF                                  JSR     \1
                              ENDIF
BABE                                  CALL    ResetVars
BABE                  9
BAC0                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0030                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BABE  8D30                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BAC0                                  DO_BRK_B
                                      IF FLEX
                                              JSR     HandleBRK
                                      ELSIF MACH_MATCHBOX
BAC0  3F                                      SWI
                                      ELSE
                                              SWI3
                                      ENDIF
BAC1  008620737061636500                 FCB  0, tknLINE, " space", 0
                      
                      
BACA                  tokas_sk2_spaceok                                                       ;LBB6B:
BACA  1F03                            TFR     D,U
BACC  3341                            LEAU    1,U
BACE  3001                            LEAX    1,X
BAD0                  tokas_lp4
BAD0  A682                            LDA     ,-X
BAD2  A7C2                            STA     ,-U
BAD4  9C3D                            CMPX    ZP_FPB + 2
BAD6  26F8                            BNE     tokas_lp4
                      
                      
BAD8  3001                            LEAX    1,X                                             ; move past 0d marker
BADA  DC2C                            LDD     ZP_INT_WA + 2                                   ; get decoded big endian line number
BADC  ED81                            STD     ,X++
BADE  D63F                            LDB     ZP_FPB + 4                                      ; line length
BAE0  E780                            STB     ,X+     
                      
BAE2  C004                            SUBB    #4                                              ; reduce line length counter by 4
BAE4  DE3B                            LDU     ZP_FPB
BAE6  A6C0            tokas_lp5       LDA     ,U+                                             ; copy from $700 to program memory
BAE8  A780                            STA     ,X+
BAEA  5A                              DECB
BAEB  26F9                            BNE     tokas_lp5
BAED                                  SEC
BAED  1A01                    ORCC    #CC_C
BAEF  39                              RTS
                      ;               
BAF0  DC12            ResetVars       LDD ZP_TOP
BAF2  DD00                            STD ZP_LOMEM
BAF4  DD02                            STD ZP_VARTOP                                   ;  LOMEM=TOP, VARTOP=TOP
BAF6                                  CALL ResetStackProgStartRepeatGosubFor
BAF6                  9
BAF8                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0020                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BAF6  8D20                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ;                       ;  Reset DATA, REPEAT, FOR, GOSUB
                      ;                       ;  Clear dynamic variables
                      ;                       ;  -----------------------
BAF8                  InittblFPRtnAddr
BAF8  3440                            PSHS    U
BAFA  8E0010                          LDX     #$10
BAFD  EC89BDD1        1               LDD     tblFPRtnAddr_const-2,X
BB01  ED8907EE                        STD     $07F0-2,X                               ;  Copy entry addresses to $07F0-$07FF
BB05  301E                            LEAX     -2, X
BB07  26F4                            BNE     1B
BB09  8640                            LDA     #$40
BB0B  8E0000                          LDX     #0
BB0E  CE0480                          LDU     #BASWKSP_DYNVAR_HEADS
BB11  AFC1            1               STX     ,U++
BB13  4A                              DECA    
BB14  26FB                            BNE     1B                                      ;  Clear dynamic variables
BB16  35C0                            PULS    U,PC
BB18                  ResetStackProgStartRepeatGosubFor
BB18  9618                            LDA     ZP_PAGE_H
BB1A  5F                              CLRB
BB1B  DD1C                            STD     ZP_READ_PTR                             ;  DATA pointer = PAGE
BB1D  DC06                            LDD     ZP_HIMEM                                ;  STACKBOT=HIMEM
BB1F  DD04                            STD     ZP_BAS_SP
BB21  961F                            LDA     ZP_LISTO
BB23  847F                            ANDA    #$7F
BB25  971F                            STA     ZP_LISTO
BB27  0F24                            CLR     ZP_REPEAT_LVL
BB29  0F26                            CLR     ZP_FOR_LVL_X_15
BB2B  0F25                            CLR     ZP_GOSUB_LVL;                   ;  Clear REPEAT, FOR, GOSUB stacks
BB2D  39                              RTS                                     ;  DATA pointer = PAGE
                      ;               
                      ;               
BB2E                  popFPFromStackToPTR1                    ; pop FP from stack, set out old stack pointer in PTR1
BB2E  109E04                          LDY     ZP_BAS_SP
BB31  109F4A                          STY     ZP_FP_TMP_PTR1
BB34  3125                            LEAY    5,Y
BB36  109F04                          STY     ZP_BAS_SP
BB39  39                              RTS
                      
BB3A                  fpStackWAtoStackReal    
BB3A  C6FB                            LDB     #-5
BB3C                                  CALL    UpdStackByBCheckFull            ; make room for a float on the stack
BB3C                  9
BB3E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BB3C  BDBC0F                                  JSR     \1
                              ENDIF
BB3F  9630                            LDA     ZP_FPA + 2
BB41  A784                            STA     0,X
BB43  962E                            LDA     ZP_FPA
BB45  9831                            EORA    ZP_FPA + 3
BB47  8480                            ANDA    #$80
BB49  9831                            EORA    ZP_FPA + 3                      ; Get top bit of sign byte and seven other bits of mantissa MSB
BB4B  A701                            STA     1,X
                      
BB4D  DC32                            LDD     ZP_FPA + 4
BB4F  ED02                            STD     2,X
                      
BB51  9634                            LDA     ZP_FPA + 6
BB53  A704                            STA     4,X
BB55  39                              RTS
BB56                  stackVarTypeInFlags
BB56  271C                            BEQ     StackString
BB58  2BE0                            BMI     fpStackWAtoStackReal
BB5A                  stackINT_WAasINT                                ; LBC26
BB5A  C6FC                            LDB     #-4
BB5C                                  CALL    UpdStackByBCheckFull
BB5C                  9
BB5E                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B1                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BB5C  BDBC0F                                  JSR     \1
                              ENDIF
BB5F  DC2A                            LDD     ZP_INT_WA
BB61  ED84                            STD     ,X
BB63  DC2C                            LDD     ZP_INT_WA + 2
BB65  ED02                            STD     2,X
BB67  39                              RTS
BB68                  pushVarPtrAndType                               ; was pullRETpushIntAtoIntAplus2pushRET
BB68  3510                            PULS    X
BB6A  DC2C                            LDD     ZP_INT_WA + 2
BB6C  3406                            PSHS    D
BB6E  962A                            LDA     ZP_INT_WA + 0
BB70  3402                            PSHS    A
BB72  6E84                            JMP     0,X
                      
                      
                      ;               ;  Stack the current string
                      ;               ;  ========================
BB74                  StackString
BB74  3454                            PSHS    B,X,U
BB76  D636                            LDB     ZP_STRBUFLEN                    ; Calculate new stack pointer address
BB78  86FF                            LDA     #$FF
BB7A  53                              COMB                                    ; D now contains -(ZP_STRBUFLEN + 1)
BB7B  9E04                            LDX     ZP_BAS_SP
BB7D  308B                            LEAX    D,X
BB7F                                  CALL    UpdStackFromXCheckFull
BB7F                  9
BB81                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0093                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BB7F  BDBC14                                  JSR     \1
                              ENDIF
BB82  D636                            LDB     ZP_STRBUFLEN                    ; store len as first byte of stacked data
BB84  E780                            STB     ,X+
BB86  270A                            BEQ     stackstrsk0
BB88  CE0600                          LDU     #BAS_StrA                       ; followed by the string data
BB8B  A6C0            stackstrlp0     LDA     ,U+
BB8D  A780                            STA     ,X+
BB8F  5A                              DECB
BB90  26F9                            BNE     stackstrlp0
BB92  35D4            stackstrsk0     PULS    B,X,U,PC
                      
                      ;       
                      ;               
BB94                  delocaliseAtZP_GEN_PTR
BB94  3440                            PSHS    U
BB96  DE04                            LDU     ZP_BAS_SP
BB98  9637                            LDA     ZP_NAMELENORVT                  ; get variable type
BB9A  8180                            CMPA    #VAR_TYPE_STRING_STAT
BB9C  2717                            BEQ     delocalizeStaticString          ; was a static string
BB9E  2528                            BLO     delocalizeNum
                      
                                      ;delocalise Dynamic String
                      
BBA0  E6C0                            LDB     ,U+                             ; get stacked string length
BBA2  270D                            BEQ     2F
BBA4  9E39                            LDX     ZP_GEN_PTR + 2                  ; string params pointer
BBA6  E703                            STB     3,X
BBA8  AE84                            LDX     ,X                              ; string pointer
                      
BBAA  A6C0            1               LDA     ,U+
BBAC  A780                            STA     ,X+
BBAE  5A                              DECB
BBAF  26F9                            BNE     1B
BBB1                  2                                                       ; LBC8D:
BBB1                  delocExit
BBB1  DF04                            STU     ZP_BAS_SP
BBB3  35C0                            PULS    U,PC
                      
BBB5                  delocalizeStaticString                                  ; LBC95
BBB5  E6C0                            LDB     ,U+                             ; get stacked string length
BBB7  272A                            BEQ     2F
BBB9  9E39                            LDX     ZP_GEN_PTR + 2                  ; get address to restore string to 
BBBB                  1                                                       ; LBC9C
BBBB  A6C0                            LDA     ,U+
BBBD  A780                            STA     ,X+
BBBF  5A                              DECB
BBC0  26F9                            BNE     1B
BBC2  860D                            LDA     #$0D
BBC4  A780                            STA     ,X+
BBC6  20E9                            BRA     delocExit
BBC8                  delocalizeNum                                           ; LBCAA
BBC8  9E39                            LDX     ZP_GEN_PTR + 2
BBCA  D637                            LDB     ZP_NAMELENORVT                  ; get var type
BBCC  5A                              DECB
BBCD  A6C0            1               LDA     ,U+                             ; for 0 (do 1 byte), for 4,5 do 4,5 bytes
BBCF  A780                            STA     ,X+
BBD1  5A                              DECB
BBD2  2AF9                            BPL     1B
BBD4  20DB                            BRA     delocExit
                      
                                      ; new API - trashes A, X
BBD6                  popStackedStringNew                                     ; LBCD2
                      
BBD6  3440                            PSHS    U
BBD8  DE04                            LDU     ZP_BAS_SP
BBDA  A6C0                            LDA     ,U+                             ; first byte contains length
BBDC  9736                            STA     ZP_STRBUFLEN
BBDE  27D1                            BEQ     delocExit
BBE0  8E0600                          LDX     #BASWKSP_STRING
BBE3  E6C0            2               LDB     ,U+
BBE5  E780                            STB     ,X+
BBE7  4A                              DECA
BBE8  26F9                            BNE     2B
BBEA  20C5                            BRA     delocExit               
                      
                      
                                      ; New API - after call all regs preserved
BBEC                  popIntANew
BBEC  3446                            PSHS    D,U
BBEE  DE04                            LDU     ZP_BAS_SP
BBF0  ECC1                            LDD     ,U++
BBF2  DD2A                            STD     ZP_INT_WA
BBF4  ECC1                            LDD     ,U++
BBF6  DD2C                            STD     ZP_INT_WA+2
BBF8  DF04                            STU     ZP_BAS_SP
BBFA  35C6                            PULS    D,U,PC
BBFC                  popIntAtZP_GEN_PTRNew                           ; LBD06
BBFC  8E0037                          LDX #ZP_GEN_PTR                 ; TODO - WORK THIS LOT OUT!
                                      ; NOTE: trashes A,B
BBFF                  popIntAtXNew                                    ; LBD08
BBFF  3440                            PSHS    U
BC01  DE04                            LDU     ZP_BAS_SP
BC03  ECC1                            LDD     ,U++
BC05  ED84                            STD     0,X
BC07  ECC1                            LDD     ,U++
BC09  ED02                            STD     2,X
BC0B  DF04                            STU     ZP_BAS_SP
BC0D  35C0                            PULS    U,PC
BC0F                  UpdStackByBCheckFull
BC0F  9E04                            LDX     ZP_BAS_SP
BC11  1D                              SEX
BC12  308B                            LEAX    D,X
BC14                  UpdStackFromXCheckFull
BC14  9C12                            CMPX    ZP_TOP
BC16  2506                            BLO     brabrkNoRoom
BC18  9F04                            STX     ZP_BAS_SP
BC1A  39                              RTS
                      ;
BC1B                  ResetVarsBrkNoRoom
BC1B                                  CALL ResetVars
BC1B                  9
BC1D                  __XBSR                  SET 9B+2
FE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BC1B  BDBAF0                                  JSR     \1
                              ENDIF
BC1E                  brabrkNoRoom    JUMP brkNoRoom
BC1E  7E93FB                                  JMP     \1
                      ;
                      ;
                      ;
BC21                  doListPrintTokenA                                       ; LBD37
BC21  8180                            CMPA    #$80
BC23  254A                            BLO     list_printA                             ; just a normal char print it and continue
BC25  9737                            STA     ZP_GEN_PTR
BC27  3450                            PSHS    X,U
BC29  308DC547                        LEAX    tblTOKENS,PCR
                      
BC2D                  doListTryNextTok                                                ; LBD46
BC2D  3384                            LEAU    ,X                                      ; Y points to name of current token
BC2F                  doListSkipKey                                                   ;LBD48:
BC2F  A680                            LDA     ,X+                                     ; TODO probably can skip first and 2nd char every time?
BC31  2AFC                            BPL     doListSkipKey                           ; not a token skip it
BC33  9137                            CMPA    ZP_GEN_PTR
BC35  2704                            BEQ     doListKeyLp                             ; it's the right token
BC37  3001                            LEAX    1,X                                     ; skip flags
BC39  20F2                            BRA     doListTryNextTok
BC3B                  doListKeyLp                                                     ;LBD60:
BC3B  A6C0                            LDA     ,U+
BC3D  2B04                            BMI     doListKeyFinished
BC3F                                  CALL    list_printA
BC3F                  9
BC41                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
002E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BC3F  8D2E                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BC41  20F8                            BRA     doListKeyLp
BC43                  doListKeyFinished                                               ;LBD6A:
BC43  35D0                            PULS    X,U,PC
                      
                      
BC45                  list_printHexByte                                       ; LBD6C
BC45  3402                            PSHS    A
BC47  44                              LSRA
BC48  44                              LSRA
BC49  44                              LSRA
BC4A  44                              LSRA
BC4B                                  CALL    list_printHexNybble
BC4B                  9
BC4D                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0004                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BC4B  8D04                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BC4D  3502                            PULS    A
BC4F  840F                            ANDA    #$0F
BC51                  list_printHexNybble                                     ; LBD77
BC51  810A                            CMPA    #$0A
BC53  2502                            BLO     list_printAasDigit
BC55  8B07                            ADDA    #$07
BC57                  list_printAasDigit                                      ; LBD7D
BC57  8B30                            ADDA    #$30
BC59                  list_printCheckPRLINCOUNT                               ; LBD7F
BC59  3402                            PSHS    A
BC5B  9623                            LDA     ZP_WIDTH
BC5D  911E                            CMPA    ZP_PRLINCOUNT
BC5F  2403                            BCC     list_printCheckPRLINCOUNT_sk1
BC61                                  CALL    PrintCRclearPRLINCOUNT
BC61                  9
BC63                  __XBSR                  SET 9B+2
FD00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00DB                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BC61  BDBA3E                                  JSR     \1
                              ENDIF
BC64                  list_printCheckPRLINCOUNT_sk1                           ; LBD89:
BC64  3502                            PULS    A
BC66  0C1E                            INC     ZP_PRLINCOUNT
BC68  7EFFEE                          JMP     OSWRCH
BC6B                  list_printHexByteAndSpace                               ; LBD8F
BC6B                                  CALL list_printHexByte
BC6B                  9
BC6D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BC6B  8DD8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BC6D                  list_print1Space                                        ; LBD92
BC6D  8620                            LDA     #$20
BC6F                  list_printA                                             ; LBD94
BC6F  0D1F                            TST     ZP_LISTO
BC71  2B0A                            BMI     list_printToVARTOP
BC73                  list_printANoEDIT                                       ; LBD98
BC73  810D                            CMPA    #$0D
BC75  26E2                            BNE     list_printCheckPRLINCOUNT
BC77  BDFFEE                          JSR     OSWRCH
BC7A                                  JUMP    clearPRLINCOUNT
BC7A  7EBA41                                  JMP     \1
BC7D                  list_printToVARTOP                                      ; LBDA2
BC7D  A79F0002                        STA     [ZP_VARTOP]                     ; store at VARTOP for EDIT
BC81  0C02                            INC     ZP_VARTOP
BC83  261D                            BNE     rtsLBDC5
BC85  0C03                            INC     ZP_VARTOP + 1
BC87  3402                            PSHS    A
BC89  9603                            LDA     ZP_VARTOP + 1
BC8B  9807                            EORA    ZP_HIMEM + 1
BC8D  278C                            BEQ     ResetVarsBrkNoRoom              ; out of space for listing
BC8F  3502                            PULS    A
BC91  39                              RTS
BC92                  doLISTOSpacesCLC                                        ; LBDB3
BC92                                  CLC
BC92  1CFE                    ANDCC   #~CC_C
BC94                  doLISTOSpaces                                           ; LBDB4
BC94  941F                            ANDA    ZP_LISTO
BC96  270A                            BEQ     rtsLBDC5
BC98  59                              ROLB
BC99  2507                            BCS     rtsLBDC5        
BC9B  2705                            BEQ     rtsLBDC5
BC9D                  list_printBSpaces                       ;LBDBF:
BC9D                                  CALL    list_print1Space
BC9D                  9
BC9F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00CE                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BC9D  8DCE                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BC9F  5A                              DECB
BCA0  26FB                            BNE     list_printBSpaces
BCA2                  rtsLBDC5
BCA2  39                              RTS
                      ;               
                      ;               
BCA3                  CopyIntWA2X                                ; DB: Changed this to use 16 bit reg and X can point anywhere!
BCA3  3406                            PSHS    D
BCA5  DC2A                            LDD     ZP_INT_WA + 0
BCA7  ED84                            STD     ,X
BCA9  DC2C                            LDD     ZP_INT_WA + 2
BCAB  ED02                            STD     2,X
BCAD  3506                            PULS    D
BCAF  39                              RTS
                      
                              IF FLEX
                      brkBadFileName  DO_BRK_B
                                      FCB     100                             ; TODOFLEX - made up error number
                                      FCB     "Bad filename", 0
                      
                      
                      FMS_ERR         LDA     FCBOFFS_ERR,X
                                      PSHS    A
                                      LDA     #FMS_CLOSE
                                      STA     ,X
                                      JSR     FMS
                                      PULS    B
                                      ORB     #$40                                    ; TODOFLEX - arbitrary number here!
                                      JMP     FLEXERROR
                              ENDIF
                      
                      
                      ;               
                      ;                       ;  Load program to PAGE
                      ;                       ;  --------------------
BCB0                  loadProg2Page
                              IF FLEX = 1
                                      CALL    evalYExpectString
                                      LDB     ZP_STRBUFLEN
                                      BEQ     brkBadFileName
                                      BMI     brkBadFileName
                                      ; copy filename to LINBUF
                                      LDU     #BASWKSP_STRING
                                      LDX     #LINBUF
                                      STX     CBUFPT
                      1               LDA     ,U+
                                      STA     ,X+
                                      DECB
                                      BNE     1B
                                      LDA     #$D
                                      STA     ,X+
                                      LDX     #SYSFCB
                                      JSR     GETFIL
                                      BCS     brkBadFileName
                                      LDA     #SETEXT_BAS
                                      JSR     SETEXT
                                      LDA     #FMS_OPENRD
                                      STA     ,X
                                      JSR     FMS
                                      BNE     FMS_ERR
                                      LDA     #$FF
                                      STA     FCBOFFS_COMPRESS,X                      ; BINary file
                                      LDA     ZP_PAGE_H
                                      CLRB
                                      TFR     D,U
                                      LDA     #FMS_RDWR
                                      STA     ,X
                      1               JSR     FMS
                                      BNE     FMS_CK_EOF
                                      STA     ,U+
                                      CMPU    ZP_HIMEM
                                      BLO     1B
                                      BRA     1F
                      FMS_CK_EOF      LDA     FCBOFFS_ERR,X                           ; Get error number
                                      CMPA    #FMS_ERR_EOF
                                      BNE     FMS_ERR
                      1               LDA     #FMS_CLOSE
                                      STA     ,X
                                      JSR     FMS
                              ELSE
BCB0                                  CALL    GetFileNamePageAndHighOrderAddr ; get cr-string, FILE_NAME=STRA, FILE_LOAD=PAGE/memhigh
BCB0                  9
BCB2                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
006B                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BCB0  8D6B                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ; Returns FILE_NAME=>string
                      ;         FILE_EXEC=&00000000
                      ;         X=machine high address
                      ;         D=page
                      ;         Cy=big/little
                      ;
BCB2  CE0039                          LDU     #ZP_GEN_PTR+2
BCB5                                  CALL    StoreFileAddress                ; Store PAGE at ctrl+2/3/4/5
BCB5                  9
BCB7                  __XBSR                  SET 9B+2
0000                  __XBSR2                 SET (\1-__XBSR) & $FF00
0078                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BCB5  8D78                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BCB7  86FF                            LDA     #OSFILE_LOAD
BCB9  8E0037                          LDX     #ZP_GEN_PTR                     ;  Point to OSFILE block
BCBC  BDFFDD                          JSR     OSFILE                          ;  Continue into FindTOP
                              ENDIF
BCBF  9618            findTOP         LDA     ZP_PAGE_H
BCC1  5F                              CLRB
BCC2  1F01                            TFR     D,X
BCC4  DD12                            STD     ZP_TOP  
BCC6  E684            ftop_lp1        LDB     ,X
BCC8  C10D                            CMPB    #$0D
BCCA  2616                            BNE     printBadProgram                 ; check for CR
BCCC  E601                            LDB     1,X                             ; check for -ve line number (end of program)
BCCE  2B0D                            BMI     ftop_sk1
BCD0  E603                            LDB     3,X                             ; check line length and add for next line
BCD2  270E                            BEQ     printBadProgram
BCD4  4F                              CLRA
BCD5  D312                            ADDD    ZP_TOP
BCD7  DD12                            STD     ZP_TOP
BCD9  1F01                            TFR     D, X
BCDB  20E9                            BRA     ftop_lp1
BCDD                  ftop_sk1        
BCDD  3002                            LEAX    2,X
BCDF  9F12                            STX     ZP_TOP
BCE1  39                              RTS
BCE2                  printBadProgram
BCE2  308C06                          LEAX    str_bad_prog,PCR
BCE5  BDFF9B                          JSR     PRSTRING
BCE8                                  JUMP    immedPrompt
BCE8  7E92EF                                  JMP     \1
                      
BCEB  0D4261642070726F6772616D0D00 str_bad_prog    FCN     "\rBad program\r"
                      
                      ;               
BCF9  8E0600          str600CRterm    LDX     #BAS_StrA
BCFC  D636            1               LDB     ZP_STRBUFLEN                    ;  Get length of string in buffer
BCFE  860D                            LDA     #$0D
BD00  3410                            PSHS    X
BD02  3A                              ABX
BD03  A784                            STA     ,X
BD05  3590                            PULS    X,PC                            ;  Store <cr> at end of string
                      
BD07                  evalYExpectString                                       ; LBE36
BD07                                  CALL    evalExpressionMAIN              ;  Call expression evaluator
BD07                  9
BD09                  __XBSR                  SET 9B+2
E000                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD07  BD9DC1                                  JSR     \1
                              ENDIF
BD0A  4D                              TSTA
BD0B  1026D6DC                        LBNE    brkTypeMismatch                 
BD0F                                  CALL    str600CRterm                    ; put terminating <cr> in
BD0F                  9
BD11                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD0F  8DE8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BD11  9F37                            STX     ZP_SAVE_BUF                     ; Point 37/8 to STRA, TODO: check needed!
BD13  A6C4                            LDA     ,U
BD15                                  JUMP    scanNextExpectColonElseCR
BD15  7E9C77                                  JMP     \1
                      
                              IF FLEX != 1
BD18  8682            OSByte82        LDA     #$82
BD1A  7EFFF4                          JMP     OSBYTE
BD1D                  GetFileNamePageAndHighOrderAddr                         ; LBE41
BD1D                                  CALL    evalYExpectString               ; Get CR-string
BD1D                  9
BD1F                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E8                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD1D  8DE8                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BD1F                                  CALL    OSByte82
BD1F                  9
BD21                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00F7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD1F  8DF7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BD21  4F                              CLRA
BD22  5F                              CLRB
BD23  DD3D                            STD     ZP_GEN_PTR+6                    ; exec=0 regardless of endianness
BD25  DD3F                            STD     ZP_GEN_PTR+8
BD27  9654                            LDA     ZP_BIGEND
BD29  48                              ASLA                                    ; Cy=big/little
BD2A  9618                            LDA     ZP_PAGE_H                       ; D=PAGE
BD2C  39                              RTS
BD2D                  StoreFileAddressNext
BD2D  3344                            LEAU    4,U                             ; Point to next address
BD2F                  StoreFileAddress
BD2F  3410                            PSHS    X
BD31  2404                            BCC     StoreFileBigAddr
BD33  1E89                            EXG     A,B                             ; Swap to make little-endian
BD35  1E10                            EXG     X,D
BD37                  StoreFileBigAddr
BD37  AFC4                            STX     0,U
BD39  ED42                            STD     2,U
BD3B  3590                            PULS    X,PC
                              ENDIF
                      
BD3D                  cmdSAVE                                                 ; LBE55
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BD3D  3440                            PSHS    U
BD3F                                  CALL    findTOP
BD3F                  9
BD41                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
007E                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD3F  BDBCBF                                  JSR     \1
                              ENDIF
BD42                                  CALL    GetFileNamePageAndHighOrderAddr         
BD42                  9
BD44                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD42  8DD9                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      ; Returns FILE_NAME=>string
                      ;         FILE_EXEC=&00000000
                      ;         X=machine high address
                      ;         D=page
                      ;         Cy=big/little
                      ;
BD44  CE0041                          LDU     #ZP_SAVE_BUF+10
BD47                                  CALL    StoreFileAddress                ; FILE_START=PAGE
BD47                  9
BD49                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E6                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD47  8DE6                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BD49  DC12                            LDD     ZP_TOP
BD4B                                  CALL    StoreFileAddressNext            ; FILE_END=TOP
BD4B                  9
BD4D                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD4B  8DE0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BD4D  CE0039                          LDU     #ZP_SAVE_BUF+2
BD50  8EFFFF                          LDX     #$FFFF
BD53  CCFB00                          LDD     #$FB00
BD56                                  CALL    StoreFileAddress                ; FILE_LOAD=FFFFFB00 = filetyped to BASIC
BD56                  9
BD58                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00D7                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD56  8DD7                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
                      
                      ;+;             LDX     #ZP_SAVE_BUF+5                  ; Implement this bit later
                      ;+;             LDA     #3
                      ;+;             STX     0,X
                      ;+;             LDA     #14
                      ;+;             CALL    varGetTime2                     ; Read RTC datestamp to FILE_EXEC
                      
BD58  8600                            LDA     #OSFILE_SAVE                    ; OSFILE 0
BD5A  8E0037                          LDX     #ZP_SAVE_BUF
BD5D  BDFFDD                          JSR     OSFILE
BD60  3540                            PULS    U
BD62                                  JUMP    continue
BD62  7E9362                                  JMP     \1
                              ENDIF
BD65                  cmdOSCLI
BD65                                  CALL    evalYExpectString
BD65                  9
BD67                  __XBSR                  SET 9B+2
FF00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A0                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
BD65  8DA0                                    BSR     \1              ; HOOP
                              ELSE
                                              JSR     \1
                              ENDIF
BD67  8E0600                          LDX     #BASWKSP_STRING
BD6A  3440                            PSHS    U
BD6C  BDFFF7                          JSR     OSCLI
BD6F  3540                            PULS    U
BD71                                  JUMP    continue
BD71  7E9362                                  JMP     \1
                      
                                              ; EXT#channel=number
                                              ; ------------------
BD74                  cmdEXTEq                                        ; LBE93
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BD74  8603                            LDA     #$03                    ; 03=Set extent
BD76  2002                            BRA     varSetFInfo
                              ENDIF
                      
                                              ; PTR#channel=number
                                              ; ------------------
BD78                  varSetPTR                                       ; LBE97
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BD78  8601                            LDA     #$01                    ; 01=Set pointer
BD7A                  varSetFInfo                                     ; LBE99
BD7A  3402                            PSHS    A
BD7C                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
BD7C                  9
BD7E                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0086                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD7C  BDBA04                                  JSR     \1
                              ENDIF
BD7F                                  CALL    skipSpacesExpectEqEvalExp
BD7F                  9
BD81                  __XBSR                  SET 9B+2
DE00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00A5                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD7F  BD9C26                                  JSR     \1
                              ENDIF
BD82                                  CALL    checkTypeInZP_VARTYPEConvert2INT
BD82                  9
BD84                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00E9                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD82  BD986D                                  JSR     \1
                              ENDIF
BD85  0D54                            TST     ZP_BIGEND
BD87  2B03                            BMI     1F
BD89                                  CALL    SwapEndian              ; Swap INTA
BD89                  9
BD8B                  __XBSR                  SET 9B+2
F100                  __XBSR2                 SET (\1-__XBSR) & $FF00
0009                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD89  BDAE94                                  JSR     \1
                              ENDIF
BD8C  DF0B            1               STU     ZP_TXTPTR               ; Save TXTPTR
BD8E  8E002A                          LDX     #ZP_INT_WA
BD91  3502                            PULS    A                       ; Get action and channel
BD93  BDFFDA                          JSR     OSARGS                  ; Write from INTA
BD96  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
BD98                                  JUMP    continue                ; Return to main execution loop
BD98  7E9362                                  JMP     \1
                              ENDIF
                                              ; CLOSE#channel
                                              ; -------------
BD9B                  cmdCLOSE                                        ; LBEAE
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BD9B                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
BD9B                  9
BD9D                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
0067                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BD9B  BDBA04                                  JSR     \1
                              ENDIF
BD9E  4F                              CLRA                            ; A=$00 for CLOSE
BD9F  BDFFCE                          JSR     OSFIND
BDA2                                  JUMP    continue                ; Return to main execution loop
BDA2  7E9362                                  JMP     \1
                              ENDIF
                                              ; BPUT#channel,number
                                              ; -------------------
BDA5                  cmdBPUT                                         ; LBEBD
                              IF FLEX = 1
                                      JUMP    brkFlexNotImpl
                              ELSE
BDA5                                  CALL    evalHashChannel         ; Evaluate #channel, save TXTPTR, Y=channel
BDA5                  9
BDA7                  __XBSR                  SET 9B+2
FC00                  __XBSR2                 SET (\1-__XBSR) & $FF00
005D                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BDA5  BDBA04                                  JSR     \1
                              ENDIF
BDA8                                  CALL    checkCommaThenEvalAtYcheckTypeInAConvert2INT
BDA8                  9
BDAA                  __XBSR                  SET 9B+2
DA00                  __XBSR2                 SET (\1-__XBSR) & $FF00
00B3                  __XBSR3                 SET (\1-__XBSR) & $FF
                              IF (__XBSR2==0 && __XBSR3 < $80) || ((__XBSR2 == $FF00) && (__XBSR3 > $80))
                                              BSR     \1              ; HOOP
                              ELSE
BDA8  BD985D                                  JSR     \1
                              ENDIF
BDAB  962D                            LDA     ZP_INT_WA+3             ; Get low byte of number
BDAD  BDFFD4                          JSR     OSBPUT                  ; Write to channel
BDB0  DE0B                            LDU     ZP_TXTPTR               ; Get TXTPTR back
BDB2                                  JUMP    continue                ; Return to main execution loop
BDB2  7E9362                                  JMP     \1
                              ENDIF
                      
                      
                      ;;callOSWORD5INT_WA                             ; get a byte from host processor
                      ;;; not actually needed, 6809 BBC API defined to pass X=>command line on entry
                      ;;              TODODEADEND "callOSWORD5INT_WA - endianness, sort out"
                      ;;              LDA     #$05
                      ;;              PSHU    X
                      ;;              LDX     #ZP_INT_WA
                      ;;              LDU     #0                      ; DP
                      ;;              JSR     OSWORD
                      ;;              PULU    X
                      ;;              LDA     ZP_INT_WA + 4           ; return value in A
BDB5  0C2D            inc_INT_WA      INC     ZP_INT_WA + 3           ; increment - note big endianness
BDB7  260A                            BNE     1F
BDB9  0C2C                            INC     ZP_INT_WA + 2
BDBB  2606                            BNE     1F
BDBD  0C2B                            INC     ZP_INT_WA + 1
BDBF  2602                            BNE     1F
BDC1  0C2A                            INC     ZP_INT_WA + 0
BDC3  39              1               RTS
                      
                      
BDC4                  deleteProgSetTOP
BDC4  9618                            LDA     ZP_PAGE_H
BDC6  5F                              CLRB
BDC7  0F20                            CLR     ZP_TRACE
BDC9  1F01                            TFR     D, X
BDCB  CC0DFF                          LDD     #$0DFF                  ; 0 length program
BDCE  ED81                            STD     ,X++                    ; store at page
BDD0  9F12                            STX     ZP_TOP
BDD2  39                              RTS
                      
                      ;                       ;  Floating-Point Routine Entries
                      ;                       ;  ==============================
                      ;                       ;  Copied to $07F0-$07FF
                      ;                       ;
                      ;               .segment "BF14"
                      ;               .org    $BF14
BDD3                  tblFPRtnAddr_const
BDD3  A802                            FDB     fpFPAeq_sqr_FPA         ;  FloatA = SQR(FloatA)
BDD5  A625                            FDB     fpFPAeqPTR1divFPA       ;  FloatA = ArgP / FloatA
BDD7  A6DC                            FDB     fpFPAeqPTR1mulFPA       ;  FloatA = ArpP * FloatA
BDD9  A6C3                            FDB     fpFPAeqPTR1addFPA       ;  FloatA = ArgP + FloatA
BDDB  AD06                            FDB     fpNegateFP_A            ;  FloatA = -FloatA
BDDD  A593                            FDB     fpCopyPTR1toFPA         ;  FloatA = (ArgP)
BDDF  A571                            FDB     fpCopyFPA_PTR1          ;  (ArgP) = FloatA
BDE1  4A                              FCB     ZP_FP_TMP_PTR1          ;  Zero page address of ArgP
BDE2  2E                              FCB     ZP_FPA          ;  Zero page address of FloatA
                      ;FPCONST:
BDE3  81C9100000      fpConstMinPiDiv2        FCB     $81, $C9, $10, $00, $00 ; -PI/2
BDE8  6F15777A61      fpConst4_454e_6         FCB     $6F, $15, $77, $7A, $61 ; 4.4544551105e-06
BDED  81490FDAA2      fpConstPiDiv2           FCB     $81, $49, $0F, $DA, $A2 ; PI/2
BDF2  8022F9836E      fpConst2DivPi           FCB     $80, $22, $F9, $83, $6E ; 2/PI = 0.6366
BDF7  7B0EFA3512      fpConstDeg2Rad          FCB     $7B, $0E, $FA, $35, $12 ;  1.74E-2 - 1 deg in rads
BDFC  86652EE0D3      fpConstRad2Deg          FCB     $86, $65, $2E, $E0, $D3 ;  57.29 - 1 rad in degrees
BE01  7F5E5BD8AA      fpConst0_43429          FCB     $7F, $5E, $5B, $D8, $AA ;  4.3429448199e-01
BE06  822DF85458      fpConst_e               FCB     $82, $2D, $F8, $54, $58 ;  e = 2.7182818279e+00
BE0B  80317217F8      fpConst_ln_2            FCB     $80, $31, $72, $17, $F8 ;  ln(2) = 6.9314718130e-01
BE10  800BD75029      fpConst0_54625          FCB     $80, $0B, $D7, $50, $29 ;  5.4625416757e-01
BE15  7CD27C8605                              FCB     $7C, $D2, $7C, $86, $05 ;  -5.1388286127e-02
BE1A  801552B636                              FCB     $80, $15, $52, $B6, $36 ;  5.8329333132e-01 ;  $BF60
BE1F  7C99983604                              FCB     $7C, $99, $98, $36, $04 ;  -3.7498675345e-02
BE24  8040000110                              FCB     $80, $40, $00, $01, $10 ;   3/4  (7.5000006333e-01)
BE29  7F2AAAAAE3                              FCB     $7F, $2A, $AA, $AA, $E3 ;   1/3  (3.3333333989e-01)
BE2E  7FFFFFFFFF      fpConstMin0_5           FCB     $7F, $FF, $FF, $FF, $FF ;  -1/2
BE33  7AC31E18BE      fpConstMin0_011909      FCB     $7A, $C3, $1E, $18, $BE ; -1.1909031069e-02 ; Used in SIN/COS
BE38  736171552D                              FCB     $73, $61, $71, $55, $2D ;  1.074994592E-4
BE3D  7B8C9B9188                              FCB     $7B, $8C, $9B, $91, $88 ; -1.716402458E-2
BE42  772BA4C453                              FCB     $77, $2B, $A4, $C4, $53 ;  1.309536901e-3
BE47  7C4CCCCAB7                              FCB     $7C, $4C, $CC, $CA, $B7 ;  4.999999223e-2
BE4C  7EAAAAAAA6                              FCB     $7E, $AA, $AA, $AA, $A6 ; -0.1666666664
BE51  8100000000      fpConst1                FCB     $81, $00, $00, $00, $00 ; 1
BE56  7DA3F2EF44      fpConstMin0_08005       FCB     $7D, $A3, $F2, $EF, $44 ;  -8.0053204787e-02
BE5B  7E1F01A14D                              FCB     $7E, $1F, $01, $A1, $4D ; 0.155279656
BE60  7F616DF43F                              FCB     $7F, $61, $6D, $F4, $3F ; 0.440292008
BE65  7E5C9123AC                              FCB     $7E, $5C, $91, $23, $AC ; 0.215397413
BE6A  7E76B88D1A                              FCB     $7E, $76, $B8, $8D, $1A ; 0.240938382
                      ;                       ;  $BFB0
BE6F  7D1D3EAB2C                              FCB     $7D, $1D, $3E, $AB, $2C ; 7.67796872e-02
BE74  81094181D2                              FCB     $81, $09, $41, $81, $D2 ; 1.07231162
BE79  8074DFBD20                              FCB     $80, $74, $DF, $BD, $20 ; 0.956538983
BE7E  80838B1FB5                              FCB     $80, $83, $8B, $1F, $B5 ; -0.513841612
BE83  7F8259ADAB                              FCB     $7F, $82, $59, $AD, $AB ; -0.254590442
BE88  806D63382C      fpConst0_9273           FCB     $80, $6D, $63, $38, $2C ;  9.2729521822e-01
BE8D  7D11D4B1D1      fpConst0_07121          FCB     $7D, $11, $D4, $B1, $D1 ;  7.1206463996e-02
BE92  7968BC4F59                              FCB     $79, $68, $BC, $4F, $59 ; 7.10252642e-03
BE97  75052C9E39                              FCB     $75, $05, $2C, $9E, $39 ; 2.54009799e-04
BE9C  7B08883BA6                              FCB     $7B, $08, $88, $3B, $A6 ; 1.66665235e-02
BEA1  6C31CFD18C                              FCB     $6C, $31, $CF, $D1, $8C ;  6.6240054064e-07
BEA6  7D2AAAAA89                              FCB     $7D, $2A, $AA, $AA, $89 ;   8.33
BEAB  7FFFFFFFE8                              FCB     $7F, $FF, $FF, $FF, $E8 ;  -0.5
BEB0  8100000000                              FCB     $81, $00, $00, $00, $00 ;   1.0
BEB5  8100000000      fpConst1__2             FCB     $81, $00, $00, $00, $00 ;   1.0
                      
BEBA                  __CODE_END
                      
0146                  __FREESPACE     EQU $C000-__CODE_END
                      
