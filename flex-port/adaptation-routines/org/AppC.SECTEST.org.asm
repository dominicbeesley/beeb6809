	* TEST UTILITY
	*
	*
	*
	*
	* TESTS SINGLE SECTOR READ AND WRITE ROUTINES.
	* PROGRAM PROMPTS USER FOR FUNCTION (F?) TO WHICH THE
	* USER CAN RESPOND 'R' (READ) OR #W@ (WRITE). THEN IT
	* PROMPTS FOR SINGLE DIGIT DRIVE NUMBER (D?), TWO DIGIT
	* HEX TRACK NUMBER (T?) AND TWO DIGIT HEX SECTOR
	* NUMBER (S?). AFTER PERFORMING THE FUNCTION, TEST
	* REPEATS THE PROMPTING FOR ANOTHER FUNCTION.
	*
	* ASSUMES THE CONSOLE I/O PACKAGE DRIVERS ARE RESIDENT.
	* BEGIN EXECUTION BY JUMPING TO $0100.
	*
	* EQUATES
INCH		EQU	$D3FB
OUTCH		EQU	$D3F9
TINIT		EQU	$D3F5
MONITR		EQU	$D3F3
STACK		EQU	$C07F
		EQU	$C840
BUFFER		EQU	$1000
READ		EQU	$DE00
WRITE		EQU	$DE03
DRIVE		EQU	$DE0C
	* TEMPORARY STORAGE
		ORG	$0020
COMMND		RMB	1
TRACK		RMB	1
SECTOR		RMB	1
	* START OF PROGRAM
		ORG	$0100
TEST		LDS	#STACK				; SETUP STACK
		JSR	[TINIT]				; INITIALIZE TERMINAL
error ;;;; !!!! ;;;; COPYRIGHT Â© 1980 by
error ;;;; !!!! ;;;; Technical Systems Consultants, Inc.
error ;;;; !!!! ;;;; 111 Providence Road
error ;;;; !!!! ;;;; Chapel Hill, North Carolina 27514
	* GET COMMAND
TEST1		LDS	#STACK				; RESET STACK
		BSR	PCRLF
		LDA	#'F				; PROMPT FOR FUNCTION
		BSR	PROMPT
		BSR	INPUT				; GET RESPONSE
		CMPA	#'R				; READ COMMAND?
		BEQ	TEST2
		CMPA	#'W				; WRITE COMMAND?
		BEQ	TEST2
		JMP	[MONITR]				; EXIT THE PROGRAM
TEST2		STA	COMMND				; SAVE COMMAND
		LDA	#'D				; PROMPT FOR DRIVE
		BSR	PROMPT
		JSR	INHEX				; GET RESPONSE
		CMPA	#4				; ENSURE 0 TO 3
		BHS	TEST1
		STA	FCB+3				; SAVE IT
		LDA	#'T				; PROMPT FOR TRACK
		BSR	HPRMPT				; GET HEX PROMPT
		STA	TRACK
		LDA	#'S				; PROMPT FOR SECTOR
		BSR	HPRMPT				; GET HEX RESPONSE
		STA	SECTOR				; SAVE IT
		BSR	PCRLF				; DO LINE FEED
	* GOT COMMAND, NOW DO IT
		LDA	COMMND				; GET COMMAND
		CMPA	#'W				; A WRITE COMMAND?
		BNE	DOREAD				; IF NOT, ITS A READ
		BSR	SELECT				; SELECT DRIVE
		LDX	#BUFFER				; POINT TO BUFFER
		LDD	TRACK				; POINT TO TRACK & SECTOR
		JSR	WRITE				; WRITE THE DATA
		BNE	ERROR
		BSR	PCRLF
		LDA	#'O				; PRINT OK
		BSR	OUTPUT
		LDA	#'K
		BSR	OUTPUT
		BRA	TEST1				; DO AGAIN
	* PROMPT ROUTINES
PROMPT		BSR	PCRLF				; DO LINE FEED
		BSR	OUTPUT				; OUTPUT PROMPT LETTER
		BRA	QUEST				; PRINT QUESTION MARK
HPRMPT		BSR	PROMPT				; DO PROMPT
		BRA	INBYTE				; GET HEX BYTE
	* CARRIAGE RETURN LINE FEED ROUTINE
PCRLF		PSHS	A				; SAVE A
		LDA	#$0D				; RETURN
		BSR	OUTPUT
		LDA	#$0A				; LINE FEED
		BSR	OUTPUT
		PULS	A				; RESTORE A
RET		RTS
	* I/O ROUTINES
INPUT		JMP	[INCH]
QUEST		LDA	#'?
OUTPUT		JMP	[OUTCH]
	* DRIVE SELECT ROUTINE
SELECT		LDX	#FCB
		JSR	DRIVE
		BEQ	RET				; RETURN IF NO ERROR
	* DRIVER ERROR
ERROR		BSR	PCRLF
		LDA	#'E
		BSR	OUTPUT
		LDA	#'=
		BSR	OUTPUT
		TFR	B,A				; GET ERROR CODE
		BSR	OUTHEX
		LBRA	TEST1				; START OVER
	* DO SINGLE SECTOR READ
DOREAD		BSR	SELECT				; SELECT DRIVE
		LDX	#BUFFER				; POINT TO BUFFER
		LDD	TRACK				; POINT TO TRACK & SECTOR
		JSR	READ				; READ THE DATA
		BNE	ERROR
	* DUMP DATA TO CONSOLE
		LDX	#BUFFER
		LDA	#16				; NO OF LINES
DUMPI		PSHS	A				; SAVE NO OF LINES
		BSR	PCRLF
		LDB	#16				; NO OF BYTES
DUMP2		LDA	0,X+				; GET A BYTE
		BSR	OUTHEX				; OUTPUT IT
error ;;;; !!!! ;;;; 01B1 5A DECB DONE WITH LINE?
		BNE	DUMP2
		PULS	A				; GET NO OF LINES
error ;;;; !!!! ;;;; 01B6 4A DECA DONE WITH DUMP
		BNE	DUMP1				; LOOP IF NOT
		LBRA	TEST1				; GET NEXT COMMAND
	* INPUT HEX BYTE ROUTINE
INBYTE		BSR	INHEX
		ASLA
		ASLA
		ASLA
		ASLA
		PSHS	A
		BSR	INHEX
		ADDA	0,S+
RETN		RTS
INHEX		BSR	INPUT
		SUBA	#$47
		BPL	INERR
		ADDA	#6
		BPL	INH2
		ADDA	#7
		BPL	INERR
INH2		ADDA	#10
		BPL	RETN
INERR		BSR	QUEST				; PRINT A QUESTION MARK
		LBRA	TEST1				; GO START OVER
	* OUTPUT HEX BYTE (FOLLOWED BY SPACE)
OUTHEX		PSHS	A
		LSRA
		LSRA
		LSRA
		LSRA
		BSR	OUTHR
		PULS	A
		BSR	OUTHR
		LDA	#$20
		BRA	OUTPUT
OUTHR		ANDA	#$0F
		ADDA	#$90
		DAA
		ADCA	#$40
		DAA
		LBRA	OUTPUT
error ;;;; !!!! ;;;; END
