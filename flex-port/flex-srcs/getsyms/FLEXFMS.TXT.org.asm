		; NAM  FLEX9 FILE MANAGER
		; OPT  PAG
	**********************************
	*
	*  TSC FLEX FILE MANAGER
	*  VERSION 3.01
	*
	**********************************
TSTSET		EQU	$C709				; TEST FLAG SET IF CLEAR
FLGCLR		EQU	$C70C				; CLEAR FLAG
MONTH		EQU	$CC0E
YEAR		EQU	$CC10
TASK1		EQU	$CCFC				; BACKGROUND STATUS FLAG
		; SPC  1
		ORG	$D400
		JMP	INIT
		JMP	CLOSE
		JMP	FMCALL
		; SPC  1
D0DIR		FDB	5				; DRIVE ZERO DIRECTORY POINTER
D1DIR		FDB	5
D2DIR		FDB	5
D3DIR		FDB	5
BASPTR		RMB	2				; FCB LIST BASE POINTER
CURFCB		RMB	2				; CURRENT FCB
RANDX		RMB	2				; RANDOM INDEX
ERR1		RMB	1				; ERROR COUNT AND TEMP
ERR2		RMB	1
RDPROT		RMB	1				; READ PROT FLAG
LNKPTR		RMB	2				; CURRENT LINKED LIST
LNKLIS		RMB	$18				; FOUR LISTS @6 BYTES EACH
		; SPC  1
		ORG	$D435
VFLAG		FCB	$FF				; VERIFY FLAG
		; SPC  1
	*INITALIZE FILE MANAGER
INIT		JSR	DRINIT				; INITALIZE DISK DRIVERS
		LDX	#BASPTR
		LDB	#$09				; SET BYTE COUNT
		BSR	INIT2				; CLEAR FMS STORAGE
		CLR	RDPROT				; TURN OFF READ PROT
INIT1		LDX	#LNKPTR				; CLEAR SECTOR LISTS
		LDB	#$1A
INIT2		CLR	,X+
		DECB
		BNE	INIT2
		JMP	FLGCLR				; CLEAR FMS INUSE FLAG
		; SPC  1
	*CLOSE ALL OPEN FILES
CLOSE		JSR	TSTSET				; SET INUSE FLAG
CLOS1		LDX	BASPTR				; GET FCB POINTER
		BEQ	INIT1				; NOTHING OPEN?
		LEAX	-$1C,X				; CORRECT OFFSET
		STX	CURFCB				; SAVE AS CURRENT FCB
		PSHS	Y				; SAVE Y
		JSR	CLOSE1				; CLOSE FILE
		PULS	Y
		BCC	CLOS1				; NO ERROR?
		LDX	CURFCB
		CLR	$02,X				; MARK AS INACTIVE
		JSR	FLGCLR				; CLEAR FMS IN USE FLAG
		LDB	#$FF				; SET NOT EQUAL STATUS
		RTS
		; SPC  1
	*CALL FILE MANAGER
FMCALL		TST	TASK1				; BACKGROUND ACTIVE?
		BEQ	CALL1				; NO THEN BRANCH
		JSR	TSTSET				; WAIT FOR FMS NOT BUSY
CALL1		PSHS	Y,B
		STX	CURFCB				; SAVE FCB POINTER
		CLR	$01,X				; CLEAR ERROR BYTE
		LDB	,X				; GET FUNCTION CODE
		BNE	CALL5				; LOOK IT UP
		LDB	$02,X				; GET FILE STATUS
		BEQ	CALL4				; BAD STATUS?
		CMPB	#$02				; OPEN FOR WRITE?
		BEQ	CALL3
		JSR	SPCEXP				; GET NEXT CHAR. FROM DISK
CALL2		LDX	CURFCB
		BCS	CALL7				; ERROR?
		TST	TASK1				; BACKGROUND ACTIVE?
		BNE	CALL8				; THEN CLEAR FLAG
		CLRB
		PULS	Y,B
		RTS
CALL3		JSR	SPCCOM				; SEND CHAR. TO DISK
		BRA	CALL2
CALL4		LDB	#$12				; FILE STATUS ERROR
		BRA	CALL7
CALL5		CMPB	#$16				; FUNCTION IN RANGE?
		BLS	CALL6
		LDB	#$01				; ILLEGAL FUNCTION
		BRA	CALL7
CALL6		DECB				;  CORRECT FOR FUNCTION 0
		ASLB				;  MULT. BY 2
		LDX	#TABLE
		JSR	[B,X]				; DO FUNCTION
		LDX	CURFCB
		BCC	CALL8				; NO ERROR?
CALL7		STB	$01,X				; SET ERROR
CALL8		JSR	FLGCLR				; CLEAR INUSE FLAG
		TST	$01,X				; ERROR?
		PULS	Y,B
		RTS
		; SPC  1
	*FUNCTION LOOKUP TABLE
TABLE		FDB	OREAD
		FDB	OWRITE
		FDB	UPDATE
		FDB	CLOSE1
		FDB	REWIND
		FDB	ODIR
		FDB	GETREC
		FDB	PUTREC
		FDB	SREAD
		FDB	SWRITE
		FDB	PUTDIR
		FDB	DELETE
		FDB	RENAME
		FDB	TSTER2
		FDB	NXTSCT
		FDB	OINFO
		FDB	GBYTE
		FDB	PBYTE
		FDB	EXPAND
		FDB	RDYCK
		FDB	POSITN
		FDB	BACKUP
		; SPC  1
LNKFCB		BSR	FINDFB				; SEARCH FOR FCB
		BNE	LINK				; NOT FOUND?
		LDB	#$02				; ERROR FCB IN USE
		ORCC	#$01
		RTS
		; SPC  1
LINK		STD	,X				; LINK FCB INTO LIST
		LDX	,X
		CLR	,X
		CLR	$01,X
		RTS
		; SPC  1
KILFCB		BSR	FINDFB				; SEARCH FOR FCB
		BEQ	UNLINK				; FCB FOUND?
		LDB	#$0D				; ERROR ILLEGAL FCB
		ORCC	#$01
		RTS
		; SPC  1
UNLINK		LDD	[,X]				; DELETE FCB FROM LIST
		STD	,X
		ANDCC	#$FE
		RTS
		; SPC  1
FINDFB		LDD	CURFCB				; POINT TO CURRENT FCB
		ADDD	#$001C				; ADD LINK OFFSET
		LDX	#BASPTR				; POINT TO FIRST FCB
FIND1		LDY	,X
		BNE	FIND2				; LAST ONE?
		ANDCC	#$FB
		RTS
FIND2		CMPD	,X				; SAME AS CURRENT?
		BNE	FIND3
		RTS
FIND3		LDX	,X				; NEXT FCB
		BRA	FIND1
		; SPC  1
CLRFCB		LDX	CURFCB
		CLRA
		CLRB				;  BYTE COUNT =256
		BSR	CLRFB1				; CLEAR FCB
		LDB	#$2F				; CLEAR MORE
CLRFB1		STA	$11,X
		LEAX	$01,X
		DECB
		BNE	CLRFB1
		RTS
		; SPC  1
MOVNAM		LDX	CURFCB				; MOVE FILE NAME TO TEMP
		LDB	#$0B
MOVNM1		LDA	$04,X
		STA	$24,X
		LEAX	$01,X
		DECB
		BNE	MOVNM1
		RTS
		; SPC  1
MATCH		LDX	CURFCB				; CHECK FILE NAME FOR MATCH
		LDB	#$0B
MATCH1		LDA	$04,X
		PSHS	A
		LDA	$24,X
		CMPA	,S+
		BNE	MATCH2
		LEAX	$01,X
		DECB
		BNE	MATCH1
MATCH2		RTS
		; SPC  1
	*GET RANDOM BYTE FROM SECTOR
GBYTE		LDX	CURFCB				; GET RANDOM BYTE
		LDB	$02,X				; GET FILE STATUS
error ;;;; !!!! ;;;;  LSRB
		BCC	ERR12				; FILE STATUS ERROR?
		LDB	$23,X				; GET BYTE INDEX
		JMP	GETB1				; GET BYTE
		; SPC  1
PUTBYT		LDX	CURFCB
		LDB	$22,X				; GET DATA INDEX
		INC	$22,X
		ABX
		STA	$40,X				; PUT BYTE IN SECTOR BUFF
		INCB
		BNE	PBYTE1				; EXIT
		ORCC	#$01				; OVERFLOW
		RTS
		; SPC  1
	*PUT RANDOM BYTE IN SECTOR
PBYTE		LDX	CURFCB
		LDB	$02,X				; GET FILE STATUS
		ANDB	#$03				; MASK WRITE FLAG
		CMPB	#$03				; OPEN FOR UPDATE?
		BNE	ERR12				; OOPS!
		ORB	#$80				; SET BYTE WRITTEN
		STB	$02,X
		LDB	$0F,X				; GET PROT BYTE
		BITB	#$80				; WRITE PROT?
		BNE	PBYTE2
		LDB	$23,X				; GET INDEX POINTER
		ABX
		STA	$40,X				; PUT BYTE
PBYTE1		ANDCC	#$FE
		RTS
PBYTE2		LDB	#$0B				; ERROR PROTECTED FILE
		ORCC	#$01
		RTS
		; SPC  1
	*GET SEQUENTIAL CHARACTER FROM FILE
SPCEXP		LDA	$3B,X				; GET SPACE COUNT
		BMI	GETBYT				; SPACE COMP. OFF?
		BEQ	SETEXP				; SPACE COUNT ZERO?
		DEC	$3B,X				; DEC SPACE COUNT
		LDA	#$20				; SPACE
		BRA	SETXP2				; EXIT
		; SPC  1
SETEXP		BSR	GETBYT				; GET NEXT BYTE FROM DISK
		BCS	SETXP3				; ERROR?
		CMPA	#$18
		BHI	SETXP2				; EXIT WITH CHAR
		BEQ	SETEXP				; IGNORE NULL
		CMPA	#$09				; H TAB?
		BNE	SETXP1
		BSR	GETBYT				; GET SPACE COUNT
		BCS	SETXP3				; ERROR?
		LDX	CURFCB
		STA	$3B,X				; PUT COUNT IN FCB
		BRA	SPCEXP
SETXP1		TSTA
		BEQ	SETEXP
SETXP2		ANDCC	#$FE
SETXP3		RTS
		; SPC  1
	*REWIND FILE TO BEGINNING
REWIND		JSR	TSTUPD				; WRITE ANY NEW DATA
		BCS	ERR12				; ERROR?
		BITA	#$01				; READ OR UPDATE?
		BEQ	ERR12				; ERROR FMS STATUS
		STA	,X				; FAKE FUNCTION
		JMP	OREAD1				; REOPEN
ERR12		LDB	#$12
		ORCC	#$01
		RTS
		; SPC  1
GETBYT		LDX	CURFCB
		LDB	$22,X				; GET INDEX
		BEQ	GETB2				; BUFFER EMPTY?
		INC	$22,X
GETB1		ABX
		LDA	$40,X				; GET DATA BYTE
		ANDCC	#$FE
		RTS
GETB2		BSR	RDNXT				; READ NEXT SECTOR
		BCC	GETBYT
		RTS
		; SPC  1
RDNXT		LDX	CURFCB
		LDD	$40,X				; GET TRACK-SECTOR
		INC	$21,X				; BUMP RECORD COUNT
		BNE	RDNX1
		INC	$20,X
RDNX1		CMPD	#$0000				; LAST SECTOR?
		BEQ	RDNX4
RDNXT2		STD	$1E,X				; STORE TRACK-SECTOR
		PSHS	A
		LDA	#$04
		STA	$22,X				; SET INDEX TO START OF DATA
		PULS	A
		BSR	SREAD				; READ SECTOR
		BCC	RDNX6				; ERROR?
		BITB	#$80				; MASK READY BIT
		BEQ	RDNX3				; OTHER ERROR?
		LDB	#$10				; ERROR NOT READY
		BRA	RDNX5
RDNX3		LDB	#$09				; READ ERROR
		BRA	RDNX5
RDNX4		LDB	#$08				; ERROR EOF
RDNX5		ORCC	#$01
RDNX6		RTS
		; SPC  1
	*SINGLE SECTOR READ
SREAD		BSR	CLRERR				; CLEAR ERROR COUNT
		LDX	CURFCB
		JSR	SELECT				; SELECT DRIVE
		BCS	SREAD3				; ERROR?
SREAD1		BSR	BUFSET				; SET BUFFER POINTER
		JSR	READ				; READ SECTOR
		BNE	SREAD2				; ERROR?
		ANDCC	#$FE
		RTS
SREAD2		PSHS	B
		BSR	TSTERR				; TEST ERROR
		PULS	B
		BCC	SREAD1				; RETRY READ?
SREAD3		RTS
		; SPC  1
BUFSET		LDX	CURFCB
		LDD	$1E,X				; GET TRACK-SECTOR
		LEAX	$40,X				; POINT TO SECTOR BUFFER
		RTS
		; SPC  1
CLRERR		CLRA				;  CLEAR ERROR COUNT
		STA	ERR1
		STA	ERR2
		RTS
		; SPC  1
TSTERR		BITB	#$10				; RECORD NOT FOUND?
		BNE	TSTER1				; OTHER ERROR?
		BITB	#$80				; NOT READY?
		BNE	TSTER3
		LDB	ERR1
		INCB
		CMPB	#$07
		BEQ	TSTER1
		STB	ERR1
		BRA	TSTER2
TSTER1		CLR	ERR1
		LDB	ERR2
		INCB
		CMPB	#$04
		BEQ	TSTER3
		STB	ERR2
		LDX	CURFCB
		JSR	RESTOR
TSTER2		ANDCC	#$FE				; RETRY
		RTS
TSTER3		ORCC	#$01				; DONT RETRY
		RTS
		; SPC  1
	*SINGLE SECTOR WRITE
SWRITE		BSR	CLRERR				; CLEAR ERROR COUNT
		LDX	CURFCB
		JSR	SELECT				; SELECT DRIVE
		BCS	SWRIT3				; ERROR?
SWRIT1		LDX	CURFCB
		BSR	BUFSET				; SET BUFFER POINTER
		JSR	WRITE				; WRITE SECTOR
		BNE	SWRIT2				; ERROR?
		LDA	VFLAG
		BEQ	PRES3				; VERIFY OFF?
		JSR	VERIFY
		BEQ	PRES3				; EXIT
SWRIT2		BITB	#$40				; WRITE PROT.?
		BNE	SWRIT4
		PSHS	B
		BSR	TSTERR
		PULS	B
		BCC	SWRIT1				; RETRY?
SWRIT3		RTS
		LDB	#$20				; SET ERROR CODE
SWRIT4		ORCC	#$01
		RTS
		; SPC  1
	*SEQUENTIAL CHARACTER WRITE
SPCCOM		LDX	CURFCB
		LDB	$3B,X				; SPACE COUNT
		BMI	WRBYTE				; SPC COMP.OFF?
		CMPA	#$20				; IS CHAR A SPACE?
		BNE	PRES2
		INCB				;  BUMP SPACE COUNT
		STB	$3B,X
		CMPB	#$7F				; OVERFLOW?
		BNE	PRES3				; EXIT
		BRA	PRES4
PRES1		BSR	PRES4
		BCC	SPCCOM
		RTS
PRES2		TSTB				;  SPACE COUNT ZERO?
		BEQ	WRBYTE
		BRA	PRES1
PRES3		ANDCC	#$FE
		RTS
PRES4		PSHS	A
		CMPB	#$01				; ONE SPACE?
		BNE	PRES5
		LDA	#$20				; SEND A SPACE
		BRA	PRES6
PRES5		LDA	#$09				; SEND H TAB
		BSR	WRBYTE
		PULS	A
		BCS	PRES7
		PSHS	A
		LDX	CURFCB
		LDA	$3B,X				; GET SPACE COUNT
PRES6		CLR	$3B,X				; CLEAR COUNT
		BSR	WRBYTE				; WRITE COUNT
		PULS	A
PRES7		RTS
		; SPC  1
WRBYTE		LDX	CURFCB
		LDB	$02,X				; GET STATUS
		CMPB	#$02				; OPEN FOR WRITE?
		LBNE	ERR12
		LDB	$22,X				; GET INDEX
		CMPB	#$04				; EMPTY BUFFER?
		BNE	BYTE1
		PSHS	A
		BSR	LNKNXT				; SET FORWARD LINK
		PULS	A
		BCS	BYTE2				; ERROR?
BYTE1		JSR	PUTBYT				; WRITE BYTE
		BCC	BYTE2
		LDB	#$04				; POINT TO START OF BUFF
		LDX	CURFCB
		STB	$22,X
		ANDCC	#$FE
BYTE2		RTS
		; SPC  1
WRTNXT		LDX	CURFCB
		CLRA
		CLRB
		STD	$20,X				; CLEAR RECORD COUNT
		STD	$42,X
		BRA	LNKNX2
		; SPC  1
LNKNXT		LDB	$12,X				; GET FILE START ADDR.
		BNE	LNKNX2				; NOT FIRST SECTOR?
		LDB	$17,X				; GET SECTOR MAP
		BEQ	RDLINK				; NOT RANDOM?
		CLR	$17,X
		BSR	RDLINK				; GET SECTOR LINK
		BCS	LNKNX1				; EXIT
		BSR	WRTNXT				; RESERVE SECTOR
		BCS	LNKNX1				; EXIT
		BSR	WRTNXT				; RESERVE SECTOR
		BCS	LNKNX1				; EXIT
		LDX	CURFCB
		LDB	#$02
		STB	$17,X				; SET SECTOR MAP
		LDD	$11,X				; POINT TO FIRST SECTOR
		JMP	BLDN4				; BUILD INDEX
		; SPC  1
LNKNX2		BSR	GETLNK				; GET LINK TO NEXT
		LDX	CURFCB
		STD	$40,X				; PUT IN SECTOR BUFFER
		JSR	SWRITE				; WRITE SECTOR
		BCC	RDLINK				; READ NEXT LINK
		JMP	WTRY1				; TRY TO RECOVER
		; SPC  1
GETLNK		BSR	GETPTR				; POINT TO FREE LIST
		LDD	,X				; GET TRACK-SECTOR
LNKNX1		RTS
		; SPC  1
GETPTR		LDX	CURFCB
		LDB	$03,X				; GET DRIVE NUMB.
		LDA	#$06				; TABLE ENTRY SIZE
		MUL
		LDX	#LNKLIS				; POINT TO TABLE BEGIN
		ABX				;  INDEX INTO TABLE
		STX	LNKPTR				; SAVE POINTER
		TST	,X
		RTS
		; SPC  1
RDLINK		BSR	GETLNK				; GET SECTOR LINK
		BNE	LINK2				; OUT OF DISK SPACE?
		LDB	#$07				; ERROR OUT OF SPACE
LINK1		ORCC	#$01
		RTS
LINK2		LDX	CURFCB
		STD	$13,X				; SET LAST SECTOR
		TST	$12,X				; FIRST SECTOR?
		BNE	LINK3
		STD	$11,X				; SET FIRST SECTOR
LINK3		INC	$16,X				; INC RECORD COUNT
		BNE	LINK4
		INC	$15,X
LINK4		TST	$17,X				; RANDOM FILE?
		BEQ	LINK5
		JSR	BLDNDX				; BUILD INDEX
		BCS	LINK1
		LDX	CURFCB
		LDD	$13,X
LINK5		JSR	RDNXT2				; READ NEXT FOR LINK
		BCS	LINK1				; ERROR?
		LDX	CURFCB
		LDD	$40,X				; GET LINK
		PSHS	B,A
		BSR	GETPTR
		PULS	B,A
		STD	,X				; SAVE LINK
		BNE	LINK6				; END OF DISK?
		CLR	$02,X
		CLR	$03,X
		CLR	$04,X
		CLR	$05,X
		BRA	LINK7
LINK6		LDY	$04,X				; DEC SECTOR REMAINING
		LEAY	-$01,Y
		STY	$04,X
LINK7		CLRA
		LDX	CURFCB
		INC	$21,X				; INC RECORD NUMB.
		BNE	LINK8
		INC	$20,X
LINK8		CLRB				;  COUNT=256
LINK9		STA	$40,X				; CLEAR SECTOR BUFF.
		LEAX	$01,X
		DECB
		BNE	LINK9
		LDX	CURFCB
		LDD	$20,X				; GET RECORD NUMB.
		STD	$42,X				; PUT IN BUFF.
		ANDCC	#$FE
		RTS
		; SPC  1
	* OPEN SYSTEM INFO SECTOR
OINFO		CLRB				;  TRACK ZERO
		PSHS	B
		LDB	#$03				; SECTOR 3
		BRA	ODIR1
		; SPC  1
		; SPC  1
	*OPEN DIRECTORY
ODIR		LDX	CURFCB				; POINT TO CURRENT FILE BLOCK
		LDB	3,X				; GET DRIVE NUMB.
		ASLB				;  MULT BY TWO
		LDX	#D0DIR				; POINT TO DIRECTORY TABLE
		LDD	B,X				; GET DIR START FOR THIS DRIVE
		PSHS	A
ODIR1		LDX	CURFCB
		STB	$41,X				; SET SECTOR
		PULS	B
		STB	$40,X				; SET TRACK
		CLRB
		STB	$22,X				; COUNT=0
		RTS
		; SPC  1
	*GET DIRECTORY ENTRY
GETREC		LDX	CURFCB
		LDB	$22,X				; GET RECORD COUNT
		BNE	GREC2				; FIRST RECORD?
		JSR	RDNXT				; READ SECTOR
		BCS	GREC4				; ERROR?
		LDX	CURFCB
GREC1		LDA	#$10				; DIR STARTS AT $10
		STA	$22,X
		LDD	$1E,X				; GET CURRENT POSITION
		STD	$2F,X				; SET CURRENT DIR. POS.
GREC2		LDA	$22,X
		STA	$31,X
		LDB	#$18				; BYTE COUNT
GREC3		PSHS	X,B
		JSR	GETBYT				; GET CHAR FROM DIR.
		PULS	X,B
		STA	$04,X				; STORE CHAR IN FCB
		LEAX	$01,X
		DECB				;  DONE?
		BNE	GREC3
		ANDCC	#$FE
GREC4		RTS
		; SPC  1
	*WRITE DIRECTORY ENTRY
PUTREC		LDX	CURFCB
		LDA	$31,X				; GET RECORD COUNT
		STA	$22,X				; PUT IN INDEX
		LDB	#$18				; BYTE COUNT
PREC1		PSHS	X,B
		LDA	$04,X				; GET CHAR
		JSR	WRBYTE				; PUT IN DIR
		PULS	X,B
		LEAX	$01,X
		DECB				;  DONE?
		BNE	PREC1
		JMP	SWRITE				; WRITE SECTOR
		; SPC  1
SCHDIR		LDX	CURFCB
		TST	3,X				; CHECK IF DRIVE NUMBER IS REAL
		BPL	SRCHIT
SRCH3		JSR	RDYCK
		BCS	SCHIT6
		BSR	SRCHIT
		BLS	SCHIT2
		JSR	RSTNAM
		BRA	SRCH3
		; SPC  1
SRCHIT		LDX	CURFCB
		CLR	RDPROT
		JSR	MOVNAM				; SAVE NAME IN SCRATCH
		JSR	ODIR				; OPEN DIRECTORY
SCHIT1		JSR	GETREC				; GET RECORD
		BCC	SCHIT3				; NO ERROR?
		CMPB	#$08				; END OF FILE?
		BEQ	SCHIT6
		ORCC	#$01
SCHIT2		RTS
SCHIT3		LDX	CURFCB
		LDA	$04,X				; GET FIRST CHAR IN NAME
		BEQ	SCHIT5				; ZERO?
		BPL	SCHIT4				; NOT DELETED?
		BSR	SETPTS				; MARK EMPTY DIR SLOT
SCHIT4		JSR	MATCH				; NAMES MATCH?
		BNE	SCHIT1				; NEXT NAME
		ANDCC	#$FE				; NAME FOUND
		RTS
SCHIT5		BSR	SETPTS				; SET POINTER TO EMPTY SLOT
SCHIT6		ANDCC	#$FB
		ANDCC	#$FE
		RTS
		; SPC  1
SETPTS		LDA	$33,X
		BNE	SETP1
		LDD	$2F,X
		STD	$32,X
		LDA	$31,X
		STA	$34,X
SETP1		RTS
		; SPC  1
GETIFO		JSR	GETPTR				; POINT TO LINK LIST
		BNE	GIFO2
		BSR	RDINFO				; READ SYS INFO
		BCS	GIFO3				; ERROR?
		LDB	#$06				; BYTE COUNT
		LDY	CURFCB
		LDX	LNKPTR
GIFO1		LDA	$5D,Y				; MOVE BUFF TO LIST
		LEAY	$01,Y
		STA	,X+
		DECB
		BNE	GIFO1
GIFO2		ANDCC	#$FE
GIFO3		RTS
		; SPC  1
RDINFO		JSR	OINFO				; OPEN T-0 S-3
		JSR	RDNXT				; READ SECTOR
		BCS	RDIFO1				; ERROR?
		LDX	CURFCB
		LDB	#$10				; SET DATA INDEX
		STB	$22,X
RDIFO1		RTS
		; SPC  1
WRINFO		JSR	GETPTR				; POINT TO LINK LIST
		BSR	RDINFO				; READ IT
		BCS	RDIFO1				; ERROR?
		LDB	#$06				; BYTE COUNT
		LDY	CURFCB
		LDX	LNKPTR
WRIFO1		LDA	,X+				; MOVE LIST TO BUFF
		STA	$5D,Y
		LEAY	$01,Y
		DECB
		BNE	WRIFO1
		JSR	SWRITE				; WRITE SECTOR
		BCC	RDIFO1				; NO ERROR?
		JMP	WTRY1				; TRY AGAIN
		; SPC  1
PUTDIR		LDX	CURFCB
		LDA	#$02				; SET OPEN FOR WRITE
		STA	$02,X
		LDD	$2F,X				; SET TO DIR POINTER
		STD	$1E,X
		JSR	SREAD				; READ DIR
		BCS	PDIR1
		JSR	PUTREC				; MOVE FCB TO DIR
		BCC	PDIR2
		JMP	WTRY1
PDIR1		LDB	#$0A
PDIR2		RTS
		; SPC  1
	*OPEN FILE FOR READ
OREAD		JSR	LNKFCB				; ADD FCB TO ACTIVE LIST
		BCS	OREAD4				; ERROR?
		JSR	SCHDIR				; FIND NAME IN DIR
		BCS	OREAD4				; ERROR?
		BNE	NOTOPN				; ERROR NOT FOUND?
		LDX	CURFCB
		TST	RDPROT				; TEST FOR PROT?
		BEQ	OREAD1				; NO?
		LDA	$0F,X				; PROT FLAG
		BITA	#$20
		BNE	OREAD5				; FILE READ PROTECTED?
OREAD1		JSR	GSMAX				; GET TRACK SIZE
		BCS	NOTOP1				; ERROR?
		LDD	$11,X				; GET FIRST SECTOR
		STD	$40,X
		JSR	SETSTA				; SET READ STATUS
		LDB	$17,X				; RANDOM?
		BEQ	OREAD3
OREAD2		PSHS	B
		JSR	RDNXT				; READ INDEX
		PULS	B
		BCS	OREAD4				; ERROR?
		DECB
		BNE	OREAD2				; MORE INDEX LEFT?
		LDX	CURFCB
		CLRB
		STB	$22,X				; CLEAR RECORD COUNT
OREAD3		ANDCC	#$FE
OREAD4		RTS
OREAD5		LDB	#$11				; ERROR PROTECTED
		BRA	NOTOP1
		; SPC  1
NOTOPN		LDB	#$04				; ERROR NOT FOUND
NOTOP1		PSHS	B
		JSR	KILFCB
		PULS	B
		ORCC	#$01
		RTS
		; SPC  1
	*OPEN FILE FOR WRITE
OWRITE		LDX	CURFCB
		TST	$03,X
		BPL	OPNWR1				; REAL DRIVE NUMB.?
		JSR	RDYCK				; SELECT NEXT READY DRV.
		BCC	OPNWR1				; DRIVE FOUND
		LDB	#$10				; ERROR DRIVE NOT READY
		RTS
OPNWR1		JSR	LNKFCB
		BCS	NOTOP1
		JSR	CLRFCB				; CLEAR FCB
		JSR	GETIFO				; GET SYS INFO
		BCS	NOTOP1
		JSR	SCHDIR				; SEARCH DIR
		BCS	NOTOP1				; ERROR?
		BNE	OPNWR2				; FILE NOT FOUND?
		LDB	#$03				; ERROR FILE EXISTS
		BRA	NOTOP1
OPNWR2		JSR	GSMAX				; GET TRACK SIZE
		BCS	NOTOP1
		LDX	CURFCB
		LDB	#$0A
OPNWR3		CLR	$0F,X				; CLEAR FIRST-LAST
		LEAX	$01,X
		DECB
		BNE	OPNWR3
		LDX	CURFCB
		LDD	$32,X				; GET DIR POINTER
		BEQ	EXPDIR				; OUT OF SPACE?
		STD	$2F,X
		LDA	$34,X
		STA	$31,X
		LDD	MONTH				; SET DATE
		STD	$19,X
		LDA	YEAR
		STA	$1B,X
		JSR	RSTNAM
		JSR	PUTDIR				; WRITE TO DIR
		BCS	NOTOP1				; ERROR?
		BSR	SETSTA				; SET WRITE STATUS
		LDA	#$04
		STA	$22,X				; SET DATA POINTER
		ANDCC	#$FE
		RTS
EXPDIR		LDX	CURFCB
		CLR	$17,X				; FORCE NOT RANDOM
		INC	$12,X				; BUMP RECORD COUNT
		LDD	$2F,X				; POINT TO LAST OF DIR
		JSR	RDNXT2				; READ IT
		BCS	EXPDR1				; ERROR?
		JSR	LNKNX2				; SET FORWARD LINK
		BCS	EXPDR1
		JSR	SWRITE				; WRITE SECTOR
		BCC	EXPDR2
		JSR	WTRY1				; RETRY ERROR
EXPDR1		JMP	NOTOP1
EXPDR2		LDX	CURFCB
		LDD	$1E,X
		STD	$32,X
		LDA	#$10
		STA	$34,X
		JSR	WRINFO				; UPDATE SYS INFO
		BCS	EXPDR1
		BRA	OPNWR2				; FINISH OPEN
		; SPC  1
SETSTA		LDX	CURFCB
		LDA	,X				; GET FUNCTION CODE
		STA	$02,X				; SAVE AS STATUS
		CLR	,X				; CLEAR FUNCTION
		CLR	$3B,X				; CLEAR SPACE COUNT
		CLRA
		STA	$22,X				; CLEAR DATA INDEX
		RTS
		; SPC  1
	*MOVE FILE TO NEXT SECTOR
NXTSCT		BSR	TSTUPD				; WRITE NEW DATA
		BCS	NXTS1
		CLR	,X				; CLEAR FUNCTION
		LSRA				;  TEST STATUS
		LBCS	RDNXT				; READ NEXT SECTOR
		LDB	#$04				; SET DATA INDEX
		STB	$22,X
		ANDCC	#$FE
NXTS1		RTS
		; SPC  1
WRUPDT		LDX	CURFCB
		LDA	$02,X				; GET STATUS
		CMPA	#$83				; DATA WRITTEN?
		BNE	WRUP2
		LDA	#$03				; CLEAR DATA FLAG
		STA	$02,X
WRUP1		JSR	SWRITE				; WRITE SECTOR
		LBCS	WTRY1				; ERROR RETRY
WRUP2		ANDCC	#$FE
		RTS
		; SPC  1
TSTUPD		BSR	WRUPDT				; WRITE IF NECESSARY
		BCS	TSTUP1
		LDX	CURFCB
		LDA	$02,X				; GET STATUS
		CMPA	#$03				; OPEN FOR UPDATE?
		BLS	WRUP2
		LDB	#$12				; ERROR FILE STATUS
		ORCC	#$01
TSTUP1		RTS
		; SPC  1
	*CLOSE FILE
CLOSE1		BSR	TSTUPD				; WRITE IF NECESSARY
		BCS	CLSE7
		CMPA	#$02				; OPEN FOR WRITE?
		BEQ	CLSE3
CLSE2		LDX	CURFCB
		CLR	$02,X				; SET STATUS NOT OPEN
		JMP	KILFCB				; UNLINK FCB
CLSE3		LDA	$12,X				; ANY DATA IN FILE?
		BNE	CLSE4				; THEN WRITE IT
		JSR	DELNAM				; DELETE NAME
		BRA	CLSE6
CLSE4		BSR	WRUP1				; WRITE DATA
		BCS	CLSE7
		LDX	CURFCB
		TST	$17,X				; RANDOM FILE?
		BEQ	CLSE5
		JSR	PUINDX				; FINISH INDEX FILE
		BCS	CLSE7				; ERROR?
CLSE5		JSR	PUTDIR				; WRITE DIR
		BCS	CLSE7
		JSR	WRINFO				; UPDATE SYS INFO
CLSE6		BCC	CLSE2
CLSE7		RTS
		; SPC  1
	*OPEN FILE FOR UPDATE
UPDATE		JSR	OREAD				; OPEN FOR READ
		BCS	EXPND2
		JSR	RDNXT				; READ FIRST SECTOR
		BCS	EXPND2
		LDA	#$03				; SET UPDATE STATUS
		BRA	EXPND1
		; SPC  1
	*EXPAND FILE
EXPAND		JSR	OREAD				; OPEN FOR READ
		BCS	EXPND2
		LDX	CURFCB
		LDA	$0F,X				; WRITE PROT.?
		BITA	#$80
		BNE	EXPND3
		LDD	$13,X				; GET LAST SECTOR
		JSR	RDNXT2				; READ IT
		BCS	EXPND2
		LDA	#$02				; WRITE STATUS
EXPND1		LDX	CURFCB
		STA	$02,X				; SET STATUS
		ANDCC	#$FE
EXPND2		RTS
EXPND3		LDB	#$0B				; ERROR PROTECTED
		ORCC	#$01
		RTS
		; SPC  1
	*RENAME FILE
RENAME		BSR	SWPNAM				; SAVE NAME
		JSR	SCHDIR				; SEARCH FOR IT
		BCS	RENAM3				; ERROR?
		BEQ	RENAM2
		LDX	CURFCB
		LDB	#$0B
RENAM1		LDA	$24,X				; MOVE NAME
		STA	$04,X
		LEAX	$01,X
		DECB
		BNE	RENAM1
		BSR	SWPSCH				; SWAP AND SEARCH
		BCS	RENAM3
		LDX	CURFCB
		LDA	$0F,X				; WRITE PROT?
		BITA	#$80
		BNE	EXPND3
		BITA	#$60				; DELETE PROT?
		BNE	RENAM4
		BSR	SWPNAM				; SAVE NAME
		BRA	DELN1				; PUT NEW NAME IN DIR
RENAM2		LDB	#$03				; ERROR NOT FOUND
		ORCC	#$01
RENAM3		RTS
RENAM4		LDB	#$0C				; ERROR WRITE PROT.
		ORCC	#$01
		RTS
		; SPC  1
SWPNAM		LDX	CURFCB
		LDA	#$0B				; BYTE COUNT
		STA	ERR1
SWPN1		LDA	$04,X				; MOVE NAME TO TEMP
		LDB	$35,X				; MOVE TEMP TO NAME
		STA	$35,X
		STB	$04,X
		LEAX	$01,X
		DEC	ERR1				; LAST BYTE?
		BNE	SWPN1
		LDX	CURFCB
		LDA	$0C,X				; EXTENTION SET?
		BNE	SWPN3
		LDB	#$03				; BYTE COUNT
SWPN2		LDA	$3D,X				; MOVE EXT. FROM TEMP
		STA	$0C,X
		LEAX	$01,X
		DECB
		BNE	SWPN2
SWPN3		LDX	CURFCB
		RTS
		; SPC  1
SWPSCH		BSR	SWPNAM				; SWAP NAME
SWSRCH		JSR	SCHDIR				; SEARCH FOR IT
		BCS	SWPSC1				; ERROR?
		BNE	SWPSC2				; NOT FOUND?
		LDX	CURFCB
		ANDCC	#$FE
SWPSC1		RTS
SWPSC2		LDB	#$04				; ERROR NOT FOUND
		ORCC	#$01
		RTS
		; SPC  1
DELNAM		LDX	CURFCB
		LDA	#$FF
		STA	$04,X				; MARK NAME AS DELETED
DELN1		JSR	PUTDIR				; WRITE DIR
		LDX	CURFCB
		LDA	#$00
		STA	$02,X				; SET FILE NOT OPEN
		RTS
		; SPC  1
WRETRY		STD	$40,X				; SET TRACK-SECTOR
		JSR	SWRITE
		BCC	WTRY4				; NO ERROR?
WTRY1		BITB	#$40				; WRITE PROT.?
		BNE	WTRY2
		BITB	#$80				; DRIVE NOT READY?
		BEQ	WTRY3
		LDB	#$10				; ERROR NOT READY
		BRA	WTRY3
WTRY2		LDB	#$0B				; ERROR WRITE PROT.
		BRA	WTRY3
		LDB	#$0A				; ERROR WRITE ERROR
WTRY3		ORCC	#$01
WTRY4		RTS
		; SPC  1
	*DELETE FILE
DELETE		JSR	GETIFO				; GET SYS INFO
		BCS	DELET4				; ERROR?
		BSR	SWSRCH				; SEARCH DIR
		BCS	DELET4
		LDX	CURFCB
		LDA	$0F,X
		BITA	#$80				; WRITE PROT?
		BNE	DELET5
		BITA	#$60				; DELETE PROT?
		BNE	DELET6
		JSR	GETPTR				; GET POINTER TO LINK
		LDX	LNKPTR
		LDD	$02,X				; ANY FREE SECTORS?
		BNE	DELET1
		LDX	CURFCB
		LDD	$11,X				; GET START OF FILE
		BEQ	DELET3
		LDX	LNKPTR
		STD	,X				; STORE AS FREE LIST
		BRA	DELET2
DELET1		LDX	CURFCB
		JSR	RDNXT2				; READ LAST FREE SECTOR
		BCS	DELET4
		LDX	CURFCB
		LDD	$11,X				; GET FIRST OF FILE
		BEQ	DELET3
		BSR	WRETRY				; LINK TO END OF FREE
		BCS	DELET4
DELET2		LDX	CURFCB
		LDD	$13,X				; GET END OF FILE
		LDX	LNKPTR
		STD	$02,X				; STORE AS END OF FREE
		LDX	CURFCB
		LDD	$15,X				; GET FILE SIZE
		LDX	LNKPTR
		ADDD	$04,X				; ADD TO SECTORS AVAIL.
		STD	$04,X
DELET3		JSR	DELNAM				; KILL NAME
		BCS	DELET4
		JSR	WRINFO				; SAVE SYS INFO
DELET4		RTS
DELET5		LDB	#$0B				; ERROR WRITE PROT
		BRA	DELET7
DELET6		LDB	#$0C				; ERROR DELETE PROT
DELET7		ORCC	#$01
		RTS
		; SPC  1
BLDNDX		LDD	$1E,X				; GET CURRENT TRACK-SECTOR
		INCB				;  BUMP SECTOR COUNT
		CMPB	$3C,X				; SAME AS MAX SECTOR?
		BLS	BLDN1
		LDB	#$01				; POINT TO SECTOR ONE
		INCA				;  BUMP TRACK
BLDN1		CMPD	$13,X				; MATCH NEXT TRACK-SECTOR
		BNE	BLDN2
		LDA	$37,X				; GET CONTIG COUNT
		CMPA	#$FF				; EQUAL MAX CONTIG.
		BEQ	BLDN2
		INCA				;  BUMP CONTIG COUNT
		STA	$37,X				; SAVE IT
		ANDCC	#$FE
		RTS
BLDN2		BSR	PUINDX				; WRITE INDEX IN MAP
		BCS	BLDN6				; ERROR?
		LDX	CURFCB
		LDA	$3A,X				; GET MAP POINTER
		ADDA	#$03				; BUMP INDEX POINTER
		BNE	BLDN5				; END OF SECTOR?
		LDD	$1E,X				; GET CURRENT TRK-SCT
		CMPD	$11,X				; FIRST OF MAP?
		BEQ	BLDN3
		LDB	#$17				; ERROR OVERFLOW
		ORCC	#$01
		RTS
BLDN3		LDD	$40,X				; GET LINK
BLDN4		STD	$38,X				; PUT IN INDEX
		LDA	#$04
BLDN5		STA	$3A,X				; RESET DATA INDEX
		LDD	$13,X
		STD	$35,X
		LDA	#$01				; RESET CONTIG COUNT
		STA	$37,X
		ANDCC	#$FE
BLDN6		RTS
		; SPC  1
PUINDX		LDD	$38,X				; GET MAP SECTOR
		JSR	RDNXT2				; READ IT
		BCS	BLDN6
		LDX	CURFCB
		TFR	X,Y
		LDB	$3A,X				; GET MAP POINTER
		ABX
		LDB	#$03				; BYTE COUNT
PNDX1		LDA	$35,Y				; MOVE TRACK-SECTOR
		LEAY	$01,Y				; TO INDEX MAP
		STA	$40,X
		LEAX	$01,X
		DECB
		BNE	PNDX1
		JSR	SWRITE				; WRITE INDEX
		BCC	BLDN6				; NO ERROR?
		JMP	WTRY1				; RETRY
GSMAX		JSR	OINFO				; READ SYS INFO
		JSR	RDNXT
		BCS	POSN2				; ERROR?
		LDX	CURFCB
		CLRA
		CLRB
		STD	$20,X				; CLEAR RECORD COUNT
		LDA	$67,X				; GET TRACK SIZE
		STA	$3C,X
		CLRB
CLRBUF		CLR	$40,X				; CLEAR SECTOR BUFF
		LEAX	$01,X
		DECB
		BNE	CLRBUF
		LDX	CURFCB
		ANDCC	#$FE
		RTS
		; SPC  1
	*BACKUP FILE ONE RECORD
BACKUP		LDX	CURFCB
		LDA	$17,X				; RANDOM?
		BEQ	POSN1
		LDD	$20,X				; GET RECORD NUMB
		SUBD	#$0001
		BPL	BACK1				; LESS THAN ZERO?
		JMP	RECD1				; ERROR
BACK1		STD	$20,X				; SET RECORD NUMB
		; SPC  1
	*POSITION FILE TO RANDOM SECTOR
POSITN		JSR	TSTUPD				; WRITE NEW DATA
		BCS	POSN2				; ERROR?
		RORA
		BCC	POSN1				; NOT READ OR UPDATE
		CLR	,X				; CLEAR FUNCTION
		LDA	$17,X				; RANDOM FILE?
		BNE	RANDOM
POSN1		LDB	#$12				; ERROR SYS FILE ERROR
		ORCC	#$01
POSN2		RTS
		; SPC  1
RANDOM		CLR	ERR1
		LDD	$11,X				; GET FILE START
		LDY	$20,X				; GET RECORD NUMB
		BEQ	RECORD				; RECORD ZERO?
		JSR	RDINDX				; READ SECTOR MAP
		BCS	POSN2
		CLRA				;  SET RECORD ZERO
		CLRB
RAND1		TST	$02,X				; OUT OF SECTORS?
		BEQ	RECD1
		ADDB	$02,X				; INC BY RECORDS
		ADCA	#$00				; IN THIS BLOCK
		STX	RANDX
		LDX	CURFCB
		CMPD	$20,X				; PROPER INDEX?
		BCC	RAND3				; YES GET POINTER
		LDX	RANDX
		LEAX	$03,X				; BUMP TO NEXT BLOCK
		PSHS	A
		LDA	ERR1
		INCA				;  BUMP BLOCK COUNT
		STA	ERR1
		CMPA	#$54
		BEQ	RAND2				; END OF SECTOR ONE?
		CMPA	#$A8
		PULS	A
		BEQ	RECD1				; END OF MAP?
		BRA	RAND1
RAND2		PSHS	B
		LDX	CURFCB
		LDD	$40,X				; LINK TO NEXT SECTOR
		BSR	RDINDX				; SET NEXT SECTOR
		BCS	RECD1
		PULS	B
		PULS	A
		BRA	RAND1
RAND3		SUBD	$20,X				; GET DIFFERENCE
		LDX	RANDX
		LDA	$02,X				; GET CONTIG COUNT
		PSHS	B
		SUBA	,S+				; CALC. SECTOR COUNT
		DECA
		TFR	A,B
		LDA	,X				; ADD COUNT TO TRACK-SECTOR
		ADDB	$01,X
		LDX	CURFCB
		BCS	RAND5
RAND4		CMPB	$3C,X				; <=MAX SECTOR?
		BLS	RECORD				; GET RECORD
RAND5		SUBB	$3C,X				; DEC SECTOR COUNT
		INCA				;  INC TRACK COUNT
		BRA	RAND4
		; SPC  1
RECORD		JSR	RDNXT2				; READ SECTOR
		BCS	RECD3				; ERROR?
		LDX	CURFCB
		LDD	$42,X				; GET RECORD NUMB
		CMPD	$20,X				; RECORD MATCH?
		BEQ	RDNDX1
		LDB	#$19				; ERROR MISMATCH
		BRA	RECD2
RECD1		LDB	#$18				; ERROR NON EXISTANT RECORD
RECD2		ORCC	#$01
RECD3		RTS
		; SPC  1
RDINDX		JSR	RDNXT2				; READ SECTOR
		BCS	RDNDX2
		LDX	CURFCB
		LDB	#$44
		ABX				;  POINT TO DATA
RDNDX1		ANDCC	#$FE
RDNDX2		RTS
		; SPC  1
RSTNAM		LDX	CURFCB
		LDB	#$0B				; BYTE COUNT
RESTN1		LDA	$24,X				; MOVE TO FCB NAME
		STA	$04,X
		LEAX	$01,X
		DECB
		BNE	RESTN1
		RTS
		; SPC  1
	*FIND NEXT READY DRIVE
RDYCK		LDX	CURFCB
		LDA	$03,X				; GET DRIVE NUMB
		INCA
		CMPA	#$04				; VALID DRIVE?
		BCC	CKRDY3
		STA	$03,X				; SET DRIVE
		BNE	CKRDY1				; NOT DRIVE 0
		JSR	CHECK				; WAIT AND CHECK
		BRA	CKRDY2
CKRDY1		JSR	QCHECK				; CHECK DRIVE READY
CKRDY2		BCS	RDYCK				; NOT READY?
		RTS
CKRDY3		LDB	#$10				; ERROR NOT READY
		ORCC	#$01
		RTS
		; SPC  1
	*DISK DRIVERS
READ		EQU	$DE00
WRITE		EQU	$DE03
VERIFY		EQU	$DE06
RESTOR		EQU	$DE09
SELECT		EQU	$DE0C
CHECK		EQU	$DE0F
QCHECK		EQU	$DE12
DRINIT		EQU	$DE15
WINITD		EQU	$DE18
SEEKIT		EQU	$DE1B
