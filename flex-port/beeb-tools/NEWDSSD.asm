* DB: 2018-04-01 - hacked together from FLEX sources, format a flex disk

		include "../../includes/hardware.inc"
		include "../../includes/oslib.inc"


	* NEWDISK
	*
	* COPYRIGHT (C) 1980 BY
	* TECHNICAL SYSTEMS CONSULTANTS, INC.
	* 111 PROVIDENCE RD, CHAPEL HILL, NC.27514
	*
	* DISK FORMATTING PROGRAM FOR 6809 FLEX.
	* GENERAL VERSION DESIGNED FOR WD 1771/1791.
	* THE NEWDISK PROGRAM INITIALIZES A NEW DISKETTE AND
	* THEN PROCEEDS TO VERIFY ALL SECTORS AND INITIALIZE
	* TABLES. THIS VERSION IS SETUP FOR AN 8 INCH DISK
	* SYSTEM WITH HINTS AT CERTAIN POINTS FOR ALTERING
	* FOR A SINGLE-DENSITY 5 INCH DISK SYSTEM. THIS
	* VERSION IS NOT INTENDED FOR 5 INCH DOUBLE-DENSITY.
	**************************************************
	* DISK SIZE PARAMETERS - DB: moved into /drivers/wd177x.inc
	* **** **** **********



	**************************************************
	* MORE DISK SIZE DEPENDENT PARAMETERS
	* **** **** **** ********* **********
	* THE FOLLOWING VALUES ARE ALSO DEPENDENT ON THE
	* SIZE OF DISK BEING FORMATTED. EACH VALUE SHOWN
	* IS FOR 8 INCH WITH PROPER 5 INCH VALUES IN
	* PARENTHESES.
	**************************************************
	* SIZE OF SINGLE DENSITY WORK BUFFER FOR ONE TRACK
TKSZ		EQU	3050				; (USE 3050 FOR 5 INCH)
	* TRACK START VALUE
TST		EQU	0				; (USE 0 FOR 5 INCH)
	* SECTOR START VALUE
SST		EQU	7				; (USE 7 FOR 5 INCH)
	* SECTOR GAP VALUE
GAP		EQU	14				; (USE 14 FOR 5 INCH)
	**************************************************
	* WORK SPACE WHERE ONE TRACK OF DATA IS SETUP
WORK		EQU	$1900 + $700			; WORK SPACE
SWKEND		EQU	TKSZ+WORK			; SINGLE DENSITY
DWKEND		EQU	TKSZ*2+WORK			; DOUBLE DENSITY
	* GENERAL EQUATES
FIRST		EQU	$0101				; FIRST USER SECTOR
FCS		EQU	30				; FCB CURRENT SECTOR
FSB		EQU	64				; SECTOR BUFFER
IRS		EQU	16				; INFO RECORD START
AVLP		EQU	FSB+IRS+13
DIRSEC		EQU	5				; FIRST DIR. SECTOR
RDSS		EQU	9				; READ SS FMS CODE
WTSS		EQU	10				; WRITE SS FMS CODE
DATE		EQU	$CC0E				; DOS DATE
	* FLEX ROUTINES EQUATES
; PSTRNG	EQU	$CD1E
; PUTCHR	EQU	$CD18
; OUTDEC	EQU	$CD39
; GETHEX	EQU	$CD42
; GETCHR	EQU	$CD15
; PCRLF		EQU	$CD24
; INBUF		EQU	$CD1B
; GETFIL	EQU	$CD2D
; INDEC		EQU	$CD48
; FMS		EQU	$D406
; FMSCLS	EQU	$D403
; OUT2HS	EQU	$CD3C
; WARMS		EQU	$CD03
	* DISK DRIVER ROUTINES
; WRITE	EQU	$DE03				; WRITE A SINGLE SECTOR
; REST		EQU	$DE09				; RESTORE HEAD
; SEEK		EQU	$DE1B				; SEEK TO TRACK
	* TEMPORARY STORAGE - DP
		ORG	$0070
		SETDP	0
TRACK		RMB	1
SECTOR		RMB	1
BADCNT		RMB	1				; BAD SECTOR COUNT
DRN		RMB	1
SIDE		RMB	1
DBSDF		RMB	1
DENSE		RMB	1
DNSITY		RMB	1
INDEX		RMB	2
SECCNT		RMB	2				; SECTOR COUNTER
		ORG	$1900							; BBC MICRO
	********************************************
	* MAIN PROGRAM STARTS HERE
	********************************************
NEWDISK		BRA	FORM1
	* BBC MICRO - moved from ZP to allow DP vars to fit in $70-$7F
VN		FCB	2				; VERSION NUMBER
FSTAVL		RMB	2				; FIRST AVAILABLE
LSTAVL		RMB	2				; LAST AVAILABLE
MAXS0		RMB	1				; MAX SIDE 0 SECTOR
MAXS1		RMB	1				; MAX SIDE 1 SECTOR
MAX		RMB	1				; MAX SECTOR
;;; FKFCB		RMB	4
;;;VOLNAM		RMB	11
;;;VOLNUM		RMB	2
VOLNAM		FCB	"ISHBELDOMSL"
VOLNUM		FDB	0

OUTIN		JSR	PSTRNG				; OUTPUT STRING
OUTIN2		JSR	GETCHR				; GET RESPONSE
		ANDA	#$5F				; MAKE IT UPPER CASE
		CMPA	#'Y'				; SEE IF "YES"
		RTS
FORM1		LDA	#SMAXS0				; INITIALIZE SECTOR MAX
		STA	MAXS0
		STA	MAX
		LDA	#SMAXS1
		STA	MAXS1

		LDD	#0
;;		JSR	GETHEX				; GET DRIVE NUMBER
;;		LBCS	EXIT
;;		TFR	X,D
		CMPD	#3				; ENSURE 0 TO 3
		BHI	EXIT
		LDX	#WORK
		STB	3,X
		STB	DRN
		LDX	#SURES				; ASK IF HE'S SURE
		BSR	OUTIN				; PRINT & GET RESPONSE
		BNE	EXIT				; EXIT IF â€œNO"
		LDX	#SCRDS				; CHECK SCRATCH DRIVE NO.
		JSR	PSTRNG				; OUTPUT IT
		LDX	#WORK+2
		CLR	0,X
		CLRB
		JSR	OUTDEC
		LDA	#'?				; PRINT QUESTION MARK
		JSR	PUTCHR
		LDA	#$20
		JSR	PUTCHR
		BSR	OUTIN2				; GET RESPONSE
		BNE	EXIT				; EXIT IF "NO"
		CLR	DBSDF				; CLEAR FLAG
	* PLACE A "BRA FORM25" HERE IF CONTROLLER
	* IS ONLY SINGLE SIDED.
;;;		BRA	FORM25
;;		LDX	#DBST				; ASK IF DOUBLE SIDED
;;		BSR	OUTIN				; PRINT & GET RESPONSE
;;		BNE	FORM25				; SKIP IF "NO"
		INC	DBSDF				; SET FLAG
		LDA	#SMAXS1				; SET MAX SECTOR
		STA	MAX
FORM25		CLR	DENSE				; INITIALIZE SINGLE DENSITY
		CLR	DNSITY
	*** PLACE A "BRA FORM26" HERE IF CONTROLLER
	*** IS ONLY SINGLE DENSITY.
;;;		BRA	FORM26
;;;		LDX	#DDSTR				; ASK IF DOUBLE DENSITY
;;;		BSR	OUTIN				; PRINT & GET RESPONSE
;;;		BNE	FORM26				; SKIP IF "NO"
;;;		INC	DENSE				; SET FLAG IF SO
;;;FORM26		LDX	#NMSTR				; ASK FOR VOLUME NAME
;;;		JSR	PSTRNG				; PRINT IT
;;;		JSR	INBUF				; GET LINE
;;;		LDX	#FKFCB				; POINT TO FAKE
;;;		JSR	GETFIL
;;;FORM27		LDX	#NUMSTR				; OUTPUT STRING
;;;		JSR	PSTRNG
;;;		JSR	INBUF				; GET LINE
;;;		JSR	INDEC				; GET NUMBER
;;;		BCS	FORM27				; ERROR?
		LDX	#0
		STX	VOLNUM				; SAVE NUMBER
		JSR	PCRLF				; PRINT CR & LF
		LDX	#WORK
		JSR	REST				; RESTORE DISK
		BEQ	FORMAT				; SKIP IF NO ERROR
		LDX	#WPST
		BITB	#$40				; WRITE PROTECT ERROR?
		BNE	EXIT2				; SKIP IF 50
	* EXIT ROUTINES
EXIT		LDX	#ABORTS				; REPORT ABORTING
EXIT2		JSR	PSTRNG				; OUTPUT IT
EXIT3
;;;		JSR	FMSCLS
		ANDCC	#$AF				; CLI
;;;		JMP	WARMS				; RETURN
		SWI
	**************************************************************
	*
	* ACTUAL FORMAT ROUTINE
	*
	* THIS CODE PERFORMS THE ACTUAL DISK FORMATTING BY PUTTING
	* ON ALL GAPS, HEADER INFORMATION, DATA AREAS, SECTOR LINKING,
	* ETC. THIS SECTION DOES NOT WORRY ABOUT SETTING UP THE
	* SYSTEM INFORMATION RECORD, BOOT SECTOR, OR DIRECTORY.
	* IT ALSO DOES NOT NEED BE CONCERNED WITH TESTING THE DISK FOR
	* ERRORS AND THE REMOVAL OF DEFECTIVE SECTORS ASSOCIATED WITH
	* SUCH TESTING. THESE OPERATIONS ARE CARRIED OUT BY THE
	* REMAINDER OF THE CODE IN "NEWDISK".
	* IF USING A WD1771 OR WD1791 CONTROLLER CHIP, THIS CODE SHOULD
	* NOT NEED CHANGING (SO LONG AS THE WRITE TRACK ROUTINE AS
	* FOUND LATER IS PROVIDED). IF USING A DIFFERENT TYPE OF
	* CONTROLLER, THIS CODE MUST BE REPLACED AND THE WRITE TRACK
	* ROUTINE (FOUND LATER) MAY BE REMOVED AS IT WILL HAVE TO BE
	* A PART OF THE CODE THAT REPLACES THIS FORMATTING CODE.
	* WHEN THIS ROUTINE IS COMPLETED, IT SHOULD JUMP TO 'SETUP'.
	*
	**************************************************************
	* MAIN FORMATTING LOOP
FORMAT		ORCC	#$50				; SEI
		CLR	TRACK
FORM3		CLR	SIDE				; SET SIDE 0
		CLR	SECTOR
		BSR	TRKHD				; SETUP TRACK HEADER
FORM32		LDX	#WORK+SST			; POINT TO SECTOR START
		TST	DNSITY				; DOUBLE DENSITY?
		BEQ	FORM4				; SKIP IF NOT
		LDX	#SST*2+WORK			; DD SECTOR START
FORM4		BSR	DOSEC				; PROCESS RAM WITH INFO
		INC	SECTOR				; ADVANCE TO NEXT
		LDA	SECTOR				; CHECK VALUE
		TST	SIDE				; CHECK SIDE
		BNE	FORM45
		CMPA	MAXS0
		BRA	FORM46
FORM45		CMPA	MAXS1
FORM46		BNE	FORM4				; REPEAT?
FORM47			
		LDB	TRACK
		CLRA
		JSR	OUTDECD
		LDA	#13
		JSR	OSWRCH



		LDA	TRACK				; GET TRACK NUMBER
		LDB	SIDE				; FAKE SECTOR FOR PROPER SIDE
		JSR	SEEK				; SEEK TRACK AND SIDE
		JSR	WRTTRK				; WRITE TRACK
FORM5		TST	DBSDF				; ONE SIDE?
		BEQ	FORM6
		TST	SIDE
		BNE	FORM6
		COM	SIDE				; SET SIDE 1
		BRA	FORM32
FORM6		INC	TRACK				; BUMP TRACK
		JSR	SWITCH				; SWITCH TO DD IF NCSSRY
FORM7		LDA	TRACK				; CHECK VALUE
		CMPA	#MAXTRK
		BNE	FORM3
		LBRA	SETUP				; DONE...GO FINISH UP
	* SETUP TRACK HEADER INFORMATION
TRKHD		LDX	#WORK				; POINT TO BUFFER
		TST	DNSITY				; DOUBLE DENSITY?
		BNE	TRHDD				; SKIP IF SO
		LDB	#$FF
TRHDS1		STB	,X+				; INITIALIZE TO $FF
		CMPX	#SWKEND
		BNE	TRHDS1
		LDX	#WORK+TST
		CLRA				;  SET IN ZEROS
		LDB	#6
		BRA	TRHDD2
TRHDD		LDB	#$4E
TRHDD1		STB	,X+				; INITIALIZE TO $4E
		CMPX	#DWKEND
		BNE	TRHDD1
		LDX	#TST*2+WORK
		CLRA				;  SET IN ZEROS
		LDB	#12
		BSR	SET
		LDA	#$F6				; SET IN $F6'S
		LDB	#3
TRHDD2		BSR	SET
		LDA	#$FC				; SET INDEX MARK
		STA	,X
		RTS
	* SET (B) BYTES OF MEMORY TO (A) STARTING AT (X)
SET		STA	,X+
		DECB
		BNE	SET
		RTS
	* PROCESS SECTOR IN RAM
DOSEC		CLRA
		TST	DNSITY				; DOUBLE DENSITY?
		BNE	DOSEC1				; SKIP IF SO
		LDB	#6				; CLEAR 6 BYTES
		BRA	DOSEC2
DOSEC1		LDB	#12				; CLEAR 12 BYTES
		BSR	SET
		LDA	#$F5				; SET IN 3 $F5'S
		LDB	#3
DOSEC2		BSR	SET
		LDA	#$FE				; ID ADDRESS MARK
		STA	,X+
		LDA	TRACK				; GET TRACK NO.
		STA	,X+
		LDB	DNSITY				; DOUBLE DENSITY?
		BEQ	DOSEC3				; SKIP IF NOT
		LDB	SIDE				; GET SIDE INDICATOR
		ANDB	#$01				; MAKE IT 0 OR 1
DOSEC3		STB	,X+
		LDB	TRACK
		ORB	SECTOR
		BEQ	DOSEC5DB			; track 0 side 0 sector 0!
1		LDB	SECTOR				; GET SECTOR NO.
		LDY	#SSCMAP				; POINT TO CORRECT MAP
		TST	DNSITY
		BEQ	DOSEC4
		LDY	#DSCMAP
DOSEC4		LDB	B,Y				; GET ACTUAL SECTOR
DOSEC5DB		STB	,X+
		CMPB	MAX				; END OF TRACK?
DOSEC6		BNE	DOSEC7				; SKIP IF NOT
		INCA					;  BUMP TRACK NO.
		CLRB					;  RESET SECTOR NO.
		CMPA	#MAXTRK				; END OF DISK?
		BNE	DOSEC7				; SKIP IF NOT
		CLRA					;  SET ZERO FORWARK LINK
		LDB	#-1
DOSEC7		INCB					;  BUMP SECTOR NO.
		PSHS	D				; SAVE FORWARD LINK
		LDA	#1				; SECTOR LENGTH = 256
		STA	,X+
		LDA	#$F7				; SET CRC CODE
		STA	,X+
		TST	DNSITY				; DOUBLE DENSITY?
		BNE	DOSEC8				; SKIP IF S0
		LEAX	11,X				; LEAVE $FF'S
		CLRA					;  PUT IN 6 ZEROS
		LDB	#6
		BRA	DOSEC9
DOSEC8		LEAX	22,X				; LEAVE $4E'S
		CLRA					;  PUT IN 12 ZEROS
		LDB	#12
		BSR	SET
		LDA	#$F5				; PUT IN 3 $F5'S
		LDB	#3
DOSEC9		BSR	SET
		LDA	#$FB				; DATA ADDRESS MARK
		STA	,X+
		PULS	D				; RESTORE FORWARD LINK
		STD	,X++				; PUT IN SECTOR BUFFER
		CLRA					;  CLEAR SECTOR BUFFER
		LDB	#254
		LBSR	SET
		LDA	#$F7				; SET CRC CODE
		STA	,X+
		LEAX	GAP,X				; LEAVE GAP
		TST	DNSITY				; DOUBLE DENSITY?
		BEQ	DOSECA				; SKIP IF NOT
		LEAX	GAP,X				; DD NEEDS MORE GAP
DOSECA		RTS
	**************************************************************
	*
	* DISK TESTING AND TABLE SETUP
	*
	* THE FOLLOWING CODE TESTS EVERY SECTOR AND REMOVES ANY
	* DEFECTIVE SECTORS FROM THE FREE CHAIN. NEXT THE SYSTEM
	* INFORMATION RECORD IS SETUP, THE DIRECTORY IS INITIALIZED,
	* AND THE BOOT IS SAVED ON TRACK ZERO. ALL THIS CODE SHOULD
	* WORK AS IS FOR ANY FLOPPY DISK SYSTEM. ONE CHANGE THAT
	* MIGHT BE REQUIRED WOULD BE IN THE SAVING OF THE BOOTSTRAP
	* LOADER. SPECIAL BOOT LOADERS MIGHT REQUIRE CHANGES IN THE
	* WAY THE BOOT SAVE IS PERFORMED. FOR EXAMPLE, IT MAY BE
	* NECESSARY TO SAVE TWO SECTORS IF THE BOOT LOADER DOES NOT
	* FIT IN ONE. ALSO IT MAY BE NECESSARY, BY SOME MEANS, TO
	* INFORM THE BOOT LOADER WHETHER THE DISK IS SINGLE OR
	* DOUBLE DENSITY SO THAT IT MAY SELECT THE PROPER DENSITY
	* FOR LOADING FLEX.
	*
	* **************************************************************
	* READ ALL SECTORS FOR ERRORS
SETUP		LDX	#VERSTR
		JSR	PSTRNG
		JSR	PCRLF

		LDB	MAX				; GET MAX SECTORS
		LDA	#MAXTRK-1
		STD	LSTAVL				; SET LAST AVAIL.
		MUL					; FIND TOTAL SECTORS
		STD	SECCNT				; SAVE IT
		LDX	#FIRST				; SET FIRST AVAIL
		STX	FSTAVL
		LDA	DRN
		STA	WORK+3
		CLRA					;  CLEAR COUNTER
		STA	BADCNT
		STA	TRACK				; SET TRACK
		STA	DNSITY				; SNGL DNST FOR TRK 0
		INCA
		STA	SECTOR				; SET SECTOR
		LDA	#SMAXS0				; RESET MAXIMUM
		STA	MAXS0				; SECTOR COUNTS
		LDA	#SMAXS1
		STA	MAXS1
		TST	DBSDF				; DOUBLE SIDED?
		BNE	SETUP1				; SKIP IF SO
		LDA	#SMAXS0
SETUP1		STA	MAX				; SET MAXIMUM SECTORS
SETUP2		
		LDD	TRACK				; D = track and sector!
		CMPD	#$0001
		BNE	1F
		DEC	SECTOR				; DB have a track 0, sector 0
1
		PSHS	D
		LDA	#13
		JSR	OSWRCH
		LDB	TRACK
		CLRA
		JSR	OUTDECD
		LDB	SECTOR
		CLRA
		JSR	OUTDECD
		PULS	D

		BSR	CHKSEC				; GO CHECK SECTOR
		BNE	REMSEC				; ERROR?
		CLR	BADCNT				; CLEAR COUNTER
SETUP4		LDD	TRACK				; GET TRACK & SECTOR
		BSR	FIXSEC				; GET TO NEXT ADR
		LBEQ	DOTRK				; SKIP IF FINISHED
		STD	TRACK				; SET TRACK & SECTOR
		BRA	SETUP2				; REPEAT

	* CHECK IF SECTOR GOOD
CHKSEC		LDX	#WORK				; POINT TO FCB
		LDD	TRACK				; GET TRACK & SECTOR
		STD	FCS,X				; SET CURRENT TRK & SCT
		JMP	READSS				; GO DO READ
	* SWITCH TO DOUBLE DENSITY IF NECESSARY
SWITCH		LDB	DENSE				; DOUBLE DENSITY DISK?
		BEQ	SWTCH2				; SKIP IF NOT
		STB	DNSITY				; SET FLAG
		LDB	#DMAXS0				; RESET SECTOR COUNTS
		STB	MAXS0
		LDB	#DMAXS1
		STB	MAXS1
		TST	DBSDF				; DOUBLE SIDED?
		BNE	SWTCH1				; SKIP IF SO
		LDB	#DMAXS0
SWTCH1		STB	MAX				; SET MAX SECTOR
SWTCH2		RTS
	* SET TRK & SEC TO NEXT
FIXSEC		CMPB	MAX				; END OF TRACK?
		BNE	FIXSE4				; SKIP IF NOT
		INCA					;  BUMP TRACK
		BSR	SWITCH				; SWITCH TO DD IF NCSSRY
		CLRB					;  RESET SECTOR NO.
		
FIXSE4		INCB					;  BUMP SECTOR NO.
		CMPD	#$0001				; DB: track 0, sector 0
		BNE	1F
		INCB		
1		CMPA	#MAXTRK				; END OF DISK?
		RTS
	* REMOVE BAD SECTOR FROM FREE SECTOR CHAIN
REMSEC		INC	BADCNT				; UPDATE COUNTER
		BEQ	REMSE1				; COUNT OVERFLOW?
		LDA	TRACK				; GET TRACK
		BNE	REMSE2				; TRACK 0?
		LDB	SECTOR				; GET SECTOR
		CMPB	#DIRSEC				; PAST DIRECTORY?
		BHI	REMSE2
REMSE1		LDX	#FATERS				; REPORT FATAL ERROR
		JMP	EXIT2				; REPORT IT
REMSE2		LDX	#WORK				; POINT TO FCB
		LDD	FSTAVL				; GET 1ST TRACK & SECTOR
		CMPD	TRACK				; CHECK TRACK & SECTOR
		BNE	REMSE3
		BSR	FIXSEC				; SET TO NEXT
		STD	FSTAVL				; SET NEW ADR
		BRA	REMSE8				; GO DO NEXT
REMSE3		LDD	TRACK				; GET TRACK & SECTOR
		SUBB	BADCNT
		BEQ	REMS35				; UNDERFLOW?
		BPL	REMSE4
REMS35		DECA					;  DEC TRACK
		LDB	MAX				; RESET SECTOR
REMSE4		STD	FCS,X				; SET CURRENT ADR
		LBSR	READSS				; GO DO READ
		BNE	REMSE1				; ERROR?
		LDD	FSB,X				; GET LINK ADR
		BSR	FIXSEC				; POINT TO NEXT
		BNE	REMSE6				; OVERFLOW?
		LDD	FCS,X				; GET CURRENT ADR
		STD	LSTAVL				; SET NEW LAST AVAIL
		CLRA					;  SET END LINK
		CLRB
REMSE6		STD	FSB,X				; SET NEW LINK
		LBSR	WRITSS				; GO DO WRITE
		BNE	REMSE1				; ERROR?
REMSE8		LDX	SECCNT				; GET SEC COUNT
		LEAX	-1,X				; DEC IT ONCE
		STX	SECCNT				; SAVE NEW COUNT
		LDX	#BADSS				; REPORT BAD SECTOR
		JSR	PSTRNG				; OUTPUT IT
		LDX	#TRACK				; POINT TO ADDRESS
		JSR	OUT2HS				; OUTPUT IT
		LDA	#$20
		JSR	PUTCHR
		LEAX	1,X				; BUMP TO NEXT
		JSR	OUT2HS
		JMP	SETUP4				; CONTINUE
	* READ A SECTOR
;;; READSS		LDX	#WORK				; POINT TO FCB
;;; 		LDA	#RDSS				; SET UP COMMAND
;;; 		STA	0,X
;;; 		JMP	FMS				; GO DO IT
;;; 	* WRITE A SECTOR
;;; WRITSS		LDX	#WORK				; POINT TO FCB
;;; 		LDA	#WTSS				; SETUP COMMAND
;;; 		STA	0,X
;;; 		JSR	FMS				; GO DO IT
;;; 		BEQ	READSS				; ERRORS?
;;; 		RTS					;  ERROR RETURN
	* SETUP SYSTEM INFORMATION RECORD
DOTRK		CLR	DNSITY				; BACK TO SINGLE DENSITY
		LDX	#WORK				; POINT TO SPACE
		CLR	FCS,X				; SET TO DIS
		LDA	#3				; SECTOR 3
		STA	FCS+1,X
		LBSR	READSS				; READ IN SIR SECTOR
		BNE	DOTRK4				; ERROR?
		LDX	#WORK				; FIX POINTER
		CLR	FSB,X				; CLEAR FORWARD LINK
		CLR	FSB+1,X
		LDD	FSTAVL				; ADDR. OF 1ST FREE SCTR.
		STD	AVLP,X				; SET IN SIR
		LDD	LSTAVL				; ADDR. OF LAST FREE SCTR.
		STD	AVLP+2,X				; PUT IN SIR
		LDD	SECCNT				; GET TOTAL SECTOR COUNT
		STD	AVLP+4,X				; PUT IN SIR
		LDA	#MAXTRK-1				; GET MAX TRACK NO.
		LDB	MAXS0				; SET MAX SECTORS/TRACK
		TST	DBSDF				; DOUBLE SIDE?
		BEQ	DOTRK2
		LDB	MAXS1				; CHANGE FOR DOUBLE SIDED
DOTRK2		STD	AVLP+9,X				; SAVE MAX TRACK & SECTOR
		LDD	DATE				; SET DATE INTO SIR
		STD	AVLP+6,X
		LDA	DATE+2
		STA	AVLP+8,X
		LDB	#13
		LDY	#VOLNAM				; POINT TO VOLUME NAME
		LDX	#WORK
DOTR33		LDA	,Y+				; COPY NAME TO SIR
		STA	FSB+IRS,X
		LEAX	1,X
		DECB					; DEC THE COUNT
		BNE	DOTR33
		LDX	#WORK
		LBSR	WRITSS				; WRITE SIR BACK OUT
		BEQ	DIRINT				; SKIP IF NO ERROR
DOTRK4		JMP	REMSE1				; GO REPORT ERROR
	* INITIALIZE DIRECTORY
DIRINT		LDX	#WORK				; SET POINTER
		LDA	#SMAXS0				; GET MAX FOR TRK 0
		TST	DBSDF				; SINGLE SIDE?
		BEQ	DIRIN1				; SKIP IF SO
		LDA	#SMAXS1				; SET MAX FOR DS
DIRIN1		STA	FCS+1,X				; SET UP
		JSR	READSS				; READ IN SECTOR
		BNE	DOTRK4				; ERROR?
		LDX	#WORK				; RESTORE POINTER
		CLR	FSB,X				; CLEAR LINK
		CLR	FSB+1,X
		JSR	WRITSS				; WRITE BACK OUT
		BNE	DOTRK4				; ERRORS?
	* SAVE BOOT ON TRACK 0 SECTOR 1
	* (MAY REQUIRE CHANGES - SEE TEXT ABOVE)
DOBOOT		LDX	#HEREBOOT			; POINT TO LOADER CODE
		CLRA					;  TRACK #0
		LDB	#0				; SECTOR #1	- DB: sector 0 for boot sector!
		JSR	WRITE				; WRITE THE SECTOR
		BNE	DOTRK4				; SKIP IF AN ERROR
	* REPORT TOTAL SECTORS AND EXIT
;;;		LDX	#WORK				; SETUP AN FCB
;;;		LDA	#16				; OPEN SIR FUNCTION
;;;		STA	0,X
;;;		JSR	FMS				; OPEN THE SIR
;;;		BNE	DOTRK4
;;;		LDA	#7				; GET INFO RECORD FUNCTION
;;;		STA	0,X
;;;		JSR	FMS				; GET 1ST INFO RECORD
;;;		BNE	DOTRK4
		LDX	#CMPLTE				; REPORT FORMATTING COMPLETE
		JSR	PSTRNG
		LDX	#SECST				; PRINT TOTAL SECTORS STRING
		JSR	PSTRNG
		LDX	#SECCNT				; TOTAL IS IN INFO RECORD - DB: no it's not!
		CLRB
		JSR	OUTDEC				; PRINT NUMBER
		JMP	EXIT3				; ALL FINISHED!
	**************************************************
	* SECTOR MAPS
	* ****** ****
	* THE MAPS SHOWN BELOW CONTAIN THE CORRECT
	* INTERLEAVING FOR AN 8 INCH DISK. IF USING 5
	* INCH DISKS (SINGLE DENSITY) YOU SHOULD USE
	* SOMETHING LIKE '1,3,5,7,9,2,4,6,8,10' FOR
	* SSCMAP FOR A SINGLE SIDED DISK.
	**************************************************
SSCMAP		FCB	1 ,8, 5, 2, 9, 6, 3, 10, 7, 4
		FCB	11,18,15,12,19,16,13,20,17,14
DSCMAP		EQU	SSCMAP
;; ;; 		FCB	16,21,26,18,23,28,20,25
;; ;; 		FCB	30,17,22,27,19,24,29
;; ;; DSCMAP		FCB	1,14,3,16,5,18,7
;; ;; 		FCB	20,9,22,11,24,13
;; ;; 		FCB	26,2,15,4,17,6,19
;; ;; 		FCB	8,21,10,23,12,25
;; ;; 		FCB	27,40,29,42,31,44,33
;; ;; 		FCB	46,35,48,37,50,39
;; ;; 		FCB	52,28,41,30,43,32,45
;; ;; 		FCB	34,47,36,49,38,51
	* STRINGS
SURES		FCC	"ARE YOU SURE? "
		FCB	4
WPST		FCC	"DISK IS PROTECTED!"
		FCB	4
SCRDS		FCC	"SCRATCH DISK IN DRIVE "
		FCB	4
FATERS		FCC	"FATAL ERROR --- "
ABORTS		FCC	"FORMATTING ABORTED"
		FCB	4
BADSS		FCC	"BAD SECTOR AT "
		FCB	4
CMPLTE		FCC	"FORMATTING COMPLETE"
		FCB	4
SECST		FCC	"TOTAL SECTORS "
		FCB	4
DBST		FCC	"DOUBLE SIDED DISK? "
		FCB	4
DDSTR		FCC	"DOUBLE DENSITY DISK? "
		FCB	4
NMSTR		FCC	"VOLUME NAME? "
		FCB	4
NUMSTR		FCC	"VOLUME NUMBER? "
		FCB	4
VERSTR		FCB	"VERIFYING..."
		FCB	4

**********************************************************************************
* INCLUDE WD specific driver stuff
		include "../drivers/wd177x/wd177x.inc"

**********************************************************************************
* INCLUDE WRTRACK.asm
		include "../drivers/wd177x/disk_wrtrack.asm"

**********************************************************************************
* INCLUDE drivers.asm
		include "../drivers/wd177x/drivers-beeb.asm"

	
**********************************************************************************
* PHONEY FLEX

PSTRNG		JSR	OSNEWL
1		LDA	,X+
		CMPA	#4
		BEQ	2F
		JSR	OSASCI
		BRA	1B
2		RTS
PUTCHR		EQU	OSASCI

GETCHR		JSR	OSRDCH
		CMPA	#' '
		BLO	1F
		JSR	OSASCI
1		RTS
PCRLF		EQU	OSNEWL

FIRDIG		RMB	1
TRNSFR		RMB	1
DIGCNT		RMB	1
CHRCNT		RMB	1

*OUTPUT DECIMAL NUMBER
OUTDECD	PSHS	D
	LEAX	,S
	JSR	OUTDEC
	PULS	D,PC

OUTDEC 	CLR FIRDIG 					; clear first digit flag
	STB TRNSFR					; save leading zero flag
	LDA #$04					; set digit count
	STA DIGCNT
	LDD ,X 						; get number to print
	LDX #DECTBL 					; point to conversion table
ODECM1	BSR ODECM2 					; convert one digit
	LEAX $02,X 					; point to next entry
	DEC DIGCNT 					; last digit?
	BNE ODECM1 					; branch if not
	TFR B,A						; move remainder to a
	BRA OUTHR 					; print it and exit
	SPC 1
ODECM2	CLR CHRCNT					; initalize to zero
ODECM3	CMPD ,X 					; is number less than
	BCS ODECM4					; number in table
	SUBD ,X						; subtract once
	INC CHRCNT					; increment count
	BRA ODECM3					; test again
ODECM4	PSHS A						; save number msb
	LDA CHRCNT					; get digit
	BNE ODECM5					; output if not zero
	TST FIRDIG					; has any digit been printed?
	BNE ODECM5					; print if so
	TST TRNSFR					; test print zeros flag
	BEQ DECRTN					; if clear skip zeros
	LDA #$20					; output a space
	BSR OUTIT
	BRA DECRTN
ODECM5	INC FIRDIG					; mark digit printed
 	BSR OUTHR					; output it
DECRTN	PULS PC,A

*OUTPUT 4 HEX DIGITS
OUT4HX	BSR OUT2HS 					;output 2 hex
	LEAX $01,X 					;point to next
OUT2HS	LDA ,X 						;get hex digit
 	BSR OUTHL 					;print left half
	LDA ,X						;get digit
	BRA OUTHR 					;print right half and return
	
OUTHL	LSRA 						;move left 4 places
	LSRA
	LSRA
	LSRA
OUTHR	ANDA #$0F					; mask off 4 lsb
	ADDA #$30					; add ascii bias
	CMPA #$39					; is it greater than 9?
	BLS OUTIT					; print if not
	ADDA #$07					; offset to ascii "A"
OUTIT	JMP PUTCHR					; print it

*BINARY TO DECIMAL TABLE
DECTBL 	FDB 10000
	FDB 1000
	FDB 100
	FDB 10


********************************************************************************
* FMS replacement routines for READ/WRITE single sector
********************************************************************************

ERR1		RMB 1					;ERROR COUNT AND TEMP
ERR2		RMB 1
CURFCB		RMB 2

* DB: API change, READSS and WRITESS expect FCB passed in X

*SINGLE SECTOR READ

READSS		BSR	CLRERR				; CLEAR ERROR COUNT
		STX	CURFCB				; DB: was LDX!
		JSR	DRV				; SELECT DRIVE
		BCS	SREAD3				; ERROR?
SREAD1		BSR	BUFSET				; SET BUFFER POINTER
		JSR	READ				; READ SECTOR
		BNE	SREAD2				; ERROR?
		ANDCC	#$FE
		RTS
SREAD2		PSHS	B
		BSR	TSTERR				; TEST ERROR
		PULS	B
		BCC	SREAD1				; RETRY READ?
SREAD3		RTS

BUFSET		
		LDX	CURFCB
		LDD	$1E,X				; GET TRACK-SECTOR
		LEAX	$40,X				; POINT TO SECTOR BUFFER
		RTS

CLRERR		CLRA					;  CLEAR ERROR COUNT
		STA	ERR1
		STA	ERR2
		RTS

TSTERR		BITB	#$10				; RECORD NOT FOUND?
		BNE	TSTER1				; OTHER ERROR?
		BITB	#$80				; NOT READY?
		BNE	TSTER3
		LDB	ERR1
		INCB
		CMPB	#$07
		BEQ	TSTER1
		STB	ERR1
		BRA	TSTER2
TSTER1		CLR	ERR1
		LDB	ERR2
		INCB
		CMPB	#$04
		BEQ	TSTER3
		STB	ERR2
		LDX	CURFCB
		JSR	REST
TSTER2		ANDCC	#$FE				; RETRY
		RTS
TSTER3		ORCC	#$01				; DONT RETRY
		RTS

	*SINGLE SECTOR WRITE
WRITSS		BSR	CLRERR				; CLEAR ERROR COUNT
		STX	CURFCB				; DB: was LDX
		JSR	DRV				; SELECT DRIVE
		BCS	SWRIT3				; ERROR?
SWRIT1		
		LDX	CURFCB
		BSR	BUFSET				; SET BUFFER POINTER
		JSR	WRITE				; WRITE SECTOR
		BNE	SWRIT2				; ERROR?
;;		LDA	VFLAG
;;		BEQ	PRES3				; VERIFY OFF?
		JSR	VERIFY
		BEQ	PRES3				; EXIT
SWRIT2		BITB	#$40				; WRITE PROT.?
		BNE	SWRIT4
		PSHS	B
		BSR	TSTERR
		PULS	B
		BCC	SWRIT1				; RETRY?
SWRIT3		RTS
		LDB	#$20				; SET ERROR CODE
SWRIT4		ORCC	#$01
		RTS

PRES3		ANDCC #$FE
 		RTS


	**********************************************************
	*
	* BOOTSTRAP FLEX LOADER
	*
	* THE CODE FOR THE BOOTSTRAP FLEX LOADER MUST BE IN MEMORY
	* AT $C100 WHEN NEWDISK IS RUN. THERE ARE TWO WAYS IT CAN
	* BE PLACED THERE. ONE IS TO ASSEMBLE THE LOADER AS A
	* SEPARATE FILE AND APPEND IT ONTO THE END OF THE NEWDISK
	* FILE. THE SECOND IS TO SIMPLY PUT THE SOURCE FOR THE
	* LOADER IN-LINE HERE WITH AN ORG TO $C100. THE FIRST FEW
	* LINES OF CODE FOR THE LATTER METHOD ARE GIVEN HERE TO
	* GIVE THE USER AN IDEA OF HOW TO SETUP THE LOADER SOURCE.
	*
	* IT IS NOT NECESSARY TO HAVE THE LOADER AT $C100 IN ORDER
	* FOR THE NEWDISK TO RUN. IT SIMPLY MEANS THAT WHATEVER
	* HAPPENS TO BE IN MEMORY AT $C100 WHEN NEWDISK IS RUN
	* WOULD BE WRITTEN OUT AS A BOOT. AS LONG AS THE CREATED
	* DISK WAS FOR USE AS A DATA DISK ONLY AND WOULD NOT BE
	* BOOTED FROM, THERE WOULD BE NO PROBLEM.
	*
	**********************************************************
	* 6809 BOOTSTRAP FLEX LOADER
HEREBOOT
		ORG	$C100
		PUT	HEREBOOT
BOOT		BRA	BOOT1
		FCB	0,0,0
TRK		FCB	0				; STARTING TRACK.(AT $C105)
SCTR		FCB	0				; STARTING SECTUR (AT $C106)
TEMP		FDB	0
		EQU	$C300
BOOT1		JMP	BOOT1				; ROUTINE GOES HERE
	**********************************************************

		FCB 	"THERE'S A MUSHROOM IN MY GARDEN..."
		END	NEWDISK

