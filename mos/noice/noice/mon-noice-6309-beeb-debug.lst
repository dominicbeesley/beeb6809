                              IF NOICE_NO_INCS
                      
                              ELSE
                                      include "../../../includes/hardware.inc"
                      ; beeb6809 hardware locations and constants
                      
003B                  rti_opcode              EQU     $3B
                      
FD00                  JIM                     EQU     $FD00
                      
                      * mos ROM memory map location
FE30                  sheila_ROMCTL_SWR       EQU     $FE30
FE31                  sheila_ROMCTL_MOS       EQU     $FE31
FE32                  sheila_MEM_DEBUG_SAVE   EQU     $FE32
                      
                      
0010                  ROMCTL_BITS_FLEX        EQU     $10
                      
                              IF MACH_BEEB
                      ;TODO: naming - harmonize with 6502
FE31                  sheila_MEM_CTL                  EQU $FE31
                      
0001                  BITS_MEM_CTL_SWMOS              EQU $01
0004                  BITS_MEM_CTL_SWMOS_DEBUG        EQU $04
0008                  BITS_MEM_CTL_SWMOS_DEBUG_EN     EQU $08
0010                  BITS_MEM_CTL_FLEX               EQU $10
0040                  BITS_MEM_CTL_SWMOS_DEBUG_5C     EQU $40
0080                  BITS_MEM_CTL_SWMOS_DEBUG_ACT    EQU $80
                      
                      
FE36                  sheila_MEM_TURBO2               EQU $FE36
0080                  BITS_MEM_TURBO2_THROTTLE        EQU $80
                      
FE37                  sheila_MEM_LOMEMTURBO           EQU $FE37
                      
                      
FCFF                  fred_JIM_DEVNO          EQU     $FCFF
FCFD                  fred_JIM_PAGE_HI        EQU     $FCFD
FCFE                  fred_JIM_PAGE_LO        EQU     $FCFE
                              
FE22                  sheila_NULA_CTLAUX      EQU     $FE22
FE23                  sheila_NULA_PALAUX      EQU     $FE23
                      
FEFF                  sheila_DEBUG            EQU     $FEFF
                      
                      
                      
                      
FE3E                  sheila_BLTCFG0          EQU     $FE3E
FE3F                  sheila_BLTCFG1          EQU     $FE3F
0001                  BLTCFG0_T65             EQU     $01
0000                  BLTCFG0_CPU_6502A_2M    EQU     $00
0002                  BLTCFG0_CPU_65C02_4M    EQU     $02
0004                  BLTCFG0_CPU_65C02_8M    EQU     $04
0008                  BLTCFG0_CPU_6x09_2M     EQU     $08
000A                  BLTCFG0_CPU_6309_4M     EQU     $0A
000C                  BLTCFG0_CPU_Z80_8M      EQU     $0C
000E                  BLTCFG0_CPU_68008       EQU     $0E
0010                  BLTCFG0_SWROMX          EQU     $10
0080                  BLTCFG0_BUGBTN          EQU     $80
                      
0001                  BLTCFG1_MEMI            EQU     $01
0002                  BLTCFG1_BUGOUT          EQU     $02
                      
                      
                              ENDIF
                      
                              IF MACH_CHIPKIT
                      sheila_ROMCTL_RAM       EQU     $FE32
                      sheila_MEMC_SCROFF      EQU     $FE33
                              ENDIF
                      
                      
                      
                      * HARDWARELOC - area of RAM used for memory mapped hardware
FC00                  HARDWARELOC                             EQU $FC00
FEFF                  HARDWARELOC_END                         EQU $FEFF
                      
                      * Where the remapped 6809 vectors live, the hardware remaps
                      * the 6809 hardware vectors to avoid the OS calls in the original 6502 memory map
F7F0                  REMAPPED_HW_VECTORS                     EQU $F7F0
                      
000A                  OFF_SWI_VEC     EQU     $A
000C                  OFF_NMI_VEC     EQU     $C
000E                  OFF_RES_VEC     EQU     $E
0008                  HW_VECTOR_COUNT EQU     8
                      
                      ***********************************************************************
                      * CRTC                                                                *
                      ***********************************************************************
FE00                  sheila_CRTC_reg                         EQU $FE00
FE01                  sheila_CRTC_rw                          EQU $FE01
                      
                      
0000                  CRTCR0_HorizontalTotal                  EQU      0      ; 8b WO m0-3:127 m4-7:63
0001                  CRTCR1_HorizontalDisplayed              EQU      1      ; 8b WO m0-3:80  m4-7:40
0002                  CRTCR2_HorizontalSyncPosition           EQU      2      ; 8b WO m0-3:98  m4-6:49 m7:51
0003                  CRTCR3_SyncPulseWidths                  EQU      3      ; Horizontal sync pulse width b0-3 WO m0-3:8 m4-7:4, Vertical sync pulse width b4-7 WO Always 2
0004                  CRTCR4_VerticalTotal                    EQU      4      ; 7b WO m0-2,4-5:38 m3,6-7:30
0005                  CRTCR5_VerticalTotalAdjust              EQU      5      ; 5b WO m0-7:0
0006                  CRTCR6_VerticalDisplayed                EQU      6      ; 7b WO m0-2,4-5:32 m3,6-7:25
0007                  CRTCR7_VerticalSyncPosition             EQU      7      ; 7b WO m0-2,4-5:34 m3,6-7:27
0008                  CRTCR8_InterlaceAndControl              EQU      8      ; Interlace modes        b0-1 00,10 non-interlaced, m0-6 01 Interlace sync, m7 11 Interlace sync and video
0009                  CRTCR9_CharacterScanLines               EQU      9      ; 5b WO m0-2,4-5:7 m3,6:9 m7:18
000A                  CRTCR10_CursorControlStart              EQU     10      ; 7b WO b7 unused b6 blink enable b5 blink fast b0-4 crsr start line
000B                  CRTCR11_CursorEnd                       EQU     11      ; 5b WO crsr end line
000C                  CRTCR12_Screen1stCharHi                 EQU     12      ; 6b WO hi byte of (start of screen address)/8
000D                  CRTCR13_Screen1stCharLo                 EQU     13      ; 8b WO lo byte of (start of screen address)/8
                      
                      ***********************************************************************
                      * Simple Video ULA                                                    *
                      ***********************************************************************
FE20                  sheila_VIDULA_ctl                       EQU $FE20
FE21                  sheila_VIDULA_pal                       EQU $FE21
                              IF MACH_CHIPKIT
                      sheila_VIDULA_pixand                    EQU $FE22
                      sheila_VIDULA_pixeor                    EQU $FE23
                      sheila_VIDULA_ttx                       EQU $FE24
                      
                      sheila_RAMDAC_ADDR_WR                   EQU $FE28
                      sheila_RAMDAC_VAL                       EQU $FE29
                      sheila_RAMDAC_PIXMASK                   EQU $FE2A
                      sheila_RAMDAC_ADDR_RD                   EQU $FE2B
                              ENDIF
                      
                      ***********************************************************************
                      * VIA constants                                                       *
                      ***********************************************************************
                      
0001                  VIA_MASK_INT_CA2                        EQU     $01
0002                  VIA_MASK_INT_CA1                        EQU     $02
0004                  VIA_MASK_INT_SR                         EQU     $04
0008                  VIA_MASK_INT_CB2                        EQU     $08
0010                  VIA_MASK_INT_CB1                        EQU     $10
0020                  VIA_MASK_INT_T2                         EQU     $20
0040                  VIA_MASK_INT_T1                         EQU     $40
0080                  VIA_MASK_INT_IRQ                        EQU     $80
                      
0002                  SYSVIA_MASK_INT_VSYNC                   EQU     VIA_MASK_INT_CA1
                      
                      ***********************************************************************
                      * System VIA                                                          *
                      ***********************************************************************
FE40                  sheila_SYSVIA_orb                       EQU $FE40
FE41                  sheila_SYSVIA_ora                       EQU $FE41
FE42                  sheila_SYSVIA_ddrb                      EQU $FE42
FE43                  sheila_SYSVIA_ddra                      EQU $FE43
FE44                  sheila_SYSVIA_t1cl                      EQU $FE44
FE45                  sheila_SYSVIA_t1ch                      EQU $FE45
FE46                  sheila_SYSVIA_t1ll                      EQU $FE46
FE47                  sheila_SYSVIA_t1lh                      EQU $FE47
FE48                  sheila_SYSVIA_t2cl                      EQU $FE48
FE49                  sheila_SYSVIA_t2ch                      EQU $FE49
FE4A                  sheila_SYSVIA_sr                        EQU $FE4A
FE4B                  sheila_SYSVIA_acr                       EQU $FE4B
FE4C                  sheila_SYSVIA_pcr                       EQU $FE4C
FE4D                  sheila_SYSVIA_ifr                       EQU $FE4D
FE4E                  sheila_SYSVIA_ier                       EQU $FE4E
FE4F                  sheila_SYSVIA_ora_nh                    EQU $FE4F
                      
                      ***********************************************************************
                      * SYS VIA - slow data bus RTC                                         *
                      ***********************************************************************
                      
                              IF MACH_CHIPKIT
                      BITS_RTC_AS_ON  equ             $88                     ; PB7
                      BITS_RTC_AS_OFF equ             $08                     ;
                      BITS_RTC_CS     equ             $04                     ; latch
                      BITS_RTC_DS     equ             $02                     ; latch
                      BITS_RTC_RnW    equ             $01                     ; latch
                      BITS_LAT_ON     equ             $08                     ; latch
                      
                      RTC_REG_SECONDS equ             $0
                      RTC_REG_MINUTES equ             $2
                      RTC_REG_HOURS   equ             $4
                      RTC_REG_DOW     equ             $6
                      RTC_REG_DAY     equ             $7
                      RTC_REG_MONTH   equ             $8
                      RTC_REG_YEAR    equ             $9
                              ENDIF
                      
                      
                      ***********************************************************************
                      * User VIA                                                            *
                      ***********************************************************************
FE60                  sheila_USRVIA_orb                       EQU $FE60
FE61                  sheila_USRVIA_ora                       EQU $FE61
FE62                  sheila_USRVIA_ddrb                      EQU $FE62
FE63                  sheila_USRVIA_ddra                      EQU $FE63
FE64                  sheila_USRVIA_t1cl                      EQU $FE64
FE65                  sheila_USRVIA_t1ch                      EQU $FE65
FE66                  sheila_USRVIA_t1ll                      EQU $FE66
FE67                  sheila_USRVIA_t1lh                      EQU $FE67
FE68                  sheila_USRVIA_t2cl                      EQU $FE68
FE69                  sheila_USRVIA_t2ch                      EQU $FE69
FE6A                  sheila_USRVIA_sr                        EQU $FE6A
FE6B                  sheila_USRVIA_acr                       EQU $FE6B
FE6C                  sheila_USRVIA_pcr                       EQU $FE6C
FE6D                  sheila_USRVIA_ifr                       EQU $FE6D
FE6E                  sheila_USRVIA_ier                       EQU $FE6E
FE6F                  sheila_USRVIA_ora_nh                    EQU $FE6F
                      
                      
                      ***********************************************************************
                      *  VIA constants                                                      *
                      ***********************************************************************
                      
0080                  VIA_IFR_BIT_ANY                         EQU $80
0040                  VIA_IFR_BIT_T1                          EQU $40
0020                  VIA_IFR_BIT_T2                          EQU $20
0010                  VIA_IFR_BIT_CB1                         EQU $10
0008                  VIA_IFR_BIT_CB2                         EQU $08
0004                  VIA_IFR_BIT_SR                          EQU $04
0002                  VIA_IFR_BIT_CA1                         EQU $02
0001                  VIA_IFR_BIT_CA2                         EQU $01
                      
                      
                      ***********************************************************************
                      * BBC B/B+ WD177x                                                     *
                      ***********************************************************************
                      
FE80                  sheila_1770_dcontrol    equ     $FE80
FE84                  sheila_1770_wdc_cmd     equ     $FE84
FE85                  sheila_1770_wdc_trk     equ     $FE85
FE86                  sheila_1770_wdc_sec     equ     $FE86
FE87                  sheila_1770_wdc_dat     equ     $FE87
                      
                      ***********************************************************************
                      * TUBE                                                                *
                      ***********************************************************************
                      
FEE0                  sheila_TUBE_R1_STATUS                   EQU $FEE0
FEE1                  sheila_TUBE_R1_DATA                     EQU $FEE1
FEE2                  sheila_TUBE_R2_STATUS                   EQU $FEE2
FEE3                  sheila_TUBE_R2_DATA                     EQU $FEE3
FEE4                  sheila_TUBE_R3_STATUS                   EQU $FEE4
FEE5                  sheila_TUBE_R3_DATA                     EQU $FEE5
FEE6                  sheila_TUBE_R4_STATUS                   EQU $FEE6
FEE7                  sheila_TUBE_R4_DATA                     EQU $FEE7
                      
                      
                              IF MACH_CHIPKIT
                      *============================================================================
                      *  Equates for memory mapped 16450 serial port 
                      *============================================================================
                      S16550                  equ     $FE78                   ; base of 16450 UART
                      S16550_RXR              equ     S16550+0                ; Receiver buffer register
                      S16550_TXR              equ     S16550+0                ; Transmitter buffer register
                      S16550_IER              equ     S16550+1                ; Interrupt enable register
                      S16550_FCR              equ     S16550+2                ; 16550 FIFO control register
                      S16550_LCR              equ     S16550+3                ; Line control register
                      S16550_MCR              equ     S16550+4                ; Modem control register
                      S16550_DTR              equ     S16550+1                ; Bit equate used to control status LED
                      S16550_LSR              equ     S16550+5                ; Line status register
                      
                      SER_BIT_RXRDY           EQU     $01            ; BIT MASK FOR RX BUFFER FULL
                      SER_BIT_TXRDY           EQU     $20            ; BIT MASK FOR TX BUFFER EMPTY
                      
                      SER_BAUD_CLOCK_IN       EQU     7372800                 ; frequency of on board serial crystal
                      
                      
                      sheila_VINC_data        EQU     $FE50
                      sheila_VINC_status      EQU     $FE52
                      VINC_status_TXE         EQU     $01
                      VINC_status_RXF         EQU     $02
                              ENDIF
                      
                              IF MACH_BEEB
                      
                      * note: this are for Retroclinic DC
FCF8                  sheila_VINC_data        EQU     $FCF8
FCF9                  sheila_VINC_status      EQU     $FCF9
0040                  VINC_status_TXE         EQU     $40
0080                  VINC_status_RXF         EQU     $80
                      
FE08                  sheila_ACIA_CTL         EQU     $FE08
FE09                  sheila_ACIA_DATA        EQU     $FE09
FE10                  sheila_SERIAL_ULA       EQU     $FE10
0001                  ACIA_RDRF               EQU     $01
0002                  ACIA_TDRE               EQU     $02
                      
                      
                      ; BLTCON is written in two passes with top bit clear i.e. not BLTCON_ACT_ACT
                      ; the exec flags are first set
                      ; then with top bit set the active flag, bit mode and cell flags are set
                      ; BLTCON/ACT byte flags
                      
0080                  BLITCON_ACT_ACT                 EQU     $80             ; always set when setting act constants/execing
0040                  BLITCON_ACT_CELL                EQU     $40             ; cell addressing used i.e. move one byte left adds 8 to address
                                                                              ; moving one line down either adds 1 byte or STRIDE depending on whether 
                                                                              ; line crosses an 8 line boundary
0000                  BLITCON_ACT_MODE_1BBP           EQU     $00             ; 1 bit per pixel mapping 2 colours
0010                  BLITCON_ACT_MODE_2BBP           EQU     $10             ; 2 bit per pixel mapping 4 colours
0020                  BLITCON_ACT_MODE_4BBP           EQU     $20             ; 4 bit per pixel mapping 16 colours
0030                  BLITCON_ACT_MODE_8BBP           EQU     $30             ; 8 bit per pixel mapping 256 colours
0008                  BLITCON_ACT_LINE                EQU     $08             ; draw a line
0004                  BLITCON_ACT_COLLISION           EQU     $04             ; gets reset for any non-zero D data (even in EXEC_D is clear) 
                      
                      
0010                  BLITCON_LINE_MAJOR_UPnRIGHT     EQU     $10             ; line draw major axis is up
0020                  BLITCON_LINE_MINOR_CCW          EQU     $20             ; minor axis is CCW to MAJOR i.e. left when maj up, up when maj right
                                                                              ; otherwise                       right when maj up, down when maj right
                      
                      
0001                  BLITCON_EXEC_A                  EQU     $01
0002                  BLITCON_EXEC_B                  EQU     $02
0004                  BLITCON_EXEC_C                  EQU     $04
0008                  BLITCON_EXEC_D                  EQU     $08
0010                  BLITCON_EXEC_E                  EQU     $10
                      
                      ; DMA controller control flags
0080                  DMACTL_ACT                      EQU     $80             ; always set to initiate a transfer
0020                  DMACTL_EXTEND                   EQU     $20             ; use extended functions from control2
0010                  DMACTL_HALT                     EQU     $10             ; halt cpu during transfer
0000                  DMACTL_STEP_DEST_NONE           EQU     $00             ; do not step destination address
0004                  DMACTL_STEP_DEST_UP             EQU     $04             ; step destination up after transfer
0008                  DMACTL_STEP_DEST_DOWN           EQU     $08             ; step destination down after transfer
000C                  DMACTL_STEP_DEST_RESV           EQU     $0C             ; reserved do not use
0000                  DMACTL_STEP_SRC_NONE            EQU     $00             ; do not step destination address
0001                  DMACTL_STEP_SRC_UP              EQU     $01             ; step destination up after transfer
0002                  DMACTL_STEP_SRC_DOWN            EQU     $02             ; step destination down after transfer
0003                  DMACTL_STEP_SRC_RESV            EQU     $03             ; reserved do not use
                      
0080                  DMACTL2_IF                      EQU     $80             ; interrupt occurred
0002                  DMACTL2_IE                      EQU     $02             ; interrupt enable, interrupt after transfer
0000                  DMACTL2_SZ_BYTE                 EQU     $00
0004                  DMACTL2_SZ_WORD                 EQU     $04
0008                  DMACTL2_SZ_WORDSWAPDEST         EQU     $08
000C                  DMACTL2_SZ_WORDSWAPSRC          EQU     $0C
0001                  DMACTL2_PAUSE                   EQU     $01
                      
                      ; Sound Status / control bits
0080                  SND_CTL_ACT                     EQU     $80
0001                  SND_CTL_REPEAT                  EQU     $01
                      
                      
0000                  DMAC_BLITCON_offs               EQU     0
0001                  DMAC_FUNCGEN_offs               EQU     $1
0002                  DMAC_WIDTH_offs                 EQU     $2
0003                  DMAC_HEIGHT_offs                EQU     $3
0004                  DMAC_SHIFT_offs                 EQU     $4
0005                  DMAC_MASK_FIRST_offs            EQU     $5
0006                  DMAC_MASK_LAST_offs             EQU     $6
0007                  DMAC_DATA_A_offs                EQU     $7
0008                  DMAC_ADDR_A_offs                EQU     $8
000B                  DMAC_DATA_B_offs                EQU     $B
000C                  DMAC_ADDR_B_offs                EQU     $C
000F                  DMAC_ADDR_C_offs                EQU     $F
0012                  DMAC_ADDR_D_offs                EQU     $12
0015                  DMAC_ADDR_E_offs                EQU     $15
0018                  DMAC_STRIDE_A_offs              EQU     $18
001A                  DMAC_STRIDE_B_offs              EQU     $1A
001C                  DMAC_STRIDE_C_offs              EQU     $1C
001E                  DMAC_STRIDE_D_offs              EQU     $1E
                      
0020                  DMAC_SND_DATA_offs              EQU     $20
0021                  DMAC_SND_ADDR_offs              EQU     $21
0024                  DMAC_SND_PERIOD_offs            EQU     $24
0026                  DMAC_SND_LEN_offs               EQU     $26
0028                  DMAC_SND_STATUS_offs            EQU     $28
0029                  DMAC_SND_VOL_offs               EQU     $29
002A                  DMAC_SND_REPOFF_offs            EQU     $2A
002C                  DMAC_SND_PEAK_offs              EQU     $2C
                      
002E                  DMAC_SND_MA_VOL_offs            EQU     $2E
002F                  DMAC_SND_SEL_offs               EQU     $2F
                      
0030                  DMAC_DMA_CTL_offs               EQU     $30
0031                  DMAC_DMA_SRC_ADDR_offs          EQU     $31
0034                  DMAC_DMA_DEST_ADDR_offs         EQU     $34
0037                  DMAC_DMA_COUNT_offs             EQU     $37
0039                  DMAC_DMA_DATA_offs              EQU     $39
003A                  DMAC_DMA_CTL2_offs              EQU     $3A
003B                  DMAC_DMA_PAUSE_offs             EQU     $3B
003F                  DMAC_DMA_SEL_offs               EQU     $3F
                      
FEFC                  jim_page_DMAC                   EQU     $FEFC           ; hardware jim page
FD60                  jim_DMAC                        EQU     $FD60           ; jim location in SYS map
                      
FC00                  jim_page_VERSION                EQU     $FC00
                      
0080                  jim_offs_VERSION_API_level      EQU     $80
0081                  jim_offs_VERSION_Board_level    EQU     $81
0082                  jim_offs_VERSION_API_sublevel   EQU     $82
0084                  jim_offs_VERSION_cfg_bits       EQU     $84
0088                  jim_offs_VERSION_cap_bits       EQU     $88
                      
                      ; Mk.2/1 option switches - note in API level >1 the sense of these is reversed!
0001                  BLT_MK2_CFG0_T65                EQU     $01
0000                  BLT_MK2_CFG0_CPU_6502A_2M       EQU     $00
0002                  BLT_MK2_CFG0_CPU_65C02_4M       EQU     $02
0004                  BLT_MK2_CFG0_CPU_65C02_8M       EQU     $04
0008                  BLT_MK2_CFG0_CPU_6x09_2M        EQU     $08
000A                  BLT_MK2_CFG0_CPU_6309_4M        EQU     $0A
000C                  BLT_MK2_CFG0_CPU_Z80_8M         EQU     $0C
000E                  BLT_MK2_CFG0_CPU_68008          EQU     $0E
0010                  BLT_MK2_CFG0_SWROMX             EQU     $10
0080                  BLT_MK2_CFG0_BUGBTN             EQU     $80
                      
0001                  BLT_MK2_CFG1_MEMI               EQU     $01
0002                  BLT_MK2_CFG1_BUGOUT             EQU     $02
                      
                      ; Mk.3 switches from PORTF/G
0008                  BLT_MK3_CFG0_T65                EQU     $08
0010                  BLT_MK3_CFG0_SWROMX             EQU     $10
0040                  BLT_MK3_CFG0_MEMI               EQU     $40
                      
                      
                      
FD60                  jim_DMAC_BLITCON                EQU     jim_DMAC + DMAC_BLITCON_offs
FD61                  jim_DMAC_FUNCGEN                EQU     jim_DMAC + DMAC_FUNCGEN_offs
FD62                  jim_DMAC_WIDTH                  EQU     jim_DMAC + DMAC_WIDTH_offs
FD63                  jim_DMAC_HEIGHT                 EQU     jim_DMAC + DMAC_HEIGHT_offs
FD64                  jim_DMAC_SHIFT                  EQU     jim_DMAC + DMAC_SHIFT_offs
FD65                  jim_DMAC_MASK_FIRST             EQU     jim_DMAC + DMAC_MASK_FIRST_offs
FD66                  jim_DMAC_MASK_LAST              EQU     jim_DMAC + DMAC_MASK_LAST_offs
FD67                  jim_DMAC_DATA_A                 EQU     jim_DMAC + DMAC_DATA_A_offs
FD68                  jim_DMAC_ADDR_A                 EQU     jim_DMAC + DMAC_ADDR_A_offs
FD6B                  jim_DMAC_DATA_B                 EQU     jim_DMAC + DMAC_DATA_B_offs
FD6C                  jim_DMAC_ADDR_B                 EQU     jim_DMAC + DMAC_ADDR_B_offs
FD6F                  jim_DMAC_ADDR_C                 EQU     jim_DMAC + DMAC_ADDR_C_offs
FD72                  jim_DMAC_ADDR_D                 EQU     jim_DMAC + DMAC_ADDR_D_offs
FD75                  jim_DMAC_ADDR_E                 EQU     jim_DMAC + DMAC_ADDR_E_offs
FD78                  jim_DMAC_STRIDE_A               EQU     jim_DMAC + DMAC_STRIDE_A_offs
FD7A                  jim_DMAC_STRIDE_B               EQU     jim_DMAC + DMAC_STRIDE_B_offs
FD7C                  jim_DMAC_STRIDE_C               EQU     jim_DMAC + DMAC_STRIDE_C_offs
FD7E                  jim_DMAC_STRIDE_D               EQU     jim_DMAC + DMAC_STRIDE_D_offs
                      
FD80                  jim_DMAC_SND_DATA               EQU     jim_DMAC + DMAC_SND_DATA_offs
FD81                  jim_DMAC_SND_ADDR               EQU     jim_DMAC + DMAC_SND_ADDR_offs
FD84                  jim_DMAC_SND_PERIOD             EQU     jim_DMAC + DMAC_SND_PERIOD_offs
FD86                  jim_DMAC_SND_LEN                EQU     jim_DMAC + DMAC_SND_LEN_offs
FD88                  jim_DMAC_SND_STATUS             EQU     jim_DMAC + DMAC_SND_STATUS_offs
FD89                  jim_DMAC_SND_VOL                EQU     jim_DMAC + DMAC_SND_VOL_offs
FD8A                  jim_DMAC_SND_REPOFF             EQU     jim_DMAC + DMAC_SND_REPOFF_offs
FD8C                  jim_DMAC_SND_PEAK               EQU     jim_DMAC + DMAC_SND_PEAK_offs
                      
                      
FD8F                  jim_DMAC_SND_SEL                EQU     jim_DMAC + DMAC_SND_SEL_offs
FD8E                  jim_DMAC_SND_MA_VOL             EQU     jim_DMAC + DMAC_SND_MA_VOL_offs
                      
FD90                  jim_DMAC_DMA_CTL                EQU     jim_DMAC + DMAC_DMA_CTL_offs
FD91                  jim_DMAC_DMA_SRC_ADDR           EQU     jim_DMAC + DMAC_DMA_SRC_ADDR_offs
FD94                  jim_DMAC_DMA_DEST_ADDR          EQU     jim_DMAC + DMAC_DMA_DEST_ADDR_offs
FD97                  jim_DMAC_DMA_COUNT              EQU     jim_DMAC + DMAC_DMA_COUNT_offs
FD99                  jim_DMAC_DMA_DATA               EQU     jim_DMAC + DMAC_DMA_DATA_offs
FD9A                  jim_DMAC_DMA_CTL2               EQU     jim_DMAC + DMAC_DMA_CTL2_offs
FD9B                  jim_DMAC_DMA_PAUSE              EQU     jim_DMAC + DMAC_DMA_PAUSE_offs
FD9F                  jim_DMAC_DMA_SEL                EQU     jim_DMAC + DMAC_DMA_SEL_offs
                      
00D0                  JIM_DEVNO_HOG1MPAULA            EQU     $D0
00D1                  JIM_DEVNO_BLITTER               EQU     $D1
                      
                      
                              ENDIF
                                      include "../../../includes/common.inc"
                                      ; processor flags
0001                  CC_C            EQU     $01
0002                  CC_V            EQU     $02
0004                  CC_Z            EQU     $04
0008                  CC_N            EQU     $08
0010                  CC_I            EQU     $10
0020                  CC_H            EQU     $20
0040                  CC_F            EQU     $40
0080                  CC_E            EQU     $80
                      
                      m_tax           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    X
                                      ENDM
                      
                      m_tax_se        MACRO
                                      jsr     _m_tax_se
                                      ENDM
                      
                      
                      m_tay           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      m_tay_c         MACRO
                                      pshs    A
                                      lda     #0
                                      sta     ,-S
                                      lda     1,S
                                      puls    Y
                                      ENDM
                      
                      
                      m_tbx           MACRO
                                      pshs    B                       ;6
                                      clr     ,-S                     ;8
                                      puls    X                       ;7 = 21
                                      ENDM
                      
                      m_tby           MACRO
                                      pshs    B
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      
                      m_txa           MACRO
                                      pshs    X
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_tya           MACRO
                                      pshs    Y
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_txb           MACRO
                                      pshs    X
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      m_tyb           MACRO
                                      pshs    Y
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      
                      
0002                  BRKSIZE         EQU     2
                      
                      
                      DEBUG_INST      MACRO
                                      SWI
                                      ENDM
                      
                      BRK     MACRO
                              swi3
                              ENDM
                      
                      DO_BRK  MACRO
                              BRK
                              FCB     \1
                              FCB     \2,0
                              ENDM
                      
                      
                      CLI     MACRO
                              ANDCC   #~(CC_I)
                              ENDM
                      
                      SEI     MACRO
                              ORCC    #CC_I
                              ENDM
                      
                      CLC     MACRO
                              ANDCC   #~CC_C
                              ENDM
                      
                      SEC     MACRO
                              ORCC    #CC_C
                              ENDM
                      
                      CLV     MACRO
                              ANDCC   #~CC_V
                              ENDM
                      
                      SEV     MACRO
                              ORCC    #CC_V
                              ENDM
                      
                      CLZ     MACRO
                              ANDCC   #~CC_Z
                              ENDM
                      
                      SEZ     MACRO
                              ORCC    #CC_Z
                              ENDM
                      
                      
                      STX_B   MACRO
                              PSHS    D
                              TFR     X,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      
                      STY_B   MACRO
                              PSHS    D
                              TFR     Y,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      LDX_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,X
                              PULS    D
                              ENDM
                      
                      LDY_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,Y
                              PULS    D
                              ENDM
                      
                      OSCALL  MACRO
                              JSR     \1
                              ENDM
                      
                      OSJMP   MACRO
                              JMP     \1
                              ENDM
                                      include "../../../includes/mosrom.inc"
0063                  mos_MACHINE_TYPE_BYTE                   EQU $63
                      
                      * Address of MOS ROM base
C000                  MOSROMBASE                              EQU $C000
F500                  MOSSTRINGS                              EQU $F500
                      
                      * default direct page for MOS ROM
0000                  MOSROMSYS_DP                            EQU $0
                      
                      * OSENTRIESLOC - this is the area that contains the OS call JSRs
                      * to mimic the published BBC MOS API
FFB6                  OSENTRIESLOC                            EQU $FFB6
                      
FF98                  JGH_OSENTRIESLOC                        EQU OSENTRIESLOC-3*10
                      
FF8C                  DOM_DEBUG_ENTRIES                       EQU JGH_OSENTRIESLOC-3*4
                      
                      * BOUNCELOC - an area of "bounces" where the indirected jumps and
                      * jsrs are stored - these need an extra instruction byte to 6502
                      * so must indirect through here
FF6C                  BOUNCELOC                               EQU JGH_OSENTRIESLOC-4*11
                      
                      
                      
0003                  FSCV_CODE_OSCLI_UK                      EQU $03
                      
                      
0000                  zp_lang                                 EQU $0000
0090                  zp_eco                                  EQU $0090
00A0                  zp_nmi                                  EQU $00A0
00A9                  L00A9                                   EQU $00A9
00B0                  zp_fs_s                                 EQU $00B0
00C0                  zp_fs_w                                 EQU $00C0
00D0                  zp_vdu_status                           EQU $00D0       ; VDU Status as read by OSBYTE &75
00D1                  zp_vdu_grpixmask                        EQU $00D1       ; Graphics pixel mask
00D2                  zp_vdu_txtcolourOR                      EQU $00D2       ; Text colour OR mask
00D3                  zp_vdu_txtcolourEOR                     EQU $00D3       ; Text colour EOR mask
00D4                  zp_vdu_gracolourOR                      EQU $00D4       ; Graphics colour OR mask
00D5                  zp_vdu_gracolourEOR                     EQU $00D5       ; Graphics colour EOR mask
00D6                  zp_vdu_gra_char_cell                    EQU $00D6       ; Graphics character cell
00D8                  zp_vdu_top_scanline                     EQU $00D8       ; Top scan line
00DA                  zp_vdu_wksp                             EQU $00DA       ; Temporary workspace
                      ;;;;removed !zp_rom_mul                 EQU $00E0       ; BBC, Electron: Row multiplication
00E2                  zp_cfs_w                                EQU $00E2
00E3                  zp_opt_val                              EQU $00E3       ; DB? check
00E4                  zp_mos_GSREAD_quoteflag                 EQU $00E4       ; GSREAD quote flag
00E5                  zp_mos_GSREAD_characc                   EQU $00E5       ; GSREAD character accumulator
00E6                  zp_mos_OS_wksp                          EQU $00E6       ; General OS workspace
00E7                  zp_mos_autorep_countdown                EQU $00E7       ; Auto repeat countdown timer
00E8                  zp_mos_input_buf                        EQU $00E8       ; Input buffer pointer for OSWORD 0
00EA                  zp_mos_rs423timeout                     EQU $00EA       ; RS423 timeout counter, unused if no RS423
00EB                  zp_mos_cfs_critical                     EQU $00EB       ; CFS/RFS 'critical' flag
00EC                  zp_mos_keynumlast                       EQU $00EC       ; Internal key number (last)
00ED                  zp_mos_keynumfirst                      EQU $00ED       ; Internal key number (first)
00EE                  zp_mos_jimdevsave                       EQU $00EE       ; Internal key number of character to be ignored by OSBYTE &79, also the 1MHz bus paging register
00EF                  zp_mos_OSBW_A                           EQU $00EF       ; OSBYTE/OSWORD A reg value
                              ***** NOTE: zp_mos_OSBW_Y&X swapped for endiannedss
00F0                  zp_mos_OSWORD_X                         EQU $00F0
00F0                  zp_mos_OSBW_Y                           EQU $00F0       ; OSBYTE/OSWORD Y reg value
00F1                  zp_mos_OSBW_X                           EQU $00F1       ; OSBYTE/OSWORD X reg value
                      
00F2                  zp_mos_txtptr                           EQU $00F2       ; OS Text pointer (eg star commands and filenames)
00F4                  zp_mos_curROM                           EQU $00F4       ; Currently selected ROM
00F5                  zp_mos_curPHROM                         EQU $00F5       ; Current PHROM or RFS ROM number or OSRDSC/OSWRSC number
00F6                  zp_mos_genPTR                           EQU $00F6       ; PHROM/RFSROM/OSRDSC/OSWRSC pointer
00F8                  zp_mos_X                                EQU $00F8       ; BBC, Electron: Unused, Master: Soft key expansion pointer
00FA                  zp_mos_OS_wksp2                         EQU $00FA       ; General OS workspace, used by buffer access code in interrupts
00FC                  zp_mos_INT_A                            EQU $00FC       ; Interrupt Temp A reg store
00FD                  zp_mos_error_ptr                        EQU $00FD       ; Error message pointer, initially set to language version string
00FF                  zp_mos_ESC_flag                         EQU $00FF       ; Escape flag (bit 7)
                      
0100                  stack                                   EQU $0100
0200                  STACKTOP                                EQU $0200
                      
0236                  sysvar_OSVARADDR                        EQU $0236       ; fx166/7 &A6/7 Address of OS variables
0238                  sysvar_ROMPTRTAB                        EQU $0238       ; fx168/9 &A8/9 Address of ROM pointer table
023A                  sysvar_ROMINFOTAB                       EQU $023A       ; fx170/1 &AA/B Address of ROM info table
023C                  sysvar_KEYB_ADDRTRANS                   EQU $023C       ; fx172/3 &AC/D Address of key translation table
023E                  sysvar_ADDRVDUVARS                      EQU $023E       ; fx174/5 &AE/F Address of VDU variables
0240                  sysvar_CFSTOCTR                         EQU $0240       ; fx176   &B0   CFS timeout counter, decremented every frame flyback
0241                  sysvar_CURINSTREAM                      EQU $0241       ; fx177   &B1   Currently selected input stream set with FX2
0242                  sysvar_KEYB_SEMAPHORE                   EQU $0242       ; fx178   &B2   BBC, Master: Keyboard semaphore
0243                  sysvar_PRI_OSHWM                        EQU $0243       ; fx179   &B3   Primary OSHWM
0244                  sysvar_CUR_OSHWM                        EQU $0244       ; fx180   &B4   Current OSHWM
0245                  sysvar_RS423_MODE                       EQU $0245       ; fx181   &B5   RS423 mode
0246                  sysvar_EXPLODESTATUS                    EQU $0246       ; fx182   &B6   BBC, Electron: Character definition explosion status
0247                  sysvar_CFSRFS_SWITCH                    EQU $0247       ; fx183   &B7   CFS/RFS switch
0248                  sysvar_VIDPROC_CTL_COPY                 EQU $0248       ; fx184   &B8   BBC, Master: RAM copy of VIDPROC control register
0249                  sysvar_VIDPROC_PAL_COPY                 EQU $0249       ; fx185   &B9   BBC, Master: RAM copy of VIDPROC palette register
024A                  sysvar_ROMNO_ATBREAK                    EQU $024A       ; fx186   &BA   ROM active last BRK
024B                  sysvar_ROMNO_BASIC                      EQU $024B       ; fx187   &BB   BASIC ROM number
024C                  sysvar_ADC_CUR                          EQU $024C       ; fx188   &BC   Current ADC Channel
024D                  sysvar_ADC_MAX                          EQU $024D       ; fx189   &BD   Maximum ADC Channel number
024E                  sysvar_ADC_ACCURACY                     EQU $024E       ; fx190   &BE   ADC conversion type/accuracy
024F                  sysvar_RS423_USEFLAG                    EQU $024F       ; fx191   &BF   RS423 use flag
0250                  sysvar_RS423_CTL_COPY                   EQU $0250       ; fx192   &C0   RAM copy of RS423 control register
0251                  sysvar_FLASH_CTDOWN                     EQU $0251       ; fx193   &C1   Flashing colour countdown timer
0252                  sysvar_FLASH_SPACE_PERIOD               EQU $0252       ; fx194   &C2   Flashing colour space period count set by FX9
0253                  sysvar_FLASH_MARK_PERIOD                EQU $0253       ; fx195   &C3   Flashing colour mark period count set by FX10
0254                  sysvar_KEYB_AUTOREP_DELAY               EQU $0254       ; fx196   &C4   Keyboard auto-repeat delay set by FX11
0255                  sysvar_KEYB_AUTOREP_PERIOD              EQU $0255       ; fx197   &C5   Keyboard auto-repeat period set by FX12
0256                  sysvar_EXEC_FILE                        EQU $0256       ; fx198   &C6   *EXEC file
0257                  sysvar_SPOOL_FILE                       EQU $0257       ; fx199   &C7   *SPOOL file handle
0258                  sysvar_BREAK_EFFECT                     EQU $0258       ; fx200   &C8   ESCAPE, BREAK effect
0259                  sysvar_KEYB_DISABLE                     EQU $0259       ; fx201   &C9   Keyboard disable
025A                  sysvar_KEYB_STATUS                      EQU $025A       ; fx202   &CA   Keyboard status byte
                                                                              ;Bit 7  =1 shift enabled   
                                                                              ;Bit 6  =1 control pressed 
                                                                              ;bit 5  =0 shift lock      
                                                                              ;Bit 4  =0 Caps lock       
                                                                              ;Bit 3  =1 shift pressed   
                      
025B                  sysvar_RS423_BUF_EXT                    EQU $025B       ; fx203   &CB   BBC, Master: Serial input buffer extent
025C                  sysvar_RS423_SUPPRESS                   EQU $025C       ; fx204   &CC   BBC, Master: Serial input supression flag
025D                  sysvar_RS423CASS_SELECT                 EQU $025D       ; fx205   &CD   BBC, Master: Serial/cassette selection flag
025E                  sysvar_ECO_OSBW_INTERCEPT               EQU $025E       ; fx206   &CE   Econet OSBYTE/OSWORD intercept flag
025F                  sysvar_ECO_OSRDCH_INTERCEPT             EQU $025F       ; fx207   &CF   Econet OSRDCH intercept flag
0260                  sysvar_ECO_OSWRCH_INTERCEPT             EQU $0260       ; fx208   &D0   Econet OSWRCH intercept flag
0261                  sysvar_SPEECH_SUPPRESS                  EQU $0261       ; fx209   &D1   Speech suppression status
0262                  sysvar_SOUND_SUPPRESS                   EQU $0262       ; fx210   &D2   Sound suppression status
0263                  sysvar_BELL_CH                          EQU $0263       ; fx211   &D3   BELL channel number
0264                  sysvar_BELL_ENV                         EQU $0264       ; fx212   &D4   BELL envelope number/amplitude
0265                  sysvar_BELL_FREQ                        EQU $0265       ; fx213   &D5   BELL frequency
0266                  sysvar_BELL_DUR                         EQU $0266       ; fx214   &D6   BELL duration
0267                  sysvar_STARTUP_DISPOPT                  EQU $0267       ; fx215   &D7   Startup display and BOOT error options
0268                  sysvar_KEYB_SOFTKEY_LENGTH              EQU $0268       ; fx216   &D8   Soft key string length
0269                  sysvar_SCREENLINES_SINCE_PAGE           EQU $0269       ; fx217   &D9   Screen lines since last page
026A                  sysvar_VDU_Q_LEN                        EQU $026A       ; fx218   &DA   256-number of items in VDU queue
026B                  sysvar_KEYB_TAB_CHAR                    EQU $026B       ; fx219   &DB   BBC, Master: TAB key character
026C                  sysvar_KEYB_ESC_CHAR                    EQU $026C       ; fx220   &DC   ESCAPE character
026D                  sysvar_KEYB_C0CF_INSERT_INT             EQU $026D       ; fx221   &DD   Char &C0-&CF buffer insert interpretation
026E                  sysvar_KEYB_D0DF_INSERT_INT             EQU $026E       ; fx222   &DE   Char &D0-&DF buffer insert interpretation
026F                  sysvar_KEYB_E0EF_INSERT_INT             EQU $026F       ; fx223   &DF   Char &E0-&EF buffer insert interpretation
0270                  sysvar_KEYB_F0FF_INSERT_INT             EQU $0270       ; fx224   &E0   Char &F0-&FF buffer insert interpretation
0271                  sysvar_KEYB_808F_INSERT_INT             EQU $0271       ; fx225   &E1   Char &80-&8F buffer insert interpretation (FKey)
0272                  sysvar_KEYB_909F_INSERT_INT             EQU $0272       ; fx226   &E2   Char &90-&9F buffer insert interpretation (Sh+FKey)
0273                  sysvar_KEYB_A0AF_INSERT_INT             EQU $0273       ; fx227   &E3   Char &A0-&AF buffer insert interpretation (Ct+FKey)
0274                  sysvar_KEYB_B0BF_INSERT_INT             EQU $0274       ; fx228   &E4   Char &B0-&BF buffer insert interpretation (Ct+Sh+FKey)
0275                  sysvar_KEYB_ESC_ACTION                  EQU $0275       ; fx229   &E5   ESCAPE key action
0276                  sysvar_KEYB_ESC_EFFECT                  EQU $0276       ; fx230   &E6   ESCAPE effects
0277                  sysvar_USERVIA_IRQ_MASK_CPY             EQU $0277       ; fx231   &E7   User 6522 VIA IRQ mask
0278                  sysvar_ACIA_IRQ_MASK_CPY                EQU $0278       ; fx232   &E8   6850 ACIA IRQ bit mask
0279                  sysvar_SYSVIA_IRQ_MASK_CPY              EQU $0279       ; fx233   &E9   System 6522 VIA IRQ mask
027A                  sysvar_TUBE_PRESENT                     EQU $027A       ; fx234   &EA   Tube presence flag
027B                  sysvar_SPEECH_PRESENT                   EQU $027B       ; fx235   &EB   Speech processor presence flag
027C                  sysvar_OUTSTREAM_DEST                   EQU $027C       ; fx236   &EC   Output stream character destination, set with FX3
027D                  sysvar_KEY_CURSORSTAT                   EQU $027D       ; fx237   &ED   Cursor key status, set with FX4
027E                  sysvar_FX238                            EQU $027E       ; fx238   &EE   BBC, Electron: unused
027F                  sysvar_FX239                            EQU $027F       ; fx239   &EF   unused
0280                  sysvar_COUNTRY                          EQU $0280       ; fx240   &F0   Country code
0281                  sysvar_USERFLAG                         EQU $0281       ; fx241   &F1   User flag location, set with FX1
0282                  sysvar_SERPROC_CTL_CPY                  EQU $0282       ; fx242   &F2   BBC, Master: RAM copy of SERPROC control register
0283                  sysvar_TIMER_SWITCH                     EQU $0283       ; fx243   &F3   Timer switch state
0284                  sysvar_KEYB_SOFT_CONSISTANCY            EQU $0284       ; fx244   &F4   Soft key consistancy flag
0285                  sysvar_PRINT_DEST                       EQU $0285       ; fx245   &F5   Printer destination, set with FX5
0286                  sysvar_PRINT_IGNORE                     EQU $0286       ; fx246   &F6   Printer ignore character, set with FX6
0287                  sysvar_BREAK_VECTOR_JMP                 EQU $0287       ; fx247   &F7   Break Intercept Vector JMP
0288                  sysvar_BREAK_VECTOR_LOW                 EQU $0288       ; fx248   &F8   Break Intercept Vector address low byte
0289                  sysvar_BREAK_VECTOR_HIGH                EQU $0289       ; fx249   &F9   Break Intercept Vector address high byte
028A                  sysvar_SHADOW1                          EQU $028A       ; fx250   &FA   BBC, Electron: unused, unless shadow screen present
028B                  sysvar_SHADOW2                          EQU $028B       ; fx251   &FB   BBC, Electron: unused, unless shadow screen present
028C                  sysvar_CUR_LANG                         EQU $028C       ; fx252   &FC   Current language ROM
028D                  sysvar_BREAK_LAST_TYPE                  EQU $028D       ; fx253   &FD   Last BREAK type
028E                  sysvar_RAM_AVAIL                        EQU $028E       ; fx254   &FE   BBC: Available RAM
028F                  sysvar_STARTUP_OPT                      EQU $028F       ; fx255   &FF   Startup options
0290                  oswksp_VDU_VERTADJ                      EQU $0290       ; VDU vertical adjust, *TV first parameter
0291                  oswksp_VDU_INTERLACE                    EQU $0291       ; Interlace toggle flag, *TV second parameter
0292                  oswksp_TIME                             EQU $0292       ; TIME value 1, high byte...low byte
0297                  oswksp_TIME2                            EQU $0297       ; TIME value 2, high byte...low byte
029C                  oswksp_OSWORD3_CTDOWN                   EQU $029C       ; OSWORD 3/4 Countdown interval timer value
02A1                  oswksp_ROMTYPE_TAB                      EQU $02A1       ; Paged ROM type table
02B1                  oswksp_INKEY_CTDOWN                     EQU $02B1       ; INKEY countdown timer
02B3                  oswksp_OSWORD0_LINE_LEN                 EQU $02B3       ; OSWORD 0 maximum line length
02B4                  oswksp_OSWORD0_MIN_CH                   EQU $02B4       ; OSWORD 0 minimum character
02B5                  oswksp_OSWORD0_MAX_CH                   EQU $02B5       ; OSWORD 0 maximum character
02B6                  adc_CH1_LOW                             EQU $02B6       ; Channel 1 ADC value low
02B7                  adc_CH2_LOW                             EQU $02B7       ; Channel 2 ADC value low
02B8                  adc_CH3_LOW                             EQU $02B8       ; Channel 3 ADC value low
02B9                  adc_CH4_LOW                             EQU $02B9       ; Channel 4 ADC value low
02BA                  adc_CH1_HI                              EQU $02BA       ; Channel 1 ADC value high
02BB                  adc_CH2_HI                              EQU $02BB       ; Channel 2 ADC value high
02BC                  adc_CH3_HI                              EQU $02BC       ; Channel 3 ADC value high
02BD                  adc_CH4_HI                              EQU $02BD       ; Channel 4 ADC value high
02BE                  adc_CH_LAST                             EQU $02BE       ; Last ADC channel converted
02BF                  mosvar_EVENT_ENABLE                     EQU $02BF       ; MOS Event enable flags
02C9                  mosvar_SOFTKEY_PTR                      EQU $02C9       ; Soft key expansion pointer
02CA                  mosvar_KEYB_AUTOREPEAT_COUNT            EQU $02CA       ; First auto repeat count
02CB                  mosvar_KEYB_TWOKEY_ROLLOVER             EQU $02CB       ; Two key rollover workspace
02CE                  mosvar_SOUND_SEMAPHORE                  EQU $02CE       ; Sound semaphore
02CF                  mosbuf_buf_busy                         EQU $02CF       ; Buffer busy flags           
02D8                  mosbuf_buf_start                        EQU $02D8       ; Buffer start indexes        
02E1                  mosbuf_buf_end                          EQU $02E1       ; Buffer end indexes          
02EA                  cfsrfs_BLK_SIZE                         EQU $02EA       ; Block size
02EC                  cfsrfs_BLK_FLAG                         EQU $02EC       ; Block flag
02ED                  cfsrfs_LAST_CHA                         EQU $02ED       ; Last input character
02EE                  osfile_ctlblk                           EQU $02EE       ; OSFILE control blocks for *LOAD, *SAVE, *CREATE and *DELETE.
0300                  vduvars_start                           EQU $0300
0300                  vduvar_GRA_WINDOW                       EQU $0300                               
0300                  vduvar_GRA_WINDOW_LEFT                  EQU $0300       ; Current graphics window left column in pixels
0302                  vduvar_GRA_WINDOW_BOTTOM                EQU $0302       ; Current graphics window bottom row in pixels
0304                  vduvar_GRA_WINDOW_RIGHT                 EQU $0304       ; Current graphics window right column in pixels
0306                  vduvar_GRA_WINDOW_TOP                   EQU $0306       ; Current graphics window top row in pixels
0308                  vduvar_TXT_WINDOW_LEFT                  EQU $0308       ; Current text window left hand column
0309                  vduvar_TXT_WINDOW_BOTTOM                EQU $0309       ; Current text window bottom row
030A                  vduvar_TXT_WINDOW_RIGHT                 EQU $030A       ; Current text window right hand column
030B                  vduvar_TXT_WINDOW_TOP                   EQU $030B       ; Current text window top column
030C                  vduvar_GRA_ORG_EXT                      EQU $030C       ; Current graphics origin in external coordinates
0310                  vduvar_GRA_CUR_EXT                      EQU $0310       ; Current graphics cursor in external coordinates
0314                  vduvar_GRA_CUR_INT_OLD                  EQU $0314       ; Old graphics cursor in external coordinates
0318                  vduvar_TXT_CUR_X                        EQU $0318       ; Current text cursor X
0319                  vduvar_TXT_CUR_Y                        EQU $0319       ; Current text cursor Y
031A                  vduvar_GRA_CUR_CELL_LINE                EQU $031A       ; Line within current graphics cell of graphics cursor
031B                  vduvar_VDU_Q_START                      EQU $031B
0324                  vduvar_VDU_Q_END                        EQU $0324       ; end of VDU Q (well 1 after!)
0324                  vduvar_GRA_CUR_INT                      EQU $0324       ; Current graphics cursor in internal coordinates
0328                  vduvar_TEMP_8                           EQU $0328       ; Bitmap read from screen by OSBYTE 135, various coordinate routines
0330                  vduvar_GRA_WKSP                         EQU $0330       ; Graphics workspace
034A                  vduvar_6845_CURSOR_ADDR                 EQU $034A       ; Text cursor address for 6845
034C                  vduvar_TXT_WINDOW_WIDTH_BYTES           EQU $034C       ; Text window width in bytes
034E                  vduvar_SCREEN_BOTTOM_HIGH               EQU $034E       ; High byte of bottom of screen memory
034F                  vduvar_BYTES_PER_CHAR                   EQU $034F       ; Bytes per character for current mode
0350                  vduvar_6845_SCREEN_START                EQU $0350       ; Screen display start address for 6845
0352                  vduvar_BYTES_PER_ROW                    EQU $0352       ; Bytes per screen row
0354                  vduvar_SCREEN_SIZE_HIGH                 EQU $0354       ; Screen memory size high byte
0355                  vduvar_MODE                             EQU $0355       ; Current screen mode
0356                  vduvar_MODE_SIZE                        EQU $0356       ; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
0357                  vduvar_TXT_FORE                         EQU $0357       ; Foreground text colour
0358                  vduvar_TXT_BACK                         EQU $0358       ; Background text colour
0359                  vduvar_GRA_FORE                         EQU $0359       ; Foreground graphics colour
035A                  vduvar_GRA_BACK                         EQU $035A       ; Background graphics colour
035B                  vduvar_GRA_PLOT_FORE                    EQU $035B       ; Foreground plot mode
035C                  vduvar_GRA_PLOT_BACK                    EQU $035C       ; Background plot mode
035D                  vduvar_VDU_VEC_JMP                      EQU $035D       ; General VDU jump vector
035F                  vduvar_CUR_START_PREV                   EQU $035F       ; Cursor start register previous setting
0360                  vduvar_COL_COUNT_MINUS1                 EQU $0360       ; Number logical colours -1
0361                  vduvar_PIXELS_PER_BYTE_MINUS1           EQU $0361       ; Pixels per byte -1 (zero if text only mode)
0362                  vduvar_LEFTMOST_PIX_MASK                EQU $0362       ; Leftmost pixel colour mask
0363                  vduvar_RIGHTMOST_PIX_MASK               EQU $0363       ; Rightmost pixel colour mask
0364                  vduvar_TEXT_IN_CUR_X                    EQU $0364       ; Text input cursor X
0365                  vduvar_TEXT_IN_CUR_Y                    EQU $0365       ; Text input cursor Y
0366                  vduvar_MO7_CUR_CHAR                     EQU $0366       ; Teletext output cursor character
0367                  vduvar_EXPLODE_FLAGS                    EQU $0367       ; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
0368                  vduvar_FONT_LOC32_63                    EQU $0368       ; Font location, characters 32-63
0369                  vduvar_FONT_LOC64_95                    EQU $0369       ; Font location, characters 64-95 
036A                  vduvar_FONT_LOC96_127                   EQU $036A       ; Font location, characters 96-127
036B                  vduvar_FONT_LOC128_159                  EQU $036B       ; Font location, characters 128-159
036C                  vduvar_FONT_LOC160_191                  EQU $036C       ; Font location, characters 160-191
036D                  vduvar_FONT_LOC192_223                  EQU $036D       ; Font location, characters 192-223
036E                  vduvar_FONT_LOC224_255                  EQU $036E       ; Font location, characters 224-255
036F                  vduvar_PALLETTE                         EQU $036F       ; Palette for colours 0 to 15
                      
03D1                  fsvar_seq_block_gap                     EQU $03D1
                      
                      ********************************************************
                      *           B U F F E R   A D D R E S S E S            *
                      ********************************************************
                      
03E0                  BUFFER_KEYB_START                       EQU $03E0
03FF                  BUFFER_KEYB_END                         EQU $03FF
0A00                  BUFFER_SERI_START                       EQU $0A00
0AFF                  BUFFER_SERI_END                         EQU $0AFF
0900                  BUFFER_SERO_START                       EQU $0900
09BF                  BUFFER_SERO_END                         EQU $09BF
0880                  BUFFER_LPT_START                        EQU $0880
08BF                  BUFFER_LPT_END                          EQU $08BF
0840                  BUFFER_SND0_START                       EQU $0840
084F                  BUFFER_SND0_END                         EQU $084F
0850                  BUFFER_SND1_START                       EQU $0850
085F                  BUFFER_SND1_END                         EQU $085F
0860                  BUFFER_SND2_START                       EQU $0860
086F                  BUFFER_SND2_END                         EQU $086F
0870                  BUFFER_SND3_START                       EQU $0870
087F                  BUFFER_SND3_END                         EQU $087F
09C0                  BUFFER_SPCH_START                       EQU $09C0
09FF                  BUFFER_SPCH_END                         EQU $09FF
                      
                      
                      BUFFER_PTR_ADDR         MACRO ; 1=START, 2=END
                                              FDB (\2+1)-$100
                                              ENDM
                      
                      BUFFER_ACC_OFF          MACRO ; 1=START, 2=END
                                              FCB \1-(\2+1)-$100              ; i.e. $100 - len!
                                              ENDM
                      
                      
                      
                      
0800                  snd_unused1                             EQU $800        ; Unused
0804                  snd_q_occupied                          EQU $804        ; Sound queue occupancy flag
0808                  snd_amplitude                           EQU $808        ; Current amplitude
080C                  snd_amplitude_phase_count               EQU $80C        ; Number of amplitude phases processed
0810                  snd_abs_pitch                           EQU $810        ; Absolute pitch value
0814                  snd_pitch_phase_count                   EQU $814        ; Number of pitch phases processed
0818                  snd_steps_left                          EQU $818        ; Number of steps to process
081C                  snd_duration_ctr                        EQU $81C        ; Duration
0820                  snd_duration_mul                        EQU $820        ; Interval multiplier
0824                  snd_env_no                              EQU $824        ; Envelope number/auto repeat parameter
0828                  snd_length_left                         EQU $828        ; Length of remaining note interval
082C                  snd_sync_hold_parm                      EQU $82C        ; Sync hold parameter
0830                  snd_chip_pitch                          EQU $830        ; Sound chip current pitch setting
0834                  snd_pitch_deviation                     EQU $834        ; Pitch deviation
0838                  snd_num_chans_sync                      EQU $838        ; Number of channels required for sync
0839                  snd_cur_amp_step                        EQU $839        ; Current amplitude step
083A                  snd_cur_target_amplitude                EQU $83A        ; Current target amplitude
083B                  snd_num_chans_hold_sync                 EQU $83B        ; Number of channels on hold for sync
                      
083C                  snd_parm_wksp                           EQU $83C        ; Sound parameter calculation workspace
083D                  snd_low_parm                            EQU $83D        ; Low order frequency parameter as sent to the sound generator
083E                  snd_high_parm                           EQU $83E        ; High order frequency parameter as sent to the sound generator
083F                  snd_tempx                               EQU $83F
                      
08C0                  snd_envelope_defs                       EQU $8C0
                      
0B00                  soft_keys_start                         EQU $B00
0B00                  soft_keys_ptrs                          EQU soft_keys_start
0B10                  soft_keys_end_ptr                       EQU soft_keys_ptrs+$10
0B11                  soft_keys_defs                          EQU soft_keys_start+$11
                      
0D00                  vec_nmi                                 EQU $0D00
                      
0DF0                  swrom_wksp_tab                          EQU $0DF0
                      
                      ; REMAPPED HARDWARE VECTOS
                      
F7F0                  HWVEC_DIV0                              EQU     $F7F0
F7F2                  HWVEC_SWI3V                             EQU     $F7F2
F7F4                  HWVEC_SWI2V                             EQU     $F7F4
F7F6                  HWVEC_FIRQV                             EQU     $F7F6
F7F8                  HWVEC_IRQV                              EQU     $F7F8
F7FA                  HWVEC_SWIV                              EQU     $F7FA
F7FC                  HWVEC_NMIV                              EQU     $F7FC
F7FE                  HWVEC_RESETV                            EQU     $F7FE
                                      include "../../../includes/noice.inc"
                      
                              IF NOICE_CODE_BASE
                              ELSE
                      NOICE_CODE_BASE         EQU     $F100   ; a hole to be left here for the noice debugger
                                                              ; if this constant is changed remember to update
                                                              ; README.txt, MONXXXX-dom1.asm and mosloader.asm
                                                              ; as required
                              ENDIF
                      
                              IF NOICE_CODE_LEN
                              ELSE
                      NOICE_CODE_LEN          EQU     $03B0   ; TODO: get this from the NOICE code?
                              ENDIF
                      
                      ;; - this now must be defined when building
                      ;;NOICE_RAM_START               EQU     $A00    ; START OF MONITOR RAM Workspace - use A00 for 
                      ;;                                      ; now which is Serial transient command buffer, 
                      ;;                                      ; might need to make an "official" hole in the 
                      ;;                                      ; memory map
                      
C200                  NOICE_BAUD_RATE         EQU     115200  ; Baud rate for serial comms
                      
                              ENDIF
                      
                              IF NOICE_MY
                      fred_MYELIN_SERIAL_STATUS       EQU     $FCA1
                      fred_MYELIN_SERIAL_DATA         EQU     $FCA0
                      MYELIN_SERIAL_TXRDY             EQU     2
                      MYELIN_SERIAL_RXRDY             EQU     1
                              ENDIF
                      
                      
                              IF DO_ROMLATCH
FE30                  MAPREG          EQU     sheila_ROMCTL_SWR
00F4                  MAPIMG          EQU     zp_mos_curROM
                              ENDIF
                      
                      * Ported to beeb6809 27/4/2017 Dominic Beesley
                      * adapted for both 6809 (define CPU_6809) or 6309 (define CPU_6309)
                      * adapted to chipkit with S16550 (define MACH_CHIPKIT) or Model B (define MACH_BEEB)
                      *  6809 Debug monitor for use with NOICE09
                      *
                      *  Copyright (c) 1992-2006 by John Hartman
                      *
                      *  Modification History:
                      *       14-Jun-93 JLH release version
                      *       24-Aug-93 JLH bad constant for COMBUF length compare
                      *       25-Feb-98 JLH assemble with either Motorola or Dunfield
                      *        1-May-06 JLH slight cleanup
                      *
                      *============================================================================
                      *
                      *  To customize for a given target, you must change code in the
                      *  hardware equates, the string TSTG, and the routines RESET and REWDT.
                      *  You may or may not need to change GETCHAR, PUTCHAR, depending on
                      *  how peculiar your UART is.
                      *
                      *  This file has been assembled with the Motorola Freeware assembler
                      *  available from the Motorola Freeware BBS and elsewhere.
                      *   BUT:  you must first "comment out" the conditionals as required,
                      *   because the Motorola assemblers do not have any IFEQ/ELSE/ENDIF
                      *
                      *  This file may also be assembled with the Dunfield assembler
                      *
                      *  To add mapped memory support:
                      *       1) Define map port MAPREG here
                      *       2) Define or import map port RAM image MAPIMG here if MAPREG is
                      *          write only.  (The application code must update MAPIMG before
                      *          outputing to MAPREG)
                      *       3) Search for and modify MAPREG, MAPIMG, and REG_PAGE usage below
                      *       4) In TSTG below edit "LOW AND HIGH LIMIT OF MAPPED MEM"
                      *          to appropriate range (typically 4000H to 07FFFH for two-bit MMU)
                      *
                      
                      *
                      *============================================================================
                      *
                      *  RAM interrupt vectors (first in SEG for easy addressing, else move to
                      *  their own SEG)
0008                  NVEC            EQU     8             ; number of vectors
                      *
                      *  Initial user stack
                      *  (Size and location is user option)
0200                  INITSTACK               EQU     $200
                      
                      
                      
C000                                  ORG     NOICE_RAM_START                 ; use cassette / serial input buffer 
C100                  MONSTACK        EQU     NOICE_RAM_START + $100          ; top of!
                      
                              IF CPU_6309
C000                  TEST_STACK      RMB     14
                      * It is not possible to read bits 0&1 of regMD so the next three lines enable
                      * testing of these bits.
C00E                  E_FLAG          RMB     1               0=not set $80=set
C00F                  S_IMAGE         RMB     2               temporary store for regS
                              ENDIF
                      
                      *  Target registers:  order must match that in TRGHC11.C
C011                  TASK_REGS
C011                  REG_STATE       RMB     1
C012                  REG_PAGE        RMB     1
C013                  REG_SP          RMB     2
C015                  REG_U           RMB     2
C017                  REG_Y           RMB     2
C019                  REG_X           RMB     2
                              IF CPU_6309
C01B                  REG_F           RMB     1               F BEFORE E, SO W IS LEAST SIG. FIRST
C01C                  REG_E           RMB     1
                              ENDIF
C01D                  REG_B           RMB     1               B BEFORE A, SO D IS LEAST SIG. FIRST
C01E                  REG_A           RMB     1
C01F                  REG_DP          RMB     1
C020                  REG_CC          RMB     1
                              IF CPU_6309
C021                  REG_MD          RMB     1
C022                  REG_V           RMB     2
                              ENDIF
C024                  REG_PC          RMB     2
0015                  TASK_REG_SZ     EQU     *-TASK_REGS
                                              IF STANDALONE
                      RAMVEC          RMB     2*NVEC
                                              ENDIF
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
                      RUNNING_FLAG    RMB     1
                              ENDIF
                      
                      *
                      *  Communications buffer
                      *  (Must be at least as long as TASK_REG_SZ.  At least 19 bytes recommended.
                      *  Larger values may improve speed of NoICE memory move commands.)
0080                  COMBUF_SIZE     EQU     128             DATA SIZE FOR COMM BUFFER
C026                  COMBUF          RMB     2+COMBUF_SIZE+1 BUFFER ALSO HAS FN, LEN, AND CHECK
                      
                              IF NOICE_DEBUG_MEMMAP
C0A9                  RW_MEM_CODE_SAVE
C0A9                                  RMB     $100
                              ENDIF
                      
                      *
C1A9                  RAM_END         EQU    *               ADDRESS OF TOP+1 OF RAM
                      
                                      IF      STANDALONE
                      *
                      *===========================================================================
                      * Bodge to make ROM start at $8000
                                      IF      NOICE_CODE_BASE != $8000
                                      ORG     $8000
                                              NOP
                                              FILL    $FF,NOICE_CODE_BASE-*
                                      ENDIF
                                      ENDIF
                      
                      
F100                                  ORG     NOICE_CODE_BASE
                      
                                      IF STANDALONE==0
F100  F537            ENTER_NMI_ENT           FDB     NMI_ENT
F102  F532            ENTER_SWI_ENT           FDB     SWI_ENT
F104  F140            ENTER_PUTCHAR           FDB     PUTCHAR
F106  F108            ENTER_RESET             FDB     RESET
                                      ENDIF
                      *
                      *  Power on reset
F108                  RESET
                      
                              IF      STANDALONE
                      *
                      *  Set CPU mode to safe state
                                      ORCC    #CC_I+CC_F            ; INTERRUPTS OFF
                                      LDS     #MONSTACK       ; CLEAN STACK IS HAPPY STACK
                      *
                      *----------------------------------------------------------------------------
                      
                      
                      SCREEN_BASEx8   EQU     0
                      
                      ; setup CRTC to show bottom part of RAM in mode 1
                      
                                      ; setup CRTC
                                      LDB     #$B
                                      LDX     #mostbl_VDU_6845_mode_012
                      crtcsetlp1      STB     sheila_CRTC_reg
                                      LDA     B,X
                                      STA     sheila_CRTC_rw
                                      DECB
                                      BPL     crtcsetlp1
                      
                                      LDA     #12
                                      STA     sheila_CRTC_reg
                                      LDA     #SCREEN_BASEx8 / $100
                                      STA     sheila_CRTC_rw
                      
                                      LDA     #13
                                      STA     sheila_CRTC_reg
                                      LDA     #SCREEN_BASEx8 % $100
                                      STA     sheila_CRTC_rw
                      
                                      LDA     #$9C
                                      STA     sheila_VIDULA_ctl
                      
                                      LDA     #12
                                      STA     sheila_CRTC_reg
                                      LDA     #SCREEN_BASEx8 / $100
                                      STA     sheila_CRTC_rw
                      
                                      LDA     #13
                                      STA     sheila_CRTC_reg
                                      LDA     #SCREEN_BASEx8 % $100
                                      STA     sheila_CRTC_rw
                      
                                      LDB     #0
                      pallp           TFR     B,A
                                      TSTB
                                      BPL     1F
                                      ORA     #$F
                      1               STA     sheila_VIDULA_pal
                                      ADDB    #$10
                                      BNE     pallp
                              ENDIF
                      
                              IF MACH_CHIPKIT
                      *
                      *  Initialize UART
                      *
                      *  Delay here in case the UART has not come out of reset yet.
                                      LDX     #0
                      LOP             LEAX    -1,X                  ;  DELAY FOR SLOW RESETTING UART
                                      NOP
                                      NOP
                                      BNE     LOP
                      *
                      *  access baud generator, no parity, 1 stop bit, 8 data bits
                                      LDA     #$83
                                      STA     S16550_LCR
                                      LDA     #%10000111                      ; enable FIFOs and clear trigger RECV interrupt at 8
                                      STA     S16550_FCR                      ; no FIFOs
                      
                      *
                      *  fixed baud rate of 19200:  crystal is 3.686400 Mhz.
                      *  Divisor is 4000000/(16*baud)
                      BAUD_WORD       EQU SER_BAUD_CLOCK_IN/(NOICE_BAUD_RATE*16)
                                      LDA     #BAUD_WORD%256
                                      STA     S16550_RXR              ; lsb
                                      LDA     #BAUD_WORD/256
                                      STA     S16550_RXR+1            ; msb=0
                      *
                      *  access data registers, no parity, 1 stop bits, 8 data bits
                                      LDA     #$03
                                      STA     S16550_LCR
                      *
                      *  no loopback, OUT2 on, OUT1 on, RTS on, DTR (LED) on
                                      LDA     #$0F
                                      STA     S16550_MCR
                      *
                      *  disable all interrupts: modem, receive error, transmit, and receive
                                      LDA     #$00
                                      STA     S16550_IER
                              ENDIF
                      
                              IF STANDALONE
                      *
                      *----------------------------------------------------------------------------
                      *
                      *  Initialize RAM interrupt vectors
                                      LDY     #INT_ENTRY      ; ADDRESS OF DEFAULT HANDLER
                                      LDX     #RAMVEC         ; POINTER TO RAM VECTORS
                                      LDB     #NVEC           ; NUMBER OF VECTORS
                      RES10           STY     ,X++            ; SET VECTOR
                                      DECB
                                      BNE     RES10
                      
                              ENDIF
                      *
                      *  Initialize user registers
                      
F108  C615                            LDB     #TASK_REG_SZ
F10A  8EC011                          LDX     #TASK_REGS
F10D  6F80            1               CLR     ,X+
F10F  5A                              DECB
F110  26FB                            BNE     1B
                      
F112  CC0200                          LDD     #INITSTACK
F115  B7C014                          STA     REG_SP+1                ; INIT USER'S STACK POINTER MSB
F118  F7C013                          STB     REG_SP                  ; LSB
                      
F11B  86D0                            LDA     #CC_E+CC_I+CC_F                  ; state "all regs pushed", no ints
F11D  B7C020                          STA     REG_CC
                      *
                      *  Set function code for "GO".  Then if we reset after being told to
                      *  GO, we will come back with registers so user can see the crash
F120  86FA                            LDA     #FN_RUN_TARG
F122  B7C026                          STA     COMBUF
                      
                              IF      STANDALONE
                      BEEP_FREQ       EQU     525
                      BEEP_76489CLK   EQU     4000000
                      
                                      JSR     reset_snd
                                      LDA     #2
                                      LDX     #((BEEP_76489CLK/32)/BEEP_FREQ)
                                      JSR     snd_tone
                                      LDA     #2
                                      LDB     #$0
                                      JSR     snd_vol
                                      LDX     #0
                      1               BRA     2F
                      2               BRA     3F
                      3               LEAX    -1,X
                                      BNE     1B
                                      LDA     #2
                                      LDB     #$F
                                      JSR     snd_vol
                      
                                      JMP     RETURN_REGS             ; DUMP REGS, ENTER MONITOR
                      
                              ELSE
                                      IF NOICE_DEBUG_MEMMAP
                                      ELSE
                                              LDA     #$FF
                                              STA     RUNNING_FLAG            ; mark as running and drop back to MOS ROM init code
                                      ENDIF
F125  39                                      RTS                             ; return to MOS
                              ENDIF
                      
                      *
                      *===========================================================================
                      *  Get a character to A
                      *
                      *  Return A=char, CY=0 if data received
                      *         CY=1 if timeout (0.5 seconds)
                      *
                      *  Uses 6 bytes of stack including return address
                      *
F126                  GETCHAR
F126  3410                            PSHS    X
F128  8E0000                          LDX     #0                      ; LONG TIMEOUT
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ORA     #LED_WT_RX
                                      STA     LEDS
                              ENDIF
F12B  301F            GC10            LEAX    -1,X
F12D  270D                            BEQ     GC90                    ; EXIT IF TIMEOUT
                              IF MACH_BEEB
                              IF NOICE_MY
                                      LDA     fred_MYELIN_SERIAL_STATUS
                                      ANDA    #MYELIN_SERIAL_RXRDY
                              ELSE
F12F  B6FE08                          LDA     sheila_ACIA_CTL         ; READ DEVICE STATUS
F132  8401                            ANDA    #1
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      LDA     S16550_LSR              ; READ DEVICE STATUS
                                      ANDA    #SER_BIT_RXRDY
                              ENDIF
                              IF MACH_WBONE
                                      TST     sheila_SERIAL2_STATUS
                                      BMI     GC10
                              ELSE
F134  27F5                            BEQ     GC10                    ; NOT READY YET.
                              ENDIF
                      *
                      *  Data received:  return CY=0. data in A
F136  4F                              CLRA                            ; CY=0
                              IF MACH_BEEB
                              IF NOICE_MY
                                      LDA     fred_MYELIN_SERIAL_DATA ; READ DATA
                              ELSE
F137  B6FE09                          LDA     sheila_ACIA_DATA        ; READ DATA
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      LDA     S16550_RXR              ; READ DATA
                              ENDIF
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ANDA    #~LED_WT_RX
                                      STA     LEDS
                                      LDA     sheila_SERIAL2_DATA
                              ENDIF
F13A  3590                            PULS    X,PC
                      
                      *
                      *  Timeout:  return CY=1
F13C                  GC90            
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ANDA    #~LED_WT_RX
                                      ORA     #LED_TO_RX
                                      STA     LEDS
                      
                                      JSR     PIPDLY
                      
                                      ANDA    #~LED_TO_RX
                                      STA     LEDS
                      
                              ENDIF
F13C  1A01                            ORCC    #CC_C                   ; CY=1
F13E  3590                            PULS    X,PC
                      
                              IF MACH_WBONE
                      PIPDLY
                                      PSHS    X
                                      LDX     #1000
                      1               LEAX    -1,X
                                      BNE     1B
                                      PULS    X,PC
                              ENDIF
                      
                      
                      *
                      *===========================================================================
                      *  Output character in A
                      *
                      *  Uses 5 bytes of stack including return address
                      *
F140                  PUTCHAR
F140  3402                            PSHS    A
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ORA     #LED_WT_TX
                                      STA     LEDS
                              ENDIF
F142                  PC10    
                              IF MACH_BEEB
                              IF NOICE_MY
                                      LDA     fred_MYELIN_SERIAL_STATUS       ; CHECK TX STATUS
                                      ANDA    #MYELIN_SERIAL_TXRDY            ; TX READY ?
                              ELSE
F142  B6FE08                          LDA     sheila_ACIA_CTL ; CHECK TX STATUS
F145  8402                            ANDA    #2              ; TX READY ?
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      LDA     S16550_LSR     ; CHECK TX STATUS
                                      ANDA    #SER_BIT_TXRDY ; RX READY ?
                              ENDIF
                              IF MACH_WBONE
                                      LDA     sheila_SERIAL2_STATUS
                                      ANDA    #SER_STAT_nTXE
                                      BNE     PC10
                              ELSE
F147  27F9                            BEQ     PC10    
                              ENDIF
F149  3502                            PULS    A
                              IF MACH_BEEB
                              IF NOICE_MY
                                      STA     fred_MYELIN_SERIAL_DATA
                              ELSE    
F14B  B7FE09                          STA     sheila_ACIA_DATA
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      STA     S16550_TXR     ; TRANSMIT CHAR.
                              ENDIF
                              IF MACH_WBONE
                                      STA     sheila_SERIAL2_DATA
                                      PSHS    A
                                      LDA     LEDS
                                      ANDA    #~LED_WT_TX
                                      STA     LEDS
                                      PULS    A
                              ENDIF
F14E  39                              RTS
                      
                      *======================================================================
                      *  Response string for GET TARGET STATUS request
                      *  Reply describes target:
F14F                  TSTG    
                              IF CPU_6309
F14F  11                              FCB     17                      ; 2: PROCESSOR TYPE = 6309
                              ELSE
                                      FCB     5                       ; 2: PROCESSOR TYPE = 6809
                              ENDIF
F150  80                              FCB     COMBUF_SIZE             ; 3: SIZE OF COMMUNICATIONS BUFFER
F151  00                              FCB     0                       ; 4: NO TASKING SUPPORT
                              IF DO_ROMLATCH
F152  8000BFFF                        FDB     $8000,$BFFF             ; PAGED SW ROM/RAM at $8000
                              ELSE
                                      FDB     0,0                     ; 5-8: LOW AND HIGH LIMIT OF MAPPED MEM (NONE)
                              ENDIF
F156  01                              FCB     B1-B0                   ; 9:  BREAKPOINT INSTR LENGTH
F157  3F              B0              SWI                             ; 10: BREAKPOINT INSTRUCTION
F158                  B1              
                              IF CPU_6309
F158  36333039                        FCC     "6309"
                              ELSE
                                      FCC     "6809"
                              ENDIF
F15C  206D6F6E69746F722056312E312D                 FCC     " monitor V1.1-"        ; DESCRIPTION, ZERO
                              IF MACH_CHIPKIT
                                      FCC     "-chipkit"
                              ENDIF
                              IF MACH_BEEB
F16A  2D424243                        FCC     "-BBC"
                              ENDIF
                              IF MACH_WBONE
                                      FCC     "-WBONE"
                              ENDIF
F16E  00                              FCB     0 
0020                  TSTG_SIZE       EQU     *-TSTG          ; SIZE OF STRING
                      *
                      *======================================================================
                      *  HARDWARE PLATFORM INDEPENDENT EQUATES AND CODE
                      *
                      *  Communications function codes.
00FF                  FN_GET_STAT     EQU     $FF    ; reply with device info
00FE                  FN_READ_MEM     EQU     $FE    ; reply with data
00FD                  FN_WRITE_M      EQU     $FD    ; reply with status (+/-)
00FC                  FN_READ_RG      EQU     $FC    ; reply with registers
00FB                  FN_WRITE_RG     EQU     $FB    ; reply with status
00FA                  FN_RUN_TARG     EQU     $FA    ; reply (delayed) with registers
00F9                  FN_SET_BYTE     EQU     $F9    ; reply with data (truncate if error)
00F8                  FN_IN           EQU     $F8    ; input from port
00F7                  FN_OUT          EQU     $F7    ; output to port
                      *
00F7                  FN_MIN          EQU     $F7    ; MINIMUM RECOGNIZED FUNCTION CODE
00F0                  FN_ERROR        EQU     $F0    ; error reply to unknown op-code
                      *
                      *===========================================================================
                      *  Common handler for default interrupt handlers
                      *  Enter with A=interrupt code = processor state
                      *  All registers stacked, PC=next instruction
                      *
                      *  If 6809 mode, stack has CC A B DP XH XL YH YL UH UL PCH PCL
                      *  If 6309 mode, stack has CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      *
F16F                  INT_ENTRY
F16F  B7C011                          STA     REG_STATE       ; SAVE STATE
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
                                      CMPA    #2              ; DB: check for NMI
                                      BNE     INT_ENTRY_GO
                                      TST     RUNNING_FLAG    ; not running just RTI
                                      BNE     INT_ENTRY_GO
                                      RTI
                      INT_ENTRY_GO
                              ENDIF
                      
                      *
                      *  Save registers from stack to reg block for return to master
                      *  Host wants least significant bytes first, so flip as necessary
F172  3502                            PULS    A
F174  B7C020                          STA     REG_CC          ; CONDITION CODES
F177  3502                            PULS    A
F179  B7C01E                          STA     REG_A           ; A
F17C  3502                            PULS    A
F17E  B7C01D                          STA     REG_B           ; B
                      
                              IF CPU_6309
                      
F181  BDF1EE                          JSR     CHECK_6309
F184  2635                            BNE     NOT_6309_1
                      
                      *  If native mode, E and F are on stack
                      *  If 6809 mode, E and F are in registers, unchanged from interrupt til here
                              ; clear BIT 1 of REG_MD before test and set if in 6309 mode
F186  72FEC021                        AIM     #$FE,REG_MD
F18A  BDF53C                          JSR     MD_TEST
F18D  2606                            BNE     IE_10           ; Jump if 6809 mode
F18F  1039                            PULSW                   ; else native: get from stack
F191  7101C021                        OIM     #$1,REG_MD
F195  11B7C01C        IE_10           STE     REG_E
F199  11F7C01B                        STF     REG_F
                      
                      *  V isn't on the stack, but we haven't touched it.  Copy to RAM
F19D  1F70                            TFR     V,D
F19F  B7C023                          STA     REG_V+1         ; MSB V
F1A2  F7C022                          STB     REG_V           ; LSB V
                      
                      *  There seems to be no way to store MD, and no way to load it except immediate
                      *  Thus we have to construct it by BITMD
F1A5  B6C021                          LDA     REG_MD
                                      ; DB: Changed this TEST_MD wasn't saving the bits!
F1A8  8403                            ANDA    #$03            ; save only bits 1 and 0 (set by MD_TEST)
F1AA  113C40                          BITMD   #$40
F1AD  2702                            BEQ     IE_11
F1AF  8A40                            ORA     #$40
F1B1  113C80          IE_11           BITMD   #$80
F1B4  2702                            BEQ     IE_12
F1B6  8A80                            ORA     #$80
F1B8  B7C021          IE_12           STA     REG_MD
                      
F1BB                  NOT_6309_1
                              ENDIF
                      
F1BB  3502                            PULS    A
F1BD  B7C01F                          STA     REG_DP          ; DP
F1C0  3506                            PULS    D
F1C2  B7C01A                          STA     REG_X+1         ; MSB X
F1C5  F7C019                          STB     REG_X           ; LSB X
F1C8  3506                            PULS    D
F1CA  B7C018                          STA     REG_Y+1         ; MSB Y
F1CD  F7C017                          STB     REG_Y           ; LSB Y
F1D0  3506                            PULS    D
F1D2  B7C016                          STA     REG_U+1         ; MSB U
F1D5  F7C015                          STB     REG_U           ; LSB U
                      *
                      *  If this is a breakpoint (state = 1), then back up PC to point at SWI
F1D8  3510                            PULS    X               ; PC AFTER INTERRUPT
F1DA  B6C011                          LDA     REG_STATE
F1DD  8101                            CMPA    #1              
F1DF  2602                            BNE     NOTBP           ; BR IF NOT A BREAKPOINT
F1E1  301F                            LEAX    -(B1-B0),X            ; ELSE BACK UP TO POINT AT SWI LOCATION
F1E3  1F10            NOTBP           TFR     X,D             ; TRANSFER PC TO D
F1E5  B7C025                          STA     REG_PC+1        ; MSB
F1E8  F7C024                          STB     REG_PC          ; LSB
F1EB  7EF459                          JMP     ENTER_MON       ; REG_PC POINTS AT POST-INTERRUPT OPCODE
                      
                              IF CPU_6309
                              ; check if this is really a 6309
F1EE  1FC0            CHECK_6309      tfr     0,D
F1F0  5D                              tstb
F1F1  39                              rts
                              ENDIF
                      
                      
                      *
                      *===========================================================================
                      *  Main loop  wait for command frame from master
                      *
                      *  Uses 6 bytes of stack including return address
                      *
F1F2                  MAIN            
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
                                      CLR     RUNNING_FLAG            ; DB: reset running flag to 0 block further NMIs
                              ENDIF
F1F2  10CEC100                        LDS     #MONSTACK               ; CLEAN STACK IS HAPPY STACK
F1F6  8EC026                          LDX     #COMBUF                 ; BUILD MESSAGE HERE
                      *
                      *  First byte is a function code
F1F9  BDF126                          JSR     GETCHAR                 ; GET A FUNCTION (6 bytes of stack)
F1FC  25F4                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F1FE  81F7                            CMPA    #FN_MIN
F200  25F0                            BLO     MAIN                    ; JIF BELOW MIN: ILLEGAL FUNCTION
F202  A780                            STA     ,X+                     ; SAVE FUNCTION CODE
                      *
                      *  Second byte is data byte count (may be zero)
F204  BDF126                          JSR     GETCHAR                 ; GET A LENGTH BYTE
F207  25E9                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F209  8180                            CMPA    #COMBUF_SIZE
F20B  22E5                            BHI     MAIN                    ; JIF TOO LONG: ILLEGAL LENGTH
F20D  A780                            STA     ,X+                     ; SAVE LENGTH
F20F  8100                            CMPA    #0
F211  270C                            BEQ     MA80                    ; SKIP DATA LOOP IF LENGTH = 0
                      *
                      *  Loop for data
F213  1F89                            TFR     A,B                     ; SAVE LENGTH FOR LOOP
F215  BDF126          MA10            JSR     GETCHAR                 ; GET A DATA BYTE
F218  25D8                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F21A  A780                            STA     ,X+                     ; SAVE DATA BYTE
F21C  5A                              DECB
F21D  26F6                            BNE     MA10
                      *
                      *  Get the checksum
F21F  BDF126          MA80            JSR     GETCHAR                 ; GET THE CHECKSUM
F222  25CE                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F224  3402                            PSHS    A                       ; SAVE CHECKSUM
                      *
                      *  Compare received checksum to that calculated on received buffer
                      *  (Sum should be 0)
F226  BDF523                          JSR     CHECKSUM
F229  ABE0                            ADDA    ,S+                     ; ADD SAVED CHECKSUM TO COMPUTED
                              IF MACH_WBONE
                                      BEQ     1F
                                      LDA     LEDS
                                      ORA     #LED_CKSUM
                                      STA     LEDS
                                      JSR     PIPDLY
                                      ANDA    #~LED_CKSUM
                                      STA     LEDS
                                      BRA     MAIN
                      1
                              ELSE
F22B  26C5                            BNE     MAIN                    ; JIF BAD CHECKSUM
                              ENDIF
                      *
                      *  Process the message.
F22D  8EC026                          LDX     #COMBUF
F230  A680                            LDA     ,X+                     ; GET THE FUNCTION CODE
F232  E680                            LDB     ,X+                     ; GET THE LENGTH
F234  81FF                            CMPA    #FN_GET_STAT
F236  2742                            BEQ     TARGET_STAT
F238  81FE                            CMPA    #FN_READ_MEM
F23A  2726                            BEQ     JREAD_MEM
F23C  81FD                            CMPA    #FN_WRITE_M
F23E  2725                            BEQ     JWRITE_MEM
F240  81FC                            CMPA    #FN_READ_RG
F242  2724                            BEQ     JREAD_REGS
F244  81FB                            CMPA    #FN_WRITE_RG
F246  2723                            BEQ     JWRITE_REGS
F248  81FA                            CMPA    #FN_RUN_TARG
F24A  2722                            BEQ     JRUN_TARGET
F24C  81F9                            CMPA    #FN_SET_BYTE
F24E  2721                            BEQ     JSET_BYTES
F250  81F8                            CMPA    #FN_IN
F252  2720                            BEQ     JIN_PORT
F254  81F7                            CMPA    #FN_OUT
F256  271F                            BEQ     JOUT_PORT
                      *
                      *  Error: unknown function.  Complain
F258  86F0                            LDA     #FN_ERROR
F25A  B7C026                          STA     COMBUF          ; SET FUNCTION AS "ERROR"
F25D  8601                            LDA     #1
F25F  7EF501                          JMP     SEND_STATUS     ; VALUE IS "ERROR"
                      *
                      *  long jumps to handlers
F262  7EF2A3          JREAD_MEM       JMP     READ_MEM
F265  7EF318          JWRITE_MEM      JMP     WRITE_MEM
F268  7EF3B0          JREAD_REGS      JMP     READ_REGS
F26B  7EF3C5          JWRITE_REGS     JMP     WRITE_REGS
F26E  7EF3D7          JRUN_TARGET     JMP     RUN_TARGET
F271  7EF494          JSET_BYTES      JMP     SET_BYTES
F274  7EF4E8          JIN_PORT        JMP     IN_PORT
F277  7EF4F3          JOUT_PORT       JMP     OUT_PORT
                      
                      *===========================================================================
                      *
                      *  Target Status:  FN, len
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F27A                  TARGET_STAT
F27A  8EF14F                          LDX     #TSTG                   ; DATA FOR REPLY
F27D  108EC027                        LDY     #COMBUF+1               ; POINTER TO RETURN BUFFER
F281  C620                            LDB     #TSTG_SIZE              ; LENGTH OF REPLY
F283  E7A0                            STB     ,Y+                     ; SET SIZE IN REPLY BUFFER
F285  A680            TS10            LDA     ,X+                     ; MOVE REPLY DATA TO BUFFER
F287  A7A0                            STA     ,Y+
F289  5A                              DECB
F28A  26F9                            BNE     TS10
                      *
                      *  Compute checksum on buffer, and send to master, then return
F28C  7EF50B                          JMP     SEND
                      
                              IF NOICE_DEBUG_MEMMAP
F28F                  MEM_DEBUG_INIT
F28F  A6A4            1               LDA     ,Y
F291  A7C0                            STA     ,U+
F293  A680                            LDA     ,X+
F295  A7A0                            STA     ,Y+
F297  5A                              DECB
F298  26F5                            BNE     1B
F29A  39                              RTS
                      
F29B                  MEM_DEBUG_RESTORE
F29B  A6C0            1               LDA     ,U+
F29D  A7A0                            STA     ,Y+
F29F  5A                              DECB
F2A0  26F9                            BNE     1B
F2A2  39                              RTS
                              ENDIF
                      
                      
                      *===========================================================================
                      *
                      *  Read Memory:  FN, len, page, Alo, Ahi, Nbytes
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F2A3                  READ_MEM
                      *
                      *  Set map
                              IF DO_ROMLATCH
F2A3  A684                            LDA     0,X
F2A5  B700F4                          STA     MAPIMG
F2A8  B7FE30                          STA     MAPREG
                              ENDIF
                      *
                      *  Get address
F2AB  A602                            LDA     2,X                     ; MSB OF ADDRESS IN A
F2AD  E601                            LDB     1,X                     ; LSB OF ADDRESS IN B
F2AF  1F02                            TFR     D,Y                     ; ADDRESS IN Y
                      *
                      *  Prepare return buffer: FN (unchanged), LEN, DATA
F2B1  E603                            LDB     3,X                     ; NUMBER OF BYTES TO RETURN
F2B3  F7C027                          STB     COMBUF+1                ; RETURN LENGTH = REQUESTED DATA        
F2B6  274C                            BEQ     GLP90                   ; JIF NO BYTES TO GET
                      
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; if running from debug mem need to look to see
                                      ; if this is an access to C000 onwards 
                                      ; and page back in original MOS if it is
                      
F2B8  108CC000                        CMPY    #$C000
F2BC  253F                            BLO     READ_MEM_NOT_MOS
                                      ; TODO this should maybe also check for FC00-FEFF?
                      
F2BE  3470                            PSHS    X,Y,U
F2C0  C611                            LDB     #READ_MEM_DEBUG_LEN
F2C2  8EF2EC                          LDX     #READ_MEM_DEBUG_LOAD
F2C5  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F2C9  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F2CC  BDF28F                          JSR     MEM_DEBUG_INIT
F2CF  3570                            PULS    X,Y,U
                      *
                      *  Read the requested bytes from local memory
F2D1  BD0100          1               JSR     READ_MEM_DEBUG                  ; GET BYTE
F2D4  A780                            STA     ,X+                             ; STORE TO RETURN BUFFER
F2D6  5A                              DECB
F2D7  26F8                            BNE     1B
                      
F2D9  3460                            PSHS    Y,U
F2DB  C611                            LDB     #READ_MEM_DEBUG_LEN
F2DD  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F2E1  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F2E4  BDF29B                          JSR     MEM_DEBUG_RESTORE
F2E7  3560                            PULS    Y,U
                      
F2E9  7EF50B                          JMP     SEND
                      
                                      ; ORG this at bottom of stack NOICE_DEBUG_CODE_BOUNCE and copy from PUT area
F2EC                  READ_MEM_DEBUG_LOAD
0100                                  ORG     NOICE_DEBUG_CODE_BOUNCE
                                      PUT     READ_MEM_DEBUG_LOAD
0100                  READ_MEM_DEBUG
0100  3404                            PSHS    B                               ; preserve B
0102  F6FE31                          LDB     $FE31                           ; save current MOS state
0105  B7FE32                          STA     $FE32                           ; restore mos state prior to debug entry
                                                                              ; NOTE: stack is from DEBUG memory so
                                                                              ; we can't use the stack until we've
                                                                              ; restored DEBUG state
0108  12                              NOP
0109  A6A0                            LDA     ,Y+                     ; GET BYTE
010B  F7FE31                          STB     $FE31
010E  12                              NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
010F  3584                            PULS    B,PC
0111                  READ_MEM_DEBUG_END
0011                  READ_MEM_DEBUG_LEN EQU READ_MEM_DEBUG_END-NOICE_DEBUG_CODE_BOUNCE
                      
F2FD                                  ORG     READ_MEM_DEBUG_LOAD + READ_MEM_DEBUG_LEN
                                      PUT     READ_MEM_DEBUG_LOAD + READ_MEM_DEBUG_LEN
F2FD                  READ_MEM_NOT_MOS
                              ENDIF
                      *
                      *  Read the requested bytes from local memory
F2FD  A6A0            GLP             LDA     ,Y+                     ; GET BYTE
F2FF  A780                            STA     ,X+                     ; STORE TO RETURN BUFFER
F301  5A                              DECB
F302  26F9                            BNE     GLP
                      *
                      *  Compute checksum on buffer, and send to master, then return
F304  7EF50B          GLP90           JMP     SEND
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; ORG this at bottom of stack NOICE_DEBUG_CODE_BOUNCE and copy from PUT area
F307                  WRITE_MEM_DEBUG_LOAD
0100                                  ORG     NOICE_DEBUG_CODE_BOUNCE
                                      PUT     WRITE_MEM_DEBUG_LOAD
0100                  WRITE_MEM_DEBUG
0100  3404                            PSHS    B                               ; preserve B
0102  F6FE31                          LDB     $FE31                           ; save current MOS state
0105  B7FE32                          STA     $FE32                           ; restore mos state prior to debug entry
                                                                              ; NOTE: stack is from DEBUG memory so
                                                                              ; we can't use the stack until we've
                                                                              ; restored DEBUG state
0108  12                              NOP
0109  A7A0                            STA     ,Y+                     ; GET BYTE
010B  F7FE31                          STB     $FE31
010E  12                              NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
010F  3584                            PULS    B,PC
0111                  WRITE_MEM_DEBUG_END
0011                  WRITE_MEM_DEBUG_LEN EQU WRITE_MEM_DEBUG_END-NOICE_DEBUG_CODE_BOUNCE
                      
F318                                  ORG     WRITE_MEM_DEBUG_LOAD + WRITE_MEM_DEBUG_LEN
                              ENDIF
                      
                      *===========================================================================
                      *
                      *  Write Memory:  FN, len, page, Alo, Ahi, (len-3 bytes of Data)
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
                      *  Uses 6 bytes of stack
                      *
F318                  WRITE_MEM
                      *
                      *  Set map
                      
F318  A680                            LDA     ,X+
                              IF DO_ROMLATCH
F31A  B700F4                          STA     MAPIMG
F31D  B7FE30                          STA     MAPREG
                              ENDIF
                      *
                      *  Get address
F320  E680                            LDB     ,X+                     ; LSB OF ADDRESS IN B
F322  A680                            LDA     ,X+                     ; MSB OF ADDRESS IN A
F324  1F02                            TFR     D,Y                     ; ADDRESS IN Y
                      
                      *
                      *  Compute number of bytes to write
F326  F6C027                          LDB     COMBUF+1                ; NUMBER OF BYTES TO RETURN
F329  C003                            SUBB    #3                      ; MINUS PAGE AND ADDRESS
F32B  277A                            BEQ     WLP50                   ; JIF NO BYTES TO PUT
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; if running from debug mem need to look to see
                                      ; if this is an access to C000 onwards 
                                      ; and page back in original MOS if it is
                      
F32D  108CC000                        CMPY    #$C000
F331  2560                            BLO     WRITE_MEM_NOT_MOS
                                      ; TODO this should maybe also check for FC00-FEFF?
                      
F333  3474                            PSHS    B,X,Y,U
F335  C611                            LDB     #WRITE_MEM_DEBUG_LEN
F337  8EF307                          LDX     #WRITE_MEM_DEBUG_LOAD
F33A  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F33E  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F341  BDF28F                          JSR     MEM_DEBUG_INIT
F344  3574                            PULS    B,X,Y,U
                      
                      *
                      *  Write the specified bytes to local memory
F346  3434                            PSHS    B,X,Y
F348  A680            1               LDA     ,X+                             ; GET BYTE TO WRITE
F34A  BD0100                          JSR     WRITE_MEM_DEBUG                 ; STORE THE BYTE AT ,Y
F34D  5A                              DECB
F34E  26F8                            BNE     1B
                      
F350  3460                            PSHS    Y,U
F352  C611                            LDB     #WRITE_MEM_DEBUG_LEN
F354  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F358  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F35B  BDF29B                          JSR     MEM_DEBUG_RESTORE
F35E  3560                            PULS    Y,U
                      
F360  3470                            PSHS    X,Y,U
F362  C611                            LDB     #READ_MEM_DEBUG_LEN
F364  8EF2EC                          LDX     #READ_MEM_DEBUG_LOAD
F367  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F36B  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F36E  BDF28F                          JSR     MEM_DEBUG_INIT
F371  3570                            PULS    X,Y,U
                      
F373  3534                            PULS    B,X,Y
F375  BD0100          1               JSR     READ_MEM_DEBUG                  ; DB: Swapped LDA/CMPA to make DEBUG case easier
F378  A180                            CMPA    ,X+                             ; GET BYTE JUST WRITTEN
F37A  2603                            BNE     2F                              ; BR IF WRITE FAILED
F37C  5A                              DECB
F37D  26F6                            BNE     1B
F37F                  2
                      
F37F  3461                            PSHS    CC,Y,U
F381  C611                            LDB     #READ_MEM_DEBUG_LEN
F383  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F387  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F38A  BDF29B                          JSR     MEM_DEBUG_RESTORE
F38D  3561                            PULS    CC,Y,U
                      
F38F  261A                            BNE     WLP80                           ; signal fail
F391  2714                            BEQ     WLP50                           ; signal pass
                      
F393                  WRITE_MEM_NOT_MOS
                              ENDIF
                      
                      *
                      *  Write the specified bytes to local memory
F393  3434                            PSHS    B,X,Y
F395  A680            WLP             LDA     ,X+                     ; GET BYTE TO WRITE
F397  A7A0                            STA     ,Y+                     ; STORE THE BYTE AT ,Y
F399  5A                              DECB
F39A  26F9                            BNE     WLP
                      *
                      *  Compare to see if the write worked
F39C  3534                            PULS    B,X,Y
F39E  A6A0            WLP20           LDA     ,Y+                     ; DB: Swapped LDA/CMPA to make DEBUG case easier
F3A0  A180                            CMPA    ,X+                     ; GET BYTE JUST WRITTEN
F3A2  2607                            BNE     WLP80                   ; BR IF WRITE FAILED
F3A4  5A                              DECB
F3A5  26F7                            BNE     WLP20
                      *
                      *  Write succeeded:  return status = 0
F3A7  8600            WLP50           LDA     #0                      ; RETURN STATUS = 0
F3A9  2002                            BRA     WLP90
                      *
                      *  Write failed:  return status = 1
F3AB  8601            WLP80           LDA     #1
                      
                      *  Return OK status
F3AD  7EF501          WLP90           JMP     SEND_STATUS
                      
                      *===========================================================================
                      *
                      *  Read registers:  FN, len=0
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F3B0                  READ_REGS
                      *
                      *  Enter here from SWI after "RUN" and "STEP" to return task registers
F3B0                  RETURN_REGS
F3B0  108EC011                        LDY     #TASK_REGS              ; POINTER TO REGISTERS
F3B4  C615                            LDB     #TASK_REG_SZ            ; NUMBER OF BYTES
F3B6  8EC027                          LDX     #COMBUF+1               ; POINTER TO RETURN BUFFER
F3B9  E780                            STB     ,X+                     ; SAVE RETURN DATA LENGTH
                      *
                      *  Copy the registers
F3BB  A6A0            GRLP            LDA     ,Y+                     ; GET BYTE TO A
F3BD  A780                            STA     ,X+                     ; STORE TO RETURN BUFFER
F3BF  5A                              DECB
F3C0  26F9                            BNE     GRLP
                      *
                      *  Compute checksum on buffer, and send to master, then return
F3C2  7EF50B                          JMP     SEND
                      
                      *===========================================================================
                      *
                      *  Write registers:  FN, len, (register image)
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F3C5                  WRITE_REGS
                      *
F3C5  5D                              TSTB                            ; NUMBER OF BYTES
F3C6  270B                            BEQ     WRR80                   ; JIF NO REGISTERS
                      *
                      *  Copy the registers
F3C8  108EC011                        LDY     #TASK_REGS              ; POINTER TO REGISTERS
F3CC  A680            WRRLP           LDA     ,X+                     ; GET BYTE TO A
F3CE  A7A0                            STA     ,Y+                     ; STORE TO REGISTER RAM
                      
F3D0  5A                              DECB
F3D1  26F9                            BNE     WRRLP
                      *
                      *  Return OK status
F3D3  4F              WRR80           CLRA
F3D4  7EF501                          JMP     SEND_STATUS
                      
                      *===========================================================================
                      *
                      *  Run Target:  FN, len
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F3D7                  RUN_TARGET
                      *
                      *  Restore user's map
                              IF DO_ROMLATCH
F3D7  B6C012                          LDA     REG_PAGE                ; USER'S PAGE
F3DA  B700F4                          STA     MAPIMG                  ; SET IMAGE
F3DD  B7FE30                          STA     MAPREG                  ; SET MAPPING REGISTER
                              ENDIF
                      *
                      *  Switch to user stack
F3E0  B6C014                          LDA     REG_SP+1                ; BACK TO USER STACK
F3E3  F6C013                          LDB     REG_SP
F3E6  1F04                            TFR     D,S                     ; TO S
                      
                              IF CPU_6309
F3E8  BDF1EE                          JSR     CHECK_6309
F3EB  261C                            BNE     NOT_6309_2
                      *
                      *  Restore MD, as it affects stack building and RTI
                      *  Only bits 1 and 0 can be written, and only using LDMD #
                      *  It's time for some self-modifying code!  Build LDMD #xxx, RTS in RAM and call it.
F3ED  CC113D                          LDD     #$113D                  ; LDMD #imm
F3F0  FDC044                          STD     COMBUF+30               ; Start code string
F3F3  B6C021                          LDA     REG_MD                  ; #imm is desired MD value
F3F6  B7C046                          STA     COMBUF+32
F3F9  8639                            LDA     #$39                    ; RTS
F3FB  B7C047                          STA     COMBUF+33
F3FE  BDC044                          JSR     COMBUF+30
                      *
                      *  Restore V, which isn't on the stack
F401  B6C023                          LDA     REG_V+1
F404  F6C022                          LDB     REG_V
F407  1F07                            TFR     D,V
F409                  NOT_6309_2
                              ENDIF
                      *
                      *  Restore registers
F409  B6C025                          LDA     REG_PC+1                ; MS USER PC FOR RTI
F40C  F6C024                          LDB     REG_PC                  ; LS USER PC FOR RTI
F40F  3406                            PSHS    D
                      
                      *
F411  B6C016                          LDA     REG_U+1
F414  F6C015                          LDB     REG_U
F417  3406                            PSHS    D
                      *
F419  B6C018                          LDA     REG_Y+1
F41C  F6C017                          LDB     REG_Y
F41F  3406                            PSHS    D
                      *
F421  B6C01A                          LDA     REG_X+1
F424  F6C019                          LDB     REG_X
F427  3406                            PSHS    D
                      *
F429  B6C01F                          LDA     REG_DP
F42C  3402                            PSHS    A
                              IF CPU_6309
F42E  BDF1EE                          JSR     CHECK_6309
F431  2611                            BNE     NOT_6309_3
                      *       
                      *  Restore W from memory (not used between here and RTI)
F433  11B6C01C                        LDE     REG_E
F437  11F6C01B                        LDF     REG_F
F43B  B6C021                          LDA     REG_MD
F43E  8501                            BITA    #1
F440  2702                            BEQ     RT_10                   ; jump if 6809 mode
F442  1038                            PSHSW                          ; else push W on stack for RTI
F444                  RT_10
F444                  NOT_6309_3
                              ENDIF
                      *
F444  B6C01D                          LDA     REG_B
F447  3402                            PSHS    A
                      *
F449  B6C01E                          LDA     REG_A
F44C  3402                            PSHS    A
                      *
F44E  B6C020                          LDA     REG_CC                  ; SAVE USER CONDITION CODES FOR RTI
F451  8A80                            ORA     #CC_E                      ; _MUST_ BE "ALL REGS PUSHED"
F453  3402                            PSHS    A
                      
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
                                      LDA     #255
                                      STA     RUNNING_FLAG
                              ENDIF
                      
                      *
                      *  Return to user (conditioned by MD.0)
                              IF NOICE_DEBUG_MEMMAP
F455  B7FE32                          STA     $FE32                           ; reset DEBUG map by writing restore reg
                              ENDIF
F458  3B                              RTI
                      *
                      *===========================================================================
                      *
                      *  Common continue point for all monitor entrances
                      *  SP = user stack
F459                  ENTER_MON
F459  1F40                            TFR     S,D             ; USER STACK POINTER
F45B  B7C014                          STA     REG_SP+1        ; SAVE USER'S STACK POINTER (MSB)
F45E  F7C013                          STB     REG_SP          ; LSB
                      *
                      *  Change to our own stack
F461  10CEC100                        LDS     #MONSTACK       ; AND USE OURS INSTEAD
                      *
                      *  Operating system variables
                              IF DO_ROMLATCH
F465  B600F4                          LDA     MAPIMG          ; GET CURRENT USER MAP
                              ELSE
                                      LDA     #0              ; ... OR ZERO IF UNMAPPED TARGET
                              ENDIF
F468  B7C012                          STA     REG_PAGE        ; SAVE USER'S PAGE
                      *
                      *  Return registers to master
F46B  7EF3B0                          JMP     RETURN_REGS
                      
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; ORG this at bottom of stack NOICE_DEBUG_CODE_BOUNCE and copy from PUT area
F46E                  SET_BYTE_DEBUG_LOAD
0100                                  ORG     NOICE_DEBUG_CODE_BOUNCE
                                      PUT     SET_BYTE_DEBUG_LOAD
0100                  SET_BYTE_DEBUG
0100  E603                            LDB     3,X                             ; GET BYTE TO STORE     
0102  B6FE31                          LDA     $FE31                           ; save current MOS state
0105  B70125                          STA     SET_BYTE_TMP                    ; preserve B - note we can't use the stack here!
0108  B7FE32                          STA     $FE32                           ; restore mos state prior to debug entry
                                                                              ; NOTE: stack is from DEBUG memory so
                                                                              ; we can't use the stack until we've
                                                                              ; restored DEBUG state
010B  12                              NOP
                      
                      *
                      *  Read current data at byte location
010C  A6A4                            LDA     0,Y
                      *
                      *  Insert new data at byte location
010E  E7A4                            STB     0,Y                     ; WRITE TARGET MEMORY
                      *
                      *  Verify write
0110  E1A4                            CMPB    0,Y                     ; READ TARGET MEMORY
0112  2609                            BNE     SET_BYTE_EXNE
0114  F60125                          LDB     SET_BYTE_TMP
0117  F7FE31                          STB     $FE31
011A  12                              NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
011B  5F                              CLRB
011C  39                              RTS
011D                  SET_BYTE_EXNE
011D  F60125                          LDB     SET_BYTE_TMP
0120  F7FE31                          STB     $FE31
0123  12                              NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
0124  39                              RTS
                      
0125                  SET_BYTE_TMP    RMB     1
0126                  SET_BYTE_DEBUG_END
0026                  SET_BYTE_DEBUG_LEN EQU SET_BYTE_DEBUG_END-NOICE_DEBUG_CODE_BOUNCE
                      
F494                                  ORG     SET_BYTE_DEBUG_LOAD + SET_BYTE_DEBUG_LEN
                              ENDIF
                      
                      
                      
                      *===========================================================================
                      *
                      *  Set target byte(s):  FN, len { (page, alow, ahigh, data), (...)... }
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
                      *  Return has FN, len, (data from memory locations)
                      *
                      *  If error in insert (memory not writable), abort to return short data
                      *
                      *  This function is used primarily to set and clear breakpoints
                      *
                      *  Uses 1 byte of stack
                      *
F494                  SET_BYTES
                      
F494  CEC027                          LDU     #COMBUF+1               ; POINTER TO RETURN BUFFER
F497  8600                            LDA     #0
F499  A7C0                            STA     ,U+                     ; SET RETURN COUNT AS ZERO
F49B  54                              LSRB
F49C  54                              LSRB                            ; LEN/4 = NUMBER OF BYTES TO SET
F49D  2746                            BEQ     SB99                    ; JIF NO BYTES (COMBUF+1 = 0)
                      
                              IF NOICE_DEBUG_MEMMAP
F49F  3474                            PSHS    B,X,Y,U
F4A1  C626                            LDB     #SET_BYTE_DEBUG_LEN
F4A3  8EF46E                          LDX     #SET_BYTE_DEBUG_LOAD
F4A6  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F4AA  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F4AD  BDF28F                          JSR     MEM_DEBUG_INIT
F4B0  3574                            PULS    B,X,Y,U
                              ENDIF
                      
                      *
                      *  Loop on inserting bytes
F4B2  3404            SB10            PSHS    B                       ; SAVE LOOP COUNTER
                      *
                      *  Set map
                              IF DO_ROMLATCH
F4B4  A684                            LDA     0,X
F4B6  B700F4                          STA     MAPIMG
F4B9  B7FE30                          STA     MAPREG
                              ENDIF
                      *
                      *  Get address
F4BC  A602                            LDA     2,X                     ; MSB OF ADDRESS IN A
F4BE  E601                            LDB     1,X                     ; LSB OF ADDRESS IN B
F4C0  1F02                            TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      
                              IF NOICE_DEBUG_MEMMAP
F4C2  BD0100                          JSR     SET_BYTE_DEBUG
                              ELSE
                      *
                      *  Read current data at byte location
                                      LDA     0,Y
                      *
                      *  Insert new data at byte location
                                      LDB     3,X                     ; GET BYTE TO STORE     
                                      STB     0,Y                     ; WRITE TARGET MEMORY
                      *
                      *  Verify write
                                      CMPB    0,Y                     ; READ TARGET MEMORY
                      
                              ENDIF
                      
F4C5  3504                            PULS    B                       ; RESTORE LOOP COUNT, CC'S INTACT
F4C7  260C                            BNE     SB90                    ; BR IF INSERT FAILED: ABORT
                      *
                      *  Save target byte in return buffer
F4C9  A7C0                            STA     ,U+
F4CB  7CC027                          INC     COMBUF+1                ; COUNT ONE RETURN BYTE
                      *
                      *  Loop for next byte
F4CE  3004                            LEAX    4,X                     ; STEP TO NEXT BYTE SPECIFIER
F4D0  F1C027                          CMPB    COMBUF+1
F4D3  26DD                            BNE     SB10                    ; *LOOP FOR ALL BYTES
                      *
                      *  Return buffer with data from byte locations
F4D5                  SB90
                              IF NOICE_DEBUG_MEMMAP
F4D5  3461                            PSHS    CC,Y,U
F4D7  C626                            LDB     #SET_BYTE_DEBUG_LEN
F4D9  108E0100                        LDY     #NOICE_DEBUG_CODE_BOUNCE
F4DD  CEC0A9                          LDU     #RW_MEM_CODE_SAVE
F4E0  BDF29B                          JSR     MEM_DEBUG_RESTORE
F4E3  3561                            PULS    CC,Y,U
                              ENDIF
                      
                      *
                      *  Compute checksum on buffer, and send to master, then return
F4E5  7EF50B          SB99            JMP     SEND
                      
                      *===========================================================================
                      *
                      *  Input from port:  FN, len, PortAddressLo, PAhi (=0)
                      *
                      *  While the 6809 has no input or output instructions, we retain these
                      *  to allow write-without-verify
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F4E8                  IN_PORT
                      *
                      *  Get port address
F4E8  A601                            LDA     1,X                     ; MSB OF ADDRESS IN A
F4EA  E684                            LDB     0,X                     ; LSB OF ADDRESS IN B
F4EC  1F02                            TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      *
                      *  Read the requested byte from local memory
F4EE  A6A4                            LDA     0,Y
                      *
                      *  Return byte read as "status"
F4F0  7EF501                          JMP     SEND_STATUS
                      
                      *===========================================================================
                      *
                      *  Output to port  FN, len, PortAddressLo, PAhi (=0), data
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F4F3                  OUT_PORT
                      *
                      *  Get port address
F4F3  A601                            LDA     1,X                     ; MSB OF ADDRESS IN A
F4F5  E684                            LDB     0,X                     ; LSB OF ADDRESS IN B
F4F7  1F02                            TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      *
                      *  Get data
F4F9  A602                            LDA     2,X
                      *
                      *  Write value to port
F4FB  A7A4                            STA     0,Y
                      *
                      *  Do not read port to verify (some I/O devices don't like it)
                      *
                      *  Return status of OK
F4FD  4F                              CLRA
F4FE  7EF501                          JMP     SEND_STATUS
                      
                      *===========================================================================
                      *  Build status return with value from "A"
                      *
F501                  SEND_STATUS
F501  B7C028                          STA     COMBUF+2                ; SET STATUS
F504  8601                            LDA     #1
F506  B7C027                          STA     COMBUF+1                ; SET LENGTH
F509  2000                            BRA     SEND
                      
                      *===========================================================================
                      *  Append checksum to COMBUF and send to master
                      *
F50B  BDF523          SEND            JSR     CHECKSUM                ; GET A=CHECKSUM, X->checksum location
F50E  40                              NEGA
F50F  A784                            STA     0,X                     ; STORE NEGATIVE OF CHECKSUM
                      *
                      *  Send buffer to master
F511  8EC026                          LDX     #COMBUF                 ; POINTER TO DATA
F514  E601                            LDB     1,X                     ; LENGTH OF DATA
F516  CB03                            ADDB    #3                      ; PLUS FUNCTION, LENGTH, CHECKSUM
F518  A680            SND10           LDA     ,X+
F51A  BDF140                          JSR     PUTCHAR                 ; SEND A BYTE
F51D  5A                              DECB
F51E  26F8                            BNE     SND10
F520  7EF1F2                          JMP     MAIN                    ; BACK TO MAIN LOOP
                      
                      *===========================================================================
                      *  Compute checksum on COMBUF.  COMBUF+1 has length of data,
                      *  Also include function byte and length byte
                      *
                      *  Returns:
                      *       A = checksum
                      *       X = pointer to next byte in buffer (checksum location)
                      *       B is scratched
                      *
F523                  CHECKSUM
F523  8EC026                          LDX     #COMBUF                 ; pointer to buffer
F526  E601                            LDB     1,X                     ; length of message
F528  CB02                            ADDB    #2                      ; plus function, length
F52A  8600                            LDA     #0                      ; init checksum to 0
F52C  AB80            CHK10           ADDA    ,X+
F52E  5A                              DECB
F52F  26FB                            BNE     CHK10                   ; loop for all
F531  39                              RTS                             ; return with checksum in A
                      
                      ***********************************************************************
                      *
                      *  Interrupt handlers to catch unused interrupts and traps
                      *  Registers are stacked.  Jump through RAM vector using X, type in A
                      *
                      *  This will affect only interrupt routines looking for register values!
                      *
                      *  Our default handler uses the code in "A" as the processor state to be
                      *  passed back to the host.
                      *
                      
                              IF STANDALONE
                      
                      *  This is "reserved" on 6809
                      *  Used for Divide-by-zero and Illegal-instruction on 6309
                      RES_ENT         LDA     #7
                                      LDX     RAMVEC+0
                                      JMP     0,X
                      *
                      SWI3_ENT        LDA     #6
                                      LDX     RAMVEC+2
                                      JMP     0,X
                      *
                      SWI2_ENT        LDA     #5
                                      LDX     RAMVEC+4
                                      JMP     0,X
                      *
                      *  Will have only PC and CC's pushed unless we were waiting for an interrupt
                      *  or MD.1 is true.  Use CC's E bit to distinguish.
                      *  Push all registers here for common entry (else we can't use our RAM vector)
                      FIRQ_ENT        STA     REG_A   ; SAVE A REG
                                      PULS    A               ; GET CC'S FROM STACK
                                      BITA    #CC_E
                                      BNE     FIRQ9   ; BR IF ALL REGISTERS PUSHED ALREADY
                              IF CPU_6309
                      
                      * CC.E was not set which means that regMD bit2 was not set and that bit in
                      * the image should be cleared. If CC.E is set, we can't tell what set it, a
                      * direct command, CWAI, or bit 1 of regMD.
                      *
                      * Push registers as if CC.E had been set
                      *  If 6809 mode, stack needs CC A B DP XH XL YH YL UH UL PCH PCL
                      *  If 6309 mode, stack needs CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      *
                                      CLR     E_FLAG
                                      LDA     REG_MD
                                      ANDA    #$FD            ; BIT1 must be clear, else all regs would have been pushed
                                      STA     REG_MD
                                      PSHS    U,Y,X,DP        ; push regs next below PC
                      
                                      JSR     CHECK_6309
                                      BNE     FE1
                      
                                      STW     REG_F           ; MD_TEST will not preserve regW
                                      JSR     MD_TEST
                                      PSHS    CC              ; Save result
                                      LDW     REG_F           ; Recover regW
                                      PULS    CC              ; Recover result of test
                                      BNE     FE1
                                      PSHSW
                      FE1             PSHS    B
                              ELSE
                                      PSHS    U,Y,X,DP,B      ;ELSE PUSH THEM NOW
                              ENDIF
                      
                                      LDB     REG_A
                                      PSHS    B
                                      ORA     #CC_E           ; SET AS "ALL REGS PUSHED"
                      
                      
                      
                      
                      FIRQ9   
                              IF CPU_6309
                                      TST     E_FLAG
                                      BNE     FIRQ9B
                                      LDB     REG_MD          ; We got here with E_FLAG clear and CC.E set which
                                      ORB     #2              ; means regMD bit2 must be set.
                                      STB     REG_MD
                      FIRQ9B  
                              ENDIF
                                      PSHS    A               ; REPLACE CC'S
                                      LDA     #4
                                      LDX     RAMVEC+6
                                      JMP     0,X
                      
                      IRQ_ENT         LDA     #3
                                      LDX     RAMVEC+8
                                      JMP     0,X
                      *
                      NMI_ENT         LDA     #2
                                      LDX     RAMVEC+12
                                      JMP     0,X
                      *
                      SWI_ENT         LDA     #1
                                      JMP     INT_ENTRY
                              ELSE
                                      ; in mos overlay these are jumped to from the two entry points at start of overlay
F532  8601            SWI_ENT         LDA     #1
F534  7EF16F                          JMP     INT_ENTRY
F537  8602            NMI_ENT         LDA     #2
F539  7EF16F                          JMP     INT_ENTRY
                      
                              ENDIF
                      
                              IF STANDALONE
                      
                      *mostbl_VDU_6845_mode_45
                      *                FCB     $3F,$28,$31,$24,$26,$00,$20,$22 
                      *                FCB     $01,$07,$67,$08                 
                      
                      
                      mostbl_VDU_6845_mode_012
                                      FCB     $7F,$50,$62,$28,$26,$00,$20,$22
                                      FCB     $01,$07,$67,$08
                      
                              ENDIF
                      
                              IF CPU_6309
                      * TEST FOR BIT0 OF regMD:
                      * Exit emulation mode: regW=$1234
                      *      native    mode: regW=$0000
                      *
                      * Preserves W and V.  Other registers destroyed.
                      *
F53C                  MD_TEST     
F53C  1038                            PSHSW
                      *
                      * If 6809 mode, RTI will pop 12 bytes: CC A B DP XH XL YH YL UH UL PCH PCL
                      * If 6309 mode, RTI will pop 14 bytes: CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      *
                      * Initialize TEST_STACK used for fake RTI. The return address will be MD_RETURN
                      * in both emulation and native modes. If native mode, regW will be cleared.
F53E  8EC000                          LDX     #TEST_STACK
                      
F541  1FA8                            TFR     CC,A
F543  8A80                            ORA     #$80                    ; DB: changed to set CC on stack (was clearing interrupt flags!)
F545  A780                            STA     ,X+                     ; CC with E set
                      
F547  C609                            LDB     #9
F549  6F80            RES11           CLR     ,X+                     ; zeros for other registers, including W
F54B  5A                              DECB
F54C  26FB                            BNE     RES11
                      
F54E  CCF562                          LDD     #MD_RETURN
F551  ED81                            STD     ,X++                    ; 6809 return address, or 6309 U
F553  ED81                            STD     ,X++                    ; 6309 return address, or past 6809 stack
                      
F555  10FFC00F                        STS     S_IMAGE
F559  10CEC000                        LDS     #TEST_STACK
F55D  10861234                        LDW     #$1234
F561  3B                              RTI                             ; if 6309 mode, W gets 0; else unchanged
                      
F562                  MD_RETURN   
F562  10FEC00F                        LDS     S_IMAGE
F566  105D                            TSTW                            ; adjust CC.Z: set if 6309 mode
F568  1039                            PULSW
F56A  39                              RTS
                              ENDIF
                      
                              IF STANDALONE
                      *********************************************************************************
                      *                               S O U N D                                       *
                      *********************************************************************************
                      
                      
                      reset_snd
                                      LDA     #$FF                    ; portA all outputs
                                      STA     sheila_SYSVIA_ddra
                                      LDA     #$0F                    ; portB bottom 4 outputs, rest inputs
                                      STA     sheila_SYSVIA_ddrb
                                      LDA     #$04                    ; CA1 active leading edge
                                      STA     sheila_SYSVIA_pcr
                                      LDA     #$60
                                      STA     sheila_SYSVIA_acr       ; turn off port latches etc
                      
                                      LDA     #$08                    ; make snd latch high
                      1               STA     sheila_SYSVIA_orb
                                      INCA
                                      CMPA    #$10
                                      BLO     1B
                      
                                      LDX     #100
                      1               LEAX    -1,X
                                      BNE     1B
                      
                                      LDA     #0
                                      LDB     #$F
                                      JSR     snd_vol
                                      LDA     #1
                                      LDB     #$F
                                      JSR     snd_vol
                                      LDA     #2
                                      LDB     #$F
                                      JSR     snd_vol
                                      LDA     #3
                                      LDB     #$F
                                      JSR     snd_vol
                                      rts
                      
                      snd_sendA
                                      PSHS    CC
                                      ORCC    #CC_I+CC_F
                                      LDB     #$FF
                                      STB     sheila_SYSVIA_ddra
                                      STA     sheila_SYSVIA_ora_nh       ; set data
                                      LDB     #0
                                      STB     sheila_SYSVIA_orb       ; we low
                                      LDB     #2
                      1               DECB
                                      BNE     1B
                                      LDB     #$08
                                      STB     sheila_SYSVIA_orb       ; we high
                                      LDB     #4
                      1               DECB
                                      BNE     1B
                      anRTS           PULS    CC,PC
                      
                      snd_vol
                                      RORA
                                      RORA
                                      RORA
                                      RORA
                                      ANDA    #$60
                                      ORA     #$90
                                      ANDB    #$0F
                                      PSHS    B
                                      ORA     ,S+
                                      BRA     snd_sendA
                      
                      snd_tone
                                      RORA
                                      RORA
                                      RORA
                                      RORA
                                      ANDA    #$60
                                      ORA     #$80
                                      PSHS    A,X
                                      LDA     2,S
                                      ANDA    #$F
                                      ORA     0,S
                                      JSR     snd_sendA
                                      LDA     2,S
                                      LDB     1,S             ; get em reversed here as we want "course" in A
                                      RORB
                                      RORA
                      
                                      RORB
                                      RORA
                      
                                      LSRA
                      
                                      LSRA
                      
                                      LEAS    3,S
                                      BRA     snd_sendA
                      
                      
                      here3           
                                      FILL    $FF, REMAPPED_HW_VECTORS-here3-1
                      
                      *
                      *============================================================================
                      *  VECTORS THROUGH RAM
                                      ORG     REMAPPED_HW_VECTORS
                      
                                      FDB     RES_ENT                ; f7f0 (reserved)
                                      FDB     SWI3_ENT               ; f7f2 (SWI3)
                                      FDB     SWI2_ENT               ; f7f4 (SWI2)
                                      FDB     FIRQ_ENT               ; f7f6 (FIRQ)
                                      FDB     IRQ_ENT                ; f7f8 (IRQ)
                                      FDB     SWI_ENT                ; f7fa (SWI/breakpoint)
                                      FDB     NMI_ENT                ; f7fc (NMI)
                                      FDB     RESET                  ; f7fe reset
                      
                      here            
                                      FILL    $FF, $FFFF-here-1
                      
                              ENDIF
                      
F56B                  herend
                              IF STANDALONE==0 && herend>=NOICE_CODE_BASE+NOICE_CODE_LEN
                                      ERROR   "OVERLAY CODE TOO BIG, INCREASE NOICE_CODE_LEN"
                              ENDIF
                      
                                      END
