                              IF NOICE_NO_INCS
                      
                              ELSE
                                      include "../../../includes/hardware.inc"
                      ; beeb6809 hardware locations and constants
                      
003B                  rti_opcode              EQU     $3B
                      
FD00                  JIM                     EQU     $FD00
                      
                      * mos ROM memory map location
FE30                  sheila_ROMCTL_SWR       EQU     $FE30
FE31                  sheila_ROMCTL_MOS       EQU     $FE31
FE32                  sheila_MEM_DEBUG_SAVE   EQU     $FE32
                      
                      
0010                  ROMCTL_BITS_FLEX        EQU     $10
                      
                              IF MACH_BEEB
                      ;TODO: naming - harmonize with 6502
FE31                  sheila_MEM_CTL                  EQU $FE31
                      
0001                  BITS_MEM_CTL_SWMOS              EQU $01
0004                  BITS_MEM_CTL_SWMOS_DEBUG        EQU $04
0008                  BITS_MEM_CTL_SWMOS_DEBUG_EN     EQU $08
0010                  BITS_MEM_CTL_FLEX               EQU $10
0040                  BITS_MEM_CTL_SWMOS_DEBUG_5C     EQU $40
0080                  BITS_MEM_CTL_SWMOS_DEBUG_ACT    EQU $80
                      
                      
FE36                  sheila_MEM_TURBO2               EQU $FE36
0080                  BITS_MEM_TURBO2_THROTTLE        EQU $80
                      
FE37                  sheila_MEM_LOMEMTURBO           EQU $FE37
                      
                      
FCFF                  fred_JIM_DEVNO          EQU     $FCFF
FCFD                  fred_JIM_PAGE_HI        EQU     $FCFD
FCFE                  fred_JIM_PAGE_LO        EQU     $FCFE
                              
FE22                  sheila_NULA_CTLAUX      EQU     $FE22
FE23                  sheila_NULA_PALAUX      EQU     $FE23
                      
FEFF                  sheila_DEBUG            EQU     $FEFF
                      
                      
                      
                      
FE3E                  sheila_BLTCFG0          EQU     $FE3E
FE3F                  sheila_BLTCFG1          EQU     $FE3F
0001                  BLTCFG0_T65             EQU     $01
0000                  BLTCFG0_CPU_6502A_2M    EQU     $00
0002                  BLTCFG0_CPU_65C02_4M    EQU     $02
0004                  BLTCFG0_CPU_65C02_8M    EQU     $04
0008                  BLTCFG0_CPU_6x09_2M     EQU     $08
000A                  BLTCFG0_CPU_6309_4M     EQU     $0A
000C                  BLTCFG0_CPU_Z80_8M      EQU     $0C
000E                  BLTCFG0_CPU_68008       EQU     $0E
0010                  BLTCFG0_SWROMX          EQU     $10
0080                  BLTCFG0_BUGBTN          EQU     $80
                      
0001                  BLTCFG1_MEMI            EQU     $01
0002                  BLTCFG1_BUGOUT          EQU     $02
                      
                      
                              ENDIF
                      
                              IF MACH_CHIPKIT
                      sheila_ROMCTL_RAM       EQU     $FE32
                      sheila_MEMC_SCROFF      EQU     $FE33
                              ENDIF
                      
                      
                      
                      * HARDWARELOC - area of RAM used for memory mapped hardware
FC00                  HARDWARELOC                             EQU $FC00
FEFF                  HARDWARELOC_END                         EQU $FEFF
                      
                      * Where the remapped 6809 vectors live, the hardware remaps
                      * the 6809 hardware vectors to avoid the OS calls in the original 6502 memory map
F7F0                  REMAPPED_HW_VECTORS                     EQU $F7F0
                      
000A                  OFF_SWI_VEC     EQU     $A
000C                  OFF_NMI_VEC     EQU     $C
000E                  OFF_RES_VEC     EQU     $E
0008                  HW_VECTOR_COUNT EQU     8
                      
                      ***********************************************************************
                      * CRTC                                                                *
                      ***********************************************************************
FE00                  sheila_CRTC_reg                         EQU $FE00
FE01                  sheila_CRTC_rw                          EQU $FE01
                      
                      
0000                  CRTCR0_HorizontalTotal                  EQU      0      ; 8b WO m0-3:127 m4-7:63
0001                  CRTCR1_HorizontalDisplayed              EQU      1      ; 8b WO m0-3:80  m4-7:40
0002                  CRTCR2_HorizontalSyncPosition           EQU      2      ; 8b WO m0-3:98  m4-6:49 m7:51
0003                  CRTCR3_SyncPulseWidths                  EQU      3      ; Horizontal sync pulse width b0-3 WO m0-3:8 m4-7:4, Vertical sync pulse width b4-7 WO Always 2
0004                  CRTCR4_VerticalTotal                    EQU      4      ; 7b WO m0-2,4-5:38 m3,6-7:30
0005                  CRTCR5_VerticalTotalAdjust              EQU      5      ; 5b WO m0-7:0
0006                  CRTCR6_VerticalDisplayed                EQU      6      ; 7b WO m0-2,4-5:32 m3,6-7:25
0007                  CRTCR7_VerticalSyncPosition             EQU      7      ; 7b WO m0-2,4-5:34 m3,6-7:27
0008                  CRTCR8_InterlaceAndControl              EQU      8      ; Interlace modes        b0-1 00,10 non-interlaced, m0-6 01 Interlace sync, m7 11 Interlace sync and video
0009                  CRTCR9_CharacterScanLines               EQU      9      ; 5b WO m0-2,4-5:7 m3,6:9 m7:18
000A                  CRTCR10_CursorControlStart              EQU     10      ; 7b WO b7 unused b6 blink enable b5 blink fast b0-4 crsr start line
000B                  CRTCR11_CursorEnd                       EQU     11      ; 5b WO crsr end line
000C                  CRTCR12_Screen1stCharHi                 EQU     12      ; 6b WO hi byte of (start of screen address)/8
000D                  CRTCR13_Screen1stCharLo                 EQU     13      ; 8b WO lo byte of (start of screen address)/8
                      
                      ***********************************************************************
                      * Simple Video ULA                                                    *
                      ***********************************************************************
FE20                  sheila_VIDULA_ctl                       EQU $FE20
FE21                  sheila_VIDULA_pal                       EQU $FE21
                              IF MACH_CHIPKIT
                      sheila_VIDULA_pixand                    EQU $FE22
                      sheila_VIDULA_pixeor                    EQU $FE23
                      sheila_VIDULA_ttx                       EQU $FE24
                      
                      sheila_RAMDAC_ADDR_WR                   EQU $FE28
                      sheila_RAMDAC_VAL                       EQU $FE29
                      sheila_RAMDAC_PIXMASK                   EQU $FE2A
                      sheila_RAMDAC_ADDR_RD                   EQU $FE2B
                              ENDIF
                      
                      ***********************************************************************
                      * VIA constants                                                       *
                      ***********************************************************************
                      
0001                  VIA_MASK_INT_CA2                        EQU     $01
0002                  VIA_MASK_INT_CA1                        EQU     $02
0004                  VIA_MASK_INT_SR                         EQU     $04
0008                  VIA_MASK_INT_CB2                        EQU     $08
0010                  VIA_MASK_INT_CB1                        EQU     $10
0020                  VIA_MASK_INT_T2                         EQU     $20
0040                  VIA_MASK_INT_T1                         EQU     $40
0080                  VIA_MASK_INT_IRQ                        EQU     $80
                      
0002                  SYSVIA_MASK_INT_VSYNC                   EQU     VIA_MASK_INT_CA1
                      
                      ***********************************************************************
                      * System VIA                                                          *
                      ***********************************************************************
FE40                  sheila_SYSVIA_orb                       EQU $FE40
FE41                  sheila_SYSVIA_ora                       EQU $FE41
FE42                  sheila_SYSVIA_ddrb                      EQU $FE42
FE43                  sheila_SYSVIA_ddra                      EQU $FE43
FE44                  sheila_SYSVIA_t1cl                      EQU $FE44
FE45                  sheila_SYSVIA_t1ch                      EQU $FE45
FE46                  sheila_SYSVIA_t1ll                      EQU $FE46
FE47                  sheila_SYSVIA_t1lh                      EQU $FE47
FE48                  sheila_SYSVIA_t2cl                      EQU $FE48
FE49                  sheila_SYSVIA_t2ch                      EQU $FE49
FE4A                  sheila_SYSVIA_sr                        EQU $FE4A
FE4B                  sheila_SYSVIA_acr                       EQU $FE4B
FE4C                  sheila_SYSVIA_pcr                       EQU $FE4C
FE4D                  sheila_SYSVIA_ifr                       EQU $FE4D
FE4E                  sheila_SYSVIA_ier                       EQU $FE4E
FE4F                  sheila_SYSVIA_ora_nh                    EQU $FE4F
                      
                      ***********************************************************************
                      * SYS VIA - slow data bus RTC                                         *
                      ***********************************************************************
                      
                              IF MACH_CHIPKIT
                      BITS_RTC_AS_ON  equ             $88                     ; PB7
                      BITS_RTC_AS_OFF equ             $08                     ;
                      BITS_RTC_CS     equ             $04                     ; latch
                      BITS_RTC_DS     equ             $02                     ; latch
                      BITS_RTC_RnW    equ             $01                     ; latch
                      BITS_LAT_ON     equ             $08                     ; latch
                      
                      RTC_REG_SECONDS equ             $0
                      RTC_REG_MINUTES equ             $2
                      RTC_REG_HOURS   equ             $4
                      RTC_REG_DOW     equ             $6
                      RTC_REG_DAY     equ             $7
                      RTC_REG_MONTH   equ             $8
                      RTC_REG_YEAR    equ             $9
                              ENDIF
                      
                      
                      ***********************************************************************
                      * User VIA                                                            *
                      ***********************************************************************
FE60                  sheila_USRVIA_orb                       EQU $FE60
FE61                  sheila_USRVIA_ora                       EQU $FE61
FE62                  sheila_USRVIA_ddrb                      EQU $FE62
FE63                  sheila_USRVIA_ddra                      EQU $FE63
FE64                  sheila_USRVIA_t1cl                      EQU $FE64
FE65                  sheila_USRVIA_t1ch                      EQU $FE65
FE66                  sheila_USRVIA_t1ll                      EQU $FE66
FE67                  sheila_USRVIA_t1lh                      EQU $FE67
FE68                  sheila_USRVIA_t2cl                      EQU $FE68
FE69                  sheila_USRVIA_t2ch                      EQU $FE69
FE6A                  sheila_USRVIA_sr                        EQU $FE6A
FE6B                  sheila_USRVIA_acr                       EQU $FE6B
FE6C                  sheila_USRVIA_pcr                       EQU $FE6C
FE6D                  sheila_USRVIA_ifr                       EQU $FE6D
FE6E                  sheila_USRVIA_ier                       EQU $FE6E
FE6F                  sheila_USRVIA_ora_nh                    EQU $FE6F
                      
                      
                      ***********************************************************************
                      *  VIA constants                                                      *
                      ***********************************************************************
                      
0080                  VIA_IFR_BIT_ANY                         EQU $80
0040                  VIA_IFR_BIT_T1                          EQU $40
0020                  VIA_IFR_BIT_T2                          EQU $20
0010                  VIA_IFR_BIT_CB1                         EQU $10
0008                  VIA_IFR_BIT_CB2                         EQU $08
0004                  VIA_IFR_BIT_SR                          EQU $04
0002                  VIA_IFR_BIT_CA1                         EQU $02
0001                  VIA_IFR_BIT_CA2                         EQU $01
                      
                      
                      ***********************************************************************
                      * BBC B/B+ WD177x                                                     *
                      ***********************************************************************
                      
FE80                  sheila_1770_dcontrol    equ     $FE80
FE84                  sheila_1770_wdc_cmd     equ     $FE84
FE85                  sheila_1770_wdc_trk     equ     $FE85
FE86                  sheila_1770_wdc_sec     equ     $FE86
FE87                  sheila_1770_wdc_dat     equ     $FE87
                      
                      ***********************************************************************
                      * TUBE                                                                *
                      ***********************************************************************
                      
FEE0                  sheila_TUBE_R1_STATUS                   EQU $FEE0
FEE1                  sheila_TUBE_R1_DATA                     EQU $FEE1
FEE2                  sheila_TUBE_R2_STATUS                   EQU $FEE2
FEE3                  sheila_TUBE_R2_DATA                     EQU $FEE3
FEE4                  sheila_TUBE_R3_STATUS                   EQU $FEE4
FEE5                  sheila_TUBE_R3_DATA                     EQU $FEE5
FEE6                  sheila_TUBE_R4_STATUS                   EQU $FEE6
FEE7                  sheila_TUBE_R4_DATA                     EQU $FEE7
                      
                      
                              IF MACH_CHIPKIT
                      *============================================================================
                      *  Equates for memory mapped 16450 serial port 
                      *============================================================================
                      S16550                  equ     $FE78                   ; base of 16450 UART
                      S16550_RXR              equ     S16550+0                ; Receiver buffer register
                      S16550_TXR              equ     S16550+0                ; Transmitter buffer register
                      S16550_IER              equ     S16550+1                ; Interrupt enable register
                      S16550_FCR              equ     S16550+2                ; 16550 FIFO control register
                      S16550_LCR              equ     S16550+3                ; Line control register
                      S16550_MCR              equ     S16550+4                ; Modem control register
                      S16550_DTR              equ     S16550+1                ; Bit equate used to control status LED
                      S16550_LSR              equ     S16550+5                ; Line status register
                      
                      SER_BIT_RXRDY           EQU     $01            ; BIT MASK FOR RX BUFFER FULL
                      SER_BIT_TXRDY           EQU     $20            ; BIT MASK FOR TX BUFFER EMPTY
                      
                      SER_BAUD_CLOCK_IN       EQU     7372800                 ; frequency of on board serial crystal
                      
                      
                      sheila_VINC_data        EQU     $FE50
                      sheila_VINC_status      EQU     $FE52
                      VINC_status_TXE         EQU     $01
                      VINC_status_RXF         EQU     $02
                              ENDIF
                      
                              IF MACH_BEEB
                      
                      * note: this are for Retroclinic DC
FCF8                  sheila_VINC_data        EQU     $FCF8
FCF9                  sheila_VINC_status      EQU     $FCF9
0040                  VINC_status_TXE         EQU     $40
0080                  VINC_status_RXF         EQU     $80
                      
FE08                  sheila_ACIA_CTL         EQU     $FE08
FE09                  sheila_ACIA_DATA        EQU     $FE09
FE10                  sheila_SERIAL_ULA       EQU     $FE10
0001                  ACIA_RDRF               EQU     $01
0002                  ACIA_TDRE               EQU     $02
                      
                      
                      ; BLTCON is written in two passes with top bit clear i.e. not BLTCON_ACT_ACT
                      ; the exec flags are first set
                      ; then with top bit set the active flag, bit mode and cell flags are set
                      ; BLTCON/ACT byte flags
                      
0080                  BLITCON_ACT_ACT                 EQU     $80             ; always set when setting act constants/execing
0040                  BLITCON_ACT_CELL                EQU     $40             ; cell addressing used i.e. move one byte left adds 8 to address
                                                                              ; moving one line down either adds 1 byte or STRIDE depending on whether 
                                                                              ; line crosses an 8 line boundary
0000                  BLITCON_ACT_MODE_1BBP           EQU     $00             ; 1 bit per pixel mapping 2 colours
0010                  BLITCON_ACT_MODE_2BBP           EQU     $10             ; 2 bit per pixel mapping 4 colours
0020                  BLITCON_ACT_MODE_4BBP           EQU     $20             ; 4 bit per pixel mapping 16 colours
0030                  BLITCON_ACT_MODE_8BBP           EQU     $30             ; 8 bit per pixel mapping 256 colours
0008                  BLITCON_ACT_LINE                EQU     $08             ; draw a line
0004                  BLITCON_ACT_COLLISION           EQU     $04             ; gets reset for any non-zero D data (even in EXEC_D is clear) 
                      
                      
0010                  BLITCON_LINE_MAJOR_UPnRIGHT     EQU     $10             ; line draw major axis is up
0020                  BLITCON_LINE_MINOR_CCW          EQU     $20             ; minor axis is CCW to MAJOR i.e. left when maj up, up when maj right
                                                                              ; otherwise                       right when maj up, down when maj right
                      
                      
0001                  BLITCON_EXEC_A                  EQU     $01
0002                  BLITCON_EXEC_B                  EQU     $02
0004                  BLITCON_EXEC_C                  EQU     $04
0008                  BLITCON_EXEC_D                  EQU     $08
0010                  BLITCON_EXEC_E                  EQU     $10
                      
                      ; DMA controller control flags
0080                  DMACTL_ACT                      EQU     $80             ; always set to initiate a transfer
0020                  DMACTL_EXTEND                   EQU     $20             ; use extended functions from control2
0010                  DMACTL_HALT                     EQU     $10             ; halt cpu during transfer
0000                  DMACTL_STEP_DEST_NONE           EQU     $00             ; do not step destination address
0004                  DMACTL_STEP_DEST_UP             EQU     $04             ; step destination up after transfer
0008                  DMACTL_STEP_DEST_DOWN           EQU     $08             ; step destination down after transfer
000C                  DMACTL_STEP_DEST_RESV           EQU     $0C             ; reserved do not use
0000                  DMACTL_STEP_SRC_NONE            EQU     $00             ; do not step destination address
0001                  DMACTL_STEP_SRC_UP              EQU     $01             ; step destination up after transfer
0002                  DMACTL_STEP_SRC_DOWN            EQU     $02             ; step destination down after transfer
0003                  DMACTL_STEP_SRC_RESV            EQU     $03             ; reserved do not use
                      
0080                  DMACTL2_IF                      EQU     $80             ; interrupt occurred
0002                  DMACTL2_IE                      EQU     $02             ; interrupt enable, interrupt after transfer
0000                  DMACTL2_SZ_BYTE                 EQU     $00
0004                  DMACTL2_SZ_WORD                 EQU     $04
0008                  DMACTL2_SZ_WORDSWAPDEST         EQU     $08
000C                  DMACTL2_SZ_WORDSWAPSRC          EQU     $0C
0001                  DMACTL2_PAUSE                   EQU     $01
                      
                      ; Sound Status / control bits
0080                  SND_CTL_ACT                     EQU     $80
0001                  SND_CTL_REPEAT                  EQU     $01
                      
                      
0000                  DMAC_BLITCON_offs               EQU     0
0001                  DMAC_FUNCGEN_offs               EQU     $1
0002                  DMAC_WIDTH_offs                 EQU     $2
0003                  DMAC_HEIGHT_offs                EQU     $3
0004                  DMAC_SHIFT_offs                 EQU     $4
0005                  DMAC_MASK_FIRST_offs            EQU     $5
0006                  DMAC_MASK_LAST_offs             EQU     $6
0007                  DMAC_DATA_A_offs                EQU     $7
0008                  DMAC_ADDR_A_offs                EQU     $8
000B                  DMAC_DATA_B_offs                EQU     $B
000C                  DMAC_ADDR_B_offs                EQU     $C
000F                  DMAC_ADDR_C_offs                EQU     $F
0012                  DMAC_ADDR_D_offs                EQU     $12
0015                  DMAC_ADDR_E_offs                EQU     $15
0018                  DMAC_STRIDE_A_offs              EQU     $18
001A                  DMAC_STRIDE_B_offs              EQU     $1A
001C                  DMAC_STRIDE_C_offs              EQU     $1C
001E                  DMAC_STRIDE_D_offs              EQU     $1E
                      
0020                  DMAC_SND_DATA_offs              EQU     $20
0021                  DMAC_SND_ADDR_offs              EQU     $21
0024                  DMAC_SND_PERIOD_offs            EQU     $24
0026                  DMAC_SND_LEN_offs               EQU     $26
0028                  DMAC_SND_STATUS_offs            EQU     $28
0029                  DMAC_SND_VOL_offs               EQU     $29
002A                  DMAC_SND_REPOFF_offs            EQU     $2A
002C                  DMAC_SND_PEAK_offs              EQU     $2C
                      
002E                  DMAC_SND_MA_VOL_offs            EQU     $2E
002F                  DMAC_SND_SEL_offs               EQU     $2F
                      
0030                  DMAC_DMA_CTL_offs               EQU     $30
0031                  DMAC_DMA_SRC_ADDR_offs          EQU     $31
0034                  DMAC_DMA_DEST_ADDR_offs         EQU     $34
0037                  DMAC_DMA_COUNT_offs             EQU     $37
0039                  DMAC_DMA_DATA_offs              EQU     $39
003A                  DMAC_DMA_CTL2_offs              EQU     $3A
003B                  DMAC_DMA_PAUSE_offs             EQU     $3B
003F                  DMAC_DMA_SEL_offs               EQU     $3F
                      
FEFC                  jim_page_DMAC                   EQU     $FEFC           ; hardware jim page
FD60                  jim_DMAC                        EQU     $FD60           ; jim location in SYS map
                      
FC00                  jim_page_VERSION                EQU     $FC00
                      
0080                  jim_offs_VERSION_API_level      EQU     $80
0081                  jim_offs_VERSION_Board_level    EQU     $81
0082                  jim_offs_VERSION_API_sublevel   EQU     $82
0084                  jim_offs_VERSION_cfg_bits       EQU     $84
0088                  jim_offs_VERSION_cap_bits       EQU     $88
                      
                      ; Mk.2/1 option switches - note in API level >1 the sense of these is reversed!
0001                  BLT_MK2_CFG0_T65                EQU     $01
0000                  BLT_MK2_CFG0_CPU_6502A_2M       EQU     $00
0002                  BLT_MK2_CFG0_CPU_65C02_4M       EQU     $02
0004                  BLT_MK2_CFG0_CPU_65C02_8M       EQU     $04
0008                  BLT_MK2_CFG0_CPU_6x09_2M        EQU     $08
000A                  BLT_MK2_CFG0_CPU_6309_4M        EQU     $0A
000C                  BLT_MK2_CFG0_CPU_Z80_8M         EQU     $0C
000E                  BLT_MK2_CFG0_CPU_68008          EQU     $0E
0010                  BLT_MK2_CFG0_SWROMX             EQU     $10
0080                  BLT_MK2_CFG0_BUGBTN             EQU     $80
                      
0001                  BLT_MK2_CFG1_MEMI               EQU     $01
0002                  BLT_MK2_CFG1_BUGOUT             EQU     $02
                      
                      ; Mk.3 switches from PORTF/G
0008                  BLT_MK3_CFG0_T65                EQU     $08
0010                  BLT_MK3_CFG0_SWROMX             EQU     $10
0040                  BLT_MK3_CFG0_MEMI               EQU     $40
                      
                      
                      
FD60                  jim_DMAC_BLITCON                EQU     jim_DMAC + DMAC_BLITCON_offs
FD61                  jim_DMAC_FUNCGEN                EQU     jim_DMAC + DMAC_FUNCGEN_offs
FD62                  jim_DMAC_WIDTH                  EQU     jim_DMAC + DMAC_WIDTH_offs
FD63                  jim_DMAC_HEIGHT                 EQU     jim_DMAC + DMAC_HEIGHT_offs
FD64                  jim_DMAC_SHIFT                  EQU     jim_DMAC + DMAC_SHIFT_offs
FD65                  jim_DMAC_MASK_FIRST             EQU     jim_DMAC + DMAC_MASK_FIRST_offs
FD66                  jim_DMAC_MASK_LAST              EQU     jim_DMAC + DMAC_MASK_LAST_offs
FD67                  jim_DMAC_DATA_A                 EQU     jim_DMAC + DMAC_DATA_A_offs
FD68                  jim_DMAC_ADDR_A                 EQU     jim_DMAC + DMAC_ADDR_A_offs
FD6B                  jim_DMAC_DATA_B                 EQU     jim_DMAC + DMAC_DATA_B_offs
FD6C                  jim_DMAC_ADDR_B                 EQU     jim_DMAC + DMAC_ADDR_B_offs
FD6F                  jim_DMAC_ADDR_C                 EQU     jim_DMAC + DMAC_ADDR_C_offs
FD72                  jim_DMAC_ADDR_D                 EQU     jim_DMAC + DMAC_ADDR_D_offs
FD75                  jim_DMAC_ADDR_E                 EQU     jim_DMAC + DMAC_ADDR_E_offs
FD78                  jim_DMAC_STRIDE_A               EQU     jim_DMAC + DMAC_STRIDE_A_offs
FD7A                  jim_DMAC_STRIDE_B               EQU     jim_DMAC + DMAC_STRIDE_B_offs
FD7C                  jim_DMAC_STRIDE_C               EQU     jim_DMAC + DMAC_STRIDE_C_offs
FD7E                  jim_DMAC_STRIDE_D               EQU     jim_DMAC + DMAC_STRIDE_D_offs
                      
FD80                  jim_DMAC_SND_DATA               EQU     jim_DMAC + DMAC_SND_DATA_offs
FD81                  jim_DMAC_SND_ADDR               EQU     jim_DMAC + DMAC_SND_ADDR_offs
FD84                  jim_DMAC_SND_PERIOD             EQU     jim_DMAC + DMAC_SND_PERIOD_offs
FD86                  jim_DMAC_SND_LEN                EQU     jim_DMAC + DMAC_SND_LEN_offs
FD88                  jim_DMAC_SND_STATUS             EQU     jim_DMAC + DMAC_SND_STATUS_offs
FD89                  jim_DMAC_SND_VOL                EQU     jim_DMAC + DMAC_SND_VOL_offs
FD8A                  jim_DMAC_SND_REPOFF             EQU     jim_DMAC + DMAC_SND_REPOFF_offs
FD8C                  jim_DMAC_SND_PEAK               EQU     jim_DMAC + DMAC_SND_PEAK_offs
                      
                      
FD8F                  jim_DMAC_SND_SEL                EQU     jim_DMAC + DMAC_SND_SEL_offs
FD8E                  jim_DMAC_SND_MA_VOL             EQU     jim_DMAC + DMAC_SND_MA_VOL_offs
                      
FD90                  jim_DMAC_DMA_CTL                EQU     jim_DMAC + DMAC_DMA_CTL_offs
FD91                  jim_DMAC_DMA_SRC_ADDR           EQU     jim_DMAC + DMAC_DMA_SRC_ADDR_offs
FD94                  jim_DMAC_DMA_DEST_ADDR          EQU     jim_DMAC + DMAC_DMA_DEST_ADDR_offs
FD97                  jim_DMAC_DMA_COUNT              EQU     jim_DMAC + DMAC_DMA_COUNT_offs
FD99                  jim_DMAC_DMA_DATA               EQU     jim_DMAC + DMAC_DMA_DATA_offs
FD9A                  jim_DMAC_DMA_CTL2               EQU     jim_DMAC + DMAC_DMA_CTL2_offs
FD9B                  jim_DMAC_DMA_PAUSE              EQU     jim_DMAC + DMAC_DMA_PAUSE_offs
FD9F                  jim_DMAC_DMA_SEL                EQU     jim_DMAC + DMAC_DMA_SEL_offs
                      
00D0                  JIM_DEVNO_HOG1MPAULA            EQU     $D0
00D1                  JIM_DEVNO_BLITTER               EQU     $D1
                      
                      
                              ENDIF
                                      include "../../../includes/common.inc"
                                      ; processor flags
0001                  CC_C            EQU     $01
0002                  CC_V            EQU     $02
0004                  CC_Z            EQU     $04
0008                  CC_N            EQU     $08
0010                  CC_I            EQU     $10
0020                  CC_H            EQU     $20
0040                  CC_F            EQU     $40
0080                  CC_E            EQU     $80
                      
                      m_tax           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    X
                                      ENDM
                      
                      m_tax_se        MACRO
                                      jsr     _m_tax_se
                                      ENDM
                      
                      
                      m_tay           MACRO
                                      pshs    A
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      m_tay_c         MACRO
                                      pshs    A
                                      lda     #0
                                      sta     ,-S
                                      lda     1,S
                                      puls    Y
                                      ENDM
                      
                      
                      m_tbx           MACRO
                                      pshs    B                       ;6
                                      clr     ,-S                     ;8
                                      puls    X                       ;7 = 21
                                      ENDM
                      
                      m_tby           MACRO
                                      pshs    B
                                      clr     ,-S
                                      puls    Y
                                      ENDM
                      
                      
                      m_txa           MACRO
                                      pshs    X
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_tya           MACRO
                                      pshs    Y
                                      leas    1,S
                                      lda     ,S+
                                      ENDM
                      
                      m_txb           MACRO
                                      pshs    X
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      m_tyb           MACRO
                                      pshs    Y
                                      leas    1,S
                                      ldb     ,S+
                                      ENDM
                      
                      
                      
0002                  BRKSIZE         EQU     2
                      
                      
                      DEBUG_INST      MACRO
                                      SWI
                                      ENDM
                      
                      BRK     MACRO
                              swi3
                              ENDM
                      
                      DO_BRK  MACRO
                              BRK
                              FCB     \1
                              FCB     \2,0
                              ENDM
                      
                      
                      CLI     MACRO
                              ANDCC   #~(CC_I)
                              ENDM
                      
                      SEI     MACRO
                              ORCC    #CC_I
                              ENDM
                      
                      CLC     MACRO
                              ANDCC   #~CC_C
                              ENDM
                      
                      SEC     MACRO
                              ORCC    #CC_C
                              ENDM
                      
                      CLV     MACRO
                              ANDCC   #~CC_V
                              ENDM
                      
                      SEV     MACRO
                              ORCC    #CC_V
                              ENDM
                      
                      CLZ     MACRO
                              ANDCC   #~CC_Z
                              ENDM
                      
                      SEZ     MACRO
                              ORCC    #CC_Z
                              ENDM
                      
                      
                      STX_B   MACRO
                              PSHS    D
                              TFR     X,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      
                      STY_B   MACRO
                              PSHS    D
                              TFR     Y,D
                              STB     \1
                              PULS    D
                              ENDM
                      
                      LDX_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,X
                              PULS    D
                              ENDM
                      
                      LDY_B   MACRO
                              PSHS    D
                              LDB     \1
                              LDA     #0      ;DB: changed as CLRA resets carry!
                              TFR     D,Y
                              PULS    D
                              ENDM
                      
                      OSCALL  MACRO
                              JSR     \1
                              ENDM
                      
                      OSJMP   MACRO
                              JMP     \1
                              ENDM
                                      include "../../../includes/mosrom.inc"
0063                  mos_MACHINE_TYPE_BYTE                   EQU $63
                      
                      * Address of MOS ROM base
C000                  MOSROMBASE                              EQU $C000
F500                  MOSSTRINGS                              EQU $F500
                      
                      * default direct page for MOS ROM
0000                  MOSROMSYS_DP                            EQU $0
                      
                      * OSENTRIESLOC - this is the area that contains the OS call JSRs
                      * to mimic the published BBC MOS API
FFB6                  OSENTRIESLOC                            EQU $FFB6
                      
FF98                  JGH_OSENTRIESLOC                        EQU OSENTRIESLOC-3*10
                      
FF8C                  DOM_DEBUG_ENTRIES                       EQU JGH_OSENTRIESLOC-3*4
                      
                      * BOUNCELOC - an area of "bounces" where the indirected jumps and
                      * jsrs are stored - these need an extra instruction byte to 6502
                      * so must indirect through here
FF6C                  BOUNCELOC                               EQU JGH_OSENTRIESLOC-4*11
                      
                      
                      
0003                  FSCV_CODE_OSCLI_UK                      EQU $03
                      
                      
0000                  zp_lang                                 EQU $0000
0090                  zp_eco                                  EQU $0090
00A0                  zp_nmi                                  EQU $00A0
00A9                  L00A9                                   EQU $00A9
00B0                  zp_fs_s                                 EQU $00B0
00C0                  zp_fs_w                                 EQU $00C0
00D0                  zp_vdu_status                           EQU $00D0       ; VDU Status as read by OSBYTE &75
00D1                  zp_vdu_grpixmask                        EQU $00D1       ; Graphics pixel mask
00D2                  zp_vdu_txtcolourOR                      EQU $00D2       ; Text colour OR mask
00D3                  zp_vdu_txtcolourEOR                     EQU $00D3       ; Text colour EOR mask
00D4                  zp_vdu_gracolourOR                      EQU $00D4       ; Graphics colour OR mask
00D5                  zp_vdu_gracolourEOR                     EQU $00D5       ; Graphics colour EOR mask
00D6                  zp_vdu_gra_char_cell                    EQU $00D6       ; Graphics character cell
00D8                  zp_vdu_top_scanline                     EQU $00D8       ; Top scan line
00DA                  zp_vdu_wksp                             EQU $00DA       ; Temporary workspace
                      ;;;;removed !zp_rom_mul                 EQU $00E0       ; BBC, Electron: Row multiplication
00E2                  zp_cfs_w                                EQU $00E2
00E3                  zp_opt_val                              EQU $00E3       ; DB? check
00E4                  zp_mos_GSREAD_quoteflag                 EQU $00E4       ; GSREAD quote flag
00E5                  zp_mos_GSREAD_characc                   EQU $00E5       ; GSREAD character accumulator
00E6                  zp_mos_OS_wksp                          EQU $00E6       ; General OS workspace
00E7                  zp_mos_autorep_countdown                EQU $00E7       ; Auto repeat countdown timer
00E8                  zp_mos_input_buf                        EQU $00E8       ; Input buffer pointer for OSWORD 0
00EA                  zp_mos_rs423timeout                     EQU $00EA       ; RS423 timeout counter, unused if no RS423
00EB                  zp_mos_cfs_critical                     EQU $00EB       ; CFS/RFS 'critical' flag
00EC                  zp_mos_keynumlast                       EQU $00EC       ; Internal key number (last)
00ED                  zp_mos_keynumfirst                      EQU $00ED       ; Internal key number (first)
00EE                  zp_mos_jimdevsave                       EQU $00EE       ; Internal key number of character to be ignored by OSBYTE &79, also the 1MHz bus paging register
00EF                  zp_mos_OSBW_A                           EQU $00EF       ; OSBYTE/OSWORD A reg value
                              ***** NOTE: zp_mos_OSBW_Y&X swapped for endiannedss
00F0                  zp_mos_OSWORD_X                         EQU $00F0
00F0                  zp_mos_OSBW_Y                           EQU $00F0       ; OSBYTE/OSWORD Y reg value
00F1                  zp_mos_OSBW_X                           EQU $00F1       ; OSBYTE/OSWORD X reg value
                      
00F2                  zp_mos_txtptr                           EQU $00F2       ; OS Text pointer (eg star commands and filenames)
00F4                  zp_mos_curROM                           EQU $00F4       ; Currently selected ROM
00F5                  zp_mos_curPHROM                         EQU $00F5       ; Current PHROM or RFS ROM number or OSRDSC/OSWRSC number
00F6                  zp_mos_genPTR                           EQU $00F6       ; PHROM/RFSROM/OSRDSC/OSWRSC pointer
00F8                  zp_mos_X                                EQU $00F8       ; BBC, Electron: Unused, Master: Soft key expansion pointer
00FA                  zp_mos_OS_wksp2                         EQU $00FA       ; General OS workspace, used by buffer access code in interrupts
00FC                  zp_mos_INT_A                            EQU $00FC       ; Interrupt Temp A reg store
00FD                  zp_mos_error_ptr                        EQU $00FD       ; Error message pointer, initially set to language version string
00FF                  zp_mos_ESC_flag                         EQU $00FF       ; Escape flag (bit 7)
                      
0100                  stack                                   EQU $0100
0200                  STACKTOP                                EQU $0200
                      
0236                  sysvar_OSVARADDR                        EQU $0236       ; fx166/7 &A6/7 Address of OS variables
0238                  sysvar_ROMPTRTAB                        EQU $0238       ; fx168/9 &A8/9 Address of ROM pointer table
023A                  sysvar_ROMINFOTAB                       EQU $023A       ; fx170/1 &AA/B Address of ROM info table
023C                  sysvar_KEYB_ADDRTRANS                   EQU $023C       ; fx172/3 &AC/D Address of key translation table
023E                  sysvar_ADDRVDUVARS                      EQU $023E       ; fx174/5 &AE/F Address of VDU variables
0240                  sysvar_CFSTOCTR                         EQU $0240       ; fx176   &B0   CFS timeout counter, decremented every frame flyback
0241                  sysvar_CURINSTREAM                      EQU $0241       ; fx177   &B1   Currently selected input stream set with FX2
0242                  sysvar_KEYB_SEMAPHORE                   EQU $0242       ; fx178   &B2   BBC, Master: Keyboard semaphore
0243                  sysvar_PRI_OSHWM                        EQU $0243       ; fx179   &B3   Primary OSHWM
0244                  sysvar_CUR_OSHWM                        EQU $0244       ; fx180   &B4   Current OSHWM
0245                  sysvar_RS423_MODE                       EQU $0245       ; fx181   &B5   RS423 mode
0246                  sysvar_EXPLODESTATUS                    EQU $0246       ; fx182   &B6   BBC, Electron: Character definition explosion status
0247                  sysvar_CFSRFS_SWITCH                    EQU $0247       ; fx183   &B7   CFS/RFS switch
0248                  sysvar_VIDPROC_CTL_COPY                 EQU $0248       ; fx184   &B8   BBC, Master: RAM copy of VIDPROC control register
0249                  sysvar_VIDPROC_PAL_COPY                 EQU $0249       ; fx185   &B9   BBC, Master: RAM copy of VIDPROC palette register
024A                  sysvar_ROMNO_ATBREAK                    EQU $024A       ; fx186   &BA   ROM active last BRK
024B                  sysvar_ROMNO_BASIC                      EQU $024B       ; fx187   &BB   BASIC ROM number
024C                  sysvar_ADC_CUR                          EQU $024C       ; fx188   &BC   Current ADC Channel
024D                  sysvar_ADC_MAX                          EQU $024D       ; fx189   &BD   Maximum ADC Channel number
024E                  sysvar_ADC_ACCURACY                     EQU $024E       ; fx190   &BE   ADC conversion type/accuracy
024F                  sysvar_RS423_USEFLAG                    EQU $024F       ; fx191   &BF   RS423 use flag
0250                  sysvar_RS423_CTL_COPY                   EQU $0250       ; fx192   &C0   RAM copy of RS423 control register
0251                  sysvar_FLASH_CTDOWN                     EQU $0251       ; fx193   &C1   Flashing colour countdown timer
0252                  sysvar_FLASH_SPACE_PERIOD               EQU $0252       ; fx194   &C2   Flashing colour space period count set by FX9
0253                  sysvar_FLASH_MARK_PERIOD                EQU $0253       ; fx195   &C3   Flashing colour mark period count set by FX10
0254                  sysvar_KEYB_AUTOREP_DELAY               EQU $0254       ; fx196   &C4   Keyboard auto-repeat delay set by FX11
0255                  sysvar_KEYB_AUTOREP_PERIOD              EQU $0255       ; fx197   &C5   Keyboard auto-repeat period set by FX12
0256                  sysvar_EXEC_FILE                        EQU $0256       ; fx198   &C6   *EXEC file
0257                  sysvar_SPOOL_FILE                       EQU $0257       ; fx199   &C7   *SPOOL file handle
0258                  sysvar_BREAK_EFFECT                     EQU $0258       ; fx200   &C8   ESCAPE, BREAK effect
0259                  sysvar_KEYB_DISABLE                     EQU $0259       ; fx201   &C9   Keyboard disable
025A                  sysvar_KEYB_STATUS                      EQU $025A       ; fx202   &CA   Keyboard status byte
                                                                              ;Bit 7  =1 shift enabled   
                                                                              ;Bit 6  =1 control pressed 
                                                                              ;bit 5  =0 shift lock      
                                                                              ;Bit 4  =0 Caps lock       
                                                                              ;Bit 3  =1 shift pressed   
                      
025B                  sysvar_RS423_BUF_EXT                    EQU $025B       ; fx203   &CB   BBC, Master: Serial input buffer extent
025C                  sysvar_RS423_SUPPRESS                   EQU $025C       ; fx204   &CC   BBC, Master: Serial input supression flag
025D                  sysvar_RS423CASS_SELECT                 EQU $025D       ; fx205   &CD   BBC, Master: Serial/cassette selection flag
025E                  sysvar_ECO_OSBW_INTERCEPT               EQU $025E       ; fx206   &CE   Econet OSBYTE/OSWORD intercept flag
025F                  sysvar_ECO_OSRDCH_INTERCEPT             EQU $025F       ; fx207   &CF   Econet OSRDCH intercept flag
0260                  sysvar_ECO_OSWRCH_INTERCEPT             EQU $0260       ; fx208   &D0   Econet OSWRCH intercept flag
0261                  sysvar_SPEECH_SUPPRESS                  EQU $0261       ; fx209   &D1   Speech suppression status
0262                  sysvar_SOUND_SUPPRESS                   EQU $0262       ; fx210   &D2   Sound suppression status
0263                  sysvar_BELL_CH                          EQU $0263       ; fx211   &D3   BELL channel number
0264                  sysvar_BELL_ENV                         EQU $0264       ; fx212   &D4   BELL envelope number/amplitude
0265                  sysvar_BELL_FREQ                        EQU $0265       ; fx213   &D5   BELL frequency
0266                  sysvar_BELL_DUR                         EQU $0266       ; fx214   &D6   BELL duration
0267                  sysvar_STARTUP_DISPOPT                  EQU $0267       ; fx215   &D7   Startup display and BOOT error options
0268                  sysvar_KEYB_SOFTKEY_LENGTH              EQU $0268       ; fx216   &D8   Soft key string length
0269                  sysvar_SCREENLINES_SINCE_PAGE           EQU $0269       ; fx217   &D9   Screen lines since last page
026A                  sysvar_VDU_Q_LEN                        EQU $026A       ; fx218   &DA   256-number of items in VDU queue
026B                  sysvar_KEYB_TAB_CHAR                    EQU $026B       ; fx219   &DB   BBC, Master: TAB key character
026C                  sysvar_KEYB_ESC_CHAR                    EQU $026C       ; fx220   &DC   ESCAPE character
026D                  sysvar_KEYB_C0CF_INSERT_INT             EQU $026D       ; fx221   &DD   Char &C0-&CF buffer insert interpretation
026E                  sysvar_KEYB_D0DF_INSERT_INT             EQU $026E       ; fx222   &DE   Char &D0-&DF buffer insert interpretation
026F                  sysvar_KEYB_E0EF_INSERT_INT             EQU $026F       ; fx223   &DF   Char &E0-&EF buffer insert interpretation
0270                  sysvar_KEYB_F0FF_INSERT_INT             EQU $0270       ; fx224   &E0   Char &F0-&FF buffer insert interpretation
0271                  sysvar_KEYB_808F_INSERT_INT             EQU $0271       ; fx225   &E1   Char &80-&8F buffer insert interpretation (FKey)
0272                  sysvar_KEYB_909F_INSERT_INT             EQU $0272       ; fx226   &E2   Char &90-&9F buffer insert interpretation (Sh+FKey)
0273                  sysvar_KEYB_A0AF_INSERT_INT             EQU $0273       ; fx227   &E3   Char &A0-&AF buffer insert interpretation (Ct+FKey)
0274                  sysvar_KEYB_B0BF_INSERT_INT             EQU $0274       ; fx228   &E4   Char &B0-&BF buffer insert interpretation (Ct+Sh+FKey)
0275                  sysvar_KEYB_ESC_ACTION                  EQU $0275       ; fx229   &E5   ESCAPE key action
0276                  sysvar_KEYB_ESC_EFFECT                  EQU $0276       ; fx230   &E6   ESCAPE effects
0277                  sysvar_USERVIA_IRQ_MASK_CPY             EQU $0277       ; fx231   &E7   User 6522 VIA IRQ mask
0278                  sysvar_ACIA_IRQ_MASK_CPY                EQU $0278       ; fx232   &E8   6850 ACIA IRQ bit mask
0279                  sysvar_SYSVIA_IRQ_MASK_CPY              EQU $0279       ; fx233   &E9   System 6522 VIA IRQ mask
027A                  sysvar_TUBE_PRESENT                     EQU $027A       ; fx234   &EA   Tube presence flag
027B                  sysvar_SPEECH_PRESENT                   EQU $027B       ; fx235   &EB   Speech processor presence flag
027C                  sysvar_OUTSTREAM_DEST                   EQU $027C       ; fx236   &EC   Output stream character destination, set with FX3
027D                  sysvar_KEY_CURSORSTAT                   EQU $027D       ; fx237   &ED   Cursor key status, set with FX4
027E                  sysvar_FX238                            EQU $027E       ; fx238   &EE   BBC, Electron: unused
027F                  sysvar_FX239                            EQU $027F       ; fx239   &EF   unused
0280                  sysvar_COUNTRY                          EQU $0280       ; fx240   &F0   Country code
0281                  sysvar_USERFLAG                         EQU $0281       ; fx241   &F1   User flag location, set with FX1
0282                  sysvar_SERPROC_CTL_CPY                  EQU $0282       ; fx242   &F2   BBC, Master: RAM copy of SERPROC control register
0283                  sysvar_TIMER_SWITCH                     EQU $0283       ; fx243   &F3   Timer switch state
0284                  sysvar_KEYB_SOFT_CONSISTANCY            EQU $0284       ; fx244   &F4   Soft key consistancy flag
0285                  sysvar_PRINT_DEST                       EQU $0285       ; fx245   &F5   Printer destination, set with FX5
0286                  sysvar_PRINT_IGNORE                     EQU $0286       ; fx246   &F6   Printer ignore character, set with FX6
0287                  sysvar_BREAK_VECTOR_JMP                 EQU $0287       ; fx247   &F7   Break Intercept Vector JMP
0288                  sysvar_BREAK_VECTOR_LOW                 EQU $0288       ; fx248   &F8   Break Intercept Vector address low byte
0289                  sysvar_BREAK_VECTOR_HIGH                EQU $0289       ; fx249   &F9   Break Intercept Vector address high byte
028A                  sysvar_SHADOW1                          EQU $028A       ; fx250   &FA   BBC, Electron: unused, unless shadow screen present
028B                  sysvar_SHADOW2                          EQU $028B       ; fx251   &FB   BBC, Electron: unused, unless shadow screen present
028C                  sysvar_CUR_LANG                         EQU $028C       ; fx252   &FC   Current language ROM
028D                  sysvar_BREAK_LAST_TYPE                  EQU $028D       ; fx253   &FD   Last BREAK type
028E                  sysvar_RAM_AVAIL                        EQU $028E       ; fx254   &FE   BBC: Available RAM
028F                  sysvar_STARTUP_OPT                      EQU $028F       ; fx255   &FF   Startup options
0290                  oswksp_VDU_VERTADJ                      EQU $0290       ; VDU vertical adjust, *TV first parameter
0291                  oswksp_VDU_INTERLACE                    EQU $0291       ; Interlace toggle flag, *TV second parameter
0292                  oswksp_TIME                             EQU $0292       ; TIME value 1, high byte...low byte
0297                  oswksp_TIME2                            EQU $0297       ; TIME value 2, high byte...low byte
029C                  oswksp_OSWORD3_CTDOWN                   EQU $029C       ; OSWORD 3/4 Countdown interval timer value
02A1                  oswksp_ROMTYPE_TAB                      EQU $02A1       ; Paged ROM type table
02B1                  oswksp_INKEY_CTDOWN                     EQU $02B1       ; INKEY countdown timer
02B3                  oswksp_OSWORD0_LINE_LEN                 EQU $02B3       ; OSWORD 0 maximum line length
02B4                  oswksp_OSWORD0_MIN_CH                   EQU $02B4       ; OSWORD 0 minimum character
02B5                  oswksp_OSWORD0_MAX_CH                   EQU $02B5       ; OSWORD 0 maximum character
02B6                  adc_CH1_LOW                             EQU $02B6       ; Channel 1 ADC value low
02B7                  adc_CH2_LOW                             EQU $02B7       ; Channel 2 ADC value low
02B8                  adc_CH3_LOW                             EQU $02B8       ; Channel 3 ADC value low
02B9                  adc_CH4_LOW                             EQU $02B9       ; Channel 4 ADC value low
02BA                  adc_CH1_HI                              EQU $02BA       ; Channel 1 ADC value high
02BB                  adc_CH2_HI                              EQU $02BB       ; Channel 2 ADC value high
02BC                  adc_CH3_HI                              EQU $02BC       ; Channel 3 ADC value high
02BD                  adc_CH4_HI                              EQU $02BD       ; Channel 4 ADC value high
02BE                  adc_CH_LAST                             EQU $02BE       ; Last ADC channel converted
02BF                  mosvar_EVENT_ENABLE                     EQU $02BF       ; MOS Event enable flags
02C9                  mosvar_SOFTKEY_PTR                      EQU $02C9       ; Soft key expansion pointer
02CA                  mosvar_KEYB_AUTOREPEAT_COUNT            EQU $02CA       ; First auto repeat count
02CB                  mosvar_KEYB_TWOKEY_ROLLOVER             EQU $02CB       ; Two key rollover workspace
02CE                  mosvar_SOUND_SEMAPHORE                  EQU $02CE       ; Sound semaphore
02CF                  mosbuf_buf_busy                         EQU $02CF       ; Buffer busy flags           
02D8                  mosbuf_buf_start                        EQU $02D8       ; Buffer start indexes        
02E1                  mosbuf_buf_end                          EQU $02E1       ; Buffer end indexes          
02EA                  cfsrfs_BLK_SIZE                         EQU $02EA       ; Block size
02EC                  cfsrfs_BLK_FLAG                         EQU $02EC       ; Block flag
02ED                  cfsrfs_LAST_CHA                         EQU $02ED       ; Last input character
02EE                  osfile_ctlblk                           EQU $02EE       ; OSFILE control blocks for *LOAD, *SAVE, *CREATE and *DELETE.
0300                  vduvars_start                           EQU $0300
0300                  vduvar_GRA_WINDOW                       EQU $0300                               
0300                  vduvar_GRA_WINDOW_LEFT                  EQU $0300       ; Current graphics window left column in pixels
0302                  vduvar_GRA_WINDOW_BOTTOM                EQU $0302       ; Current graphics window bottom row in pixels
0304                  vduvar_GRA_WINDOW_RIGHT                 EQU $0304       ; Current graphics window right column in pixels
0306                  vduvar_GRA_WINDOW_TOP                   EQU $0306       ; Current graphics window top row in pixels
0308                  vduvar_TXT_WINDOW_LEFT                  EQU $0308       ; Current text window left hand column
0309                  vduvar_TXT_WINDOW_BOTTOM                EQU $0309       ; Current text window bottom row
030A                  vduvar_TXT_WINDOW_RIGHT                 EQU $030A       ; Current text window right hand column
030B                  vduvar_TXT_WINDOW_TOP                   EQU $030B       ; Current text window top column
030C                  vduvar_GRA_ORG_EXT                      EQU $030C       ; Current graphics origin in external coordinates
0310                  vduvar_GRA_CUR_EXT                      EQU $0310       ; Current graphics cursor in external coordinates
0314                  vduvar_GRA_CUR_INT_OLD                  EQU $0314       ; Old graphics cursor in external coordinates
0318                  vduvar_TXT_CUR_X                        EQU $0318       ; Current text cursor X
0319                  vduvar_TXT_CUR_Y                        EQU $0319       ; Current text cursor Y
031A                  vduvar_GRA_CUR_CELL_LINE                EQU $031A       ; Line within current graphics cell of graphics cursor
031B                  vduvar_VDU_Q_START                      EQU $031B
0324                  vduvar_VDU_Q_END                        EQU $0324       ; end of VDU Q (well 1 after!)
0324                  vduvar_GRA_CUR_INT                      EQU $0324       ; Current graphics cursor in internal coordinates
0328                  vduvar_TEMP_8                           EQU $0328       ; Bitmap read from screen by OSBYTE 135, various coordinate routines
0330                  vduvar_GRA_WKSP                         EQU $0330       ; Graphics workspace
034A                  vduvar_6845_CURSOR_ADDR                 EQU $034A       ; Text cursor address for 6845
034C                  vduvar_TXT_WINDOW_WIDTH_BYTES           EQU $034C       ; Text window width in bytes
034E                  vduvar_SCREEN_BOTTOM_HIGH               EQU $034E       ; High byte of bottom of screen memory
034F                  vduvar_BYTES_PER_CHAR                   EQU $034F       ; Bytes per character for current mode
0350                  vduvar_6845_SCREEN_START                EQU $0350       ; Screen display start address for 6845
0352                  vduvar_BYTES_PER_ROW                    EQU $0352       ; Bytes per screen row
0354                  vduvar_SCREEN_SIZE_HIGH                 EQU $0354       ; Screen memory size high byte
0355                  vduvar_MODE                             EQU $0355       ; Current screen mode
0356                  vduvar_MODE_SIZE                        EQU $0356       ; Memory map type: 0 - 20K, 1 - 16K, 2 - 10K, 3 - 8K, 4 - 1K
0357                  vduvar_TXT_FORE                         EQU $0357       ; Foreground text colour
0358                  vduvar_TXT_BACK                         EQU $0358       ; Background text colour
0359                  vduvar_GRA_FORE                         EQU $0359       ; Foreground graphics colour
035A                  vduvar_GRA_BACK                         EQU $035A       ; Background graphics colour
035B                  vduvar_GRA_PLOT_FORE                    EQU $035B       ; Foreground plot mode
035C                  vduvar_GRA_PLOT_BACK                    EQU $035C       ; Background plot mode
035D                  vduvar_VDU_VEC_JMP                      EQU $035D       ; General VDU jump vector
035F                  vduvar_CUR_START_PREV                   EQU $035F       ; Cursor start register previous setting
0360                  vduvar_COL_COUNT_MINUS1                 EQU $0360       ; Number logical colours -1
0361                  vduvar_PIXELS_PER_BYTE_MINUS1           EQU $0361       ; Pixels per byte -1 (zero if text only mode)
0362                  vduvar_LEFTMOST_PIX_MASK                EQU $0362       ; Leftmost pixel colour mask
0363                  vduvar_RIGHTMOST_PIX_MASK               EQU $0363       ; Rightmost pixel colour mask
0364                  vduvar_TEXT_IN_CUR_X                    EQU $0364       ; Text input cursor X
0365                  vduvar_TEXT_IN_CUR_Y                    EQU $0365       ; Text input cursor Y
0366                  vduvar_MO7_CUR_CHAR                     EQU $0366       ; Teletext output cursor character
0367                  vduvar_EXPLODE_FLAGS                    EQU $0367       ; Font explosion flags, b1=224-255 in RAM, b7=32-63 in RAM
0368                  vduvar_FONT_LOC32_63                    EQU $0368       ; Font location, characters 32-63
0369                  vduvar_FONT_LOC64_95                    EQU $0369       ; Font location, characters 64-95 
036A                  vduvar_FONT_LOC96_127                   EQU $036A       ; Font location, characters 96-127
036B                  vduvar_FONT_LOC128_159                  EQU $036B       ; Font location, characters 128-159
036C                  vduvar_FONT_LOC160_191                  EQU $036C       ; Font location, characters 160-191
036D                  vduvar_FONT_LOC192_223                  EQU $036D       ; Font location, characters 192-223
036E                  vduvar_FONT_LOC224_255                  EQU $036E       ; Font location, characters 224-255
036F                  vduvar_PALLETTE                         EQU $036F       ; Palette for colours 0 to 15
                      
03D1                  fsvar_seq_block_gap                     EQU $03D1
                      
                      ********************************************************
                      *           B U F F E R   A D D R E S S E S            *
                      ********************************************************
                      
03E0                  BUFFER_KEYB_START                       EQU $03E0
03FF                  BUFFER_KEYB_END                         EQU $03FF
0A00                  BUFFER_SERI_START                       EQU $0A00
0AFF                  BUFFER_SERI_END                         EQU $0AFF
0900                  BUFFER_SERO_START                       EQU $0900
09BF                  BUFFER_SERO_END                         EQU $09BF
0880                  BUFFER_LPT_START                        EQU $0880
08BF                  BUFFER_LPT_END                          EQU $08BF
0840                  BUFFER_SND0_START                       EQU $0840
084F                  BUFFER_SND0_END                         EQU $084F
0850                  BUFFER_SND1_START                       EQU $0850
085F                  BUFFER_SND1_END                         EQU $085F
0860                  BUFFER_SND2_START                       EQU $0860
086F                  BUFFER_SND2_END                         EQU $086F
0870                  BUFFER_SND3_START                       EQU $0870
087F                  BUFFER_SND3_END                         EQU $087F
09C0                  BUFFER_SPCH_START                       EQU $09C0
09FF                  BUFFER_SPCH_END                         EQU $09FF
                      
                      
                      BUFFER_PTR_ADDR         MACRO ; 1=START, 2=END
                                              FDB (\2+1)-$100
                                              ENDM
                      
                      BUFFER_ACC_OFF          MACRO ; 1=START, 2=END
                                              FCB \1-(\2+1)-$100              ; i.e. $100 - len!
                                              ENDM
                      
                      
                      
                      
0800                  snd_unused1                             EQU $800        ; Unused
0804                  snd_q_occupied                          EQU $804        ; Sound queue occupancy flag
0808                  snd_amplitude                           EQU $808        ; Current amplitude
080C                  snd_amplitude_phase_count               EQU $80C        ; Number of amplitude phases processed
0810                  snd_abs_pitch                           EQU $810        ; Absolute pitch value
0814                  snd_pitch_phase_count                   EQU $814        ; Number of pitch phases processed
0818                  snd_steps_left                          EQU $818        ; Number of steps to process
081C                  snd_duration_ctr                        EQU $81C        ; Duration
0820                  snd_duration_mul                        EQU $820        ; Interval multiplier
0824                  snd_env_no                              EQU $824        ; Envelope number/auto repeat parameter
0828                  snd_length_left                         EQU $828        ; Length of remaining note interval
082C                  snd_sync_hold_parm                      EQU $82C        ; Sync hold parameter
0830                  snd_chip_pitch                          EQU $830        ; Sound chip current pitch setting
0834                  snd_pitch_deviation                     EQU $834        ; Pitch deviation
0838                  snd_num_chans_sync                      EQU $838        ; Number of channels required for sync
0839                  snd_cur_amp_step                        EQU $839        ; Current amplitude step
083A                  snd_cur_target_amplitude                EQU $83A        ; Current target amplitude
083B                  snd_num_chans_hold_sync                 EQU $83B        ; Number of channels on hold for sync
                      
083C                  snd_parm_wksp                           EQU $83C        ; Sound parameter calculation workspace
083D                  snd_low_parm                            EQU $83D        ; Low order frequency parameter as sent to the sound generator
083E                  snd_high_parm                           EQU $83E        ; High order frequency parameter as sent to the sound generator
083F                  snd_tempx                               EQU $83F
                      
08C0                  snd_envelope_defs                       EQU $8C0
                      
0B00                  soft_keys_start                         EQU $B00
0B00                  soft_keys_ptrs                          EQU soft_keys_start
0B10                  soft_keys_end_ptr                       EQU soft_keys_ptrs+$10
0B11                  soft_keys_defs                          EQU soft_keys_start+$11
                      
0D00                  vec_nmi                                 EQU $0D00
                      
0DF0                  swrom_wksp_tab                          EQU $0DF0
                      
                      ; REMAPPED HARDWARE VECTOS
                      
F7F0                  HWVEC_DIV0                              EQU     $F7F0
F7F2                  HWVEC_SWI3V                             EQU     $F7F2
F7F4                  HWVEC_SWI2V                             EQU     $F7F4
F7F6                  HWVEC_FIRQV                             EQU     $F7F6
F7F8                  HWVEC_IRQV                              EQU     $F7F8
F7FA                  HWVEC_SWIV                              EQU     $F7FA
F7FC                  HWVEC_NMIV                              EQU     $F7FC
F7FE                  HWVEC_RESETV                            EQU     $F7FE
                                      include "../../../includes/noice.inc"
                      
                              IF NOICE_CODE_BASE
                              ELSE
                      NOICE_CODE_BASE         EQU     $F100   ; a hole to be left here for the noice debugger
                                                              ; if this constant is changed remember to update
                                                              ; README.txt, MONXXXX-dom1.asm and mosloader.asm
                                                              ; as required
                              ENDIF
                      
                              IF NOICE_CODE_LEN
                              ELSE
                      NOICE_CODE_LEN          EQU     $03B0   ; TODO: get this from the NOICE code?
                              ENDIF
                      
                      ;; - this now must be defined when building
                      ;;NOICE_RAM_START               EQU     $A00    ; START OF MONITOR RAM Workspace - use A00 for 
                      ;;                                      ; now which is Serial transient command buffer, 
                      ;;                                      ; might need to make an "official" hole in the 
                      ;;                                      ; memory map
                      
C200                  NOICE_BAUD_RATE         EQU     115200  ; Baud rate for serial comms
                      
                              ENDIF
                      
                              IF NOICE_MY
FCA1                  fred_MYELIN_SERIAL_STATUS       EQU     $FCA1
FCA0                  fred_MYELIN_SERIAL_DATA         EQU     $FCA0
0002                  MYELIN_SERIAL_TXRDY             EQU     2
0001                  MYELIN_SERIAL_RXRDY             EQU     1
                              ENDIF
                      
                      
                              IF DO_ROMLATCH
FE30                  MAPREG          EQU     sheila_ROMCTL_SWR
00F4                  MAPIMG          EQU     zp_mos_curROM
                              ENDIF
                      
                      * Ported to beeb6809 27/4/2017 Dominic Beesley
                      * adapted for both 6809 (define CPU_6809) or 6309 (define CPU_6309)
                      * adapted to chipkit with S16550 (define MACH_CHIPKIT) or Model B (define MACH_BEEB)
                      *  6809 Debug monitor for use with NOICE09
                      *
                      *  Copyright (c) 1992-2006 by John Hartman
                      *
                      *  Modification History:
                      *       14-Jun-93 JLH release version
                      *       24-Aug-93 JLH bad constant for COMBUF length compare
                      *       25-Feb-98 JLH assemble with either Motorola or Dunfield
                      *        1-May-06 JLH slight cleanup
                      *
                      *============================================================================
                      *
                      *  To customize for a given target, you must change code in the
                      *  hardware equates, the string TSTG, and the routines RESET and REWDT.
                      *  You may or may not need to change GETCHAR, PUTCHAR, depending on
                      *  how peculiar your UART is.
                      *
                      *  This file has been assembled with the Motorola Freeware assembler
                      *  available from the Motorola Freeware BBS and elsewhere.
                      *   BUT:  you must first "comment out" the conditionals as required,
                      *   because the Motorola assemblers do not have any IFEQ/ELSE/ENDIF
                      *
                      *  This file may also be assembled with the Dunfield assembler
                      *
                      *  To add mapped memory support:
                      *       1) Define map port MAPREG here
                      *       2) Define or import map port RAM image MAPIMG here if MAPREG is
                      *          write only.  (The application code must update MAPIMG before
                      *          outputing to MAPREG)
                      *       3) Search for and modify MAPREG, MAPIMG, and REG_PAGE usage below
                      *       4) In TSTG below edit "LOW AND HIGH LIMIT OF MAPPED MEM"
                      *          to appropriate range (typically 4000H to 07FFFH for two-bit MMU)
                      *
                      
                      *
                      *============================================================================
                      *
                      *  RAM interrupt vectors (first in SEG for easy addressing, else move to
                      *  their own SEG)
0008                  NVEC            EQU     8             ; number of vectors
                      *
                      *  Initial user stack
                      *  (Size and location is user option)
0200                  INITSTACK               EQU     $200
                      
                      
                      
0A00                                  ORG     NOICE_RAM_START                 ; use cassette / serial input buffer 
0B00                  MONSTACK        EQU     NOICE_RAM_START + $100          ; top of!
                      
                              IF CPU_6309
0A00                  TEST_STACK      RMB     14
                      * It is not possible to read bits 0&1 of regMD so the next three lines enable
                      * testing of these bits.
0A0E                  E_FLAG          RMB     1               0=not set $80=set
0A0F                  S_IMAGE         RMB     2               temporary store for regS
                              ENDIF
                      
                      *  Target registers:  order must match that in TRGHC11.C
0A11                  TASK_REGS
0A11                  REG_STATE       RMB     1
0A12                  REG_PAGE        RMB     1
0A13                  REG_SP          RMB     2
0A15                  REG_U           RMB     2
0A17                  REG_Y           RMB     2
0A19                  REG_X           RMB     2
                              IF CPU_6309
0A1B                  REG_F           RMB     1               F BEFORE E, SO W IS LEAST SIG. FIRST
0A1C                  REG_E           RMB     1
                              ENDIF
0A1D                  REG_B           RMB     1               B BEFORE A, SO D IS LEAST SIG. FIRST
0A1E                  REG_A           RMB     1
0A1F                  REG_DP          RMB     1
0A20                  REG_CC          RMB     1
                              IF CPU_6309
0A21                  REG_MD          RMB     1
0A22                  REG_V           RMB     2
                              ENDIF
0A24                  REG_PC          RMB     2
0015                  TASK_REG_SZ     EQU     *-TASK_REGS
                                              IF STANDALONE
0A26                  RAMVEC          RMB     2*NVEC
                                              ENDIF
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
0A36                  RUNNING_FLAG    RMB     1
                              ENDIF
                      
                      *
                      *  Communications buffer
                      *  (Must be at least as long as TASK_REG_SZ.  At least 19 bytes recommended.
                      *  Larger values may improve speed of NoICE memory move commands.)
0080                  COMBUF_SIZE     EQU     128             DATA SIZE FOR COMM BUFFER
0A37                  COMBUF          RMB     2+COMBUF_SIZE+1 BUFFER ALSO HAS FN, LEN, AND CHECK
                      
                              IF NOICE_DEBUG_MEMMAP
                      RW_MEM_CODE_SAVE
                                      RMB     $100
                              ENDIF
                      
                      *
0ABA                  RAM_END         EQU    *               ADDRESS OF TOP+1 OF RAM
                      
                                      IF      STANDALONE
                      *
                      *===========================================================================
                      * Bodge to make ROM start at $8000
                                      IF      NOICE_CODE_BASE != $8000
8000                                  ORG     $8000
8000  12                                      NOP
8001  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF                         FILL    $FF,NOICE_CODE_BASE-*
                                      ENDIF
                                      ENDIF
                      
                      
F100                                  ORG     NOICE_CODE_BASE
                      
                                      IF STANDALONE==0
                      ENTER_NMI_ENT           FDB     NMI_ENT
                      ENTER_SWI_ENT           FDB     SWI_ENT
                      ENTER_PUTCHAR           FDB     PUTCHAR
                      ENTER_RESET             FDB     RESET
                                      ENDIF
                      *
                      *  Power on reset
F100                  RESET
                      
                              IF      STANDALONE
                      *
                      *  Set CPU mode to safe state
F100  1A50                            ORCC    #CC_I+CC_F            ; INTERRUPTS OFF
F102  10CE0B00                        LDS     #MONSTACK       ; CLEAN STACK IS HAPPY STACK
                      *
                      *----------------------------------------------------------------------------
                      
                      
0000                  SCREEN_BASEx8   EQU     0
                      
                      ; setup CRTC to show bottom part of RAM in mode 1
                      
                                      ; setup CRTC
F106  C60B                            LDB     #$B
F108  8EF522                          LDX     #mostbl_VDU_6845_mode_012
F10B  F7FE00          crtcsetlp1      STB     sheila_CRTC_reg
F10E  A685                            LDA     B,X
F110  B7FE01                          STA     sheila_CRTC_rw
F113  5A                              DECB
F114  2AF5                            BPL     crtcsetlp1
                      
F116  860C                            LDA     #12
F118  B7FE00                          STA     sheila_CRTC_reg
F11B  8600                            LDA     #SCREEN_BASEx8 / $100
F11D  B7FE01                          STA     sheila_CRTC_rw
                      
F120  860D                            LDA     #13
F122  B7FE00                          STA     sheila_CRTC_reg
F125  8600                            LDA     #SCREEN_BASEx8 % $100
F127  B7FE01                          STA     sheila_CRTC_rw
                      
F12A  869C                            LDA     #$9C
F12C  B7FE20                          STA     sheila_VIDULA_ctl
                      
F12F  860C                            LDA     #12
F131  B7FE00                          STA     sheila_CRTC_reg
F134  8600                            LDA     #SCREEN_BASEx8 / $100
F136  B7FE01                          STA     sheila_CRTC_rw
                      
F139  860D                            LDA     #13
F13B  B7FE00                          STA     sheila_CRTC_reg
F13E  8600                            LDA     #SCREEN_BASEx8 % $100
F140  B7FE01                          STA     sheila_CRTC_rw
                      
F143  C600                            LDB     #0
F145  1F98            pallp           TFR     B,A
F147  5D                              TSTB
F148  2A02                            BPL     1F
F14A  8A0F                            ORA     #$F
F14C  B7FE21          1               STA     sheila_VIDULA_pal
F14F  CB10                            ADDB    #$10
F151  26F2                            BNE     pallp
                              ENDIF
                      
                              IF MACH_CHIPKIT
                      *
                      *  Initialize UART
                      *
                      *  Delay here in case the UART has not come out of reset yet.
                                      LDX     #0
                      LOP             LEAX    -1,X                  ;  DELAY FOR SLOW RESETTING UART
                                      NOP
                                      NOP
                                      BNE     LOP
                      *
                      *  access baud generator, no parity, 1 stop bit, 8 data bits
                                      LDA     #$83
                                      STA     S16550_LCR
                                      LDA     #%10000111                      ; enable FIFOs and clear trigger RECV interrupt at 8
                                      STA     S16550_FCR                      ; no FIFOs
                      
                      *
                      *  fixed baud rate of 19200:  crystal is 3.686400 Mhz.
                      *  Divisor is 4000000/(16*baud)
                      BAUD_WORD       EQU SER_BAUD_CLOCK_IN/(NOICE_BAUD_RATE*16)
                                      LDA     #BAUD_WORD%256
                                      STA     S16550_RXR              ; lsb
                                      LDA     #BAUD_WORD/256
                                      STA     S16550_RXR+1            ; msb=0
                      *
                      *  access data registers, no parity, 1 stop bits, 8 data bits
                                      LDA     #$03
                                      STA     S16550_LCR
                      *
                      *  no loopback, OUT2 on, OUT1 on, RTS on, DTR (LED) on
                                      LDA     #$0F
                                      STA     S16550_MCR
                      *
                      *  disable all interrupts: modem, receive error, transmit, and receive
                                      LDA     #$00
                                      STA     S16550_IER
                              ENDIF
                      
                              IF STANDALONE
                      *
                      *----------------------------------------------------------------------------
                      *
                      *  Initialize RAM interrupt vectors
F153  108EF1EF                        LDY     #INT_ENTRY      ; ADDRESS OF DEFAULT HANDLER
F157  8E0A26                          LDX     #RAMVEC         ; POINTER TO RAM VECTORS
F15A  C608                            LDB     #NVEC           ; NUMBER OF VECTORS
F15C  10AF81          RES10           STY     ,X++            ; SET VECTOR
F15F  5A                              DECB
F160  26FA                            BNE     RES10
                      
                              ENDIF
                      *
                      *  Initialize user registers
                      
F162  C615                            LDB     #TASK_REG_SZ
F164  8E0A11                          LDX     #TASK_REGS
F167  6F80            1               CLR     ,X+
F169  5A                              DECB
F16A  26FB                            BNE     1B
                      
F16C  CC0200                          LDD     #INITSTACK
F16F  B70A14                          STA     REG_SP+1                ; INIT USER'S STACK POINTER MSB
F172  F70A13                          STB     REG_SP                  ; LSB
                      
F175  86D0                            LDA     #CC_E+CC_I+CC_F                  ; state "all regs pushed", no ints
F177  B70A20                          STA     REG_CC
                      *
                      *  Set function code for "GO".  Then if we reset after being told to
                      *  GO, we will come back with registers so user can see the crash
F17A  86FA                            LDA     #FN_RUN_TARG
F17C  B70A37                          STA     COMBUF
                      
                              IF      STANDALONE
020D                  BEEP_FREQ       EQU     525
0900                  BEEP_76489CLK   EQU     4000000
                      
F17F  BDF55D                          JSR     reset_snd
F182  8602                            LDA     #2
F184  8E00EE                          LDX     #((BEEP_76489CLK/32)/BEEP_FREQ)
F187  BDF5D1                          JSR     snd_tone
F18A  8602                            LDA     #2
F18C  C600                            LDB     #$0
F18E  BDF5C1                          JSR     snd_vol
F191  8E0000                          LDX     #0
F194  2000            1               BRA     2F
F196  2000            2               BRA     3F
F198  301F            3               LEAX    -1,X
F19A  26F8                            BNE     1B
F19C  8602                            LDA     #2
F19E  C60F                            LDB     #$F
F1A0  BDF5C1                          JSR     snd_vol
                      
F1A3  7EF36D                          JMP     RETURN_REGS             ; DUMP REGS, ENTER MONITOR
                      
                              ELSE
                                      IF NOICE_DEBUG_MEMMAP
                                      ELSE
                                              LDA     #$FF
                                              STA     RUNNING_FLAG            ; mark as running and drop back to MOS ROM init code
                                      ENDIF
                                              RTS                             ; return to MOS
                              ENDIF
                      
                      *
                      *===========================================================================
                      *  Get a character to A
                      *
                      *  Return A=char, CY=0 if data received
                      *         CY=1 if timeout (0.5 seconds)
                      *
                      *  Uses 6 bytes of stack including return address
                      *
F1A6                  GETCHAR
F1A6  3410                            PSHS    X
F1A8  8E0000                          LDX     #0                      ; LONG TIMEOUT
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ORA     #LED_WT_RX
                                      STA     LEDS
                              ENDIF
F1AB  301F            GC10            LEAX    -1,X
F1AD  270D                            BEQ     GC90                    ; EXIT IF TIMEOUT
                              IF MACH_BEEB
                              IF NOICE_MY
F1AF  B6FCA1                          LDA     fred_MYELIN_SERIAL_STATUS
F1B2  8401                            ANDA    #MYELIN_SERIAL_RXRDY
                              ELSE
                                      LDA     sheila_ACIA_CTL         ; READ DEVICE STATUS
                                      ANDA    #1
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      LDA     S16550_LSR              ; READ DEVICE STATUS
                                      ANDA    #SER_BIT_RXRDY
                              ENDIF
                              IF MACH_WBONE
                                      TST     sheila_SERIAL2_STATUS
                                      BMI     GC10
                              ELSE
F1B4  27F5                            BEQ     GC10                    ; NOT READY YET.
                              ENDIF
                      *
                      *  Data received:  return CY=0. data in A
F1B6  4F                              CLRA                            ; CY=0
                              IF MACH_BEEB
                              IF NOICE_MY
F1B7  B6FCA0                          LDA     fred_MYELIN_SERIAL_DATA ; READ DATA
                              ELSE
                                      LDA     sheila_ACIA_DATA        ; READ DATA
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      LDA     S16550_RXR              ; READ DATA
                              ENDIF
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ANDA    #~LED_WT_RX
                                      STA     LEDS
                                      LDA     sheila_SERIAL2_DATA
                              ENDIF
F1BA  3590                            PULS    X,PC
                      
                      *
                      *  Timeout:  return CY=1
F1BC                  GC90            
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ANDA    #~LED_WT_RX
                                      ORA     #LED_TO_RX
                                      STA     LEDS
                      
                                      JSR     PIPDLY
                      
                                      ANDA    #~LED_TO_RX
                                      STA     LEDS
                      
                              ENDIF
F1BC  1A01                            ORCC    #CC_C                   ; CY=1
F1BE  3590                            PULS    X,PC
                      
                              IF MACH_WBONE
                      PIPDLY
                                      PSHS    X
                                      LDX     #1000
                      1               LEAX    -1,X
                                      BNE     1B
                                      PULS    X,PC
                              ENDIF
                      
                      
                      *
                      *===========================================================================
                      *  Output character in A
                      *
                      *  Uses 5 bytes of stack including return address
                      *
F1C0                  PUTCHAR
F1C0  3402                            PSHS    A
                              IF MACH_WBONE
                                      LDA     LEDS
                                      ORA     #LED_WT_TX
                                      STA     LEDS
                              ENDIF
F1C2                  PC10    
                              IF MACH_BEEB
                              IF NOICE_MY
F1C2  B6FCA1                          LDA     fred_MYELIN_SERIAL_STATUS       ; CHECK TX STATUS
F1C5  8402                            ANDA    #MYELIN_SERIAL_TXRDY            ; TX READY ?
                              ELSE
                                      LDA     sheila_ACIA_CTL ; CHECK TX STATUS
                                      ANDA    #2              ; TX READY ?
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      LDA     S16550_LSR     ; CHECK TX STATUS
                                      ANDA    #SER_BIT_TXRDY ; RX READY ?
                              ENDIF
                              IF MACH_WBONE
                                      LDA     sheila_SERIAL2_STATUS
                                      ANDA    #SER_STAT_nTXE
                                      BNE     PC10
                              ELSE
F1C7  27F9                            BEQ     PC10    
                              ENDIF
F1C9  3502                            PULS    A
                              IF MACH_BEEB
                              IF NOICE_MY
F1CB  B7FCA0                          STA     fred_MYELIN_SERIAL_DATA
                              ELSE    
                                      STA     sheila_ACIA_DATA
                              ENDIF
                              ENDIF
                              IF MACH_CHIPKIT
                                      STA     S16550_TXR     ; TRANSMIT CHAR.
                              ENDIF
                              IF MACH_WBONE
                                      STA     sheila_SERIAL2_DATA
                                      PSHS    A
                                      LDA     LEDS
                                      ANDA    #~LED_WT_TX
                                      STA     LEDS
                                      PULS    A
                              ENDIF
F1CE  39                              RTS
                      
                      *======================================================================
                      *  Response string for GET TARGET STATUS request
                      *  Reply describes target:
F1CF                  TSTG    
                              IF CPU_6309
F1CF  11                              FCB     17                      ; 2: PROCESSOR TYPE = 6309
                              ELSE
                                      FCB     5                       ; 2: PROCESSOR TYPE = 6809
                              ENDIF
F1D0  80                              FCB     COMBUF_SIZE             ; 3: SIZE OF COMMUNICATIONS BUFFER
F1D1  00                              FCB     0                       ; 4: NO TASKING SUPPORT
                              IF DO_ROMLATCH
F1D2  8000BFFF                        FDB     $8000,$BFFF             ; PAGED SW ROM/RAM at $8000
                              ELSE
                                      FDB     0,0                     ; 5-8: LOW AND HIGH LIMIT OF MAPPED MEM (NONE)
                              ENDIF
F1D6  01                              FCB     B1-B0                   ; 9:  BREAKPOINT INSTR LENGTH
F1D7  3F              B0              SWI                             ; 10: BREAKPOINT INSTRUCTION
F1D8                  B1              
                              IF CPU_6309
F1D8  36333039                        FCC     "6309"
                              ELSE
                                      FCC     "6809"
                              ENDIF
F1DC  206D6F6E69746F722056312E312D                 FCC     " monitor V1.1-"        ; DESCRIPTION, ZERO
                              IF MACH_CHIPKIT
                                      FCC     "-chipkit"
                              ENDIF
                              IF MACH_BEEB
F1EA  2D424243                        FCC     "-BBC"
                              ENDIF
                              IF MACH_WBONE
                                      FCC     "-WBONE"
                              ENDIF
F1EE  00                              FCB     0 
0020                  TSTG_SIZE       EQU     *-TSTG          ; SIZE OF STRING
                      *
                      *======================================================================
                      *  HARDWARE PLATFORM INDEPENDENT EQUATES AND CODE
                      *
                      *  Communications function codes.
00FF                  FN_GET_STAT     EQU     $FF    ; reply with device info
00FE                  FN_READ_MEM     EQU     $FE    ; reply with data
00FD                  FN_WRITE_M      EQU     $FD    ; reply with status (+/-)
00FC                  FN_READ_RG      EQU     $FC    ; reply with registers
00FB                  FN_WRITE_RG     EQU     $FB    ; reply with status
00FA                  FN_RUN_TARG     EQU     $FA    ; reply (delayed) with registers
00F9                  FN_SET_BYTE     EQU     $F9    ; reply with data (truncate if error)
00F8                  FN_IN           EQU     $F8    ; input from port
00F7                  FN_OUT          EQU     $F7    ; output to port
                      *
00F7                  FN_MIN          EQU     $F7    ; MINIMUM RECOGNIZED FUNCTION CODE
00F0                  FN_ERROR        EQU     $F0    ; error reply to unknown op-code
                      *
                      *===========================================================================
                      *  Common handler for default interrupt handlers
                      *  Enter with A=interrupt code = processor state
                      *  All registers stacked, PC=next instruction
                      *
                      *  If 6809 mode, stack has CC A B DP XH XL YH YL UH UL PCH PCL
                      *  If 6309 mode, stack has CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      *
F1EF                  INT_ENTRY
F1EF  B70A11                          STA     REG_STATE       ; SAVE STATE
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
F1F2  8102                            CMPA    #2              ; DB: check for NMI
F1F4  2606                            BNE     INT_ENTRY_GO
F1F6  7D0A36                          TST     RUNNING_FLAG    ; not running just RTI
F1F9  2601                            BNE     INT_ENTRY_GO
F1FB  3B                              RTI
F1FC                  INT_ENTRY_GO
                              ENDIF
                      
                      *
                      *  Save registers from stack to reg block for return to master
                      *  Host wants least significant bytes first, so flip as necessary
F1FC  3502                            PULS    A
F1FE  B70A20                          STA     REG_CC          ; CONDITION CODES
F201  3502                            PULS    A
F203  B70A1E                          STA     REG_A           ; A
F206  3502                            PULS    A
F208  B70A1D                          STA     REG_B           ; B
                      
                              IF CPU_6309
                      
F20B  BDF278                          JSR     CHECK_6309
F20E  2635                            BNE     NOT_6309_1
                      
                      *  If native mode, E and F are on stack
                      *  If 6809 mode, E and F are in registers, unchanged from interrupt til here
                              ; clear BIT 1 of REG_MD before test and set if in 6309 mode
F210  72FE0A21                        AIM     #$FE,REG_MD
F214  BDF52E                          JSR     MD_TEST
F217  2606                            BNE     IE_10           ; Jump if 6809 mode
F219  1039                            PULSW                   ; else native: get from stack
F21B  71010A21                        OIM     #$1,REG_MD
F21F  11B70A1C        IE_10           STE     REG_E
F223  11F70A1B                        STF     REG_F
                      
                      *  V isn't on the stack, but we haven't touched it.  Copy to RAM
F227  1F70                            TFR     V,D
F229  B70A23                          STA     REG_V+1         ; MSB V
F22C  F70A22                          STB     REG_V           ; LSB V
                      
                      *  There seems to be no way to store MD, and no way to load it except immediate
                      *  Thus we have to construct it by BITMD
F22F  B60A21                          LDA     REG_MD
                                      ; DB: Changed this TEST_MD wasn't saving the bits!
F232  8403                            ANDA    #$03            ; save only bits 1 and 0 (set by MD_TEST)
F234  113C40                          BITMD   #$40
F237  2702                            BEQ     IE_11
F239  8A40                            ORA     #$40
F23B  113C80          IE_11           BITMD   #$80
F23E  2702                            BEQ     IE_12
F240  8A80                            ORA     #$80
F242  B70A21          IE_12           STA     REG_MD
                      
F245                  NOT_6309_1
                              ENDIF
                      
F245  3502                            PULS    A
F247  B70A1F                          STA     REG_DP          ; DP
F24A  3506                            PULS    D
F24C  B70A1A                          STA     REG_X+1         ; MSB X
F24F  F70A19                          STB     REG_X           ; LSB X
F252  3506                            PULS    D
F254  B70A18                          STA     REG_Y+1         ; MSB Y
F257  F70A17                          STB     REG_Y           ; LSB Y
F25A  3506                            PULS    D
F25C  B70A16                          STA     REG_U+1         ; MSB U
F25F  F70A15                          STB     REG_U           ; LSB U
                      *
                      *  If this is a breakpoint (state = 1), then back up PC to point at SWI
F262  3510                            PULS    X               ; PC AFTER INTERRUPT
F264  B60A11                          LDA     REG_STATE
F267  8101                            CMPA    #1              
F269  2602                            BNE     NOTBP           ; BR IF NOT A BREAKPOINT
F26B  301F                            LEAX    -(B1-B0),X            ; ELSE BACK UP TO POINT AT SWI LOCATION
F26D  1F10            NOTBP           TFR     X,D             ; TRANSFER PC TO D
F26F  B70A25                          STA     REG_PC+1        ; MSB
F272  F70A24                          STB     REG_PC          ; LSB
F275  7EF418                          JMP     ENTER_MON       ; REG_PC POINTS AT POST-INTERRUPT OPCODE
                      
                              IF CPU_6309
                              ; check if this is really a 6309
F278  1FC0            CHECK_6309      tfr     0,D
F27A  5D                              tstb
F27B  39                              rts
                              ENDIF
                      
                      
                      *
                      *===========================================================================
                      *  Main loop  wait for command frame from master
                      *
                      *  Uses 6 bytes of stack including return address
                      *
F27C                  MAIN            
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
F27C  7F0A36                          CLR     RUNNING_FLAG            ; DB: reset running flag to 0 block further NMIs
                              ENDIF
F27F  10CE0B00                        LDS     #MONSTACK               ; CLEAN STACK IS HAPPY STACK
F283  8E0A37                          LDX     #COMBUF                 ; BUILD MESSAGE HERE
                      *
                      *  First byte is a function code
F286  BDF1A6                          JSR     GETCHAR                 ; GET A FUNCTION (6 bytes of stack)
F289  25F1                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F28B  81F7                            CMPA    #FN_MIN
F28D  25ED                            BLO     MAIN                    ; JIF BELOW MIN: ILLEGAL FUNCTION
F28F  A780                            STA     ,X+                     ; SAVE FUNCTION CODE
                      *
                      *  Second byte is data byte count (may be zero)
F291  BDF1A6                          JSR     GETCHAR                 ; GET A LENGTH BYTE
F294  25E6                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F296  8180                            CMPA    #COMBUF_SIZE
F298  22E2                            BHI     MAIN                    ; JIF TOO LONG: ILLEGAL LENGTH
F29A  A780                            STA     ,X+                     ; SAVE LENGTH
F29C  8100                            CMPA    #0
F29E  270C                            BEQ     MA80                    ; SKIP DATA LOOP IF LENGTH = 0
                      *
                      *  Loop for data
F2A0  1F89                            TFR     A,B                     ; SAVE LENGTH FOR LOOP
F2A2  BDF1A6          MA10            JSR     GETCHAR                 ; GET A DATA BYTE
F2A5  25D5                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F2A7  A780                            STA     ,X+                     ; SAVE DATA BYTE
F2A9  5A                              DECB
F2AA  26F6                            BNE     MA10
                      *
                      *  Get the checksum
F2AC  BDF1A6          MA80            JSR     GETCHAR                 ; GET THE CHECKSUM
F2AF  25CB                            BCS     MAIN                    ; JIF TIMEOUT: RESYNC
F2B1  3402                            PSHS    A                       ; SAVE CHECKSUM
                      *
                      *  Compare received checksum to that calculated on received buffer
                      *  (Sum should be 0)
F2B3  BDF49E                          JSR     CHECKSUM
F2B6  ABE0                            ADDA    ,S+                     ; ADD SAVED CHECKSUM TO COMPUTED
                              IF MACH_WBONE
                                      BEQ     1F
                                      LDA     LEDS
                                      ORA     #LED_CKSUM
                                      STA     LEDS
                                      JSR     PIPDLY
                                      ANDA    #~LED_CKSUM
                                      STA     LEDS
                                      BRA     MAIN
                      1
                              ELSE
F2B8  26C2                            BNE     MAIN                    ; JIF BAD CHECKSUM
                              ENDIF
                      *
                      *  Process the message.
F2BA  8E0A37                          LDX     #COMBUF
F2BD  A680                            LDA     ,X+                     ; GET THE FUNCTION CODE
F2BF  E680                            LDB     ,X+                     ; GET THE LENGTH
F2C1  81FF                            CMPA    #FN_GET_STAT
F2C3  2742                            BEQ     TARGET_STAT
F2C5  81FE                            CMPA    #FN_READ_MEM
F2C7  2726                            BEQ     JREAD_MEM
F2C9  81FD                            CMPA    #FN_WRITE_M
F2CB  2725                            BEQ     JWRITE_MEM
F2CD  81FC                            CMPA    #FN_READ_RG
F2CF  2724                            BEQ     JREAD_REGS
F2D1  81FB                            CMPA    #FN_WRITE_RG
F2D3  2723                            BEQ     JWRITE_REGS
F2D5  81FA                            CMPA    #FN_RUN_TARG
F2D7  2722                            BEQ     JRUN_TARGET
F2D9  81F9                            CMPA    #FN_SET_BYTE
F2DB  2721                            BEQ     JSET_BYTES
F2DD  81F8                            CMPA    #FN_IN
F2DF  2720                            BEQ     JIN_PORT
F2E1  81F7                            CMPA    #FN_OUT
F2E3  271F                            BEQ     JOUT_PORT
                      *
                      *  Error: unknown function.  Complain
F2E5  86F0                            LDA     #FN_ERROR
F2E7  B70A37                          STA     COMBUF          ; SET FUNCTION AS "ERROR"
F2EA  8601                            LDA     #1
F2EC  7EF47C                          JMP     SEND_STATUS     ; VALUE IS "ERROR"
                      *
                      *  long jumps to handlers
F2EF  7EF31C          JREAD_MEM       JMP     READ_MEM
F2F2  7EF33B          JWRITE_MEM      JMP     WRITE_MEM
F2F5  7EF36D          JREAD_REGS      JMP     READ_REGS
F2F8  7EF382          JWRITE_REGS     JMP     WRITE_REGS
F2FB  7EF394          JRUN_TARGET     JMP     RUN_TARGET
F2FE  7EF42D          JSET_BYTES      JMP     SET_BYTES
F301  7EF463          JIN_PORT        JMP     IN_PORT
F304  7EF46E          JOUT_PORT       JMP     OUT_PORT
                      
                      *===========================================================================
                      *
                      *  Target Status:  FN, len
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F307                  TARGET_STAT
F307  8EF1CF                          LDX     #TSTG                   ; DATA FOR REPLY
F30A  108E0A38                        LDY     #COMBUF+1               ; POINTER TO RETURN BUFFER
F30E  C620                            LDB     #TSTG_SIZE              ; LENGTH OF REPLY
F310  E7A0                            STB     ,Y+                     ; SET SIZE IN REPLY BUFFER
F312  A680            TS10            LDA     ,X+                     ; MOVE REPLY DATA TO BUFFER
F314  A7A0                            STA     ,Y+
F316  5A                              DECB
F317  26F9                            BNE     TS10
                      *
                      *  Compute checksum on buffer, and send to master, then return
F319  7EF486                          JMP     SEND
                      
                              IF NOICE_DEBUG_MEMMAP
                      MEM_DEBUG_INIT
                      1               LDA     ,Y
                                      STA     ,U+
                                      LDA     ,X+
                                      STA     ,Y+
                                      DECB
                                      BNE     1B
                                      RTS
                      
                      MEM_DEBUG_RESTORE
                      1               LDA     ,U+
                                      STA     ,Y+
                                      DECB
                                      BNE     1B
                                      RTS
                              ENDIF
                      
                      
                      *===========================================================================
                      *
                      *  Read Memory:  FN, len, page, Alo, Ahi, Nbytes
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F31C                  READ_MEM
                      *
                      *  Set map
                              IF DO_ROMLATCH
F31C  A684                            LDA     0,X
F31E  B700F4                          STA     MAPIMG
F321  B7FE30                          STA     MAPREG
                              ENDIF
                      *
                      *  Get address
F324  A602                            LDA     2,X                     ; MSB OF ADDRESS IN A
F326  E601                            LDB     1,X                     ; LSB OF ADDRESS IN B
F328  1F02                            TFR     D,Y                     ; ADDRESS IN Y
                      *
                      *  Prepare return buffer: FN (unchanged), LEN, DATA
F32A  E603                            LDB     3,X                     ; NUMBER OF BYTES TO RETURN
F32C  F70A38                          STB     COMBUF+1                ; RETURN LENGTH = REQUESTED DATA        
F32F  2707                            BEQ     GLP90                   ; JIF NO BYTES TO GET
                      
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; if running from debug mem need to look to see
                                      ; if this is an access to C000 onwards 
                                      ; and page back in original MOS if it is
                      
                                      CMPY    #$C000
                                      BLO     READ_MEM_NOT_MOS
                                      ; TODO this should maybe also check for FC00-FEFF?
                      
                                      PSHS    X,Y,U
                                      LDB     #READ_MEM_DEBUG_LEN
                                      LDX     #READ_MEM_DEBUG_LOAD
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_INIT
                                      PULS    X,Y,U
                      *
                      *  Read the requested bytes from local memory
                      1               JSR     READ_MEM_DEBUG                  ; GET BYTE
                                      STA     ,X+                             ; STORE TO RETURN BUFFER
                                      DECB
                                      BNE     1B
                      
                                      PSHS    Y,U
                                      LDB     #READ_MEM_DEBUG_LEN
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_RESTORE
                                      PULS    Y,U
                      
                                      JMP     SEND
                      
                                      ; ORG this at bottom of stack NOICE_DEBUG_CODE_BOUNCE and copy from PUT area
                      READ_MEM_DEBUG_LOAD
                                      ORG     NOICE_DEBUG_CODE_BOUNCE
                                      PUT     READ_MEM_DEBUG_LOAD
                      READ_MEM_DEBUG
                                      PSHS    B                               ; preserve B
                                      LDB     $FE31                           ; save current MOS state
                                      STA     $FE32                           ; restore mos state prior to debug entry
                                                                              ; NOTE: stack is from DEBUG memory so
                                                                              ; we can't use the stack until we've
                                                                              ; restored DEBUG state
                                      NOP
                                      LDA     ,Y+                     ; GET BYTE
                                      STB     $FE31
                                      NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
                                      PULS    B,PC
                      READ_MEM_DEBUG_END
                      READ_MEM_DEBUG_LEN EQU READ_MEM_DEBUG_END-NOICE_DEBUG_CODE_BOUNCE
                      
                                      ORG     READ_MEM_DEBUG_LOAD + READ_MEM_DEBUG_LEN
                                      PUT     READ_MEM_DEBUG_LOAD + READ_MEM_DEBUG_LEN
                      READ_MEM_NOT_MOS
                              ENDIF
                      *
                      *  Read the requested bytes from local memory
F331  A6A0            GLP             LDA     ,Y+                     ; GET BYTE
F333  A780                            STA     ,X+                     ; STORE TO RETURN BUFFER
F335  5A                              DECB
F336  26F9                            BNE     GLP
                      *
                      *  Compute checksum on buffer, and send to master, then return
F338  7EF486          GLP90           JMP     SEND
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; ORG this at bottom of stack NOICE_DEBUG_CODE_BOUNCE and copy from PUT area
                      WRITE_MEM_DEBUG_LOAD
                                      ORG     NOICE_DEBUG_CODE_BOUNCE
                                      PUT     WRITE_MEM_DEBUG_LOAD
                      WRITE_MEM_DEBUG
                                      PSHS    B                               ; preserve B
                                      LDB     $FE31                           ; save current MOS state
                                      STA     $FE32                           ; restore mos state prior to debug entry
                                                                              ; NOTE: stack is from DEBUG memory so
                                                                              ; we can't use the stack until we've
                                                                              ; restored DEBUG state
                                      NOP
                                      STA     ,Y+                     ; GET BYTE
                                      STB     $FE31
                                      NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
                                      PULS    B,PC
                      WRITE_MEM_DEBUG_END
                      WRITE_MEM_DEBUG_LEN EQU WRITE_MEM_DEBUG_END-NOICE_DEBUG_CODE_BOUNCE
                      
                                      ORG     WRITE_MEM_DEBUG_LOAD + WRITE_MEM_DEBUG_LEN
                              ENDIF
                      
                      *===========================================================================
                      *
                      *  Write Memory:  FN, len, page, Alo, Ahi, (len-3 bytes of Data)
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
                      *  Uses 6 bytes of stack
                      *
F33B                  WRITE_MEM
                      *
                      *  Set map
                      
F33B  A680                            LDA     ,X+
                              IF DO_ROMLATCH
F33D  B700F4                          STA     MAPIMG
F340  B7FE30                          STA     MAPREG
                              ENDIF
                      *
                      *  Get address
F343  E680                            LDB     ,X+                     ; LSB OF ADDRESS IN B
F345  A680                            LDA     ,X+                     ; MSB OF ADDRESS IN A
F347  1F02                            TFR     D,Y                     ; ADDRESS IN Y
                      
                      *
                      *  Compute number of bytes to write
F349  F60A38                          LDB     COMBUF+1                ; NUMBER OF BYTES TO RETURN
F34C  C003                            SUBB    #3                      ; MINUS PAGE AND ADDRESS
F34E  2714                            BEQ     WLP50                   ; JIF NO BYTES TO PUT
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; if running from debug mem need to look to see
                                      ; if this is an access to C000 onwards 
                                      ; and page back in original MOS if it is
                      
                                      CMPY    #$C000
                                      BLO     WRITE_MEM_NOT_MOS
                                      ; TODO this should maybe also check for FC00-FEFF?
                      
                                      PSHS    B,X,Y,U
                                      LDB     #WRITE_MEM_DEBUG_LEN
                                      LDX     #WRITE_MEM_DEBUG_LOAD
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_INIT
                                      PULS    B,X,Y,U
                      
                      *
                      *  Write the specified bytes to local memory
                                      PSHS    B,X,Y
                      1               LDA     ,X+                             ; GET BYTE TO WRITE
                                      JSR     WRITE_MEM_DEBUG                 ; STORE THE BYTE AT ,Y
                                      DECB
                                      BNE     1B
                      
                                      PSHS    Y,U
                                      LDB     #WRITE_MEM_DEBUG_LEN
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_RESTORE
                                      PULS    Y,U
                      
                                      PSHS    X,Y,U
                                      LDB     #READ_MEM_DEBUG_LEN
                                      LDX     #READ_MEM_DEBUG_LOAD
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_INIT
                                      PULS    X,Y,U
                      
                                      PULS    B,X,Y
                      1               JSR     READ_MEM_DEBUG                  ; DB: Swapped LDA/CMPA to make DEBUG case easier
                                      CMPA    ,X+                             ; GET BYTE JUST WRITTEN
                                      BNE     2F                              ; BR IF WRITE FAILED
                                      DECB
                                      BNE     1B
                      2
                      
                                      PSHS    CC,Y,U
                                      LDB     #READ_MEM_DEBUG_LEN
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_RESTORE
                                      PULS    CC,Y,U
                      
                                      BNE     WLP80                           ; signal fail
                                      BEQ     WLP50                           ; signal pass
                      
                      WRITE_MEM_NOT_MOS
                              ENDIF
                      
                      *
                      *  Write the specified bytes to local memory
F350  3434                            PSHS    B,X,Y
F352  A680            WLP             LDA     ,X+                     ; GET BYTE TO WRITE
F354  A7A0                            STA     ,Y+                     ; STORE THE BYTE AT ,Y
F356  5A                              DECB
F357  26F9                            BNE     WLP
                      *
                      *  Compare to see if the write worked
F359  3534                            PULS    B,X,Y
F35B  A6A0            WLP20           LDA     ,Y+                     ; DB: Swapped LDA/CMPA to make DEBUG case easier
F35D  A180                            CMPA    ,X+                     ; GET BYTE JUST WRITTEN
F35F  2607                            BNE     WLP80                   ; BR IF WRITE FAILED
F361  5A                              DECB
F362  26F7                            BNE     WLP20
                      *
                      *  Write succeeded:  return status = 0
F364  8600            WLP50           LDA     #0                      ; RETURN STATUS = 0
F366  2002                            BRA     WLP90
                      *
                      *  Write failed:  return status = 1
F368  8601            WLP80           LDA     #1
                      
                      *  Return OK status
F36A  7EF47C          WLP90           JMP     SEND_STATUS
                      
                      *===========================================================================
                      *
                      *  Read registers:  FN, len=0
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F36D                  READ_REGS
                      *
                      *  Enter here from SWI after "RUN" and "STEP" to return task registers
F36D                  RETURN_REGS
F36D  108E0A11                        LDY     #TASK_REGS              ; POINTER TO REGISTERS
F371  C615                            LDB     #TASK_REG_SZ            ; NUMBER OF BYTES
F373  8E0A38                          LDX     #COMBUF+1               ; POINTER TO RETURN BUFFER
F376  E780                            STB     ,X+                     ; SAVE RETURN DATA LENGTH
                      *
                      *  Copy the registers
F378  A6A0            GRLP            LDA     ,Y+                     ; GET BYTE TO A
F37A  A780                            STA     ,X+                     ; STORE TO RETURN BUFFER
F37C  5A                              DECB
F37D  26F9                            BNE     GRLP
                      *
                      *  Compute checksum on buffer, and send to master, then return
F37F  7EF486                          JMP     SEND
                      
                      *===========================================================================
                      *
                      *  Write registers:  FN, len, (register image)
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F382                  WRITE_REGS
                      *
F382  5D                              TSTB                            ; NUMBER OF BYTES
F383  270B                            BEQ     WRR80                   ; JIF NO REGISTERS
                      *
                      *  Copy the registers
F385  108E0A11                        LDY     #TASK_REGS              ; POINTER TO REGISTERS
F389  A680            WRRLP           LDA     ,X+                     ; GET BYTE TO A
F38B  A7A0                            STA     ,Y+                     ; STORE TO REGISTER RAM
                      
F38D  5A                              DECB
F38E  26F9                            BNE     WRRLP
                      *
                      *  Return OK status
F390  4F              WRR80           CLRA
F391  7EF47C                          JMP     SEND_STATUS
                      
                      *===========================================================================
                      *
                      *  Run Target:  FN, len
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F394                  RUN_TARGET
                      *
                      *  Restore user's map
                              IF DO_ROMLATCH
F394  B60A12                          LDA     REG_PAGE                ; USER'S PAGE
F397  B700F4                          STA     MAPIMG                  ; SET IMAGE
F39A  B7FE30                          STA     MAPREG                  ; SET MAPPING REGISTER
                              ENDIF
                      *
                      *  Switch to user stack
F39D  B60A14                          LDA     REG_SP+1                ; BACK TO USER STACK
F3A0  F60A13                          LDB     REG_SP
F3A3  1F04                            TFR     D,S                     ; TO S
                      
                              IF CPU_6309
F3A5  BDF278                          JSR     CHECK_6309
F3A8  261C                            BNE     NOT_6309_2
                      *
                      *  Restore MD, as it affects stack building and RTI
                      *  Only bits 1 and 0 can be written, and only using LDMD #
                      *  It's time for some self-modifying code!  Build LDMD #xxx, RTS in RAM and call it.
F3AA  CC113D                          LDD     #$113D                  ; LDMD #imm
F3AD  FD0A55                          STD     COMBUF+30               ; Start code string
F3B0  B60A21                          LDA     REG_MD                  ; #imm is desired MD value
F3B3  B70A57                          STA     COMBUF+32
F3B6  8639                            LDA     #$39                    ; RTS
F3B8  B70A58                          STA     COMBUF+33
F3BB  BD0A55                          JSR     COMBUF+30
                      *
                      *  Restore V, which isn't on the stack
F3BE  B60A23                          LDA     REG_V+1
F3C1  F60A22                          LDB     REG_V
F3C4  1F07                            TFR     D,V
F3C6                  NOT_6309_2
                              ENDIF
                      *
                      *  Restore registers
F3C6  B60A25                          LDA     REG_PC+1                ; MS USER PC FOR RTI
F3C9  F60A24                          LDB     REG_PC                  ; LS USER PC FOR RTI
F3CC  3406                            PSHS    D
                      
                      *
F3CE  B60A16                          LDA     REG_U+1
F3D1  F60A15                          LDB     REG_U
F3D4  3406                            PSHS    D
                      *
F3D6  B60A18                          LDA     REG_Y+1
F3D9  F60A17                          LDB     REG_Y
F3DC  3406                            PSHS    D
                      *
F3DE  B60A1A                          LDA     REG_X+1
F3E1  F60A19                          LDB     REG_X
F3E4  3406                            PSHS    D
                      *
F3E6  B60A1F                          LDA     REG_DP
F3E9  3402                            PSHS    A
                              IF CPU_6309
F3EB  BDF278                          JSR     CHECK_6309
F3EE  2611                            BNE     NOT_6309_3
                      *       
                      *  Restore W from memory (not used between here and RTI)
F3F0  11B60A1C                        LDE     REG_E
F3F4  11F60A1B                        LDF     REG_F
F3F8  B60A21                          LDA     REG_MD
F3FB  8501                            BITA    #1
F3FD  2702                            BEQ     RT_10                   ; jump if 6809 mode
F3FF  1038                            PSHSW                          ; else push W on stack for RTI
F401                  RT_10
F401                  NOT_6309_3
                              ENDIF
                      *
F401  B60A1D                          LDA     REG_B
F404  3402                            PSHS    A
                      *
F406  B60A1E                          LDA     REG_A
F409  3402                            PSHS    A
                      *
F40B  B60A20                          LDA     REG_CC                  ; SAVE USER CONDITION CODES FOR RTI
F40E  8A80                            ORA     #CC_E                      ; _MUST_ BE "ALL REGS PUSHED"
F410  3402                            PSHS    A
                      
                              IF NOICE_DEBUG_MEMMAP
                              ELSE
F412  86FF                            LDA     #255
F414  B70A36                          STA     RUNNING_FLAG
                              ENDIF
                      
                      *
                      *  Return to user (conditioned by MD.0)
                              IF NOICE_DEBUG_MEMMAP
                                      STA     $FE32                           ; reset DEBUG map by writing restore reg
                              ENDIF
F417  3B                              RTI
                      *
                      *===========================================================================
                      *
                      *  Common continue point for all monitor entrances
                      *  SP = user stack
F418                  ENTER_MON
F418  1F40                            TFR     S,D             ; USER STACK POINTER
F41A  B70A14                          STA     REG_SP+1        ; SAVE USER'S STACK POINTER (MSB)
F41D  F70A13                          STB     REG_SP          ; LSB
                      *
                      *  Change to our own stack
F420  10CE0B00                        LDS     #MONSTACK       ; AND USE OURS INSTEAD
                      *
                      *  Operating system variables
                              IF DO_ROMLATCH
F424  B600F4                          LDA     MAPIMG          ; GET CURRENT USER MAP
                              ELSE
                                      LDA     #0              ; ... OR ZERO IF UNMAPPED TARGET
                              ENDIF
F427  B70A12                          STA     REG_PAGE        ; SAVE USER'S PAGE
                      *
                      *  Return registers to master
F42A  7EF36D                          JMP     RETURN_REGS
                      
                      
                              IF NOICE_DEBUG_MEMMAP
                                      ; ORG this at bottom of stack NOICE_DEBUG_CODE_BOUNCE and copy from PUT area
                      SET_BYTE_DEBUG_LOAD
                                      ORG     NOICE_DEBUG_CODE_BOUNCE
                                      PUT     SET_BYTE_DEBUG_LOAD
                      SET_BYTE_DEBUG
                                      LDB     3,X                             ; GET BYTE TO STORE     
                                      LDA     $FE31                           ; save current MOS state
                                      STA     SET_BYTE_TMP                    ; preserve B - note we can't use the stack here!
                                      STA     $FE32                           ; restore mos state prior to debug entry
                                                                              ; NOTE: stack is from DEBUG memory so
                                                                              ; we can't use the stack until we've
                                                                              ; restored DEBUG state
                                      NOP
                      
                      *
                      *  Read current data at byte location
                                      LDA     0,Y
                      *
                      *  Insert new data at byte location
                                      STB     0,Y                     ; WRITE TARGET MEMORY
                      *
                      *  Verify write
                                      CMPB    0,Y                     ; READ TARGET MEMORY
                                      BNE     SET_BYTE_EXNE
                                      LDB     SET_BYTE_TMP
                                      STB     $FE31
                                      NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
                                      CLRB
                                      RTS
                      SET_BYTE_EXNE
                                      LDB     SET_BYTE_TMP
                                      STB     $FE31
                                      NOP                                     ; stores to FE31 bit 2 are delayed by 1 instruction!
                                      RTS
                      
                      SET_BYTE_TMP    RMB     1
                      SET_BYTE_DEBUG_END
                      SET_BYTE_DEBUG_LEN EQU SET_BYTE_DEBUG_END-NOICE_DEBUG_CODE_BOUNCE
                      
                                      ORG     SET_BYTE_DEBUG_LOAD + SET_BYTE_DEBUG_LEN
                              ENDIF
                      
                      
                      
                      *===========================================================================
                      *
                      *  Set target byte(s):  FN, len { (page, alow, ahigh, data), (...)... }
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
                      *  Return has FN, len, (data from memory locations)
                      *
                      *  If error in insert (memory not writable), abort to return short data
                      *
                      *  This function is used primarily to set and clear breakpoints
                      *
                      *  Uses 1 byte of stack
                      *
F42D                  SET_BYTES
                      
F42D  CE0A38                          LDU     #COMBUF+1               ; POINTER TO RETURN BUFFER
F430  8600                            LDA     #0
F432  A7C0                            STA     ,U+                     ; SET RETURN COUNT AS ZERO
F434  54                              LSRB
F435  54                              LSRB                            ; LEN/4 = NUMBER OF BYTES TO SET
F436  2728                            BEQ     SB99                    ; JIF NO BYTES (COMBUF+1 = 0)
                      
                              IF NOICE_DEBUG_MEMMAP
                                      PSHS    B,X,Y,U
                                      LDB     #SET_BYTE_DEBUG_LEN
                                      LDX     #SET_BYTE_DEBUG_LOAD
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_INIT
                                      PULS    B,X,Y,U
                              ENDIF
                      
                      *
                      *  Loop on inserting bytes
F438  3404            SB10            PSHS    B                       ; SAVE LOOP COUNTER
                      *
                      *  Set map
                              IF DO_ROMLATCH
F43A  A684                            LDA     0,X
F43C  B700F4                          STA     MAPIMG
F43F  B7FE30                          STA     MAPREG
                              ENDIF
                      *
                      *  Get address
F442  A602                            LDA     2,X                     ; MSB OF ADDRESS IN A
F444  E601                            LDB     1,X                     ; LSB OF ADDRESS IN B
F446  1F02                            TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      
                              IF NOICE_DEBUG_MEMMAP
                                      JSR     SET_BYTE_DEBUG
                              ELSE
                      *
                      *  Read current data at byte location
F448  A6A4                            LDA     0,Y
                      *
                      *  Insert new data at byte location
F44A  E603                            LDB     3,X                     ; GET BYTE TO STORE     
F44C  E7A4                            STB     0,Y                     ; WRITE TARGET MEMORY
                      *
                      *  Verify write
F44E  E1A4                            CMPB    0,Y                     ; READ TARGET MEMORY
                      
                              ENDIF
                      
F450  3504                            PULS    B                       ; RESTORE LOOP COUNT, CC'S INTACT
F452  260C                            BNE     SB90                    ; BR IF INSERT FAILED: ABORT
                      *
                      *  Save target byte in return buffer
F454  A7C0                            STA     ,U+
F456  7C0A38                          INC     COMBUF+1                ; COUNT ONE RETURN BYTE
                      *
                      *  Loop for next byte
F459  3004                            LEAX    4,X                     ; STEP TO NEXT BYTE SPECIFIER
F45B  F10A38                          CMPB    COMBUF+1
F45E  26D8                            BNE     SB10                    ; *LOOP FOR ALL BYTES
                      *
                      *  Return buffer with data from byte locations
F460                  SB90
                              IF NOICE_DEBUG_MEMMAP
                                      PSHS    CC,Y,U
                                      LDB     #SET_BYTE_DEBUG_LEN
                                      LDY     #NOICE_DEBUG_CODE_BOUNCE
                                      LDU     #RW_MEM_CODE_SAVE
                                      JSR     MEM_DEBUG_RESTORE
                                      PULS    CC,Y,U
                              ENDIF
                      
                      *
                      *  Compute checksum on buffer, and send to master, then return
F460  7EF486          SB99            JMP     SEND
                      
                      *===========================================================================
                      *
                      *  Input from port:  FN, len, PortAddressLo, PAhi (=0)
                      *
                      *  While the 6809 has no input or output instructions, we retain these
                      *  to allow write-without-verify
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F463                  IN_PORT
                      *
                      *  Get port address
F463  A601                            LDA     1,X                     ; MSB OF ADDRESS IN A
F465  E684                            LDB     0,X                     ; LSB OF ADDRESS IN B
F467  1F02                            TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      *
                      *  Read the requested byte from local memory
F469  A6A4                            LDA     0,Y
                      *
                      *  Return byte read as "status"
F46B  7EF47C                          JMP     SEND_STATUS
                      
                      *===========================================================================
                      *
                      *  Output to port  FN, len, PortAddressLo, PAhi (=0), data
                      *
                      *  Entry with A=function code, B=data size, X=COMBUF+2
                      *
F46E                  OUT_PORT
                      *
                      *  Get port address
F46E  A601                            LDA     1,X                     ; MSB OF ADDRESS IN A
F470  E684                            LDB     0,X                     ; LSB OF ADDRESS IN B
F472  1F02                            TFR     D,Y                     ; MEMORY ADDRESS IN Y
                      *
                      *  Get data
F474  A602                            LDA     2,X
                      *
                      *  Write value to port
F476  A7A4                            STA     0,Y
                      *
                      *  Do not read port to verify (some I/O devices don't like it)
                      *
                      *  Return status of OK
F478  4F                              CLRA
F479  7EF47C                          JMP     SEND_STATUS
                      
                      *===========================================================================
                      *  Build status return with value from "A"
                      *
F47C                  SEND_STATUS
F47C  B70A39                          STA     COMBUF+2                ; SET STATUS
F47F  8601                            LDA     #1
F481  B70A38                          STA     COMBUF+1                ; SET LENGTH
F484  2000                            BRA     SEND
                      
                      *===========================================================================
                      *  Append checksum to COMBUF and send to master
                      *
F486  BDF49E          SEND            JSR     CHECKSUM                ; GET A=CHECKSUM, X->checksum location
F489  40                              NEGA
F48A  A784                            STA     0,X                     ; STORE NEGATIVE OF CHECKSUM
                      *
                      *  Send buffer to master
F48C  8E0A37                          LDX     #COMBUF                 ; POINTER TO DATA
F48F  E601                            LDB     1,X                     ; LENGTH OF DATA
F491  CB03                            ADDB    #3                      ; PLUS FUNCTION, LENGTH, CHECKSUM
F493  A680            SND10           LDA     ,X+
F495  BDF1C0                          JSR     PUTCHAR                 ; SEND A BYTE
F498  5A                              DECB
F499  26F8                            BNE     SND10
F49B  7EF27C                          JMP     MAIN                    ; BACK TO MAIN LOOP
                      
                      *===========================================================================
                      *  Compute checksum on COMBUF.  COMBUF+1 has length of data,
                      *  Also include function byte and length byte
                      *
                      *  Returns:
                      *       A = checksum
                      *       X = pointer to next byte in buffer (checksum location)
                      *       B is scratched
                      *
F49E                  CHECKSUM
F49E  8E0A37                          LDX     #COMBUF                 ; pointer to buffer
F4A1  E601                            LDB     1,X                     ; length of message
F4A3  CB02                            ADDB    #2                      ; plus function, length
F4A5  8600                            LDA     #0                      ; init checksum to 0
F4A7  AB80            CHK10           ADDA    ,X+
F4A9  5A                              DECB
F4AA  26FB                            BNE     CHK10                   ; loop for all
F4AC  39                              RTS                             ; return with checksum in A
                      
                      ***********************************************************************
                      *
                      *  Interrupt handlers to catch unused interrupts and traps
                      *  Registers are stacked.  Jump through RAM vector using X, type in A
                      *
                      *  This will affect only interrupt routines looking for register values!
                      *
                      *  Our default handler uses the code in "A" as the processor state to be
                      *  passed back to the host.
                      *
                      
                              IF STANDALONE
                      
                      *  This is "reserved" on 6809
                      *  Used for Divide-by-zero and Illegal-instruction on 6309
F4AD  8607            RES_ENT         LDA     #7
F4AF  BE0A26                          LDX     RAMVEC+0
F4B2  6E84                            JMP     0,X
                      *
F4B4  8606            SWI3_ENT        LDA     #6
F4B6  BE0A28                          LDX     RAMVEC+2
F4B9  6E84                            JMP     0,X
                      *
F4BB  8605            SWI2_ENT        LDA     #5
F4BD  BE0A2A                          LDX     RAMVEC+4
F4C0  6E84                            JMP     0,X
                      *
                      *  Will have only PC and CC's pushed unless we were waiting for an interrupt
                      *  or MD.1 is true.  Use CC's E bit to distinguish.
                      *  Push all registers here for common entry (else we can't use our RAM vector)
F4C2  B70A1E          FIRQ_ENT        STA     REG_A   ; SAVE A REG
F4C5  3502                            PULS    A               ; GET CC'S FROM STACK
F4C7  8580                            BITA    #CC_E
F4C9  262E                            BNE     FIRQ9   ; BR IF ALL REGISTERS PUSHED ALREADY
                              IF CPU_6309
                      
                      * CC.E was not set which means that regMD bit2 was not set and that bit in
                      * the image should be cleared. If CC.E is set, we can't tell what set it, a
                      * direct command, CWAI, or bit 1 of regMD.
                      *
                      * Push registers as if CC.E had been set
                      *  If 6809 mode, stack needs CC A B DP XH XL YH YL UH UL PCH PCL
                      *  If 6309 mode, stack needs CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      *
F4CB  7F0A0E                          CLR     E_FLAG
F4CE  B60A21                          LDA     REG_MD
F4D1  84FD                            ANDA    #$FD            ; BIT1 must be clear, else all regs would have been pushed
F4D3  B70A21                          STA     REG_MD
F4D6  3478                            PSHS    U,Y,X,DP        ; push regs next below PC
                      
F4D8  BDF278                          JSR     CHECK_6309
F4DB  2613                            BNE     FE1
                      
F4DD  10B70A1B                        STW     REG_F           ; MD_TEST will not preserve regW
F4E1  BDF52E                          JSR     MD_TEST
F4E4  3401                            PSHS    CC              ; Save result
F4E6  10B60A1B                        LDW     REG_F           ; Recover regW
F4EA  3501                            PULS    CC              ; Recover result of test
F4EC  2602                            BNE     FE1
F4EE  1038                            PSHSW
F4F0  3404            FE1             PSHS    B
                              ELSE
                                      PSHS    U,Y,X,DP,B      ;ELSE PUSH THEM NOW
                              ENDIF
                      
F4F2  F60A1E                          LDB     REG_A
F4F5  3404                            PSHS    B
F4F7  8A80                            ORA     #CC_E           ; SET AS "ALL REGS PUSHED"
                      
                      
                      
                      
F4F9                  FIRQ9   
                              IF CPU_6309
F4F9  7D0A0E                          TST     E_FLAG
F4FC  2608                            BNE     FIRQ9B
F4FE  F60A21                          LDB     REG_MD          ; We got here with E_FLAG clear and CC.E set which
F501  CA02                            ORB     #2              ; means regMD bit2 must be set.
F503  F70A21                          STB     REG_MD
F506                  FIRQ9B  
                              ENDIF
F506  3402                            PSHS    A               ; REPLACE CC'S
F508  8604                            LDA     #4
F50A  BE0A2C                          LDX     RAMVEC+6
F50D  6E84                            JMP     0,X
                      
F50F  8603            IRQ_ENT         LDA     #3
F511  BE0A2E                          LDX     RAMVEC+8
F514  6E84                            JMP     0,X
                      *
F516  8602            NMI_ENT         LDA     #2
F518  BE0A32                          LDX     RAMVEC+12
F51B  6E84                            JMP     0,X
                      *
F51D  8601            SWI_ENT         LDA     #1
F51F  7EF1EF                          JMP     INT_ENTRY
                              ELSE
                                      ; in mos overlay these are jumped to from the two entry points at start of overlay
                      SWI_ENT         LDA     #1
                                      JMP     INT_ENTRY
                      NMI_ENT         LDA     #2
                                      JMP     INT_ENTRY
                      
                              ENDIF
                      
                              IF STANDALONE
                      
                      *mostbl_VDU_6845_mode_45
                      *                FCB     $3F,$28,$31,$24,$26,$00,$20,$22 
                      *                FCB     $01,$07,$67,$08                 
                      
                      
F522                  mostbl_VDU_6845_mode_012
F522  7F50622826002022                 FCB     $7F,$50,$62,$28,$26,$00,$20,$22
F52A  01076708                        FCB     $01,$07,$67,$08
                      
                              ENDIF
                      
                              IF CPU_6309
                      * TEST FOR BIT0 OF regMD:
                      * Exit emulation mode: regW=$1234
                      *      native    mode: regW=$0000
                      *
                      * Preserves W and V.  Other registers destroyed.
                      *
F52E                  MD_TEST     
F52E  1038                            PSHSW
                      *
                      * If 6809 mode, RTI will pop 12 bytes: CC A B DP XH XL YH YL UH UL PCH PCL
                      * If 6309 mode, RTI will pop 14 bytes: CC A B E  F  DP XH XL YH YL UH  UL  PCH PCL
                      *
                      * Initialize TEST_STACK used for fake RTI. The return address will be MD_RETURN
                      * in both emulation and native modes. If native mode, regW will be cleared.
F530  8E0A00                          LDX     #TEST_STACK
                      
F533  1FA8                            TFR     CC,A
F535  8A80                            ORA     #$80                    ; DB: changed to set CC on stack (was clearing interrupt flags!)
F537  A780                            STA     ,X+                     ; CC with E set
                      
F539  C609                            LDB     #9
F53B  6F80            RES11           CLR     ,X+                     ; zeros for other registers, including W
F53D  5A                              DECB
F53E  26FB                            BNE     RES11
                      
F540  CCF554                          LDD     #MD_RETURN
F543  ED81                            STD     ,X++                    ; 6809 return address, or 6309 U
F545  ED81                            STD     ,X++                    ; 6309 return address, or past 6809 stack
                      
F547  10FF0A0F                        STS     S_IMAGE
F54B  10CE0A00                        LDS     #TEST_STACK
F54F  10861234                        LDW     #$1234
F553  3B                              RTI                             ; if 6309 mode, W gets 0; else unchanged
                      
F554                  MD_RETURN   
F554  10FE0A0F                        LDS     S_IMAGE
F558  105D                            TSTW                            ; adjust CC.Z: set if 6309 mode
F55A  1039                            PULSW
F55C  39                              RTS
                              ENDIF
                      
                              IF STANDALONE
                      *********************************************************************************
                      *                               S O U N D                                       *
                      *********************************************************************************
                      
                      
F55D                  reset_snd
F55D  86FF                            LDA     #$FF                    ; portA all outputs
F55F  B7FE43                          STA     sheila_SYSVIA_ddra
F562  860F                            LDA     #$0F                    ; portB bottom 4 outputs, rest inputs
F564  B7FE42                          STA     sheila_SYSVIA_ddrb
F567  8604                            LDA     #$04                    ; CA1 active leading edge
F569  B7FE4C                          STA     sheila_SYSVIA_pcr
F56C  8660                            LDA     #$60
F56E  B7FE4B                          STA     sheila_SYSVIA_acr       ; turn off port latches etc
                      
F571  8608                            LDA     #$08                    ; make snd latch high
F573  B7FE40          1               STA     sheila_SYSVIA_orb
F576  4C                              INCA
F577  8110                            CMPA    #$10
F579  25F8                            BLO     1B
                      
F57B  8E0064                          LDX     #100
F57E  301F            1               LEAX    -1,X
F580  26FC                            BNE     1B
                      
F582  8600                            LDA     #0
F584  C60F                            LDB     #$F
F586  BDF5C1                          JSR     snd_vol
F589  8601                            LDA     #1
F58B  C60F                            LDB     #$F
F58D  BDF5C1                          JSR     snd_vol
F590  8602                            LDA     #2
F592  C60F                            LDB     #$F
F594  BDF5C1                          JSR     snd_vol
F597  8603                            LDA     #3
F599  C60F                            LDB     #$F
F59B  BDF5C1                          JSR     snd_vol
F59E  39                              rts
                      
F59F                  snd_sendA
F59F  3401                            PSHS    CC
F5A1  1A50                            ORCC    #CC_I+CC_F
F5A3  C6FF                            LDB     #$FF
F5A5  F7FE43                          STB     sheila_SYSVIA_ddra
F5A8  B7FE4F                          STA     sheila_SYSVIA_ora_nh       ; set data
F5AB  C600                            LDB     #0
F5AD  F7FE40                          STB     sheila_SYSVIA_orb       ; we low
F5B0  C602                            LDB     #2
F5B2  5A              1               DECB
F5B3  26FD                            BNE     1B
F5B5  C608                            LDB     #$08
F5B7  F7FE40                          STB     sheila_SYSVIA_orb       ; we high
F5BA  C604                            LDB     #4
F5BC  5A              1               DECB
F5BD  26FD                            BNE     1B
F5BF  3581            anRTS           PULS    CC,PC
                      
F5C1                  snd_vol
F5C1  46                              RORA
F5C2  46                              RORA
F5C3  46                              RORA
F5C4  46                              RORA
F5C5  8460                            ANDA    #$60
F5C7  8A90                            ORA     #$90
F5C9  C40F                            ANDB    #$0F
F5CB  3404                            PSHS    B
F5CD  AAE0                            ORA     ,S+
F5CF  20CE                            BRA     snd_sendA
                      
F5D1                  snd_tone
F5D1  46                              RORA
F5D2  46                              RORA
F5D3  46                              RORA
F5D4  46                              RORA
F5D5  8460                            ANDA    #$60
F5D7  8A80                            ORA     #$80
F5D9  3412                            PSHS    A,X
F5DB  A662                            LDA     2,S
F5DD  840F                            ANDA    #$F
F5DF  AAE4                            ORA     0,S
F5E1  BDF59F                          JSR     snd_sendA
F5E4  A662                            LDA     2,S
F5E6  E661                            LDB     1,S             ; get em reversed here as we want "course" in A
F5E8  56                              RORB
F5E9  46                              RORA
                      
F5EA  56                              RORB
F5EB  46                              RORA
                      
F5EC  44                              LSRA
                      
F5ED  44                              LSRA
                      
F5EE  3263                            LEAS    3,S
F5F0  20AD                            BRA     snd_sendA
                      
                      
F5F2                  here3           
F5F2  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF                 FILL    $FF, REMAPPED_HW_VECTORS-here3-1
                      
                      *
                      *============================================================================
                      *  VECTORS THROUGH RAM
F7F0                                  ORG     REMAPPED_HW_VECTORS
                      
F7F0  F4AD                            FDB     RES_ENT                ; f7f0 (reserved)
F7F2  F4B4                            FDB     SWI3_ENT               ; f7f2 (SWI3)
F7F4  F4BB                            FDB     SWI2_ENT               ; f7f4 (SWI2)
F7F6  F4C2                            FDB     FIRQ_ENT               ; f7f6 (FIRQ)
F7F8  F50F                            FDB     IRQ_ENT                ; f7f8 (IRQ)
F7FA  F51D                            FDB     SWI_ENT                ; f7fa (SWI/breakpoint)
F7FC  F516                            FDB     NMI_ENT                ; f7fc (NMI)
F7FE  F100                            FDB     RESET                  ; f7fe reset
                      
F800                  here            
F800  FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF                 FILL    $FF, $FFFF-here-1
                      
                              ENDIF
                      
FFFE                  herend
                              IF STANDALONE==0 && herend>=NOICE_CODE_BASE+NOICE_CODE_LEN
                                      ERROR   "OVERLAY CODE TOO BIG, INCREASE NOICE_CODE_LEN"
                              ENDIF
                      
                                      END
